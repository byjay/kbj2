{"instruction": "Excel VBA code for: (1645) 괄호안의 문자 추출하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Text_In_Paren()\nDim msg As String\n'메시지 반환값 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim strU As String\n'문자를 합칠변수\nDim c As Long\n'열 개수를 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nmsg = MsgBox(\"선택한 열의 오른쪽에 복사되며 되돌리기 안되므로 주의. 계속할까요?\", 4, \"주의하세요\")\nIf msg = \"7\" Then Exit Sub\n'No(아니오) 선택하면 매크로 종료\nIf Selection.Columns.Count >= 2 Then\n'2열 이상을 선택한 경우\nMsgBox\n\"1열만 선택하고 재실행 하세요.\", 64, \"1열만 선택\"\nExit Sub\n'매크로 종료\nEnd If\nFor Each rngC In Selection\n'선택영역의 각 셀을 순환\nFor i = 1 To\nLen\n(rngC)\n'각 셀의 문자 길이만큼 반복\nIf\nMid\n(rngC, i, 1) = \"(\" Then\n'만약 각 문자가 ( 라면\nIf Mid(rngC, i + 1, 1) <> \"(\" Then\n'(뒤에 연달아 (가 있지 않으면\nDo\n'다음을 실행\ni = i + 1\n'각 셀의 문자위치를 1씩 늘려감\nstrU = strU & Mid(rngC, i, 1)\n'추출한 문자를 합쳐감\nLoop Until Mid(rngC, i + 1, 1) = \")\" Or i > Len(rngC)\n'추출한 문자가 ) 이거나 마지막 문자까지 무한 반복\nc = c + 1\n'열 개수를 하나씩 늘려감\nIf strU <> \"\" Then\n'strU가 비어 있지 않을 경우\n'(오른쪽 괄호 없는 경우 대비한 코드)\nrngC.\nOffset\n(, c) = strU\n'합친 문자를 셀에 뿌림\nEnd If\nstrU = \"\"\n'재사용 위하여 strU 초기화\nEnd If\nEnd If\nNext i\nc = 0\n'재사용 위하여 초기화\nNext rngC\nColumns.AutoFit\n'전체열 열너비 자동맞춤\nEnd Sub", "context": "1. 괄호 안의 모든 문자를 오른쪽 열에 추출하는 기능\n2. 각 셀안의 괄호 개수는 제한 없음\n3. 한 개의 열만 영역 선택 후 매크로 실행\n4. 괄호가 중복될 경우 제일 안쪽 괄호안의 문자만 추출\n5. 괄호 닫기가 안된 경우도 문자를 추출\n매크로 실행전 영역을 선택한 모습\n매크로 실행 후 결과\nOption Explicit\nSub extract_Text_In_Paren()\nDim msg As String\n'메시지 반환값 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim strU As String\n'문자를 합칠변수\nDim c As Long\n'열 개수를 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nmsg = MsgBox(\"선택한 열의 오른쪽에 복사되며 되돌리기 안되므로 주의. 계속할까요?\", 4, \"주의하세요\")\nIf msg = \"7\" Then ..."}
{"instruction": "Excel VBA code for: (1648) 폴더내 엑셀파일의 모든 외부 링크제거(엑셀 VBA 매크로)", "input": "", "output": "Sub break_All_Links_In_Folder()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim xlApp As New Excel.Application\n'엑셀 프로그램 넣을 변수\nDim wkBk As Workbook\n'각 파일을 넣을 변수\nDim varLinks As Variant\n'링크 소스를 넣기 위한 배열변수\nDim i As Integer\n'반복구문에 사용할 변수\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시)중지\n.DisplayAlerts = False\n'(링크 제거시 뜨는) 경고창 표시안되도록 함\n.Calculation = xlCalculationManual\n'셀계산을 수동모드로(셀의 재계산 방지 목적)\n'-----------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'-----------------------------------------------\nWith .FileDialog(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show                                             '\n탐색기 폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub                                       '\n매크로 중단\nElse                                                '\n폴더 선택시\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'--------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'--------------------------------\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\n'-------------------------------\n' 각 파일을 열고 링크를 깨는 코드\n'-------------------------------\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nSet wkBk = xlApp.Workbooks.Open(strPath & fileName)\n'파일을 열고 변수에 넣음\nvarLinks = wkBk.\nLinkSources\n(1)\n'폴더내 열린 엑셀파일의 링크소스를 변수에 넣음\nIf\nNot IsEmpty\n(varLinks) Then\n'만일 링크가 하나라도 있다면\nFor i = 1 To UBound(varLinks)\n'1부터 배열변수 varLinks의 상한값까지 반복\nwkBk.\nBreakLink\n_\nName:=varLinks(i), _\nType:=xlLinkTypeExcelLinks\n'배열내의 링크이름과 일치시 링크를 제거\nNext i\nElse\nExit Sub\n'(링크가 없을 경우)매크로 종료\nEnd If\nwkBk.Close True\n'열려진 파일을 저장하고 닫음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\n.ScreenUpdating = True\n'화면 업데이트 복원\n.DisplayAlerts = True\n'경고창 표시되도록 복원\n.Calculation = xlCalculationAutomatic\n'셀계산을 자동모드로 복원\nEnd With\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nSet wkBk = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "파일내 특정 셀이 외부의 파일과 연결되어 있을 경우, 파일을 열면 아래와 같이 창이 뜨면서, 사용자에게 계속할지 또는 링크를 편집할지 묻는 창이 나타난다.\n당연한 얘기지만, 셀에 불필요한 링크가 많이 걸릴 수록 파일크기도 커지므로 파일을 열거나, 셀작업을 하거나 또는 닫을때 더 많은 시간이 소요된다.\n아래의 코드는 폴더내 엑셀파일의\n모든\n외부 링크를 제거하는\n기능\n을 한다.  그러므로,\n특정 링크는 계속 유지하며 나머지 링크만 삭제하려면\n아래의 코드를 사용할 수\n없다.\n엑셀의 기본 기능 중 이미 링크를 깨는 기능이 있지만 이것도 파일이 많으면 노가다가 된다.\n물론 특정 링크는 살려두면서 그 이외의 링크만을 제거하게 할 수도 있지만 너무 복잡해지므로 모든 링크를 제거하는 것으로 코드를 작성하였다.\n매크로 실행 전 : 초록색으로 표시한 셀에 링크가 걸려 있는 모습\n매크로 실행 후 : 링크가 모두 깨지고 셀에 값으로 입력된 모습\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsub..."}
{"instruction": "Excel VBA code for: (1649) 뒤섞인 괄호안 숫자 품명열에 입력하기(엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Qty_And_Sort()\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim i  As Long\n'반복구문에 사용할 변수\nDim strName As String\n'제품명(N)ame을 합쳐갈 변수\nDim strQ As String\n'추출한 제품의 개수(Q)uantity 넣을 변수\nDim rngF As Range\n'제품이름 검색(F)ind 하여 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, 1).End(3))\n'선택영역의 각 셀을 순환\nFor i = 1 To\nLen\n(rngC)\n'각 셀의 문자 길이만큼 반복\n'----------------------\n' 제품명 추출하는 코드\n'----------------------\nDo\n'다음을 실행\nstrName = strName &\nMid\n(rngC, i, 1)\n'추출한 문자를 합쳐감\ni = i + 1\n'각 셀의 문자위치를 1씩 늘려감\nLoop Until Mid(rngC, i, 1) = \"(\" Or i > Len(rngC)\n'추출한 문자가 ( 이거나 마지막 문자까지 무한 반복\ni = i + 1\n'문자위치 1개 오른쪽으로\n'----------------------------\n' 괄호안 숫자를 추출하는 코드\n'----------------------------\nDo\n'다음을 실행\nstrQ = strQ & Mid(rngC, i, 1)\n'추출한 문자를 합쳐감\ni = i + 1\n'각 셀의 문자위치를 1씩 늘려감\nLoop Until Mid(rngC, i, 1) = \")\" Or i > Len(rngC)\n'추출한 문자가 ) 이거나 마지막 문자까지 무한 반복\n'----------------------------------\n' 일치하는 제품명 찾아 값 넣는 코드\n'----------------------------------\nSet rngF = Rows(1).\nFind\n(What:=strName, Lookat:=xlWhole)\n'추출한 제품명과 일치하는 이름을 1행에서 찾음\nIf\nNot\nrngF\nIs Nothing\nThen\n'일치하는 이름이 1행에 있으면\nrngC.Offset(, rngF.Column - 1) = strQ\n'셀에 추출한 개수를 넣음\nEnd If\ni = i + 1\n'문자위치 1개 오른쪽으로\nstrName = \"\"\n'재사용 위하여 strName 초기화\nstrQ = \"\"\n'재사용 위하여 strQ 초기화\nNext i\nNext rngC\nSet rngF = Nothing\n'\n개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "판매된 제품이 아래와 같이 개수는 다르지만 \"갑, 을병, 정무기\"의 순서대로 그리고 규칙적으로 데이터가 입력된 경우 엑셀의 기본 기능인 문자나누기(구분자를 콤마로 사용)를 이용하여 제품명을 추출 후 간단한 함수로 개수를 넣을 수 있다.\n하지만 이래와 같이 품명이 뒤죽박죽 섞이거나 없는 품명들이 있는 경우 괄호안의 개수를 각 제품명에 넣는 것은 쉽지 않다. 아래의 코드는 이렇게 품명이 뒤섞인 제품의 개수를 각 제품명에 넣어주는 것임.\n참고로, A3셀의 \"\n갑갑갑\n\"과 같이 일치하는 품명이 없을 경우 당연히 값을 가져오지 못한다.​ 그러므로 1행의 품명 또는 A열에 입력된 데이터의 품명에는 오타가 없어야 한다.\n﻿\n매크로 실행 전\n매크로 실행 후 결과\n위의 매크로 잘 활용하시고 언제나 그렇듯 \"후다닥, 휘리릭,\n빨리 퇴근하여 가족과 함께 많은 시간\n보내시기\" 바라면서 이만.....\nSub extract_Qty_And_Sort()\nDim rngC As Range\n'각 셀(C)ell을 넣을..."}
{"instruction": "Excel VBA code for: (1653) 문자로 입력된 숫자를 숫자셀의 숫자로 변환 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub convert_Text_To_Numbers()\n'문자로 입력된셀 숫자셀로 변환\nDim rngC As Range\n'각 셀을 순환할 변수\nWith Application\n'앱 즉 엑셀에서\n.Calculation = xlCalculationManual\n'셀계산 수동으로\n.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nOn Error Resume Next\n'(오른쪽셀에 데이터 있어 문자나누기 경고창 출력 시)\n'코드 멈추지 말고 다음코드 진행\nFor Each rngC In ActiveSheet.UsedRange\n'전체 데이터 입력영역 각 셀을 순환\nIf\nLen\n(rngC) > 0 Then\n'길이가 0보다 큰 경우 즉, 빈셀이 아닐경우\nIf rngC.\nNumberFormat\n= \"@\" Then\n'셀서식이 문자일 경우\nIf\nInStr\n(1, rngC, \" \", vbTextCompare) = 0 Then\n'셀에 공백이 없을 경우\nrngC.\nTextToColumns\n, xlFixedWidth\n'각 열을 고정된 열너비로 문자나누기\nrngC.NumberFormat = \"General\"\n'셀 서식을 일반으로\nEnd If\nEnd If\nEnd If\nNext rngC\nOn Error GoTo 0\n'발생한 에러 초기화\n.Calculation = xlCalculationAutomatic\n'셀계산 자동으로 복원\n.ScreenUpdating = True\n'화면 업데이트 복원\nEnd With\nEnd Sub", "context": "엑셀 작업을 하다보면 다양한 이유로 숫자로 입력해야 할 셀들이 문자로 입력되어 있어 곤욕을 치르곤 한다. 아래 코드는\n현재시트에 있는 모든 문자셀에 입력된 숫자를 숫자셀의 숫자로 변환\n하는 코드이다. 현재 시트에서만 작동된다. 필요 시 각 시트를 순환하는 코드를 만들고 아래 코드를 하위(sub) 프로시저로 만들면 모든 시트에도 적용이 가능할 것이다.\n빈셀 복사 후 시트 전체 데이터 선택하여 붙여 넣기(더하기 옵션)를 하면 B13셀 같은 수식셀이 깨지고,\n문자 나누기로 시트 전체 영역을 돌리면, B6, B12셀과 같이 공백이 있는 셀에 문제가 생기며,\n영역 선택 후 단순히 각 셀의 서식을 \"일반(General)\"로 바꾸면 B2, B11 셀 값이 숫자로 바뀌지 않는다. 이게 은근히 생각보다 오류날 변수가 많은 코드이다. 아래와 같이 내가 아는 모든 셀서식에 적용했을 때 문제가 없었지만, 사용하다가 혹 문제가 있을 경우 댓글달기 바랍니다.\n매크로 실행 전\n1) B열에 다양한 서식의 데이터..."}
{"instruction": "Excel VBA code for: (1654) 역피벗 즉 피벗테이블을 되돌리기(엑셀 VBA 매크로)", "input": "", "output": "Sub revert_Pivot_Table()\nDim rngAll As Range\n'A열 데이터 영역을 넣을 개체변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim r As Long\n'행(r)ow을 늘려갈 별수\nDim j As Integer\n'반복구문에 사용할 변수\nDim varTop As Variant\n'제목행 넣을 배열변수\nDim rngA As Range\n'각 TYPE별 영역(A)rea를 넣을 변수\nWith Application\n.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n.Calculation = xlCalculationManual\n'수식계산 자동 업데이트 수동으로\nRange(\"Q1\").CurrentRegion.Clear\n'기존 데이터 삭제\nSet rngAll = Range(\"B1\", Cells(1, Columns.Count).End(1))\n'전체 영역을 개체변수에 넣음\nFor Each rngC In rngAll\n'1행 각 셀을 순환\nrngC =\nReplace\n(rngC,\nChr(10)\n, \"\")\n'Alt + Enter 제거\nNext rngC\nvarTop =\nArray\n(\"BOX.\", \"SIZE\", \"ITEM\", \"실제\", \"POR\", \"잔량\")\n'제목행을 배열변수에 넣음\nCells(1, 17).Resize(, 6) = varTop\n'제목행 셀에 입력\nSet rngAll = Range(\"A3\", Cells(Rows.Count, \"A\").End(3)\n(\n0\n)\n)\n'A열 전체영역을 영역변수에 넣음\nFor Each rngC In rngAll\n'전체 데이터 영역 각 셀을 순환\nIf Len(rngC) < 7 Then\n'문자 길이가 7자 미만이면\nr = r + 1\n'행 개수를 1씩 더해감\nFor j = 1 To 7\n'7번 반복\nIf Application.\nSum\n(rngC.Offset(, j * 2 - 1).Resize(, 2)) > 0 Then\n'두 셀을 합친것이 0보다 크면\nCells(Rows.Count, 17).End(3)(2) = rngC.Offset(-r)\n'BOX 번호 값 입력\nCells(Rows.Count, 18).End(3)(2) = rngC\n'SIZE 입력\nWith Cells(Rows.Count, 19)\n'T열의 마지막 데이터 셀\n.End(3)(2) = Cells(1, j * 2)\n'ITEM 입력\n.End(3).Offset(, 1) = rngC.Offset(, j * 2)\n'\"실제\" 입력\n.End(3).Offset(, 2) = rngC.Offset(, j * 2 - 1)\n'POR 입력\nSet rngA = .End(3)\n'T열의 마지막 데이터 셀\nEnd With\nrngA.Offset(, 3) = rngA.Offset(, 2) - rngA.Offset(, 1)\n'실제 - POR 값을 입력\nEnd If\nNext j\nElse\nr = 0\n'재사용 위하여 행번호 초기화\nEnd If\nNext rngC\nSet rngAll = Range(\"V2\", Cells(Rows.Count, \"V\").End(3)(0))\n'V열 전체영역을 영역변수에 넣음\nFor Each rngC In rngAll\n'V열 값이 있는 각 셀 순환\nIf rngC < 0 Then\n'셀 값이 음수이면\nrngC.Offset(, -5).Resize(, 6).Interior.\nColorIndex\n= 6\n'Q:V 열에 노란색으로 표시\nEnd If\nNext rngC\nRange(\"Q1\").CurrentRegion.Borders.LineStyle = 1\n'생성한 전체 데이터 영역에 외곽선 추가\nColumns(\"Q:V\").AutoFit\n'Q:V 열의 열너비 자동 맞춤\n.ScreenUpdating = True\n'화면 업데이트 자동으로 복원\n.Calculation = xlCalculationAutomatic\n'셀계산 자동으로 복원\nEnd With\nSet rngAll = Nothing\n'개체 변수(들) 초기화(메모리 비우기)\nSet rngA = Nothing\nSet rngC = Nothing\nEnd Sub", "context": "일종의 피벗테이블을 되돌리는 기능.\n1. Alt + Enter로 입력된 1행의 Alt + Enter를 제거\n2. 수량이 입력된 데이터의 경우 각 TYPE, SIZE, ITEM 별로 구분하여 정리\n3. \"실제\"와 POR의 위치를 바꿈\n4. \"잔량\" = \"실제\" - \"POR\"\n5. 잔량이 마이너스일 경우 노란색으로 표시.\n매크로 실행 전\n매크로 실행 후 결과(아래로 데이터 더 있음)\nSub revert_Pivot_Table()\nDim rngAll As Range\n'A열 데이터 영역을 넣을 개체변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim r As Long\n'행(r)ow을 늘려갈 별수\nDim j As Integer\n'반복구문에 사용할 변수\nDim varTop As Variant\n'제목행 넣을 배열변수\nDim rngA As Range\n'각 TYPE별 영역(A)rea를 넣을 변수\nWith Application\n.ScreenUpdating = False\n'화면 업..."}
{"instruction": "Excel VBA code for: (1655) 매개변수(Parameter)와 인수(Argument)의 차이 (엑셀 VBA 매크로)", "input": "", "output": "Sub passingArgument()\nCall havingParameter\n(30)\nEnd Sub\n\nSub havingParameter(ByVal\nintAge\nAs Integer)\nMsgBox \"Received argument as 30\"\nEnd Sub", "context": "매개변수(parameter)와 인수(argument)의 차이\n를 말해보라면 대충 알고 있어 주저하는 분들이 있을 것이다. MS사의 도움말을 찾아보면 아래와 같다. 영어에 거부감을 갖는 분들을 위해 간단히 설명하면,\n​\n아래와 같은 두 개의 프로시저가 있을 경우, 위에 있는\npassingArgument() 코드를 실행되면 아래 하위 havingParameter() 코드가 실행 되며 메시지박스가 출력된다.\n​\nSub passingArgument()\nCall havingParameter\n(30)\nEnd Sub\n​\nSub havingParameter(ByVal\nintAge\nAs Integer)\nMsgBox \"Received argument as 30\"\nEnd Sub\n​\n각 프로시저에는 매개변수(parameter)들이 변수, 상수, 구문으로 정의 되어 있고, 이 프로시저안의 매개변수에게 건네지는 것이 인수(argument)이다. 쉽게 말해 호출을 행하는 프로시저가 건네주는 것이 인수이며, (..."}
{"instruction": "Excel VBA code for: (1660) 선택영역의 숫자만큼 빈행 삽입하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Blank_Rows2()\nDim msg As String\n'출력할 메시지를 넣을 변수\nDim r As Long\n'행r(ow) 위치 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\n'------------------------------------------\n' 선택영역이 1개의 열만 선택하도록 하는 코드\n'------------------------------------------\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nmsg = \"2열 이상 선택했거나, \" &\nvbCrLf\n& _\n\"전체행 또는 전체열 선택하거나 \" & vbCrLf & _\n\"Ctrl + 마우스로 다중 영역을 선택한 오류가, \" & vbCrLf & _\n\"발생하여 매크로를 중단합니다.\"\nWith Selection\n'선택영역\nIf  .Columns.Count > 1 Or _\n.Rows.Count = Rows.Count Or _\n.Areas.Count > 1 Then\n'셀선택 오류를 범하면\nMsgBox msg, vbExclamation, \"영역선택 오류\"\n'경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nEnd With\n'------------------------------------------------\n' 선택영역 숫자합이 0 즉 숫자 없으면 매크로 중단 or\n' 선택영역내에 에러가 입력된셀 있으면 매크로 중단\n'------------------------------------------------\nmsg = \"선택 영역내에 숫자가 없거나,\" & vbCrLf & _\n\"선택 영영내에 에러셀이 있을 수 있음\"\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nIf Application.\nWorksheetFunction\n.Sum(Selection) = 0 Then\nMsgBox msg, vbExclamation\n'선택영역에 숫자없으면 에러가 입력된셀 있으면 경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nOn Error GoTo 0\n'에러 처리기능 초기화\nWith Selection\n'선택영역\nr = .Cells(1).Row\n'첫 셀의 행번호를 변수에\n'------------------------------------------\n' 선택영역 아래에서 위로 올라가며 빈 행 삽입\n'------------------------------------------\nFor i = .Cells.Count To 1 Step -1\n'전체셀 개수에서 1씩 줄여가며 반복\nIf .Cells(i) <> \"\" Then\n'빈셀이 아닐 경우\nCells(r + i, 1).Resize(.Cells(i)).\nEntireRow\n.Insert\n'숫자만큼 행삽입\nEnd If\nNext i\nEnd With\nEnd Sub", "context": "속도는 좀 떨어지더라도, 가능하면 사용하기 쉽고, 많은 사람이 에러없이 빈 행을 손쉽게 삽입할 수 있는 방법을 생각해 보았다. 아래 코드는 영역을 선택하고 매크로 실행하면\n셀 안의 숫자만큼 빈 행을 삽입\n해준다.\n매크로 실행 전                                         →       매크로 실행 후 결과\n매크로 실행 전                                        →        매크로 실행 후 결과\n매크로 실행 전                                        →        매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1660) 선택영역의 숫자만큼 빈행 삽입하기 (엑셀 VBA 매크로)\n재생\n937\n공유하기\n재생 (space/k)\n재생\n01:18\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:18\n실시간..."}
{"instruction": "Excel VBA code for: (1661) .pdf로 인쇄시 사용할 기본코드 (엑셀 VBA 매크로)", "input": "", "output": "Sub printPDF_All_Sheets()\nDim i As Long\nFor i = 1 To ActiveWorkbook.\nSheets.Count\n'모든 시트의 인쇄영역을 통일하지 않으면\n'시트마다 기존 설정대로 뒤죽박죽 인쇄되므로 주의.\nIf\nTypeName\n(ActiveWorkbook.Sheets(i)) <> \"Chart\" Then\n'차트시트에서 에러 회피\nWith Application\n.PrintCommunication = False\nWith ActiveWorkbook.Sheets(i).PageSetup\n.PrintArea = \"$1:$2\"\n.CenterHeader = \"머릿말 연습\"\n.Orientation = xlLandscape\n.Zoom = 80\nEnd With\n.PrintCommunication = True\nEnd With\nEnd If\nNext i\nActiveWorkbook\n.ExportAsFixedFormat _\nType:=xlTypePDF, _\nFilename:=ActiveWorkbook.Path & \"\\\" & \"엑셀파일 전체인쇄\" & \".pdf\", _\nQuality:=xlQualityStandard, _\nIncludeDocProperties:=True, _\nIgnorePrintAreas:=False, _\nOpenAfterPublish:=False\nEnd Sub\n\nSub printPDF_Activesheet()\nWith Application\n.PrintCommunication = False\nWith ActiveSheet.PageSetup\n.PrintArea = \"$1:$2\"\n.CenterHeader = \"머릿말 연습\"\n.Orientation = xlLandscape\n.Zoom = 80\nEnd With\n.PrintCommunication = True\nEnd With\nActiveSheet\n.ExportAsFixedFormat _\nType:=xlTypePDF, _\nFilename:=ActiveWorkbook.Path & \"\\\" & \"현재시트만 인쇄\" & \".pdf\", _\nQuality:=xlQualityStandard, _\nIncludeDocProperties:=True, _\nIgnorePrintAreas:=False, _\nOpenAfterPublish:=False\nEnd Sub\n\nSub printWorkBookAsEachSheet()\nDim i As Long\nFor i = 1 To ActiveWorkbook.\nSheets.Count\n'모든 시트의 인쇄영역을 통일하지 않으면\n'시트마다 기존 설정대로 뒤죽박죽 인쇄되므로 주의.\nIf\nTypeName\n(ActiveWorkbook.Sheets(i)) <> \"Chart\" Then\n'차트시트에서 에러 회피\nWith Application\n.PrintCommunication = False\nWith ActiveWorkbook.Sheets(i).PageSetup\n'                    .PrintArea = \"$1:$2\"\n'차트시트의 경우 반복인쇄영역설정 안되므로 주석처리\n.CenterHeader = \"머릿말 연습\"\n.Orientation = xlLandscape\n.Zoom = 80\nEnd With\n.PrintCommunication = True\nEnd With\nEnd If\nActiveWorkbook\n.Sheets(i).ExportAsFixedFormat _\nType:=xlTypePDF, _\nFilename:=ActiveWorkbook.Path & \"\\\" & ActiveWorkbook.Name & \" \" & _\nActiveWorkbook.Sheets(i).Name & \".pdf\", _\nQuality:=xlQualityStandard, _\nIncludeDocProperties:=True, _\nIgnorePrintAreas:=False, _\nOpenAfterPublish:=False\nNext i\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1661) .pdf로 인쇄시 사용할 기본코드 (엑셀 VBA 매크로)\n재생\n1,260\n공유하기\n재생 (space/k)\n재생\n01:21\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:21\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n1) 바탕화면에 엑셀파일이 저장되어 있음.\n2) 파일에는 3개의 시트가 저장되어 있음. Shee..."}
{"instruction": "Excel VBA code for: (1662) .pdf파일 나누어 저장하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub pdfExtract()\nDim varName As Variant\n'선택한 .pdf파일 넣을 변수\nDim strPath As String\n'파일 경로를 넣을 변수\nDim pdfDoc As Acrobat.CAcroPDDoc\n'Acrobat instance넣을 변수\nDim blnPath As Boolean\n'.pdf파일을 넣을 변수\nDim totalPage As Long\n'전체 페이지 숫자 넣을 변수\nDim pagNo As Integer\n'분리된 파일의 페이지 수\nDim intMod As Integer\n'페이지 나머지 구할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim newPdf As Acrobat.CAcroPDDoc\n'새로운 파일 넣을 개체변수\nDim newName As String\n'새로운 파일 이름 넣을 변수\nvarName = Application.\nGetOpenFilename\n(\"pdf Files,*.pdf\", , \"pdf 파일선택\", False)\n'파일선택\nIf TypeName(varName) = \"Boolean\" Then Exit Sub\n'취소 선택 시 매크로 종료\nstrPath = Left(varName,\nInStrRev\n(varName, \"\\\"))\n'확장자를 제거한 경로 추출\n'----------------------------------\n' 원본파일을 불러와 전체 페이지 추출\n'----------------------------------\nSet pdfDoc =\nCreateObject\n(\"AcroExch.pdDoc\")\n'pdf document 개체 생성\nblnPath = pdfDoc.\nOpen\n(varName)\n'지정한 파일을 열어 변수에 넣음\nIf Right(varName, 4) <> \".pdf\" Then\n'선택한 파일이 .pdf 아닐경우\nMsgBox \"선택한 파일은 .pdf파일이 아닙니다.\", vbExclamation\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\ntotalPage = pdfDoc.\nGetNumPages\n'원본 pdf파일의 전체 페이지 추출\npagNo = 3\n'각 파일마다 인쇄될 페이지 숫자\n'------------------------------------------\n' 분리된 페이지가 원본보다 클경우 에러 출력\n'------------------------------------------\nIf pagNo > totalPage Then\n'분리될 파일 페이지가 원본보다 크면\nMsgBox \"분리된 파일 페이지가 원본보다 큽니다.\", vbExclamation\n'에러 출력후 종료\nExit Sub\n'매크로 중단\nEnd If\nintMod = totalPage Mod pagNo\n'전체 페이지/분리파일로 나머지 구함\nFor i = 1 To totalPage Step pagNo\n'원본파일 페이지수 만큼 반복\n'-----------------------------------------\n' 분리된 마지막 파일에서 에러 방지하는 코드\n'-----------------------------------------\nIf intMod <> 0 Then\n'나머지가 0이 아니면\nIf i + pagNo > totalPage Then\n'순환하다가 전체페이지 넘어가면\npagNo = pagNo - (pagNo - intMod)\n'마지막파일 페이지는 나머지 만큼만 추출\nEnd If\nEnd If\n'---------------------------------------\n' 원본파일을 분리하고 파일명 생성 후 저장\n'---------------------------------------\nSet newPdf = CreateObject(\"AcroExch.pdDoc\")\n'새로운 파일 개체 생성\nnewPdf.Create\n'새로운 파일을 생성\nnewName = \"Page \" & i & \"-\" & i + pagNo - 1 & \" of total \" & totalPage & \" pages.pdf\"\n'파일명을 할당하고\nnewPdf.InsertPages -1, pdfDoc, i - 1, pagNo, 0\n'페이지를 삽입\nnewPdf.Save 1, strPath & newName\n'파일을 저장\nnewPdf.Close\n'파일 닫기\nSet newPdf = Nothing\n'새파일 개체변수 초기화\nNext i\nEnd Sub", "context": "아래의 코드는 한 개의 .pdf 파일을 여러개의 .pdf파일로 나누어 주는 기능을 한다. 아래 코드에서는\npagNo = 3 으로 3페이지씩 나누어진다. 예를 들어 10페이지씩 나누고 싶으면 코드를 pagNo = 10 이라고 바꾸면 된다.\n아래코드 실행전 VBE창의 Tools => References 에서\nAdobe Acrobat 라이브러리를 활성화해야 한다. 물론 Acrobat가 컴퓨터에 깔려 있어야 나타난다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1662) .pdf파일 나누어 저장하기 (엑셀 VBA 매크로)\n재생\n896\n공유하기\n재생 (space/k)\n재생\n00:45\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:45\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설..."}
{"instruction": "Excel VBA code for: (1663) 폴더내 파일 열지 않고 데이터 통합 기본코드 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub get_From_Closed_Files4()\nDim strSht As String\n'시트 이름을 넣을 변수\nDim rngData As Range\n'데이터 영역을 넣을 영역변수\nDim intRows As Long\n'가져올 데이터의 행 개수 넣을 변수\nDim intColumns As Long\n'가져올 데이터의 열 개수 넣을 변수\nDim rngT As Range\n'복사될위치 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n'------------------------------------------------------------------\n' 본인 시트명과 데이터 영역으로 수정사용. 시트명 틀리면 엑셀 에러창 뜸\n'------------------------------------------------------------------\nstrSht = \"\nSheet1\n\"\n'데이터가 저장된 시트의 이름\nSet rngData = Range(\"\nB2:E4\n\")\n'데이터가 입력된 영역(3행 4열)\nSet rngT = Range(\"\nA1:D3\n\")\n'데이터 복사될 위치(rngData와 크기 맞춰야함)\n'즉 현재의 예제는 3행 4열임.\nintRows = rngData.Rows.Count\n'행방향 건너뛰며 offset할 개수 넣음\nintColumns = rngData.Columns.Count\n'열방향 건너뛰며 offset할 개수 넣음\nrngData.CurrentRegion.ClearContents\n'기존 데이터 삭제\n'----------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'----------------------------------------------\nChDir ThisWorkbook.Path\n'매크로 실행파일과 동일한 경로 기준\nWith Application.FileDialog(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더를 선택한 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'--------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'--------------------------------\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\n'--------------------------------------------------------------\n' 배열수식을 이용하여 데이터 가져오고 수식을 값으로 변환하는 코드\n'--------------------------------------------------------------\nWith rngT\n.FormulaArray = \"='\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & rngData.Address(1, 1, 1)\n'데이터 영역을 배열로 가져옴\n.Value = .Value\n'셀의 수식을 값으로 바꿈\nEnd With\nrngT.Cells(1).Offset(, intColumns) = fileName\n'파일 이름 넣음\nSet rngT = rngT.Offset(intRows)\n'데이터 복사될 위치 설정\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nSet rngData = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub\n\nSub combine_Column_In_Folder_1()\nDim strSht As String\n'시트 이름을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strCol As String\n'가져올 열 넣을 변수\nDim rngT As Range\n'각 열이 복사될 위치 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Offset(, 1).ClearContents\n'기존데이터 삭제\n﻿\nstrSht = \"\nSheet1\n\"\n'데이터가 저장된 시트의 이름\nstrCol = \"C\"\n'가져올 열을 변수에 넣음\nstrCol = \"$\" & strCol & \":\" & \"$\" & strCol\n'열을 절대주소로 바꿈\n'-------------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'-------------------------------------------------\nWith Application.FileDialog(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더를 선택한 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'-------------------------------------\n' 폴더내 엑셀파일 유무를 확인하는 코드\n'-------------------------------------\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 엑셀 파일이 없음.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\n'-----------------------------------------------------------------\n' 배열수식을 이용하여 데이터 가져오고 수식을 값으로 변환하는 코드\n'-----------------------------------------------------------------\nSet rngT = Cells(1, Columns.Count).End(1)(1, 2)\n'각 열이 복사되는 기준위치를 변수에\nrngT.Formula\n= \"=COUNTA('\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & strCol & \")\"\n'C열의 데이터 개수를 찾아 변수에 넣음\nWith rngT.Offset(1).Resize(rngT.Value)\n'각 열의 데이터\n.FormuraArray\n= \"='\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & Cells(1, 3).Resize(rngT.Value).Address(1, 1, 1)\n'데이터 영역을 배열 이용하여 가져옴\n.Value\n= .Value\n'셀의 수식을 값으로 바꿈\nEnd With\nrngT = fileName\n'1행에 파일 이름을 넣음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nColumns.AutoFit\n'열너비 자동 맞춤\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub\n\nSub combine_Row_In_Folder_1()\nDim strSht As String\n'시트 이름을 넣을 변수\nDim strRow As String\n'가져올 열 넣을 변수\nDim strAddr As String\n'행의 주소를 절대주소로 하여 넣을 변수\nDim rngData As Range\n'가져올 데이터 영역 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim rngT As Range\n'각 열이 복사될 위치 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Offset(, 1).ClearContents\n'기존데이터 삭제\nstrSht = \"\nSheet1\n\"\n'데이터가 저장된 시트의 이름\nstrRow =\n1\n'가져올 행을 변수에 넣음\nstrAddr = \"$\" & strRow & \":\" & \"$\" & strRow\n'가져올 행을 절대주소로 만듬\n'----------------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'----------------------------------------------------\nWith Application.FileDialog(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더를 선택한 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'-----------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'-----------------------------------\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nSet rngT = Cells(Rows.Count, \"A\").End(3)(2)\n'각 행이 복사되는 기준위치를 변수에\n'--------------------------------------------------------------\n' 배열수식을 이용하여 데이터 가져오고 수식을 값으로 변환하는 코드\n'--------------------------------------------------------------\nrngT.Formula = \"=COUNTA('\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & strAddr & \")\"\n'1행의 데이터 개수를 찾아 변수에 넣음\nSet rngData = Cells(strRow, 1).Resize(, rngT.Value)\n'가져올 행 주소를 변수에 넣음\nWith rngT.Offset(, 1).Resize(1, rngT.Value)\n'각 행의 데이터\n.FormulaArray = \"='\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & rngData.Address(1, 1, 1)\n'데이터 영역을 배열 이용하여 가져옴\n.Value = .Value\n'셀의 수식을 값으로 바꿈\nEnd With\nrngT = fileName\n'1행에 파일 이름을 넣음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nColumns.AutoFit\n'열너비 자동 맞춤\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nSet rngData = Nothing\n'개체변수(들) 초기화(메모리 비우기)\n﻿    Set rngT = Nothing\n﻿\nEnd Sub", "context": "엑셀파일을 열고 닫지 않고\n특정 폴더내 모든 엑셀파일의 특정 시트(아래 예제는 Sheet1)에 있는 특정 영역의 데이터를 파일 이름과 함께 가져오는 기능. 아래 코드에서 주황색으로 표시한 영역만 자신의 데이터 시트 이름 및 영역에 맞추어 수정하면 된다. 자신의 데이터 즉, rngData영역이 D2:M4 일 경우, 이 크기에 맞추어 rngT의 영역을 A1:J3 과 같이 크기를 맞춰주면 된다. 물론 가져올 시트명도 정확히 입력해야함.\nstrSht = \"\nSheet1\n\"\n'데이터가 저장된 시트의 이름\nSet rngData = Range(\"\nB2:E4\n\")\n'데이터가 입력된 영역\nSet rngT = Range(\"\nA1:D3\n\")\n'데이터 복사될 위치(rngData와 크기 맞춰야함)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1663) 폴더내 파일 열지 않고 데이터 통합 기본코드 3 (엑셀 VBA 매크로)\n재생\n1,892\n공유하기\n재생 (space..."}
{"instruction": "Excel VBA code for: (1664) 폴더내 특정시트 모두 복사해오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_All_Sheets_In_Folder()\nDim shtName As String\n'가져올 시트이름 넣을 변수\nDim wkb As Workbook\n'각 파일을 넣을 변수\nDim wks As Worksheet\n'각 시트를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nshtName = \"\nSheet2\n\"\n'가져올 시트이름을 변수에 넣음\n'----------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'----------------------------------------------\nWith Application.FileDialog(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\n'---------------------------------------------------\n' 파일을 열고 시트이름 일치하는 시트만 복사해오는 코드\n'---------------------------------------------------\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nSet wkb = Workbooks.\nOpen\n(strPath & \"\\\" & fileName)\n'파일을 열고 변수에 넣음\nFor Each wks In wkb.Worksheets\n'열린파일 각 시트를 순환\nIf wks.Name = shtName Then\n'시트이름이 일치하면\nWith ThisWorkbook\n'이 매크로를 실행하는 파일\nwks.\nCopy\nAfter:=.Sheets(.Sheets.Count)\n'제일 뒤쪽에 시트 복사\n.Sheets(.Sheets.Count).Name = fileName\n'시트이름을 파일 이름으로 변경\nEnd With\nEnd If\nNext wks\nwkb.\nClose\nFalse\n'열려진 각 파일을 저장없이 닫음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nSet wkb = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "아래의 코드는 폴더내 저장되어 있는 모든 엑셀파일의 특정 시트(아래 예제는 Sheet2)를 현재 파일로 복사해오는 기능이다. 시트이름이 중복될 수 있으므로 시트의 이름은 그 시트가 속한 파일명으로 가져온다. 자신의 데이터에 적용하려면 아래 코드의 Sheet2를 자신의 시트명으로 바꾸면 된다.\nshtName = \"\nSheet2\n\"\n'가져올 시트이름을 변수에 넣음\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1664) 폴더내 특정시트 모두 복사해오기 (엑셀 VBA 매크로)\n재생\n1,973\n공유하기\n재생 (space/k)\n재생\n00:41\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:41\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1...."}
{"instruction": "Excel VBA code for: (1665) 특정이름 포함된 시트 모두 복사해오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_All_Sheets_In_Folder()\nDim shtName As String\n'가져올 시트이름 넣을 변수\nDim wkb As Workbook\n'각 파일을 넣을 변수\nDim wks As Worksheet\n'각 시트를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nshtName = \"\nsheet\n\"\n'가져올 시트이름을 변수에 넣음\n'----------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'----------------------------------------------\nWith Application.FileDialog(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\n'---------------------------------------------------------\n' 파일을 열고 시트명에 sheet가 포함된 시트만 복사해오는 코드\n'---------------------------------------------------------\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nSet wkb = Workbooks.Open(strPath & \"\\\" & fileName)\n'파일을 열고 변수에 넣음\nFor Each wks In wkb.Worksheets\n'열린파일 각 시트를 순환\nIf\nInStr\n(1, wks.Name, shtName,\nvbTextCompare\n) Then\n'시트이름이 shtName 포함하면\nWith ThisWorkbook\n'이 매크로를 실행하는 파일\nwks.\nCopy\nAfter:=.Sheets(.Sheets.Count)\n'제일 뒤쪽에 시트 복사\n.Sheets(.Sheets.Count).Name = Split(fileName, \".\")(0) & \" \" & wks.Name\n'파일명 + 시트이름으로 시트명 변경\nEnd With\nEnd If\nNext wks\nwkb.Close\nFalse\n'열려진 각 파일을 저장없이 닫음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nSet wkb = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "아래의 코드는 폴더내 저장되어 있는 모든 엑셀파일 중에서\n특정 이름(아래 예제는 sheet)을 포함하고 있는 모든 시트를 현재 파일로 복사해오는 기능\n이다. 시트이름이 중복될 수 있으므로 시트의 이름은 \"파일명 + 공백 + 시트명\"으로 가져온다. 자신의 데이터에 적용하려면 아래 코드의 sheet를 자신의 시트명에 맞추어 수정하여 사용하면 된다.\nshtName = \"\nsheet\n\"\n'가져올 시트이름을 변수에 넣음\n참고로, 아래 코드에서 알아두어야 할 명령어 중의 하나가\nvbTextCompare\n이다. vbCompareMethod에는 3가지가 있는데 아래와 같다.\n1. vbBinaryCompare : 대소문자 구분. 즉, Sheet  = sheeT 의 값은 거짓.\n2. vbTextCompare : 대소문자 구분안함. 즉, Sheet = sHeeT = shEET = SHEET 의 값은 참.\n그러므로 아래의 코드에서는 대문자든 소문자든 무조건 sheet가 들어간 모든 시트를 가져옴.\n3. ..."}
{"instruction": "Excel VBA code for: (1666) 아웃룩(Outlook)으로 메일보내기 기본코드 (엑셀 VBA 매크로)", "input": "", "output": "Sub email_From_Outlook()\nDim outApp As New\nOutlook\n.Application\n'아웃룩 프로그램 넣을 변수\nDim mail_Item As Outlook.\nMailItem\n'아룻룩 메일아이템 넣을 변수\nDim rngAll As Range\n'A열 머릿말 제외한 영역 넣을 변수\nDim rngC As Range\n'반복구문에 사용할 영역 변수\nDim strPath As String\n'파일 경로 넣을 변수\nDim c As Long\n'열방향 반복에 넣을 변수\nDim a As Integer\n'첨부파일 반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet\noutApp =\nNew\nOutlook.Application\n'새로운 아웃룩 인스턴스 생성\nSet rngAll = Range(Cells(2, 1), Cells(Rows.Count, \"A\").End(3))\n'A열을 개체변수에 넣음\nFor Each rngC In rngAll\n'A열 각셀을 순환\nSet mail_Item = outApp.\nCreateItem\n(\nolMailItem\n)\n'메일아이템을 생성하여 변수에 넣음\nstrPath = rngC.Offset(0, 5)\n'첨부파일 경로 넣을 변수\nWith mail_Item\n'메일아이템에서\n.To = rngC\n'받는 사람 메일주소\n.CC = rngC.Offset(0, 1)\n'참조(CC)\n.BCC = rngC.Offset(0, 2)\n'부참조(BCC)\n.Subject = rngC.Offset(0, 3)\n'제목\n.Body = rngC.Offset(0, 4)\n'메일내용\nDo While Not IsEmpty(rngC.Offset(0, 5 + c))\n'첨부파일 없을때까지 무한 반복\nc = c + 1\n'열 위치를 1씩 늘려감\n.Attachments.Add (strPath)\n'첨부파일\nstrPath = rngC.Offset(0, 5 + c)\n'첨부파일 위치 재지정(오른쪽으로 1셀 이동)\nLoop\nc = 0\n'재사용하기 위하여 초기화\n.Display\n'화면에서 (보내기전) 보여주기\n'            .Send\n'메일 송부\nApplication.Wait\nNow\n+ TimeValue(\"00:00:01\")\n'1초씩 시간 지연 (서버에게 시간 주기 위해)\nEnd With\nNext rngC\nSet outApp = Nothing\n'개체변수(들) 초기화 - 메모리 비우기\nSet mail_Item = Nothing\nSet rngAll = Nothing\nEnd Sub", "context": "나 자신이 아웃룩(Outlook)으로 많은 메일을 보낼것 같지는 않지만 공부하면서 코드를 작성하였기에 기본코드에 정리하여 둔다. 스팸메일 보내는 사람들이나 필요하지 않을까 싶지만 혹 필요한 사람이 있을 수 있기에 ... 예전에 눈으로 한 번 공부해 봤지만 직접 해보니 별거 아니다.\n엑셀파일에 아래와 같이 메일주소와 함께 메일을 보낼 내용 첨부파일과 함께 정리되어 있다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1666) 아웃룩(Outlook)으로 메일보내기 기본코드 (엑셀 VBA 매크로)\n재생\n3,613\n공유하기\n재생 (space/k)\n재생\n01:25\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:25\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n..."}
{"instruction": "Excel VBA code for: (1667) 중첩배열로 데이터 취합 기본코드 (엑셀 VBA 매크로)", "input": "", "output": "Sub nested_Array_Ubound()\nDim i As Long\n'반복 구문에 사용할 변수\nDim varA()\n'동적배열로 사용할 배열변수\nDim shtCnt As Long\n'전체 시트 개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nshtCnt = Sheets.Count - 1\n'전체시트 개수 -1(통합시트 제외)을 변수에 넣음\nReDim\nvarA(1 To shtCnt)\n'배열크기 재지정\nFor i = 1 To shtCnt\n'시트개수 -1 만큼 반복\nWith Sheets(i + 1).UsedRange\n'각 시트의 사용영역에서\nvarA(i) = .Offset(1).Resize(.Rows.Count - 1)\n'제목행 뺀 데이터 영역만 배열에 넣음\nEnd With\nNext i\nFor i = 1 To shtCnt\n'시트개수 -1만큼 반복\nCells(Rows.Count, \"A\").End(3)(2).Resize(\nUBound\n(varA(i),\n1\n), _\nUBound(varA(i),\n2\n)) = varA(i)\n'배열내 각 값을 셀에 뿌림\nNext i\nEnd Sub\n\nSub trans_Data_Using_Array()\nDim s As Long\n'(s)sheet 반복구문에 사용할 변수\nDim rowCnt As Long\n'row 방향 행 개수(c)ou(nt)넣을 변수\nDim colCnt As Long\n'(col)umn 방향 열 개수(c)ou(nt) 넣을 변수\nDim rngData As Range\n'시트내 데이터 영역 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor s = 1 To Sheets.Count - 1\n'시트개수 -1 만큼 반복(2번째 시트부터 작업)\nWith Sheets(s + 1).UsedRange\n'각 시트 사용영역에서\nSet rngData = .Offset(1).Resize(.Rows.Count - 1)\n'제목행 제외한 데이터영역 개체변수에\nEnd With\nrowCnt = rngData.Rows.Count\n'행 제외한 데이터영역 총 행개수를 변수에\ncolCnt = rngData.Columns.Count\n'데이터영역 총 열 개수를 변수에\nCells(Rows.Count, \"A\").End(3)(2).Resize(rowCnt, colCnt) = rngData.\nValue\nNext s\n'각 시트의 사용영역을 통합시트에 뿌림\nEnd Sub\n\nSub how_To_Find_Ubound_With_MultiD_Array()\n'중첩배열의 Ubound 참조용\nDim var1D(1 To 3)\nDebug.Print UBound(var1D) = 3\nvar1D(1) = Range(\"A1:C5\")\n'1차원 배열에 2차원을 넣음\nDebug.Print\nUBound\n(var1D(1), 1) = 5\nDebug.Print UBound(var1D(1), 2) = 3\nDim var2D(1 To 3, 1 To 2)\nDebug.Print UBound(var2D, 1) = 3\nDebug.Print UBound(var2D, 2) = 2\nvar2D(1, 1) = Range(\"A1:C5\")\n'2차원 배열에 2차원을 넣음\nDebug.Print UBound(var2D(1, 1), 1) = 5\nDebug.Print UBound(var2D(1, 1), 2) = 3\nvar2D(3, 1) = Range(\"A1:C5\")\nDebug.Print UBound(var2D(3, 1), 1) = 5\nDebug.Print UBound(var2D(3, 1), 2) = 3\nDim var3D(1 To 3, 1 To 4, 1 To 2)\nDebug.Print UBound(var3D, 1) = 3\nDebug.Print UBound(var3D, 2) = 4\nDebug.Print UBound(var3D, 3) = 2\nvar3D(1, 1, 1) = Range(\"A1:C5\")\n'3차원 배열에 2차원을 넣음\nDebug.Print UBound(var3D(1, 1, 1), 1) = 5\nDebug.Print UBound(var3D(1, 1, 1), 2) = 3\nvar3D(1, 4, 1) = Range(\"A1:C5\")\nDebug.Print UBound(var3D(1, 4, 1), 1) = 5\nDebug.Print UBound(var3D(1, 4, 1), 2) = 3\nDim var3D1(1 To 2, 1 To 3, 1 To 4)\nDim var3D2(1 To 5, 1 To 6, 1 To 7)\nvar3D1(1, 2, 3) = var3D2\n'3차원 배열에 3차원을 넣음\nDebug.Print UBound(var3D1(1, 2, 3), 1) = 5\nDebug.Print UBound(var3D1(1, 2, 3), 2) = 6\nDebug.Print UBound(var3D1(1, 2, 3), 3) = 7\nvar3D1(1, 2, 3)(1, 1, 1) = \"Wow\"\nDebug.Print var3D(1, 2, 3)(1, 1, 1)\n'Wow가 출력된다.\nEnd Sub\n\nSub find_Ubound()\nDim 정보 As 신상정보\nDebug.Print UBound(정보.주소(), 1) = 3\nDebug.Print UBound(정보.주소(), 2) = 5\nEnd Sub", "context": "배열내에 다시 배열을 넣는 중첩배열(nested array)에 대하여 조금더 공부를 해봤다. 3차원 이상되는 다차원 배열내에 셀 영역을 넣거나 하면 너무 복잡해서 사용하기 어렵다는 생각이다. 하지만, 2차원 배열까지는 배열내에 배열을 넣기도 쉽고, 다시 빼내에 셀에 뿌리기도 별로 어렵지 않으므로 가끔 사용할 수 있을 것 같아 정리해 둔다.\n아래 코드는 1차원 배열에 2차원 배열(각 시트의 데이터영역)을 넣고\n이를 통합시트에 다시 뿌리는 기능이다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1667) 중첩배열로 데이터 취합 기본코드 (엑셀 VBA 매크로)\n재생\n914\n공유하기\n재생 (space/k)\n재생\n00:21\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:21\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p..."}
{"instruction": "Excel VBA code for: (1671) 중복데이터만 순차적으로 숫자 붙이기 (엑셀 VBA 매크로)", "input": "", "output": "Sub add_Number_To_Dupes()\n'위아래 중복 데이터에 오른편에 숫자넣기\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim intC As Integer\n'열(C)olumn 번호 넣을 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngC As Range\n'중복 영역(r)a(ng)e 각셀(C)ell 넣을 영역변수\nDim rngArea As Range\n'중복 영역(Area)을 넣을 영역변수\nDim y As Long\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 5\n'5행 부터 시작\nintC = 5\n'열번호 변수에 넣음\nDo\nIf Cells(r, intC) = Cells(r + 1, intC) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nSet rngArea = Cells(r - i, intC).Resize(i + 1, 1)\n'중복 구역을 변수에 넣음\nIf i = 0 Then\n'아래셀과 이름이 다르면\nCells(r, 11) = Cells(r, intC)\n'이름을 그대로 넣음\nElse\n'아래셀과 이름이 같으면\nFor Each rngC In rngArea.Cells\n'이름 같은 영역 각 셀을 순환\ny = y + 1\n'이름 뒤 붙여갈 숫자 1씩 늘려감\nrngC.Offset(, 6) = rngC & \"-\" &\nFormat\n(y, \"0#\")\nNext rngC\n'K열에 이름 + 0 + 숫자를 늘려감\nEnd If\ni = 0\n'재사용 위하여 초기화\ny = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, intC) = \"\"\n'E열에 빈셀 나올때까지 무한 반복\nSet rngArea = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "위아래 값이 같은 즉 중복된 데이터만 순차적으로 숫자를 붙여가는 기능.\n매크로 실행 전                                                  매크로 실행 후 결과\nOption Explicit\nSub add_Number_To_Dupes()\n'위아래 중복 데이터에 오른편에 숫자넣기\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim intC As Integer\n'열(C)olumn 번호 넣을 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngC As Range\n'중복 영역(r)a(ng)e 각셀(C)ell 넣을 영역변수\nDim rngArea As Range\n'중복 영역(Area)을 넣을 영역변수\nDim y As Long\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 5\n'5행 부터 시작\nintC = 5\n'열번호 변수에 넣음\nDo\nIf Cells(r, intC) = Cell..."}
{"instruction": "Excel VBA code for: (1673) 모든시트 특정영역내 사진삭제 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Shapes_In_A_Specific_Range()\nDim rngSel As Range\n'선택영역 전체를 넣을 변수\nDim wks As Worksheet\n'각 시트(w)ro(ks)heet 넣을 변수\nDim rngAll As Range\n'삭제할 전체영역을 넣을 변수\nDim shpC As Shape\n'각각의 도형(shape)을 넣을 변수\nDim rngShp As Range\n'각 도형의 왼쪽위가 속한 영역을 넣을 변수\n'------------------------\n' 영역 선택창 띄우는 코드\n'------------------------\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel = Application.\nInputBox\n(\"마우스로 영역을 설정하시오!\",\nType:=8\n)\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지.\nFor Each wks In ActiveWorkbook.Worksheets\n'엑셀파일 각 시트를 순환\nSet rngAll = wks.Range(rngSel.Address)\n'사진 삭제할 영역으로 설정\n'------------------------------------------------\n' 선택영역과 사진의 영역이 교차하는지 검사 후 삭제\n'------------------------------------------------\nFor Each shpC In wks.\nShapes\n'삭제영역내의 각 도형을 순환\nSet rngShp = shpC.\nTopLeftCell\n'각 도형 왼쪽위가 속한 영역을 변수에 넣음\nIf Not\nIntersect\n(rngAll, rngShp) Is Nothing Then   '도형과 삭제영역이 겹치면\nshpC.Delete\n'각 도형을 삭제\nEnd If\nNext shpC\nNext wks\nSet rngAll = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngShp = Nothing\nMsgBox \"매크로가 종료되었습니다.\"\n'매크로 종료 메시지 출력\nEnd Sub", "context": "아래의 코드는 모든 시트를 순환하며 마우스로\n선택한 영역\n(1개의 셀 또는 여러개의 셀을 한 번에 선택하는 것도 가능)\n과 일치하는 곳에 있는 모든 사진을 삭제\n하는 기능을 한다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1673) 모든시트 특정영역내 사진삭제 (엑셀 VBA 매크로)\n재생\n1,182\n공유하기\n재생 (space/k)\n재생\n00:37\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:37\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n..."}
{"instruction": "Excel VBA code for: (1674) 사진크기 확대/축소하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub shrink_Pictures_1()\nDim rngC As Range\n'선택영역 각셀을 순환할 변수\nDim shp As Shape\n'각 그림을 넣을 변수\nDim C As Range\n'검색에 일치한 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nIf\nTypeName\n(Selection) <> \"Range\" Then\n'영역이 아니 사진을 선택하고 매크로 실행 시\nMsgBox \"영역을 선택하고 실행하시오.\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\n'----------------------------------------------------\n' 선택영역 각 셀과 모든 사진의 위치를 순환하며 교차 비교\n'----------------------------------------------------\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nFor Each shp In ActiveSheet.Shapes\n'활성화된 시트 모든 shape 순환\nSet C = shp.\nTopLeftCell\n'shape 왼쪽위 위치를 변수에 넣음\nIf Not\nIntersect\n(rngC, C) Is Nothing Then\n'선택영역과 shape 왼쪽위 위치가 겹치면\n'            shp.ShapeRange.LockAspectRatio = msoFalse\n'사진의 가로/세로크기 고정 해제\n'------------------------------------\n'사진 폭이 사진 높이보다 클 경우의 처리\n'------------------------------------\nIf shp.\nWidth\n>= shp.\nHeight\nThen\n'사진 가로크기가 세로보다 큰 경우\nIf shp.Height <= 2 Then\n'높이가 2보다 작거나 같으면\nMsgBox \"높이를 더 이상 줄일 수 없습니다.\" & vbCrLf _\n& \"복수의 사진 선택 시에는 여러 사진중의 하나가 최소크기.\", vbExclamation\nEnd\n'메시지 출력 후 매크로 종료\nElse\n'높이가 2보다 크면\n'-------------\n'사진크기 조정\n'-------------\nWith shp\n'작업중인 shape를\n.Height = .Height - 2\n'사진의 높이 줄임\n.Width = .Width - 2\n'사진의 폭 줄임\n.Left = .Left + 1\n'사진의 왼쪽위치 지정\n.Top = .Top + 1\n'사진의 위쪽위치 지정\nEnd With\nEnd If\n'--------------------------------------\n'사진 폭이 사진 높이보다 작은 경우의 처리\n'--------------------------------------\nElse\n'사진 가로크기가 세로보다 작은 경우\nIf shp.Width <= 2 Then\n'shape의 폭이 2보다 작거나 같으면\nMsgBox \"폭을 더 이상 줄일 수 없습니다.\" & vbCrLf _\n& \"복수의 사진 선택 시에는 여러 사진중의 하나가 최소크기.\", vbExclamation\nEnd\n'메시지 출력 후 매크로 종료\nElse\n'shape의 폭이 2보다 크면\nWith shp\n'shape를\n.Height = .Height - 2\n'사진의 높이 줄임\n.Width = .Width - 2\n'사진의 폭 줄임\n.Left= .Left + 1\n'사진의 왼쪽위치 지정\n.Top = .Top + 1\n'사진의 위쪽위치 지정\nEnd With\nEnd If\nEnd If\nEnd If\nNext shp\nNext rngC\nSet C = Nothing\nEnd Sub\n\nSub enlarge_Pictures_1()\nDim rngC As Range\nDim shp As Shape\nDim C As Range\nApplication.ScreenUpdating = False\nIf TypeName(Selection) <> \"Range\" Then\nMsgBox \"영역을 선택하고 실행하시오.\"\nExit Sub\nEnd If\nFor Each rngC In Selection\nFor Each shp In ActiveSheet.Shapes\nSet C = shp.TopLeftCell\nIf Not Intersect(rngC, C) Is Nothing Then\n'            shp.ShapeRange.LockAspectRatio = msoFalse\nIf shp.Width >= shp.Height Then\nIf shp.Height > rngC.MergeArea.Height - 4 Then\nMsgBox \"높이를 더 확대할 없습니다.\" & vbCrLf _\n& \"복수의 사진 선택 시에는 여러 사진중의 하나가 최대크기.\", vbExclamation\nEnd\nElse\nWith shp\n.Height = .Height + 2\n.Width = .Width + 2\n.Left = .Left - 1\n.Top = .Top - 1\nEnd With\nEnd If\nElse\nIf shp.Width > rngC.MergeArea.Width - 4 Then\nMsgBox \"폭을 더 확대할 수 없습니다.\" & vbCrLf _\n& \"복수의 사진 선택 시에는 여러 사진중의 하나가 최대크기.\", vbExclamation\nEnd\nElse\nWith shp\n.Height = .Height + 2\n.Width = .Width + 2\n.Left = .Left - 1\n.Top = .Top - 1\nEnd With\nEnd If\nEnd If\nEnd If\nNext shp\nNext rngC\nSet C = Nothing\nEnd Sub", "context": "엑셀은 수식을 계산하기 위해 만든 프로그램인데 생각보다 많은 사람들이 사진대지와 같이 사진작업을 상당히 많이 한다. 엑셀의 숫자계산은 완벽하지만 아쉽게도 그래픽 관련되어서는 가끔씩 에러가 나고, 또한 사진 작업이 그리 편하진 않다. 아래의 코드는 동영상에서 보는 바와 같이,\n영역을 선택하고 매크로 실행\n시 사진이 속한 셀의 크기 내에서 사진의 크기를 일괄적으로 확대/축소하는 기능을 하여준다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1674) 사진크기 확대/축소하기 (엑셀 VBA 매크로)\n재생\n1,912\n공유하기\n재생 (space/k)\n재생\n00:32\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:32\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n..."}
{"instruction": "Excel VBA code for: (1675) 같은 셀위치에 사진 삽입하고 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_Matching_Picture()\nDim rngC As Range\n'각 (C)ell 영역(range)을 넣을 변수\nDim rngAll As Range\n'A열 전체(All) 영역(range)을 넣을 변수\nDim wks As Worksheet\n'각 시트 (w)or(ks)heet 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nSet rngAll = Range(\"A1\", Cells(Rows.Count, \"A\").End(3))\n'A열을 변수에\nFor Each rngC In rngAll\n'A열 각셀을 순환\nIf rngC <> \"\" Then\n'빈셀이 아니라면\nFor Each wks In ActiveWorkbook.\nWorksheets\n'파일내 각 시트를 순환\nIf wks.Name <> \"Data\" Then\n'시트이름이 Data가 아니라면\nIf wks.Name = rngC Then\n'시트이름이 셀에 있는 이름과 일치하면\nrngC.\nNext\n.Copy wks.Range(\"E2\")\n'Data시트에 있는 사진을 복사\nEnd If\nEnd If\nNext wks\nEnd If\nNext rngC\nSet rngAll = Nothing\n'개체변수 초기화\nMsgBox \"매크로가 종료되었습니다.\"\n'매크로 종료창 출력\nEnd Sub\n\nSub delete_All_Pictures()\nDim wks As Worksheet\n'각 시트 (w)or(ks)heet 넣을 변수\nDim shp As Shape\n'각 도형을 넣을 변수\nDim C As Range\n'도형위치 넣을 변수\nFor Each wks In ActiveWorkbook.Worksheets\n'파일내 각 시트를 순환\nIf wks.Name <> \"Data\" Then\n'시트이름이 Data가 아니라면\nFor Each shp In wks.Shapes\n'시트내 각 도형을 순환\nSet C = shp.TopLeftCell\n'각 도형의 왼쪽위 위치를 변수에 넣음\nIf Not Intersect(wks.Range(\"E2\"), C) Is Nothing Then\n'도형위치와 셀위치가 일치하면\nshp.Delete\n'도형을 삭제\nEnd If\nNext shp\nEnd If\nNext wks\nMsgBox \"모든 사진이 삭제되었습니다.\"          '매크로 종료창 출력\nEnd Sub", "context": "엑셀 시트에 사진을 삽입하는 것은 여러 방법이 있다. 특히, 특정 폴더에 있는 많은 사진을 일치하는 이름의 위치에 한 번에 가져오는 것은 많이 해보았다.\nhttps://blog.naver.com/rosa0189/60147277109\n(622) 선택영역내 그림을 각 셀의 크기에 맞추기 (엑셀 VBA 매크로)\nVBA를 사용하여 엑셀에 그림을 삽입하는 방법도 여러가지가 있다. 아래의 매크로는, 영역을 선택하고 매...\nblog.naver.com\n아래의 코드는 (위와 같은 매크로를 이용하여 미리 한 시트(Data 시트)에 사진을 다 넣어 놓고), 나머지\n모든\n다른 시트의 특정 위치에 사진을 복사\n해서 넣고 필요 시 이를\n삭제\n하는 기능을 한다. 직원이 100명 정도 있고, 각 직원의 신상명세 또는 이력서 같은 것을 하나의 엑셀파일로 보관할 때 동일한 위치에 증명사진을 넣거나 변경 시 업데이트하는 경우에 사용할 수 있을것 같다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubje..."}
{"instruction": "Excel VBA code for: (1676) 중복데이터 찾기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Duplicates_And_Highlight()\nDim rngAll As Range\nDim lngC As Long\nDim r As Long\nDim dupe As Long\nDim c As Long\nDim varD()\nDim m As Long\nDim n As Long\nDim j As Long\nDim blnTF As\nBoolean\nDim rngArea As Range\nDim cnt As Long\nDim rngF As Range\nDim varCol()\nDim varF()\nSet rngAll = Range(\"A1\").CurrentRegion\nWith Application\n.ScreenUpdating = False\n.Calculation =\nxlCalculationManual\n'---------------------------------------------------------\n' 마지막 시트 뒤에 Data 시트 복사하고  A열 기준 오름차순 정렬\n'---------------------------------------------------------\nSheets.Add\nrngAll.SpecialCells(xlCellTypeVisible).Copy Range(\"A1\")\nWith Range(\"A1\").\nCurrentRegion\nlngC = .Columns.Count\n.Offset(1).\nSort\nKey1:=Range(\"A2\"), Order1:=xlAscending\nEnd With\nr = 2\nIf lngC = 1 Then\n'데이터가 A열에만 즉,  한 열에만 있을 때의 처리\n'----------------------------------------------\n' A열에 빈셀 나올때까지 위아래 셀값이 같은지 확인\n'----------------------------------------------\nDo\nIf Cells(r, 1) = Cells(r + 1, 1) Then\ndupe = dupe + 1\nElse\nSet\nrngArea = Cells(r - dupe, 1).Resize(dupe + 1, lngC)\nIf dupe >= 1 Then\nWith rngArea\nFor m = 1 To .Rows.Count - 1\nIf .Cells(m, 1) = .Cells(m + 1, 1) Then\n'---------------------------------------------------------\n'중복데이터 발견되면 동적배열에 넣음(우선 중복되는 행 모두)\n'---------------------------------------------------------\nIf blnTF = False Then\nc = c + 1\nReDim Preserve\nvarD(1 To c)\nvarD(c) = .Rows(m)\nc = c + 1\nReDim Preserve varD(1 To c)\nvarD(c) = .Rows(m + 1)\nblnTF = True\nElse\nc = c + 1\nReDim Preserve varD(1 To c)\nvarD(c) = .Rows(m + 1)\nEnd If\nEnd If\nNext m\nblnTF = False\nEnd With\nEnd If\ndupe = 0\nEnd If\nr = r + 1\nLoop Until Cells(r, 1) = \"\"\nElse\n'데이터가 복수의 열일 때의 처리\n'-----------------------------------------------\n' A열에 빈셀 나올때까지 위아래 셀값이 같은지 확인\n'-----------------------------------------------\nDo\nIf Cells(r, 1) = Cells(r + 1, 1) Then\ndupe = dupe + 1\nElse\nSet rngArea = Cells(r - dupe, 1).Resize(dupe + 1, lngC)\n'--------------------------------------\n'첫 필드 중복이면 나머지 필드의 중복 확인\n'--------------------------------------\nIf dupe >= 1 Then\nWith rngArea\nFor m = 1 To .Rows.Count - 1\nFor n = m + 1 To .Columns.Count\nFor j = 2 To .Columns.Count\nIf .Cells(m, j) = .Cells(n, j) Then\ncnt = cnt + 1\nEnd If\n'-------------------------------------------------------\n'중복데이터 발견되면 동적배열에 넣음(우선 중복되는 행 모두)\n'-------------------------------------------------------\nIf cnt = .Columns.Count -1 Then\nIf blnTF = False Then\nc = c + 1\nReDim Preserve varD(1 To c)\nvarD(c) = .Rows(m)\nc = c + 1\nReDim Preserve varD(1 To c)\nvarD(c) = .Rows(n)\nElse\nc = c + 1\nReDim Preserve varD(1 To c)\nvarD(c) = .Rows(n)\nEnd If\nEnd If\nNext j\nblnTF = False\ncnt = 0\nNext n\nNext m\nEnd With\nEnd If\ndupe = 0\nEnd If\nr = r + 1\nLoop Until Cells(r, 1) = \"\"\nEnd If\n'-------------------------------------------------\n'중복 하나도 없을 때 처리코드 : 배열이 비었는지 확인\n'-------------------------------------------------\nOn Error Resume Next\nFor c = 1 To\nUBound\n(varD)\nIf\nErr.Number\n<> 0 Then\nMsgBox \"중복 데이터가 없습니다. 종료합니다.\"\n.DisplayAlerts = False\n.DisplayAlerts = True\n.ScreenUpdating = True\n.Calculation =\nxlCalculationAutomatic\nExit Sub\nEnd If\n'-------------------------------------------------\n' (중복 제거하기 위해)배열의 값을 임시로 시트에 뿌림\n'-------------------------------------------------\nCells(Rows.Count, lngC + 2).End(3)(2).Resize(, lngC) = varD(c)\nNext c\nOn Error GoTo 0\nReDim varCol(0 To lngC - 1)\n'Array함수 대신 사용할 것이므로 반드시 0부터 시작\nFor c = 0 To lngC - 1\nvarCol(c) = c + 1\nNext c\n'-------------------------------------------\n' 시트에 임시로 넣은 추출한 데이터의 중복제거\n'-------------------------------------------\nCells(2, lngC + 2).CurrentRegion.\nRemoveDuplicates\nColumns:=\n(\nvarCol\n)\n, Header:=xlNo\nWith Cells(2, lngC + 2).CurrentRegion\nFor c = 1 To .Rows.Count\nReDim Preserve varF(1 To c)\nvarF(c) = .Rows(c)\nNext c\nEnd With\n'---------------------------------------------------\n' 중복제거된 유일한 목록으로 find_Matching_Data 실행\n'---------------------------------------------------\nCells(2, lngC + 2).CurrentRegion.Clear\nFor c = 1 To UBound(varF)\nCall\nfind_Matching_Data(varF(c))\nNext c\n'----------------------------------------------------\n' 이상 없이 코드 완료되면 임시창 삭제하고 설정 돌려놓음\n'----------------------------------------------------\n.\nDisplayAlerts\n= True\n.ScreenUpdating = True\n.Calculation = xlCalculationAutomatic\nEnd With\nIf ActiveSheet.\nAutoFilterMode\nThen\nActiveSheet.UsedRange.\nAutoFilter\nEnd If\n'------------------------------------------------------\n' 필터 적용하고 (중복데이터 표시위해) 빨간색으로 색상정렬\n'------------------------------------------------------\nSet rngF = Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\nActiveSheet.UsedRange.AutoFilter\nActiveSheet.Range(rngF.\nAddress(0, 0)\n).AutoFilter _\nField:=1, Criteria1:=RGB(255, 0, 0), Operator:=\nxlFilterCellColor\nMsgBox \"완료되었습니다. 중복데이터는 빨간색\"\nEnd Sub\n\nSub find_Matching_Data(ByVal varF As Variant)\nDim strAddr As String\nDim i As Long\nDim cnt As Long\nDim rngF As Range\n'-----------------------------\n' 일치하는 데이터 검색하는 코드\n'-----------------------------\nWith ActiveSheet.UsedRange\nIf\nVarType\n(varF) = 5 Then\n'1열만 있을 때의 검색\nSet rngF = .\nFind\n(What:=varF, Lookat:=xlWhole)\nstrAddr = rngF\n.Address\nDo\n'---------------------------------\n' 중복 발견 시 행에 빨간색으로 표시\n'---------------------------------\nrngF.Interior.ColorIndex = 3\nSet rngF = .\nFindNext\n(rngF)\nLoop While Not rngF Is Nothing And rngF.Address <> strAddr\nElse\n'데이터가 복수의 열일 때의 검색\nSet rngF = .Find(What:=varF(1, 1), Lookat:=xlWhole)\nstrAddr = rngF.Address\n'---------------------------------------------\n' 전체 열 모든 데이터가 일치하는지 확인하는 코드\n'---------------------------------------------\nDo\nFor i = 1 To UBound(varF, 2) - 1\nIf rngF.Offset(, i) = varF(1, i + 1) Then\ncnt = cnt + 1\nElse\nExit For\nEnd If\nNext i\n'---------------------------------\n' 중복 발견 시 행에 빨간색으로 표시\n'---------------------------------\nIf cnt = UBound(varF, 2) - 1 Then\nrngF.Resize(, UBound(varF, 2)).Interior.ColorIndex = 3\ncnt = 0\nElse\ncnt = 0\nEnd If\nSet rngF = .FindNext(rngF)\nLoop While Not rngF Is Nothing And rngF.Address <> strAddr\nEnd If\nEnd With\nEnd Sub", "context": "1. 혹시 데이터가 0110, 0220과 같이 0으로 시작하는 text는 오류 나므로 제일 앞의 0 삭제하고 실행.)\n2. 아래의 코드는,\n위와 같이 많은 데이터에서 특정 몇 개의 데이터가 중복되어 있을 때 사용할 목적으로 만듬.\n아래와 같은 경우에는 동일한 이름을 가진 첫 번째 데이터만 중복으로 처리하므로 주의. 물론 모두 적용할 수 있지만, 그렇게 되면 코드의 속도가 떨어지므로 이는 제외.\n매크로 실행 전              실행 후 결과                     매크로 실행 전             실행 후 결과\n조건부 서식이나 함수 등을 이용하여 다양한 중복찾기를 할 수 있다. 데이터가 많지 않을 때는 COUNTIF, VLOOKUP, INDEX/MATCH, 배열함수 등등을 사용해도 큰 문제가 없다. 하지만, 데이터가 1만행이 넘어가면 많이 늦어지고, 몇 만행이 넘어가면 그런 함수를 사용하는 것이 거의 불가능해진다. 아래의 코드는\n데이터의 위치를 그대로 유지하며,..."}
{"instruction": "Excel VBA code for: (1677) 다중조건으로 고급필터 적용하기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub append_Data()\nDim rngC As Range\nDim rngAll As Range\nDim rngD As Range\nDim rngData As Range\nDim i As Long\nDim j As Long\nDim str As String\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nIf Range(\"A2\") = \"\" Then\nMsgBox \"옮길 데이터가 없습니다. 종료합니다.\"\nElse\nSet rngAll = Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\nFor Each rngC In rngAll\n'---------------------------------------\n' 빈 시트일 경우 중복체크 없이 데이터 추가\n'---------------------------------------\nIf Sheets(rngC.Value).Range(\"A2\") = \"\" Then\n'월 시트에 데이터가 없으면\nrngC.Resize(, intCol).Copy Sheets(rngC).Cells(Rows.Count, \"A\").End(3)(2)\nExit For\nElse\nWith Sheets(rngC.Value)\nSet rngData = .Range(.Range(\"A2\"), .Cells(Rows.Count, \"A\").End(3))\nEnd With\n'--------------------\n' 중복 데이터인지 확인\n'--------------------\nFor Each rngD In rngData\nIf rngC = rngD Then\nFor i = 1 To intCol - 1\nIf rngC.Offset(, i) = rngD.Offset(, i) Then\nj = j + 1\nElse\nExit For\nEnd If\nNext i\n'---------------------------------------\n' 데이터가 이미 있을 경우 덮어쓸지 물어봄\n'---------------------------------------\nIf j = intCol Then\nstr = MsgBox(rngC.Row & \"행 : \" & rngC & \", \" & _\nrngC.Offset(, 1) & \", \" & rngC.Offset(, 2) & _\n\"과 동일한 데이터가 이미 존재합니다. 추가할까요?\", _\nvbYesNo + vbExclamation, \"데이터 중복\")\nIf str = vbYes Then\nrngC.Resize(, intCol).Copy _\nSheets(rngC.Value).Cells(Rows.Count, \"A\").End(3)(2)\nj = 0\nGoTo no_Two_Copies\nElse\nj = 0\nGoTo no_Two_Copies\nEnd If\nEnd If\nEnd If\nNext rngD\nrngC.Resize(, intCol).Copy _\nSheets(rngC.Value).Cells(Rows.Count, \"A\").End(3)(2)\nno_Two_Copies:\nEnd If\nNext rngC\nEnd If\nMsgBox \"데이터가 새로이 추가 되었습니다.\"\nEnd Sub\n\nSub delete_Append()\nActiveSheet.UsedRange.Offset(1).ClearContents\nEnd Sub\n\nSub back_To_Default_Data()\nDim str As String\nDim s As Long\n'----------------------------------------------------\n' 월 시트에 있는 모든 데이터를 초기화하므로 강력히 경고\n'----------------------------------------------------\nstr = MsgBox(\"경고!!! 모든 데이터를 초기화(삭제)합니다. 진행할까요?\", vbYesNo + vbCritical, \"전체데이터 삭제 경고\")\nIf str = vbYes Then\nFor s = 2 To Sheets.Count\nSheets(s).UsedRange.Offset(1).ClearContents\nNext s\nEnd If\nMsgBox \"모든 데이터가 삭제 되었습니다.\" & vbCrLf _\n& \"삭제를 되돌리려면 저장하지 말고 엑셀을 종료하세요.\"\nEnd Sub\n\nSub use_Advanced_Filter()\nDim rngCri As Range\n'필터링 조건 영역을 넣을 변수\nDim rngData As Range\n'전체 데이터 영역을 넣을 변수\nDim rngT As Range\n'필터된 결과 복사될 위치 넣을 변수\nDim rngAuto As Range\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n'-------------------------------------\n' 가져올 데이터가 없는 경우 매크로 종료\n'-------------------------------------\nIf Sheets(\"통합\").Range(\"A2\") = \"\" Then\nMsgBox \"통합시트에 데이터가 없습니다. 종료합니다.\", vbExclamation\nExit Sub\nEnd If\n'-------------------------\n' 고급필터 조건자료 가져옴.\n'-------------------------\nRange(\"A1\", Range(\"A1\").End(2)).Resize(2).Copy Cells(1, 1).Offset(, intCol + 1)\nRange(\"K2\") = \">=\" & Range(\"A2\")\nRange(\"L2\") = \"<=\" & Range(\"B2\")\nSet rngCri = Range(\"A1\", Range(\"A1\").End(2)).Offset(, intCol + 1).Resize(2) '고급필터 criteria 영역을 변수에 넣음\n'------------------------------\n' 고급필터 후 복사될 지점을 지정\n'------------------------------\nWith Sheets(\"통합\")\n'통합 시트에서\n.Activate\n'활성화\nSet rngData = Range(\"A1\").CurrentRegion\n'사용영역을 변수에 넣음\nSet rngT = Sheets(\"Main\").Cells(4, 1).Resize(, intCol)\n'복사가 될 지점을 변수에 넣음\nEnd With\n'--------------\n' 고급필터 실행\n'--------------\nrngData.AdvancedFilter _\nAction:=xlFilterCopy, _\nCriteriaRange:=rngCri, _\nCopyToRange:=rngT, _\nUnique:=False\n'각 조건에 따라 고급필터 적용\nSheets(\"Main\").Activate\n'Main 시트 활성화\n'-----------------------\n' 고급필터 후 필터링 실시\n'-----------------------\nSet rngAuto = Range(\"A4\", Cells(Rows.Count, \"A\").End(3))\n'자동필터 영역을 변수에\nIf ActiveSheet.AutoFilterMode = False Then\nrngAuto.Resize(, intCol).AutoFilter\n'자동필터 실행\nEnd If\nWith ActiveWorkbook.Worksheets(\"Main\").AutoFilter.Sort\n.SortFields.Clear\n.SortFields.Add2 Key:=rngAuto.Offset(, 1), SortOn:=0, Order:=1, DataOption:=0\n.Apply\nEnd With\nCells(4, intCol + 1).Formula = \"=SUBTOTAL(9, \" & rngAuto.Offset(1, intCol - 1).Address(0, 0) & \")\"\n'합계를 셀에 넣음\nrngCri.Clear\nSet rngData = Nothing\n'개체변수(들) 초기화\nSet rngT = Nothing\nEnd Sub\n\nSub delete_Main()\nIf Range(\"A5\") <> \"\" Then\nRange(\"A5\", Cells(Rows.Count, \"A\").End(3)).Resize(, intCol).Clear\nIf ActiveSheet.AutoFilterMode Then\nActiveSheet.UsedRange.AutoFilter\n'현재시트내의 필터 해제함\nEnd If\nEnd If\nEnd Sub\n\nSub bring_All_Data()\nDim s As Long\n'(s)heet 반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor s = 4 To Sheets.Count\nWith Sheets(s).UsedRange.Offset(1)\n.Copy Cells(Rows.Count, \"A\").End(3)(2).Resize(.Rows.Count, .Columns.Count)\nEnd With\nNext s\nRange(\"A1\").CurrentRegion.Offset(1).Sort [A2], 1\nEnd Sub\n\nSub delete_Data()\nRange(\"A1\").CurrentRegion.Offset(1).Clear\nEnd Sub", "context": "(개인적으로 이렇게 긴 코드들은 별로 선호하지 않는다. 주석달기도 힘들고, 오류 확률도 높고, 또 내가 목표로 하는 가능하면 많은 사람들이 사용하기를 원하는 코드를 올리기 힘들기 때문이다. 하지만, 이것 저것 까먹은 내용 공부하다가 지난번 올린 내용들 중에서 반응은 좋았지만, 내용은 좀 부실했었다고 생각이 들어서 조금 더 업데이트를 해보았다.)\nA2:G2 셀에 입력한 조건으로 1월~12월까지 12개의 시트에서\n부분일치하\n는 데이터를 고급필터를 이용하여 가져오는 기능.\n첨부된 파일을 내려받은 뒤 자신의 데이터에 맞추어 수정하고 사용하면 된다. 코드를 간단히 수정하면 열 개수의 제한이 없으므로 본인의 데이터에 맞추어 사용한다.(단 2열 이상이어야 함).\n시트개수에 제한이 없으므로 시트개수를 늘리거나 삭제하여 줄여도 된다.\n시트이름에 제한이 없으므로 원하는 이름으로 1월 ~ 12월 시트의 이름을 바꾸어도 된다.\n1월 ~ 12월 시트위치 제한이 없으므로 원하는 위치에 뒤죽박죽 시트를 위치하..."}
{"instruction": "Excel VBA code for: (1678) 데이터의 열개수 변환하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub transpose_Data_Vertically()\nDim rngIn As Range\n'마우스로 선택한 영역을 넣을 개체변수\nDim msg As String\n'입력창의 (m)e(s)sa(g)e 넣을 변수\nDim lngCol As Long\n'열(Col)umn 개수 넣을 변수\nDim rngSel As Range\n'선택(Sel)ection 영역 전체를 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nSet rngIn = Selection\n'마우스로 선택한 선택영역을 개체변수에 넣음\n'------------------------------\n'잘못된 영역 선택 시 경고창 출력\n'------------------------------\nIf rngIn.Cells.Count = 1 Or rngIn.\nAreas\n.Count > 1 Or _\nrngIn.Rows.Count = Rows.Count Or rngIn.Columns.Count = Columns.Count Then\nmsg = \"2셀 이상 선택하시고, \" & vbCrLf\nmsg = msg & \"1개의 영역만 선택하시고,\" & vbCrLf\nmsg = msg & \"전체행/전체열 선택하지 마시고 매크로를 실행하세요.\"\n'잘못된 영역 선택 시 경고창 출력\nMsgBox msg, vbExclamation\n'메시지창 출력\nExit Sub\n'매크로 종료\nEnd If\n'-------------------\n' 열 개수 입력창 출력\n'-------------------\nlngCol = Application.\nInputBox\n(\"열 개수를 입력하시요. 행 개수는 자동계산됩니다.\", _\n\"열개수 입력\", \"양의 숫자만 입력\", Type:=1)\n'영역을 선택할 수 있는 입력창 출력\nIf lngCol = False Then Exit Sub\n'복사될 위치 지정하지 않고 취소시 매크로 종료\nIf lngCol <= 0 Then\n'음수를 입력하면\nMsgBox \"양의 숫자만 입력하세요.\", vbExclamation\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nIf WorksheetFunction.\nCountA\n(rngIn) < lngCol Then\n'데이터가 열개수보다 작으면\nMsgBox \"데이터 개수가 입력한 열 개수보다 작습니다.\", vbExclamation\nExit Sub\n'메시지창 출력 후 종료\nEnd If\n'------------------------\n' 이동될 위치 입력창 출력\n'------------------------\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel = Application.InputBox(\"마우스로 복사될 위치를 선택하시오!\", , _\n\"한셀만 클릭\", Type:=8)\nIf rngSel Is Nothing Then\n'입력창에서 취소 선택 시\nExit Sub\n'취소 선택시 매크로 중단\nEnd If\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n'------------------------\n' 지정 위치에 데이터 입력\n'------------------------\nFor Each rngC In Range(rngSel.\nAddress\n).Resize(rngIn.Cells.Count / lngCol + 1, lngCol)\n'새로운 영역의 각 셀을 순환\ni = i + 1\n'셀의 위치가 될 숫자를 1씩 늘려감\nrngC = rngIn.Cells(i)\n'각 셀에 값을 입력\nIf i = rngIn.Cells.Count Then Exit Sub\n'마지막 데이터에 도달하면 매크로 종료\nNext rngC\nSet rngIn = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngSel = Nothing\nEnd Sub", "context": "데이터의 열 개수를 변환하는 기능.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1678) 데이터의 열개수 변환하기 (엑셀 VBA 매크로)\n재생\n530\n공유하기\n재생 (space/k)\n재생\n00:49\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:49\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n데이터를 (\nctrl + a\n)를 이용하여 선택.\n매크로 실행. 입력창에..."}
{"instruction": "Excel VBA code for: (1680) 조직도에 사진 넣기 (엑셀 VBA 매크로)", "input": "", "output": "Sub picture_To_Organiztion_Chart()\nDim rngC As Range\n'각 (C)ell 영역(range)을 넣을 변수\nDim rngAll As Range\n'A열 전체(All) 영역(range)을 넣을 변수\nDim wks As Worksheet\n'각 시트 (w)or(ks)heet 넣을 변수\nDim strName As String\n'이름 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nWith Sheets(\"Data\")\nSet rngAll = .Range(.Range(\"A1\"), .Cells(Rows.Count, \"A\").End(3))\n'A열을 변수에\nEnd With\nFor Each rngC In rngAll\n'A열 각셀을 순환\nIf rngC <> \"\" Then\n'빈셀이 아니라면\nstrName = rngC\n'이름을 변수에 넣음\nCall\nfind_Matching_Data(rngC, strName)\n'일치하는 이름 찾아 사진 복사하는 매크로 호출\nEnd If\nNext rngC\nCall\nfit_Picture_In_Cell\n'사진 속한 영역에 사진크기 맞추는 매크로\n호출\nSet rngAll = Nothing\n'개체변수 초기화\nMsgBox \"매크로가 종료되었습니다.\"\n'매크로 종료창 출력\nEnd Sub\n\nSub find_Matching_Data(ByVal rngC As Range, ByVal strName As String)\nDim strAddr As String\n'처음 검색하여 찾은 셀의 주소 넣을 변수\nDim C As Range\n'검색하여 찾은 영역을 넣을 변수\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\nSet C = .\nFind\n(What:=strName, Lookat:=xlWhole)\n'처음 일치하는 데이터 찾아 C에 넣고\nIf Not C Is Nothing Then\n'만일 일치하는 데이터가 있으면\nstrAddr = C.\nAddress\n'첫 일치하는 주소를 strAddr에 넣고\nSheets(\"Data\").Range(rngC.Address).Offset(, 1).Copy C.Offset(-1).\nMergeArea\nDo\n'다음을 실행\nSet C = .\nFindNext\n(C)\n'다음 일치하는 데이터를 찾아 변수에 넣고\nSheets(\"Data\").Range(rngC.Address).Offset(, 1).Copy C.Offset(-1).MergeArea\nLoop While Not C Is Nothing And C.Address <> strAddr\n'일치하는 데이터 없고 처음 일치한 주소 아닐때까지 반복\nEnd If\nEnd With\nEnd Sub\n\nSub fit_Picture_In_Cell()\nDim rngAll As Range\n'선택영역을 넣을 변수\nDim rngShp As Range\n'각 그림의 왼쪽위가 속한 영역을 넣을 변수\nDim shpC As Shape\n'각각의 도형(shape)을 넣을 변수\nDim rotationDegree As Integer\n'도형의 회전각도 넣을 변수\nSet rngAll = ActiveSheet.UsedRange\n'전체 사용영역을 변수에 넣음\nFor Each shpC In ActiveSheet.Shapes\n'전체영역내 각 그림을 순환\nIf shpC.\nType\n= 13 Then\n'만일 각 도형이 그림이라면\nSet rngShp = shpC.TopLeftCell\n'각 도형의 왼쪽위 영역을 변수에 넣음\nIf rngShp.MergeCells Then\n'rngShp가 셀병합된 셀이라면\nSet rngShp = rngShp.\nMergeArea\n'영역을 셀병합 영역으로 확장\nEnd If\nIf Not Intersect(rngAll, rngShp) Is Nothing Then\n'각 도형이 전체영역에 포함되면\nrotationDegree = shpC.\nRotation\n'그림의 회전각을 변수에 넣음\nIf rotationDegree = 90 Or rotationDegree = 270 Then\n'그림이 90도 or 270도 회전된 경우\nWith shpC\n'각 그림으로 작업\n.LockAspectRatio =\nmsoFalse\n'그림 좌우고정비율 해제\n.Rotation = 0\n'그림 회전을 원상태로 돌려 놓음\n.Height = rngShp.Width - 4\n'그림 높이를 현재셀 크기  - 4\n.Width = rngShp.Height - 4\n'그림 폭을 현재셀 크기 - 4\n.Left = rngShp.Left + (rngShp.Width - shpC.Width) / 2\n'그림 폭 가운데 위치가 셀의 중앙 오도록 정렬\n.Top = rngShp.Top + (rngShp.Height - shpC.Height) / 2\n'그림위쪽 가운데 위치가 셀의 중앙 오도록 정렬\n.Rotation = rotationDegree\n'그림 회전 각도를 복원\nEnd With\nElse\nWith shpC\n'각 그림으로 작업\n.LockAspectRatio = msoFalse\n'그림 좌우고정비율 해제\n.Left = rngShp.Left + 2\n'그림왼쪽위치를 셀의 왼쪽위 + 2\n.Top = rngShp.Top + 2\n'그림위쪽 위치를  셀의 왼쪽위 위치 + 2\n.Height = rngShp.Height - 4\n'그림 높이를 현재셀 크기  - 4\n.Width = rngShp.Width - 4\n'그림 폭을 현재셀 크기 - 4\nEnd With\nEnd If\nEnd If\nEnd If\nNext shpC\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nSub delete_All_Pictures()\nDim shp As Shape\n'각 도형을 넣을 변수\nFor Each shp In ActiveSheet.Shapes\n'시트내 각 도형을 순환\nIf shp.Name <> \"Insert\" And shp.Name <> \"Delete\" Then\n'도형이름이 Insert, Delete 아니라면\nshp.Delete\n'도형을 삭제\nEnd If\nNext shp\nMsgBox \"모든 사진이 삭제되었습니다.\"\n'매크로 종료창 출력\nEnd Sub", "context": "조직도에 사진을 넣는 기능. 코드는 길지만 예전에 만들어 놓은 것을 하위 프로시저로 사용하여 실제 코드 작성에는 몇 분 안걸렸다. 나는 1인 기업이라 이걸 만들어도 직접 사용할 가능성은 없다. 나도 이렇게 큰 회사 운영하면서 이런코드 한 번 써봤으면. 그나저나, 사장(Koala)님 인상 좋네.^^\n매크로 실행 전                                                    매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1680) 조직도에 사진 넣기 (엑셀 VBA 매크로)\n재생\n3,913\n공유하기\n재생 (space/k)\n재생\n00:25\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:25\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n..."}
{"instruction": "Excel VBA code for: (1682) 각행 무작위로 섞고 대괄호 안에 넣기 (엑셀 VBA 매크로)", "input": "", "output": "Sub reshuffle_and_Join()\nDim colsCnt As Integer\n'열 개수 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim str As String\n'문자 합칠 때 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nIf Selection.Cells.Count = 1 Then\n'영역을 선택하지 않았을 때\nMsgBox \"영역을 선택하고 매크로 실행.\", vbExclamation\n'메시지창 출력\nExit Sub\n'매크로 종류\nEnd If\nCall\nrandom_Reshuffle_Rows_Columns(Selection)\n'선택영역의 열(좌우)를 섞는 하위 코드 실행\ncolsCnt = Selection.Columns.Count\n'선택영역 열 개수를 변수에 넣음\nFor Each rngC In Selection.Columns(1).Cells\n'선택영역 각 셀을 순환\nstr = rngC.Value\n'문자를 이를 str변수에 첫 값을 넣음\nFor i = 1 To colsCnt - 1\n'전체 열개수 -1 만큼 반복\nstr = str & \" / \" & rngC.Offset(0, i)\n' /와 공백으로 문자들 연결\nNext i\nrngC.Resize(, colsCnt).ClearContents\n'기존 데이터 삭제\nrngC = \"[ \"\n&\nstr & \" ]\"\n'앞뒤에 대괄호 삽입\nstr = \"\"\n'재사용위하여 초기화\nNext rngC\nSelection.Columns(1).AutoFit\n'열너비 자동으로\nEnd Sub\n\nSub random_Reshuffle_Rows_Columns(ByVal rngSel As Range)\n'영역을 받아서 뒤섞을 코드\nDim varA As Variant\n'선택영역 넣을 배열변수\nDim rowsCnt As Long\n'선택영역 행 개수 넣을 변수\nDim colsCnt As Integer\n'선택영역 열 개수 넣을 변수\nDim varR\n'뒤섞은 결과 값을 넣을 배열\nDim varCnt() As Long\n'행 또는 열의 숫자만큼 카운터로 쓰일 배열\nDim varNo() As Long\n'행 또는 열 개수만큼 순차적으로 숫자 넣을 배열\nDim i As Long\n'행 또는 열 개수만큼 반복할 변수\nDim y As Long\n'행 또는 열 개수만큼 반복할 변수\nDim j As Long\n'랜덤 값을 넣을 변수\nRandomize\n'랜덤 발생기 초기화\nWith rngSel\n'선택영역에서\nvarA = .Value\n'배열에 선택영역을 넣음\nrowsCnt = .Rows.Count\n'선택영역 행 개수를 변수에 넣음\ncolsCnt = .Columns.Count\n'선택영역 열 개수를 변수에 넣음\nReDim\nvarR(1 To rowsCnt, 1 To colsCnt)\n'결과배열 크기 재지정\nReDim varCnt(1 To colsCnt)\n'카운터로 사용될 배열 크기 재지정\nFor i = 1 To colsCnt\n'열 개수만큼 반복\nvarCnt(i) = i\n'카운터 배열에 순차적 값을 넣음\nNext i\nFor y = 1 To rowsCnt\n'행 개수만큼 반복\nvarNo = varCnt\n'varNo 배열에 varCnt값을 넣음\n'-------------------------------------------------------------------------------\n' 무작위 위치값 추출 => 그 위치의 배열값을 결과배열에 => 제일뒤를 추출한 자리로 반복\n'-------------------------------------------------------------------------------\nFor i = colsCnt To 1 Step -1\n'제일 큰 열에서 부터 1씩 빼며 반복\nj = Int(Rnd * i) + 1\n'무작위 값을 추출\nvarR(y, i) = varA(y, varNo(j))\n'무작위로 추출한 위치의 배열 값을 varR에 순차적으로 넣음\nvarNo(j) = varNo(i)\n'제일 뒤에 있는 배열 값을 추출한 곳에 채워 넣음\nNext i\nNext y\n.Value = varR\n'결과배열에 추출한 값을 각 area에 뿌림\nEnd With\nEnd Sub", "context": "아래 코드는\n선택한 영역 각행\n을 좌우로 무작위로 섞어주고 대괄호\n안에 /와 함께 넣어 합치는 기능.\n코드는 길지만 좌우로 무작위로 섞는 코드는 예전에 이미 만든 것을 재활용 하였기에 금방 완성.\n매크로 실행 전 영역을 선택한 모습                       →    매크로 실행 후 결과\nOption Explicit\nSub reshuffle_and_Join()\nDim colsCnt As Integer\n'열 개수 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim str As String\n'문자 합칠 때 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nIf Selection.Cells.Count = 1 Then\n'영역을 선택하지 않았을 때\nMsgBox \"영역을 선택하고 매크로 실행.\", vbExclamation\n'메시지창 출력\nExit Sub\n'매크로 종류\nEnd If\nCall\nrandom_Reshuffle_Rows_Columns(Sele..."}
{"instruction": "Excel VBA code for: (1683) 폴더내 모든 그림파일 행열로 삽입 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Pictures_Column_Row_2()\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\n​\nDim 행 As Integer\n'행방향 들어가 사진의 개수\nDim 열 As Integer\n'열방향 들어가 사진의 개수\nDim 행높이 As Integer\n'그림이 들어갈 셀의 높이 넣을 변수\nDim 열너비 As Integer\n'그림이 들어갈 셀의 너비 넣을 변수\nDim 빈행 As Integer\n'행방향 그림사이 삽입할 빈 행의 개수 넣을 변수\nDim 빈열 As Long\n'열방향 그림사이 삽입할 빈 열의 개수 넣을 변수\nDim 빈행높이 As Integer\n'행방향 빈 행의 셀 높이 넣을 변수\nDim 빈열너비 As Long\n'열방향 빈 열의 셀 너비 넣을 변수\nDim 테두리 As Integer\n'사진테두리 남겨둘 변수\nDim cntP As Long\n'삽입할 사진의 총 개수 추출할 변수\nDim c As Long\n'열(c)olumn 방향 반복할 변수\nDim r As Long\n'행(r)ow 방향 반복할 변수\nDim cntPic As Long\n'사진개수 더해갈 변수\nDim rngC As Range\n'사진 들어갈 셀 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n​\n'----------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'----------------------------------------------\nWith Application.FileDialog(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName =\nDir\n(strPath)\n'(폴더내)각 그림파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\n열\n= Cells(6, 2)\n'B6 셀을 참조\n행높이\n= Cells(8, 2)\n열너비\n= Cells(9, 2)\n빈행\n= Cells(11, 2)\n빈열\n= Cells(12, 2)\n빈행높이\n= Cells(14, 2)\n빈열너비\n= Cells(15, 2)\n테두리\n= Cells(17, 2)\nSheets.Add\n'사진 삽입할 빈시트 하나 추가\n'---------------------\n' 폴더내 파일 개수 추출\n'---------------------\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\ncntP = cntP + 1\n'사진파일 개수를 1씩 늘려감\nfileName = Dir\n'다음 사진파일을 파일이름에 넣음\nLoop\n'무한 반복\n'---------------------------------\n' 사진 들어갈 셀, 빈행의 행높이 맞춤\n'---------------------------------\nIf 빈행 = 0 Then\n'빈행 삽입하지 않을 경우\nFor c = 1 To cntP / 열 + 1\n'전체사진개수/열개수 + 1만큼 반복\nCells(c, 1).RowHeight = 행높이\n'행 높이 설정\nNext c\nElse\nFor r = 1 To cntP / 열 + 1\n'빈행 삽입하는 경우\nCells(r + (r - 1) * 빈행, 1).\nRowHeight\n= 행높이\n'사진들어갈 행의 높이 설정\nCells(r + (r - 1) * 빈행, 1).Offset(1).Resize(빈행).RowHeight = 빈행높이\nNext r\n'빈행들의 행높이 설정\nEnd If\n'---------------------------------\n' 사진 들어갈 셀, 빈열의 열너비 맞춤\n'---------------------------------\nIf 빈열 = 0 Then\n'빈열 삽입하지 않을 경우\nFor c = 1 To 열\n'열 개수만큼 반복\nCells(1, c).\nColumnWidth\n= 열너비\n'열너비 설정\nNext c\nElse\n'빈열 삽입하는 경우\nFor c = 1 To 열 * 빈열\n'열 x 빈열 만큼 반복\nCells(1, c + (c - 1) * 빈열).ColumnWidth = 열너비\n'사진들어갈 열의 열너비 설정\nCells(1, c + (c - 1) * 빈열).Offset(, 1).Resize(, 빈열).ColumnWidth = 빈열너비\nNext c\n'빈열들의 열너비 설정\nEnd If\nfileName = Dir(strPath)\n'(폴더내)각 그림파일 이름을 변수에 넣음\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\n'---------------------------\n' 사진의 위치를 지정하는 코드\n'---------------------------\nFor r = 1 To 100000\n'10만장 넣을 가능성 없으므로 넉넉하게 숫자 넣음\nFor c = 1 To 열\n'전체열 개수만큼 반복\nIf cntPic = cntP Then\n'만일 전체 사진 숫자에 도달하면\nExit Do\n'Do 구문 종료\nEnd If\ncntPic = cntPic + 1\n'삽입하는 사진 숫자 1씩 늘려감\n'------------------------------------------------\n' 빈행 또는 빈열 삽입 유무에 따른 사진 삽입위치 설정\n'------------------------------------------------\nIf 빈행 = 0 And 빈열 = 0 Then\n'빈행과 빈열을 삽입하지 않을 경우\nSet rngC = Cells(r, c)\n'사진이 삽입될 위치 지정\nElseIf 빈행 <> 0 And 빈열 = 0 Then\n'빈열만 삽입할 경우\nSet rngC = Cells(r + ((r - 1) * 빈행), c)\n'사진이 삽입될 위치 지정\nElseIf 빈행 = 0 And 빈열 <> 0 Then\n'빈행만 삽입할 경우\nSet rngC = Cells(r, c + ((c - 1) * 빈열))\n'사진이 삽입될 위치 지정\nElse\n'빈행과 빈열을 삽입할 경우\nSet rngC = Cells(r + ((r - 1) * 빈행), c + ((c - 1) * 빈열))\n'사진이 삽입될 위치 지정\nEnd If\nActiveSheet.Shapes.AddPicture(strPath & fileName, 1, 1, 1, 1, 100, 100).Select\n'사진을 대충 아무위치 아무크기로 불러옴\n​\n'                ActiveSheet.Pictures.Insert(strPath & fileName).Select\n'링크로 삽입하기 원할 경우 윗행 삭제후 이 코드 주석제거\n'-------------------------------------\n' 지정된 위치에 테두리\n여유주고 사진삽입\n'-------------------------------------\nWith Selection\n'선택된 사진에서\n.ShapeRange.LockAspectRatio =\nmsoFalse\n'사진의 가로/세로크기 고정 해제\n.Height = rngC.Height - (테두리 * 2)\n'사진의 가로크기 지정\n.Width = rngC.Width - (테두리 * 2)\n'사진의 세로크기 지정\n.Left = rngC.Left + 테두리\n'사진의 왼쪽위치 지정\n.Top = rngC.Top + 테두리\n'사진의 위쪽위치 지정\nrngC.Offset(1) = fileName\n'사진 아래에 파일명 넣음\nEnd With\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nNext c\nNext r\nLoop\n'무한 반복\n'----------------------------------------------\n' 사진을 압축하여 파일크기 줄일것인지 묻는창 출력\n'----------------------------------------------\nApplication.CommandBars.\nExecuteMso\n\"PicturesCompress\"\n'사진 압축창 출력\nMsgBox \"매크로가 종료 되었습니다.\"\n'매크로 종료창 출력\nEnd Sub", "context": "앞 버전이 이것 저것 사소한 문제가 있어서 단점을 보완하고 , 그리고 사용하기 편하게 만들었다.\n​\n습관상 모든 변수를 영어로 사용하지만 이 코드만큼은 많은 분들이 알아듣기 쉽고 사용하기 편하도록 중요 변수마저도 한글로 하였다. 윗 그림과 아래 설명을 두 어번만 읽어보고 아래 동영상을 보면 어떻게 수정할지 손쉽게 알 수 있을 것이다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1683) 폴더내 모든 그림파일 행열로 삽입 2 (엑셀 VBA 매크로)\n재생\n1,138\n공유하기\n재생 (space/k)\n재생\n01:24\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:24\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x..."}
{"instruction": "Excel VBA code for: (1684) 폴더내 모든파일 특정시트 복수열 불러오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_Multiple_Columns_In_Folder_1()\nDim strSht As String\n'시트 이름을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim rngT As Range\n'각 열이 복사될 위치 넣을 영역변수\nDim i As Long\n'열 개수만큼 반복할 변수\nDim strC As String\n'choose 함수에 사용할 변수\nDim strCol As String\n'가져올 열 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.ClearContents\n'기존데이터 삭제\nstrSht = \"\nSheet1\n\"\n'데이터가 저장된 시트의 이름\n'-----------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'-----------------------------------------------\nWith Application.FileDialog(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더를 선택한 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'--------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'--------------------------------\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 엑셀 파일이 없음.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nFor i = 1 To\n3\nSet rngT = Cells(1, Columns.Count).End(1)(1, 2)\n'각 열이 복사되는 기준위치를 변수에\nstrC =\nChoose\n(i,\n\"A\", \"C\", \"E\"\n)\n'각 열을 돌아가면서 선택\nstrCol = \"$\" & strC & \":\" & \"$\" & strC\n'열 위치를 변수에 넣음\nrngT.Offset(1) = strC\n'열 문자 입력\n'-------------------------------------------------------------\n' 배열수식을 이용하여 데이터 가져오고 수식을 값으로 변환하는 코드\n'-------------------------------------------------------------\nrngT.Formula = \"=\nCOUNTA\n('\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & strCol & \")\"\n'각열의 데이터 개수를 찾아 변수에 넣음\nIf rngT > 0 Then\n'열에 데이터가 존재할 경우\nWith rngT.Offset(2).Resize(rngT.Value)\n'각 열의 데이터\n.FormulaArray = \"='\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & Range(strC & \"1\").Resize(rngT.Value).Address(1, 1, 1)\n'데이터 영역을 배열 이용하여 가져옴\n.Value = .Value\n'셀의 수식을 값으로 바꿈\nEnd With\nEnd If\nrngT = fileName\n'1행에 파일 이름을 넣음\nNext i\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nColumns.AutoFit\n'열너비 자동 맞춤\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "​\n폴더내에 저장된 모든 엑셀파일내 특정 이름을 가진 시트로부터 복수의 열을 가져오는 코드\n이다. 아래의 코드는 Sheet1시트로 부터 A, C, E 3개의 열을 가져오는 것을 예제로 하였다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1684) 폴더내 모든파일 특정시트 복수열 불러오기 (엑셀 VBA 매크로)\n재생\n1,721\n공유하기\n재생 (space/k)\n재생\n00:37\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:37\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재..."}
{"instruction": "Excel VBA code for: (1685) 사진 테두리 없애기(crop) 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub crop_Picture_Frame()\nDim obj As Object\n'선택한 개체를 넣을 개체 변수\nDim sngLeft As Single\n'사진의 왼쪽 위치 넣을 변수\nDim sngTop As Single\n'사진의 윗쪽 위치 넣을 변수\nDim sngWidth As Single\n'사진의 폭을 넣을 변수\nDim sngHeight As Single\n'사진의 높이를 넣을 변수\nDim intCrop As Integer\n'사진의 crop 되는 정도를 넣을 변수\nDim raiseW As Single\n'사진의 너비 키울 변수\nDim raiseH As Single\n'사진의 높이 키울 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet obj = Selection\n'선택한 것을 개체 변수에 넣음\nintCrop =\n1\n'\n테두리 잘려나갈 크기\n는 기본으로 1 넣음\nIf\nTypeName\n(obj) <> \"Picture\" Then\n'선택한 것이 사진이 아니라면\nMsgBox \"사진을 선택 후 재실행 하시오.\", vbExclamation\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nWith Selection\n'선택한 것과 함께\nraiseW = (.Width * 1 / 100) / 2\n'사진 너비를 1/100 배 나누기 2 (증가시키려 함)\nraiseH = (.Height * 1 / 100) / 2\n'사진 높이를 1/100배 나누기 2 (증가시키려 함)\nWith .ShapeRange\n'사진의 범위\n.LockAspectRatio =\nmsoFalse\n'좌우 고정비율을 해제\n.IncrementLeft raiseW\n'사진 왼쪽 위치 늘림\n.IncrementTop raiseH\n'사진 윗쪽 위치 늘림\n.ScaleWidth 0.99, 0, 0\n'사진의 너비 스케일을 0.01% 낮춤\n.ScaleHeight 0.99, 0, 0\n'사진의 높이 스케일을 0.01% 낮춤\nWith .PictureFormat.\nCrop\n'사진포맷의 crop\n.PictureWidth = .PictureWidth + intCrop\n'지정한 크기 만큼 너비 늘림\n.PictureHeight = .PictureHeight + intCrop\n'지정한 크기 만큼 높이 늘림\n'                .PictureOffsetX = 0\n'                .PictureOffsetY = 0\nEnd With\nEnd With\nEnd With\nSet obj = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "지난 번부터 이 기능을 만들어 두려고 하였다. 회사 소개서나 다른 문서 작업을 워드나 파워포인트에서 하면서 사진에 테두리를 넣었다가 나중에 재활용 시 이 테두리를 없애는데 상당한 시간을 빼았겼다. 워드, 엑셀, 파워포인트, 아웃룩은 모두 호환이 잘되니 엑셀에 가져와서 테두리 제거하고 사용하면 될듯.\n이 코드는 검색도 한 번 안하고 자동기록 장치와 짜깁기를 이용하여 즉석에서 만듬. 매크로는 필요할 때 이렇게 만들 수 있는 능력만 있으면 일반인은 더 공부하지 않아도 될 것 같다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1685) 사진 테두리 없애기(crop) 1 (엑셀 VBA 매크로)\n재생\n622\n공유하기\n재생 (space/k)\n재생\n00:35\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:35\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n..."}
{"instruction": "Excel VBA code for: (1686) 번호표 인쇄 (엑셀 VBA 매크로)", "input": "", "output": "Sub print_Number_Ticket()\nDim rngAll As Range\n'전체(All) 영역을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell 영역을 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Range(\"A1\", Cells(Rows.Count, \"A\").End(3))\n'A열 데이터를 변수에\nIf Range(\"C2\") = \"\" Or Range(\"C5\") = \"\" Then\n'페이지 또는 가로/세로 옵션을 선택안하면\nMsgBox \"페이지 숫자 또는 가로/세로 옵션 선택후 재실행\", vbExclamation\nExit Sub\n'메시지 출력 후 매크로 중단\nEnd If\nIf Range(\"C2\") = 1 And Range(\"C5\") = \"세로\" Then\n'페이지당 1장, 세로인쇄 선택시\nFor Each rngC In rngAll\n'전체영역 각셀을 순환\nSheets(\"1P\").Range(\"A1\") = rngC\n'각 셀값을 셀에 입력\nSheets(\"1P\").\nPrintOut\n'1P 시트 인쇄\nNext rngC\nElseIf Range(\"C2\") = 2 And Range(\"C5\") = \"세로\" Then\n'페이지당 2장, 세로인쇄 선택시\nr = 1\n'1행부터 시작\nDo\nSheets(\"2P\").Range(\"A1\") = Cells(r, 1)\n'첫 셀값을 셀에 입력\nSheets(\"2P\").Range(\"A24\") = Cells(r + 1, 1)\n'두 번째 셀값을 셀에 입력\nSheets(\"2P\").PrintOut\n'2P 시트 인쇄\nr = r + 2\n'2행씩 늘려감\nLoop Until\nCells(r, 1) = \"\"\nElseIf Range(\"C2\") = 4 And Range(\"C5\") = \"세로\" Then\n'페이지당 2장, 세로인쇄 선택시\nr = 1\n'1행부터 시작\nDo\nSheets(\"4P\").Range(\"A1\") = Cells(r, 1)\n'첫 셀값을 셀에 입력\nSheets(\"4P\").Range(\"C1\") = Cells(r + 1, 1)\n'두 번째 셀값을 셀에 입력\nSheets(\"4P\").Range(\"A24\") = Cells(r + 2, 1)\n'세 번째 셀값을 셀에 입력\nSheets(\"4P\").Range(\"C24\") = Cells(r + 3, 1)\n'네 번째 셀값을 셀에 입력\nSheets(\"4P\").PrintOut\n'4P 시트 인쇄\nr = r + 4\n'4행씩 늘려감\nLoop Until Cells(r, 1) = \"\"\nElseIf Range(\"C2\") = 1 And Range(\"C5\") = \"가로\" Then\n'페이지당 1장, 가로인쇄 선택시\nFor Each rngC In rngAll\n'전체영역 각셀을 순환\nSheets(\"1H\").Range(\"A1\") = rngC\n'각 셀값을 셀에 입력\nSheets(\"1H\").PrintOut\n'1H 시트 인쇄\nNext rngC\nElseIf Range(\"C2\") = 2 And Range(\"C5\") = \"가로\" Then\n'페이지당 2장, 가로인쇄 선택시\nr = 1\n'1행부터 시작\nDo\nSheets(\"2H\").Range(\"A1\") = Cells(r, 1)\n'첫 셀값을 셀에 입력\nSheets(\"2H\").Range(\"C1\") = Cells(r + 1, 1)\n'두 번째 셀값을 셀에 입력\nSheets(\"2H\").PrintOut\n'2H 시트 인쇄\nr = r + 2\n'2행씩 늘려감\nLoop Until Cells(r, 1) = \"\"\nElseIf Range(\"C2\") = 4 And Range(\"C5\") = \"가로\" Then\n'페이지당 4장, 가로인쇄 선택시\nr = 1\n'1행부터 시작\nDo\nSheets(\"4H\").Range(\"A1\") = Cells(r, 1)\n'첫 셀값을 셀에 입력\nSheets(\"4H\").Range(\"C1\") = Cells(r + 1, 1)\n'두 번째 셀값을 셀에 입력\nSheets(\"4H\").Range(\"A17\") = Cells(r + 2, 1)\n'세 번째 셀값을 셀에 입력\nSheets(\"4H\").Range(\"C17\") = Cells(r + 3, 1)\n'네 번째 셀값을 셀에 입력\nSheets(\"4H\").PrintOut\n'4H 시트 인쇄\nr = r + 4\n'4행씩 늘려감\nLoop Until Cells(r, 1) = \"\"\nEnd If\nSheets(\"Data\").Activate\n'Data 시트 활성화\nEnd Sub\n\nSub delete_Data()\nDim i As Long\n'반복구문에 사용할 변수\nFor i = 3 To Sheets.Count\n'3번째 시트 부터 마지막 시트까지 반복\nSheets(i).UsedRange.\nClearContents\n'사용영역의 데이터 삭제\nNext i\nMsgBox \"모든 기존 데이터가 삭제되었습니다.\"\n'삭제 완료 메시지 출력\nEnd Sub", "context": "음식점은 물론 줄서는 곳이나 사람이 많이 모이는 곳에서 번호표를 많이 사용한다. 아래의 코드는\n번호표 또는 자신이 원하는 문자를 크게 인쇄하기 위한 용도\n로 만들었다.\nA열에 입력된 문자를 인쇄하려는 목적. 각 셀에 있는 글자를 옵션 선택에 따라 페이지당\n1자, 2자, 4자를 세로로 인쇄, 또는\n1자, 2자, 4자를 가로로 인쇄하는 기능을 한다.\n페이지당 인쇄를 원하는 옵션과 가로/세로 옵션 선택 후 인쇄를 누르면 된다.\n1P, 2P, 4P는 한 셀에 숫자 1개씩만 크게 인쇄되도록 설정하였고,\n1H, 2H, 4H는 한 셀에 숫자 3개 까지 들어가도록 설정하여 놓았다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1686) 번호표 인쇄 (엑셀 VBA 매크로)\n재생\n1,100\n공유하기\n재생 (space/k)\n재생\n00:42\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:42\n실시간\n설정\n전체 화면 (f)\n해..."}
{"instruction": "Excel VBA code for: (1690) 선택영역을 랜덤(random)하게 뒤섞기 11 (엑셀 VBA 매크로)", "input": "", "output": "Sub random_Reshuffle_6()\nDim rngA As Range\n'각 area를 넣을 변수\nDim rowsCnt As Long\n'전체 행의 개수 넣을 변수\nDim colsCnt As Integer\n'전체 열의 개수 넣을 변수\nDim maxNo As Long\n'선택영역 셀 개수 넣을 변수\nDim varTemp()\n'임시배열로 사용할 배열변수\nDim varR()\n'결과 값을 넣을 동적배열 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nDim x As Integer\n'열 방향 늘려갈 변수\nDim y As Long\n'행 방향 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngA In Selection.\nAreas\n'선택영역 각 area를 순환\nRandomize\n'랜덤값 발생기 초기화\n'(계속 새로운 랜덤 기준값 생성)\nWith rngA\n'각 area에서\nrowsCnt = .Rows.Count\n'전체 행 개수를 변수에 넣음\ncolsCnt = .Columns.Count\n'전체 열 개수를 변수에 넣음\nmaxNo = .Count\n'선택영역 셀 개수를 변수에 넣음\nEnd With\nReDim\nvarTemp(1 To maxNo)\n'임시배열의 크기 재지정\nReDim varR(1 To rowsCnt, 1 To colsCnt)\n'결과 열의 크기 재지정\nFor Each rngC In rngA\n'가 area의 각 셀을 순환\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = rngC\n'각 셀을 배열에 넣음\nNext rngC\nFor y = 1 To rowsCnt\n'area 의 행 개수 만큼 반복\nFor x = 1 To colsCnt\n'area의 열 개수 만큼 반복\nr = Int(\nRnd\n() * maxNo) + 1\n'무작위 값을 추출\nvarR(y, x) = varTemp(r)\n'배열에 랜덤값을 채워감\nvarTemp(r) = varTemp(maxNo)\n'배열 윗값을 추출된 위치에 채움\nmaxNo = maxNo - 1\n'전체 셀 개수 1개씩 줄여감\nNext x\nNext y\nrngA = varR\n'결과배열 값을 각 area에 뿌림\nr = 0\nNext rngA\nEnd Sub", "context": "아래 동영상에서 보듯 선택된 영역을 무작위로 뒤 섞어 주는 기능. 기존에는 1개의 area만 선택할 수 있었지만 이제는 ctrl + 마우스로 여러개의 영역을 선택하여도 된다. A1:J100000 셀까지 즉,\n1,000,000 개의 셀\n을 선택하고 무작위로 섞었을 때 내 컴퓨터로\n2초 정도 소요\n.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1396) 선택영역을 랜덤(random)하게 뒤섞기 10 (엑셀 VBA 매크로)\n재생\n1,880\n공유하기\n재생 (space/k)\n재생\n00:09\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:09\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해..."}
{"instruction": "Excel VBA code for: (1691) 매크로파일(.xlsm)을 매크로와 매크로 버튼 제거후 저장(엑셀 VBA 매크로)", "input": "", "output": "Sub save_As_Xlsx_File()\nDim btnName As String\n'매크로 버튼의 이름 넣을 변수\nDim wkb As Workbook\n'매크로 실행파일 넣을 변수\nDim newName As String\n'파일이름 넣을 변수\nDim s As Integer\n'반복구문에 사용할 변수\nbtnName = ActiveSheet.Shapes(\nApplication.Caller\n).Name\n'매크로 버튼 이름을 변수에 넣음\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet wkb = ActiveWorkbook\n'현재 시트를 개체변수에 넣음\nnewName = wkb.Path & \"\\\" &\nFormat\n(\nNow\n, \"yyyy-mm-dd AM/PM hh-nn\") & \".xlsx\"\n'복사된 파일을 날짜 + 시간으로 .xlsx로 저장\n'----------------------------------------------------------\n' 너무 빨리 매크로 연속실행 시 기존파일 존재하면 경고하는 기능\n'----------------------------------------------------------\nIf\nLen\n(\nDir\n(newName)) <> 0 Then\n'동일이름의 파일 존재 유무 확인\nMsgBox \"파일이 이미 존재. 조금 있다 다시 시행\", 64, \"동일 파일 존재\"\nExit Sub\n'매크로 종료\nEnd If\nSheets.Copy\n'전체 시트를 복사\nActiveSheet.Shapes(btnName).Delete\n'매크로 버튼만 삭제\nApplication.\nDisplayAlerts\n= False\n'화면 경고 비활성화\nWith ActiveWorkbook\n.\nSaveAs\nFilename:=newName, FileFormat:=xlOpenXMLWorkbook\n'파일을 일반 .xlsx파일로 다른이름으로 저장\n.Close\n'복사된 파일 닫기\nEnd With\nApplication.DisplayAlerts = False\n'화면 경고창 되돌려 놓기\nMsgBox \"파일이 xlsx 파일로 성공적으로 저장되었습니다.\"\n'성공 메시지 출력\nEnd Sub", "context": "아래의 코드는\n1. 매크로파일(.xlsm)에서 매크로와 매크로 버튼 제거후 일반 엑셀파일 즉, .xlsx 파일로 저장.\n2. 복사파일의 저장위치는 매크로를 실행한 폴더와 동일한 위치.\n3. 저장 파일명은 오늘날짜 + 시간.\n와 같은 기능을 한다. 일종의 매크로 파일의 백업 파일을 생성하는 것과 기능을 함.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1691) 매크로파일(.xlsm)을 매크로와 매크로 버튼 제거후 저장(엑셀 VBA 매크로)\n재생\n1,891\n공유하기\n재생 (space/k)\n재생\n00:37\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:37\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x..."}
{"instruction": "Excel VBA code for: (1693) 폴더내 모든 그림파일 행열로 삽입 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Pictures_Column_Row_3()\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n'----------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'----------------------------------------------\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nCall\nloop_Through_Folders\n'폴더 순환하는 하위 코드를 호출\nSheets(1).Activate\n'매크로 시트 활성화\nMsgBox \"사진삽입이 완료 되었습니다.\"\n'매크로 종료창 출력\nEnd Sub\n\nPrivate Function loop_Through_Folders()\nDim fSO As Scripting.\nFileSystemObject\n'FileSystemObject를 넣을 변수\nDim fldName As Scripting.Folder\n'상위폴더 전체경로(마지막이 \"\\\")를 넣을 변수\nDim subFolder As Scripting.Folder\n'하위폴더 넣을 변수\nSet fSO = New Scripting.FileSystemObject\n'새로운 파일시스템 개체를 변수에\nSet fldName = fSO.GetFolder(strPath)\n'선택한 폴더의 이름을 변수에 넣음\n'-----------------------------------------------------------------\n''사진폴더'내 하위폴더를 순환하며 폴더명을 사진삽입 프로시저에 넘겨줌\n'-----------------------------------------------------------------\nFor Each subFolder In fldName.\nSubFolders\n'각 폴더의 하위폴더를 순환\nCall\ninsert_Pictures_Column_Row_2(subFolder)\n'사진삽입해주는 하위 프로시저 호출\nNext subFolder\nSet fSO = Nothing\nSet fldName = Nothing\n'개체변수들 초기화(메모리 비우기)\nEnd Function\n\nSub insert_Pictures_Column_Row_2(ByVal subFolder As String)\nDim wksName As String\n'각 시트이름 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim 행 As Integer\n'행방향 들어갈 사진의 개수\nDim 열 As Integer\n'열방향 들어갈 사진의 개수\nDim 행높이 As Integer\n'그림이 들어갈 셀의 높이 넣을 변수\nDim 열너비 As Integer\n'그림이 들어갈 셀의 너비 넣을 변수\nDim 빈행 As Integer\n'행방향 그림사이 삽입할 빈 행의 개수 넣을 변수\nDim 빈열 As Long\n'열방향 그림사이 삽입할 빈 열의 개수 넣을 변수\nDim 빈행높이 As Integer\n'행방향 빈 행의 셀 높이 넣을 변수\nDim 빈열너비 As Long\n'열방향 빈 열의 셀 너비 넣을 변수\nDim 테두리 As Integer\n'사진테두리 남겨둘 변수\nDim cntP As Long\n'삽입할 사진의 총 개수 추출할 변수\nDim c As Long\n'열(c)olumn 방향 반복할 변수\nDim r As Long\n'행(r)ow 방향 반복할 변수\nDim cntPic As Long\n'사진개수 더해갈 변수\nDim rngC As Range\n'사진 들어갈 셀 넣을 변수\nwksName = Right(subFolder, Len(subFolder) -\nInStrRev\n(subFolder, \"\\\"))\n'폴더명(시트명) 추출\n​\nWith Sheets(1)\n'매크로시트에서\n열 = .Cells(6, 2)\n'B6 셀을 열에 넣음\n행높이 = .Cells(8, 2)\n열너비 = .Cells(9, 2)\n빈행 = .Cells(11, 2)\n빈열 = .Cells(12, 2)\n빈행높이 = .Cells(14, 2)\n빈열너비 = .Cells(15, 2)\n테두리 = .Cells(17, 2)\nEnd With\nSheets(wksName).Activate\n'이름 일치하는 시트 활성화\nsubFolder = subFolder & \"\\\"\n'폴더 경로에 \\ 추가\nfileName = Dir(subFolder)\n'(폴더내)각 그림파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nExit Sub\n'하위 프로시저 빠져나감\nEnd If\n'----------------------\n' 폴더내 파일 개수 추출\n'----------------------\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\ncntP = cntP + 1\n'사진파일 개수를 1씩 늘려감\nfileName = Dir\n'다음 사진파일을 파일이름에 넣음\nLoop\n'무한 반복\n'---------------------------------\n' 사진 들어갈 셀, 빈행의 행높이 맞춤\n'---------------------------------\nIf 빈행 = 0 Then\n'빈행 삽입하지 않을 경우\nFor c = 1 To cntP / 열 + 1\n'전체사진개수/열개수 + 1만큼 반복\nCells(c, 1).RowHeight = 행높이\n'행 높이 설정\nNext c\nElse\nFor r = 1 To cntP / 열 + 1\n'빈행 삽입하는 경우\nCells(r + (r - 1) * 빈행, 1).\nRowHeight\n= 행높이\n'사진들어갈 행의 높이 설정\nCells(r + (r - 1) * 빈행, 1).Offset(1).Resize(빈행).RowHeight = 빈행높이\nNext r\n'빈행들의 행높이 설정\nEnd If\n'---------------------------------\n' 사진 들어갈 셀, 빈열의 열너비 맞춤\n'---------------------------------\nIf 빈열 = 0 Then\n'빈열 삽입하지 않을 경우\nFor c = 1 To 열\n'열 개수만큼 반복\nCells(1, c).\nColumnWidth\n= 열너비\n'열너비 설정\nNext c\nElse\n'빈열 삽입하는 경우\nFor c = 1 To 열 * 빈열\n'열 x 빈열 만큼 반복\nCells(1, c + (c - 1) * 빈열).ColumnWidth = 열너비\n'사진들어갈 열의 열너비 설정\nCells(1, c + (c - 1) * 빈열).Offset(, 1).Resize(, 빈열).ColumnWidth = 빈열너비\nNext c\n'빈열들의 열너비 설정\nEnd If\nfileName = Dir(subFolder)\n'(폴더내)각 그림파일 이름을 변수에 넣음\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\n'---------------------------\n' 사진의 위치를 지정하는 코드\n'---------------------------\nFor r = 1 To 100000\n'10만장 넣을 가능성 없으므로 넉넉하게 숫자 넣음\nFor c = 1 To 열\n'전체열 개수만큼 반복\nIf cntPic = cntP Then\n'만일 전체 사진 숫자에 도달하면\nExit Do\n'Do 구문 종료\nEnd If\ncntPic = cntPic + 1\n'삽입하는 사진 숫자 1씩 늘려감\n'------------------------------------------------\n' 빈행 또는 빈열 삽입 유무에 따른 사진 삽입위치 설정\n'------------------------------------------------\nIf 빈행 = 0 And 빈열 = 0 Then\n'빈행과 빈열을 삽입하지 않을 경우\nSet rngC = Cells(r, c)\n'사진이 삽입될 위치 지정\nElseIf 빈행 <> 0 And 빈열 = 0 Then\n'빈열만 삽입할 경우\nSet rngC = Cells(r + ((r - 1) * 빈행), c)\n'사진이 삽입될 위치 지정\nElseIf 빈행 = 0 And 빈열 <> 0 Then\n'빈행만 삽입할 경우\nSet rngC = Cells(r, c + ((c - 1) * 빈열))\n'사진이 삽입될 위치 지정\nElse\n'빈행과 빈열을 삽입할 경우\nSet rngC = Cells(r + ((r - 1) * 빈행), c + ((c - 1) * 빈열))\n'사진이 삽입될 위치 지정\nEnd If\nActiveSheet.Shapes.\nAddPicture\n(subFolder & fileName, 1, 1, 1, 1, 100, 100).Select\n'사진을 대충 아무위치 아무크기로 불러옴\n'                ActiveSheet.Pictures.Insert(strPath & fileName).Select\n'링크로 삽입하기 원할 경우 윗행 삭제후 이 코드 주석제거\n​\n​\nfileName = Dir\n'다음 파일을 파일이름에 넣음\n'-------------------------------------\n' 지정된 위치에 테두리\n여유주고 사진삽입\n'-------------------------------------\nWith Selection\n'선택된 사진에서\n.ShapeRange.LockAspectRatio =\nmsoFalse\n'사진의 가로/세로크기 고정 해제\n.Height = rngC.Height - (테두리 * 2)\n'사진의 가로크기 지정\n.Width = rngC.Width - (테두리 * 2)\n'사진의 세로크기 지정\n.Left = rngC.Left + 테두리\n'사진의 왼쪽위치 지정\n.Top = rngC.Top + 테두리\n'사진의 위쪽위치 지정\nEnd With\nNext c\nNext r\nLoop\n'무한 반복\n'-----------------------------------------------\n' 사진을 압축하여 파일크기 줄일것인지 묻는창 출력\n'-----------------------------------------------\n'    Application.CommandBars.ExecuteMso \"PicturesCompress\"   '사진 압축창 출력\nEnd Sub\n\nSub delete_Pictures()\nDim wks As Worksheet\n'각 시트를 넣을 변수\nDim shp As\nShape\n'도형을 넣을 변수\nFor Each wks In ActiveWorkbook.Worksheets\n'파일 각 시트 순환\nIf wks.Name <> \"매크로시트\" Then\n'매크로시트가 아니면\nFor Each shp In wks.Shapes\n'각 시트의 도형을 순환\nshp.Delete\n'도형을 삭제\nNext shp\nwks.\nCells\n.Delete Shift:=xlUp\n'전체 데이터 영역 삭제\nEnd If\nNext wks\nMsgBox \"모든 사진이 삭제 되었습니다.\"\n'매크로 종료창 출력\nEnd Sub", "context": "메인 '사진폴더'가 있고, 그 폴더의 하위폴더에 많은 사진들이 저장된 상태.\n하위폴더의 이름과 시트명이 일치할 때, 하위폴더 내의 사진을 일치한 시트명에 삽입해주는 코드\n.\n사진 폴더내에 3개의 폴더(Sheet1, Sheet2, Sheet3)가 들어 있음. Sheet3는 폴더가 없음.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1693) 폴더내 모든 그림파일 행열로 삽입 3 (엑셀 VBA 매크로)\n재생\n858\n공유하기\n재생 (space/k)\n재생\n01:35\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:35\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도..."}
{"instruction": "Excel VBA code for: (1694) Dictionary, 피벗 이용한 중복 제거 (엑셀 VBA 매크로)", "input": "", "output": "Sub unique_Dictionary()\nDim DicT As\nDictionary\n'새로운 사전(DicT)ionary 넣을 변수\nDim rngAll As Range\n'전체(All) 데이터 영역(r)a(ng)e을 넣을 변수\nDim r As Long\n'행(r)ow 반복에 사용할 변수\nDim rngC As Range\n'영역(r)a(ng)e 순환 시 셀(C)ell 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Range(\"A1\", Cells(Rows.Count, \"A\").End(3))\n'전체 영역을 변수에 넣음\nSet DicT = New Dictionary\n'개체변수에 사전을 넣음\nFor Each rngC In rngAll.Cells\n'전체영역 각 셀을 순환\nIf Not DicT.\nExists\n(rngC.Value) Then DicT.Add rngC.Value, \"\"\n'사전에 없으면 사전에 넣음\nNext rngC\nFor r = 0 To DicT.Count - 1\n'\n사전 item 개수만큼 반복 (배열이라 0부터 시작)\nCells(r + 1, 3) = DicT.Keys(r)\n'셀에 사전내의 key 값을 뿌림\nNext r\nRange(\"C1\").CurrentRegion.Sort [C1], xlAscending\n'추출한 중복없는 값들을 오름차순으로 정렬\n'    Dim strText As String\n'문자를 합쳐서 넣을 변수\n'    strText = Join(DicT.Keys, \",\")\n'사전 내의 모든 key를 콤마로 연결\nSet rngAll = Nothing\n'개체변수(들) 초기화\nSet DicT = Nothing\nEnd Sub\n\nSub unique_List_With_PivotTable()\n'\n피벗 이용한 경우\nDim rngData As Range\nDim sht As Worksheet\nDim tblName As String\nDim verNo As Integer\nDim fldName As String\nDim varList\nSet rngData = Range(\"A1\").CurrentRegion\nSet sht = ActiveSheet\ntblName = \"PivotTable1\"\nverNo = 6\n'엑셀 2016\nfldName = \"거래처\"\nSheets.Add after:=Sheets(Sheets.Count)\nActiveWorkbook.PivotCaches.Create(SourceType:=xlDatabase, _\nSourceData:=sht.Name & \"!\" & rngData.Address(1, 1, xlR1C1), _\nVersion:=verNo).CreatePivotTable _\nTableDestination:=ActiveSheet.Name & \"!R1C1\", _\nTableName:=tblName, _\nDefaultVersion:=verNo\nWith ActiveSheet.PivotTables(tblName)\n.PivotFields(fldName).Orientation = xlRowField\n.PivotFields(fldName).Position = 1\n.DisplayFieldCaptions = False\n.ColumnGrand = False\nEnd With\nvarList = Columns(\"A\").SpecialCells(2)\nEnd Sub", "context": "Collection과 Dictionary는 유사점이 많으면서 차이가 있다.\nCollection                           Dictionary\n엑셀 기본기능                      Scripting.Runtim 추가필요\nIndex이 느림                       컬렉션보다는 빠르다.\nwrite-only,                          read, write, change\n배열로 한 번에 못내보냄        배열로 한 번에 내보낼 수 있음\n한 번에 삭제못함                  한 번에 삭제 가능\n대소문자 구분가능(vbTextCompare) 옵션\n.Exists 메서드 보유\nA열의 중복없는 유일한 문자 C열에 추출\n아래의 코드는 Microsoft Scripting Runtime 타입 라이브러리가 참조되어야 한다.\nOption Explicit\nSub unique_Dictionary()\nDim DicT As\nDiction..."}
{"instruction": "Excel VBA code for: (1695) 선택영역 빈셀 전체행 삭제 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Row_Of_Blank_Cell_1()\n'선택영역 빈셀의 행은 무조건 삭제\nDim rngRow As Range\n'전체행(Row) 영역을 넣을 변수\nDim rngC As Range\n'선택영역(r)a(ng)e 각셀(C)ell을 넣을 변수\nDim rngSel As Range\n'선택(Sel)ection 영역(r)a(ng)e 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngT As Range\n'복사될 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n'------------------------------------------\n' 선택영역이 1개의 열만 선택하도록 하는 코드\n'------------------------------------------\nWith Selection\n'선택 영역에서\nIf .Cells.Count = 1 Or _\n.Columns.\nCount\n> 1 Or _\n.Rows.Count = Rows.Count Or _\n.Areas.Count > 1 Then\n'영역선택 오류시\nMsgBox \"1개영역, 2셀이상, 전체열 아닌 1 열만선택\", _\nvbExclamation, \"영역선택 오류\"\n'경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nEnd With\n'------------------------------------------------\n'빈셀이 없으면 중단하고, 모두 빈셀이면 전체행 삭제\n'------------------------------------------------\nWith WorksheetFunction\n'엑셀 함수에서\nIf .\nCountBlank\n(Selection) = 0 Then\n'데이터 입력 셀의 개수가 0이면\nMsgBox \"선택영역에 빈셀이 없습니다.\", vbExclamation\nExit Sub\n'메시지 출력 후 매크로 중단\nElseIf .CountA(Selection) = 0 Then\n'선택영역이 모두 빈셀이면\nSelection.\nEntireRow\n.Delete\n'선택영역 전체행을 삭제\nExit Sub\n'매크로 종료\nEnd If\nEnd With\nSet rngRow = Selection.Offset(0, -(Selection.Column - 1)).Resize(, _\nActiveSheet.UsedRange.Columns.Count)\n'선택영역을 전체 영역으로 확대해 변수에 넣음\n'(셀 병합된 셀이 있는지 확인할 목적)\n'----------------------------------------\n' 선택영역 같은 행에 셀병합셀 있는지 확인\n'----------------------------------------\nFor Each rngC In rngRow\n'전체영역 각 셀을 순환\nIf rngC.\nMergeCells\nThen\n'셀병합 영역이 있을 경우\nMsgBox \"선택영역 같은 행에 셀병합된 셀이 있습니다.\", _\nvbExclamation, \"셀병합 오류\"\n'경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nNext rngC\nSelection.EntireColumn.Insert\n'선택영역 전체열을 삽입\nSet rngSel = Selection\n'개체변수에 선택 영역을 넣음\n'--------------------------------------------------------\n' 기존 데이터 순서가 섞이지 않도록 순서로대 번호와 빈행 삽입\n'--------------------------------------------------------\nOn Error Resume Next\n'선택영역 중 에러(ex. #REF!)있는 셀에서 오류방지용\nFor Each rngC In Selection.Offset(0, 1)\n'선택영역 오른쪽 열의 각셀을 순환\nIf rngC <> \"\" Then\n'셀에 값이 입력되어 있으면\ni = i + 1\n'카운터를 1씩 늘려감\nrngC.Previous = i\n'셀에 앞셀의 값을 넣음\nEnd If\nNext rngC\nSet rngT = Selection.Cells(1)\n'선택영역 첫 번째 셀을 개체변수에 넣음\n'---------------------------------------\n' 오름차순 정렬로 빈행 삽입후 임시열 삭제\n'---------------------------------------\nSelection.EntireRow.\nSort\nrngT, 1, Header:=False\n'오름차순 정렬\nrngSel.SpecialCells(xlCellTypeBlanks).EntireRow.Delete\n'빈셀이 있는 전체행 삭제\nOn Error GoTo 0\n'에러 검출기능 초기화\nrngSel.EntireColumn.Delete\n'전체 열을 삭제\nSet rngRow = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngSel = Nothing\nSet rngT = Nothing\nEnd Sub", "context": "아래의 코드는\n선택영역의 빈셀이 있는 곳 전체행을 삭제하는 기능\n이다. 빈행 삭제는 여러가지 방법으로 가능하며, 속도 무시하고 행삭제에 집중하면 몇 줄의 코드면 되지만, 좀더 안정적이고 빠르게 행삭제를 하기 위해 사용하는 방법이다.\n실제로 몇 만행의 데이터에서도 빠르게 행이 삭제\n된다. 1열로 공백의 삭제를 원하는 영역을 선택 후 매크로 실행.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1695) 선택영역 빈셀 전체행 삭제 1 (엑셀 VBA 매크로)\n재생\n1,270\n공유하기\n재생 (space/k)\n재생\n00:58\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:58\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1...."}
{"instruction": "Excel VBA code for: (1696) 전체가 공백인 행만 삭제 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Entire_Blank_Row()\n'선택영역 전체행이 빈셀이어야 삭제하는 코드\nDim rngRow As Range\n'전체행(Row) 영역을 넣을 변수\nDim rngC As Range\n'선택영역(r)a(ng)e 각셀(C)ell을 넣을 변수\nDim rngSel As Range\n'선택(Sel)ection 영역(r)a(ng)e 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngT As Range\n'복사될 위치 넣을 변수\n'------------------------------------------\n' 선택영역이 1개의 열만 선택하도록 하는 코드\n'------------------------------------------\nWith Selection\n'선택 영역에서\nIf .Cells.Count = 1 Or _\n.Columns.\nCount\n> 1 Or _\n.Rows.Count = Rows.Count Or _\n.Areas.Count > 1 Then\n'영역선택 오류시\nMsgBox \"1개영역, 1셀이상, 전체열 아닌 1열만선택\", _\nvbExclamation, \"영역선택 오류\"\n'경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nEnd With\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngRow = Selection.Offset(0, -(Selection.Column - 1)).Resize(, _\nActiveSheet.UsedRange.Columns.Count)\n'선택영역을 전체 영역으로 확대해 변수에 넣음\nIf Application.WorksheetFunction.\nCountA\n(rngRow) = 0 Then\n'선택영역 전체가 빈행이면\nrngRow.EntireRow.Delete\n'선택된행 전체행을 삭제\nExit Sub\n'매크로 종료\nEnd If\n'----------------------------------------\n' 선택영역 같은 행에 셀병합셀 있는지 확인\n'----------------------------------------\nFor Each rngC In rngRow\n'전체영역 각 셀을 순환\nIf rngC.\nMergeCells\nThen\n'셀병합 영역이 있을 경우\nMsgBox \"선택영역 같은 행에 셀병합된 셀이 있습니다.\", _\nvbExclamation, \"셀병합 오류\"\n'경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nNext rngC\nSelection.EntireColumn.Insert\n'선택영역 전체열을 삽입\nSet rngSel = Selection\n'개체변수에 선택 영역을 넣음\n'--------------------------------------------------------\n' 기존 데이터 순서가 섞이지 않도록 순서로대 번호와 빈행 삽입\n'--------------------------------------------------------\nOn Error Resume Next\n'선택영역 중 에러(ex. #REF!)있는 셀에서 오류방지용\nFor Each rngC In Selection.Offset(0, 1)\n'선택영역 오른쪽 열의 각셀을 순환\nIf rngC <> \"\" Or Application.WorksheetFunction.CountA(Rows(rngC.Row)) <> 0 Then\n'셀에 값이 입력되어 있으면\ni = i + 1\n'카운터를 1씩 늘려감\nrngC.Previous = i\n'셀에 앞셀의 값을 넣음\nEnd If\nNext rngC\nOn Error GoTo 0\n'에러 검출기능 초기화\nSet rngT = Selection.Cells(1)\n'선택영역 첫 번째 셀을 개체변수에 넣음\n'---------------------------------------\n' 오름차순 정렬로 빈행 삽입후 임시열 삭제\n'---------------------------------------\nSelection.EntireRow.\nSort\nrngT, 1, Header:=False\n'오름차순 정렬\nIf Application.WorksheetFunction.CountBlank(Selection) <> 0 Then\n'선택영역에 빈셀이 있는 경우\nrngSel.\nSpecialCells\n(\nxlCellTypeBlanks\n).EntireRow.Delete\n'빈셀 전체행을 삭제\nOn Error GoTo 0\n'에러 검출기능 초기화\nrngSel.EntireColumn.Delete\n'(임시로 사용한) 전체 열 삭제\nElse\n'선택영역에 빈셀이 없는 경우\nMsgBox \"전체가 빈행인 삭제할 행이 없습니다.\", vbExclamation\n'메시지 박스 출력\nrngSel.EntireColumn.Delete\n'(임시로 사용한)전체 열 삭제\nEnd If\nSet rngRow = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngSel = Nothing\nSet rngT = Nothing\nEnd Sub", "context": "앞서 올린 코드(1695)는 선택영역의 빈셀이 있는 곳 전체행을 삭제하는 기능을 하였다. 즉, 선택영역내에 빈셀이 있을 경우 무조건 행을 삭제하였다. 아래의 코드는 설령 선택영역내에 빈셀이 있어도 다른열에 데이터가 있으면 이를 삭제하지 않고 남겨둔다. 즉,\n전체행이 빈 행만 삭제\n한다.\nC1:C11 영역을 선택하고 매크로를 실행한다고 가정할 때,\n앞서 올린 코드(1695)는 4 행을 삭제.                    아래의 코드(1696)는 전체가 빈행인 2행 만을 삭제.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1696) 전체가 공백인 행만 삭제 (엑셀 VBA 매크로)\n재생\n663\n공유하기\n재생 (space/k)\n재생\n00:34\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:34\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도..."}
{"instruction": "Excel VBA code for: (1697) 소분류의 중복제거 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Dupes_In_SubGroup()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 영역변수\nDim rngArea As Range\n'각 구역(A)rea 넣을 영역 변수\nDim rngA As Range\n'각 셀을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.Copy after:=Sheets(1)\n'(원본데이터 보존위해)시트 복사\nWith Cells(Rows.Count, \"B\").End(3)\n'(예외처리) B열 마지막행\nIf .Offset(, -1) = \"\" Then\n'왼쪽위가 빈셀이면\n.Offset(1, -1) = \"임시값\"\n'A열 제일 마지막행에 \"임시값\"입력\nEnd If\nSet rngAll = Range(\"B1\", .Offset(1))\n'B열 전체 데이터영역을 변수에\nEnd With\nFor Each rngArea In rngAll.Offset(, -1).SpecialCells(xlCellTypeBlanks).\nAreas\n'A열 전체 빈셀구역을 순환\nSet rngA = rngArea.Offset(-1, 1).Resize(rngArea.Rows.Count + 1)\n'공백영역보다 1열 많게 B열 영역을 변수에\nrngA.\nRemoveDuplicates\nColumns:=1, Header:=xlNo\nNext rngArea\n'B열 소분류 중복제거\nCall delete_Row_Of_Blank_Cell(rngAll)\n'행을 삭제하는 하위 프로시저 호출\nCells(Rows.Count, \"A\").End(3).\nClear\n'임시로 사용한 셀값 삭제\nSet rngAll = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngA = Nothing\nEnd Sub", "context": "B열 전체데이터를 기준으로 중복제거를 하게되면 B열에 각 종목별로 1개만 남게된다. 아래의 코드는\n소분류(종목)의 중복된 데이터를 삭제\n해주는 기능. 원 데이터에는 색칠이 없지만, 어떤 데이터가 중복되어 있는지 알아보기 쉽도록 매크로 실행 전 색을 칠해 두었음.\n매크로 실행 전(데이터 더 있음)                          매크로 실행 후 결과(새로운 시트에 중복제거)\n하위 코드(\ndelete_Row_Of_Blank_Cell\n)는 어제 올린 1695를 재활용함.\nOption Explicit\nSub remove_Dupes_In_SubGroup()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 영역변수\nDim rngArea As Range\n'각 구역(A)rea 넣을 영역 변수\nDim rngA As Range\n'각 셀을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.Copy ..."}
{"instruction": "Excel VBA code for: (1700) 값 만큼 복사 후 색칠 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_As_Numbered()\nDim r As Long\n'행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nr = 2\n'2행 부터 시작\nDo\n'실행\nWith Cells(Rows.Count, \"D\").End(3)(2)\n'D열 종단셀 윗방향 바로 아래\n.Resize(Cells(r, 1).\nNext\n) = Cells(r, 1)\n'숫자만큼 대표자 복사\n.Interior.\nColorIndex\n= 35\n'중복 첫번째 이름에 색칠\nEnd With\n'행 숫자만큼 반복하여 복사\nr = r + 1\n'행을 1씩 늘려감\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nEnd Sub\n\nSub delete_Data()\nRange(\"D1\").CurrentRegion.Offset(1).Clear   '기존 데이터 삭제\nEnd Sub", "context": "아래의 코드는 B열 '행'에 입력된 숫자만큼 '대표자' 이름을 복사하고, 첫 번째 이름에 색칠하는 기능.\n매크로 실행전(아래로 데이터 더 있음)                                      매크로 실행 후 결과\nOption Explicit\nSub copy_As_Numbered()\nDim r As Long\n'행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nr = 2\n'2행 부터 시작\nDo\n'실행\nWith Cells(Rows.Count, \"D\").End(3)(2)\n'D열 종단셀 윗방향 바로 아래\n.Resize(Cells(r, 1).\nNext\n) = Cells(r, 1)\n'숫자만큼 대표자 복사\n.Interior.\nColorIndex\n= 35\n'중복 첫번째 이름에 색칠\nEnd With\n'행 숫자만큼 반복하여 복사\nr = r + 1\n'행을 1씩 늘려감\nLoop Until\nCells(r, 1) = \"\"\n'A열에 ..."}
{"instruction": "Excel VBA code for: (1701) 중복 중 최신 데이터만 남기기 (엑셀 VBA 매크로)", "input": "", "output": "Sub leave_Only_The_Latest_1()\nDim rngAll As Range\n'전체 데이터 영역(B열)을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell 영역(r)a(ng)e 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Range(\"B2\", Cells(Rows.Count, \"B\").End(3))\n'B열 전체 데이터 영역을 변수에 넣음\nrngAll.EntireColumn.\nInsert\n'임시로 열 삽입\n'-------------------------\n'정렬 시 이용한 순번을 입력\n'-------------------------\nFor Each rngC In rngAll\n'임시열에 오름차순 숫자 입력\nr = r + 1\n'숫자를 1씩 늘려감\nrngC.\nPrevious\n= r\n'임시열에 숫자 입력\nNext rngC\n'----------------------------------------------------\n'중복제거는 제일 윗행만 남기므로 내림차순으로 중복제거\n'----------------------------------------------------\nWith rngAll.Offset(, -1).CurrentRegion\n'전체 영역으로 확대\n.\nSort\n[B2], xlDescending, Header:=xlYes\n'임시열 기준 내림차순 정렬\n.\nRemoveDuplicates\n3, Header:=xlYes\n'중복 제거\n.Sort [B2], xlAscending, Header:=xlYes\n'임시열 기준 오름차순 정렬\nEnd With\nrngAll.Offset(, -1).EntireColumn.\nDelete\n'임시열 삭제\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "아래의 코드는 B열의 중복되는 제품명 중에서 가장 최근(가장 아래)에 있는 데이터만 보존하고 다른 중복 데이터는 삭제를 하는 기능. (알아보기 쉽도록 결과 값에는 색을 칠해두었음.)\n매크로 실행 전                                                       매크로 실행 후 결과\nOption Explicit\nSub leave_Only_The_Latest_1()\nDim rngAll As Range\n'전체 데이터 영역(B열)을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell 영역(r)a(ng)e 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Range(\"B2\", Cells(Rows.Count, \"B\").End(3))\n'B열 전체 데이터 영역을 변수에 넣음\nrngAll.EntireColumn.\nInsert\n'..."}
{"instruction": "Excel VBA code for: (1702) Alt + Enter로 저장된 데이터 연결 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_Alt_Enter()\nDim rngC As Range\n'각 셀(C)ell 영역(r)a(ng)e를 넣을 변수\nDim varL\n'왼쪽(L)eft 값을 넣을 배열(var)iant 변수\nDim varR\n'오른쪽(R)ight 값을 넣을 배열(var)iant 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim str\n'문자(str)ing 연결해 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nIf rngC.Offset(, -2) <> \"\" And rngC.Offset(, -1) <> \"\" Then\n'왼쪽 모두 값이 있다면\nvarL =\nSplit\n(rngC.Offset(, -2),\nChr(10)\n)\n'왼쪽 값을 Alt + Enter로 나누어 변수에\nvarR = Split(rngC.Offset(, -1), Chr(10))\n'오른쪽 값을 Alt + Enter로 나누어 변수에\nFor i =\nLBound\n(varL) To\nUBound\n(varR) - 1\n'배열 상한값 -1까지 반복\nstr = str & varL(i) & varR(i) & Chr(10)\n'문자를 합쳐감\nNext i\nstr = str & varL(i) & varR(i)\n'제일 아래쪽 문자를 합침\nrngC = str\n'합친 값을 셀에 뿌림\nstr = \"\"\n'재사용 위하여 초기화\nrngC.Rows.AutoFit\n'행 높이 자동 맞춤\nEnd If\nNext rngC\nEnd Sub", "context": "한 셀에 Alt  + Enter로 입력한 두 데이터를 연결하여 한 셀에 넣는 기능. 이미 유사한걸 많이 해봤었다. 실제로는 Alt + Enter로 합쳐진 셀을 각 셀로 붙리하여 데이터를 관리해야 하는데, 많은 분들이 반대로 한다. 나름 다 이유가 있어서 이렇게 하겠지만, 나라면 내 직원이 이런식으로 데이터 관리하면 혼내줄거다... 것도 많이.\n매크로 실행전 영역을 선택한 모습                             매크로 실행 후 결과\nOption Explicit\nSub combine_Alt_Enter()\nDim rngC As Range\n'각 셀(C)ell 영역(r)a(ng)e를 넣을 변수\nDim varL\n'왼쪽(L)eft 값을 넣을 배열(var)iant 변수\nDim varR\n'오른쪽(R)ight 값을 넣을 배열(var)iant 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim str\n'문자(str)ing 연결해 넣을 변수\nApplication.ScreenUp..."}
{"instruction": "Excel VBA code for: (1703) 두 열만 텍스트 파일로 내보내기 (엑셀 VBA 매크로)", "input": "", "output": "Sub save_Columns_BD_As_Text()\nDim strPath As String\n'파일 경로(Path) 넣을 문자(str)ing변수\nDim shp As Object\n'도형(sh)a(p)e 넣을 변수\nDim vbYN As String\n'메시지창 반환값 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트(일시) 정지\nstrPath = ThisWorkbook.\nPath\n& \"\\\" & ActiveSheet.Name\n'파일 경로를 변수에 넣음\n'---------------------------\n'동일 경로에 파일 있는지 확인\n'---------------------------\nIf\nLen\n(\nDir\n(strPath & \".txt\")) > 0 Then\n'동일 경로에 이미 파일이 있을 경우\nvbYN = MsgBox(\"같은 파일 있음. 덮어쓸까요?\", vbExclamation + vbYesNo)\n'같은 파일 있음 경고창 출력\nIf vbYN =\nvbNo\nThen\n'No를 선택하면\nExit Sub\n'매크로 종료\nEnd If\nEnd If\nActiveSheet.Copy\n'현재시트 복사\nFor Each shp In ActiveSheet\n.Shapes\n'시트내 모든 도형을 순환\nshp.Delete\n'도형을 삭제\nNext shp\n'---------------------\n'불필요한 행과 열 삭제\n'---------------------\nRows(\"1:4\").EntireRow.Delete\n'1 ~ 4행 삭제\nCells(1, 5).Resize(, 100).EntireColumn.Delete\n'E열 포함 100개의 열(충분한 숫자) 삭제\nRange(\"A:A,C:C\").Delete Shift:=xlToLeft\n'A, C열 삭제\n'------------------------------\n'텍스트로 파일 저장하고 창 닫음\n'------------------------------\nApplication.\nDisplayAlerts\n= False\n'화면 경고창 비활성화\nActiveWorkbook.\nSaveAs\nstrPath & \".txt\", FileFormat:=xlText\n'파일을 경로에 text로 저장\nApplication.DisplayAlerts = True\n'화면 경고창 복원\nActiveWorkbook.Close\n'복사된 파일 닫기\nMsgBox \"B, D열을 텍스트 파일로 저장 하였습니다.\"\n'메시지창 출력\nEnd Sub", "context": "1~4행 삭제 후\nB, D 열만 텍스트 파일로 내보내는 기능.\n파일 이름은 시트 이름으로 함.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1703) 두 열만 텍스트 파일로 내보내기 (엑셀 VBA 매크로)\n재생\n1,054\n공유하기\n재생 (space/k)\n재생\n00:23\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:23\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n엑..."}
{"instruction": "Excel VBA code for: (1704) 폴더 이름 한 번에 바꾸기 (엑셀 VBA 매크로)", "input": "", "output": "Sub loop_Through_All_Folders()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\neachFolder strPath\n'eachFolder 코드를 호출\nEnd Sub\n\nPrivate Function eachFolder(mainFolder As String)\nDim fSO As\nScripting.FileSystemObject\n'FileSystemObject를 넣을 변수\nDim fldName As Scripting.Folder\n'상위폴더 전체경로(마지막이 \"\\\")를 넣을 변수\nDim subFolder As Scripting.Folder\n'하위폴더 넣을 변수\nDim fileName As Object\n'각 파일의 이름(확장자포함)을 넣을 변수\nDim r As Long\n'숫자 1씩 늘려갈 변수\nSet fSO = New Scripting.\nFileSystemObject\n'새로운 파일시스템개체를 변수에\nSet fldName = fSO.GetFolder(mainFolder)\n'선택한 폴더의 이름을 변수에 넣음\n'-----------------------------------\n'재귀 호출하면 모든 하위폴더까지 순환\n'-----------------------------------\nFor Each subFolder In fldName.\nSubFolders\n'각 폴더의 하위폴더를 순환\nIf subFolder.Name <> \"A 폴더\" And subFolder.Name <> \"B 폴더\" And _\nsubFolder.Name <> \"C 폴더\" And subFolder.Name <> \"D 폴더\" Then\n'폴더이름이 A,B,C,D 폴더가 아니면\nr = r + 1\n'숫자를 1씩 늘려감\nsubFolder.\nName\n= r\n'폴더 이름을 변경함\nEnd If\neachFolder subFolder.Path\n'각 폴더경로로 eachFolder함수호출\nNext subFolder\nSet fSO = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet fldName = Nothing\nEnd Function", "context": "'1, 2, 3, ....500' 이라는 모든 폴더가 하위폴더로 'A 폴더, B 폴더, C 폴더, D 폴더'라는 4개의 동일한 폴더를 갖도록 하는 코드. 즉,\n폴더의 이름을 한 번에 바꿈.\n매크로를 이용하여 모두 다 할 수도 있지만, 효율적으로 하기 위해 수작업과 매크로를 병행.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1704) 폴더 이름 한 번에 바꾸기 (엑셀 VBA 매크로)\n재생\n691\n공유하기\n재생 (space/k)\n재생\n00:56\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:56\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움..."}
{"instruction": "Excel VBA code for: (1705) 수식 없는 빈행만 삭제 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Row_If_Nothing()\n'선택영역 빈셀의 행은 무조건 삭제\nDim rngRow As Range\n'전체행(Row) 영역을 넣을 변수\nDim rngC As Range\n'선택영역(r)a(ng)e 각셀(C)ell을 넣을 변수\nDim rngSel As Range\n'선택(Sel)ection 영역(r)a(ng)e 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngT As Range\n'복사될 위치 넣을 변수\n'------------------------------------------\n' 선택영역이 1개의 열만 선택하도록 하는 코드\n'------------------------------------------\nWith Selection\n'선택 영역에서\nIf .Cells.Count = 1 Or _\n.Columns.\nCount\n> 1 Or _\n.Rows.Count = Rows.Count Or _\n.Areas.Count > 1 Then\n'영역선택 오류시\nMsgBox \"1개영역, 2셀이상, 전체열 아닌 1 열만선택\", _\nvbExclamation, \"영역선택 오류\"\n'경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nEnd With\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n'------------------------------------------------\n'빈셀이 없으면 중단하고, 모두 빈셀이면 전체행 삭제\n'------------------------------------------------\nWith WorksheetFunction\n'엑셀 함수에서\nIf .\nCountBlank\n(Selection) = 0 Then\n'데이터 입력 셀의 개수가 0이면\nMsgBox \"선택영역에 빈셀이 없습니다.\", vbExclamation\nExit Sub\n'메시지 출력 후 매크로 중단\nElseIf .CountA(Selection) = 0 Then\n'선택영역이 모두 빈셀이면\nSelection.\nEntireRow\n.Delete\n'선택영역 전체행을 삭제\nExit Sub\n'매크로 종료\nEnd If\nEnd With\nSet rngRow = Selection.Offset(0, -(Selection.Column - 1)).Resize(, _\nActiveSheet.UsedRange.Columns.Count)\n'선택영역을 전체 영역으로 확대해 변수에 넣음\n'(셀 병합된 셀이 있는지 확인할 목적)\n'----------------------------------------\n' 선택영역 같은 행에 셀병합셀 있는지 확인\n'----------------------------------------\nFor Each rngC In rngRow\n'전체영역 각 셀을 순환\nIf rngC.\nMergeCells\nThen\n'셀병합 영역이 있을 경우\nMsgBox \"선택영역 같은 행에 셀병합된 셀이 있습니다.\", _\nvbExclamation, \"셀병합 오류\"\n'경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nNext rngC\nSelection.EntireColumn.Insert\n'선택영역 전체열을 삽입\nSet rngSel = Selection\n'개체변수에 선택 영역을 넣음\n'--------------------------------------------------------\n' 기존 데이터 순서가 섞이지 않도록 순서로대 번호와 빈행 삽입\n'--------------------------------------------------------\nOn Error Resume Next\n'선택영역 중 에러(ex. #REF!)있는 셀에서 오류방지용\nFor Each rngC In Selection.Offset(0, 1)\n'선택영역 오른쪽 열의 각셀을 순환\nIf Len(rngC.Formula) > 0 Then\n'셀값의 길이가 0보다 크면(빈서식의 LEN값은 0)\ni = i + 1\n'카운터를 1씩 늘려감\nrngC.Previous = i\n'셀에 앞셀의 값을 넣음\nEnd If\nNext rngC\nSet rngT = Selection.Cells(1)\n'선택영역 첫 번째 셀을 개체변수에 넣음\n'---------------------------------------\n' 오름차순 정렬로 빈행 삽입후 임시열 삭제\n'---------------------------------------\nSelection.EntireRow.\nSort\nrngT, 1, Header:=False\n'오름차순 정렬\nrngSel.SpecialCells(xlCellTypeBlanks).EntireRow.Delete\n'빈셀이 있는 전체행 삭제\nOn Error GoTo 0\n'에러 검출기능 초기화\nrngSel.EntireColumn.Delete\n'전체 열을 삭제\nSet rngRow = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngSel = Nothing\nSet rngT = Nothing\nEnd Sub", "context": "아래의 코드는 1개의 열을 선택하고 매크로 실행 시,\n셀에 수식을 포함하여 아무 것도 입력되지 않은 행만 삭제하는 코드\n이다. IFERROR와 같이 error 조건일 때 아무것도 표시되지 않도록 한 셀의 경우 마치 빈셀 같지만 수식이 들어가 있는 경우가 많다. 이와 같이 수식이 있는 셀은 삭제하지 않는다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1705) 수식 없는 빈행만 삭제 (엑셀 VBA 매크로)\n재생\n507\n공유하기\n재생 (space/k)\n재생\n00:37\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:37\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다..."}
{"instruction": "Excel VBA code for: (1707) 요일 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_Weekday()\nDim rngCol As Range\n'요일 열(Col)umn 영역(r)a(ng)e을 넣을 변수\nDim c As Integer\n'열(c)olumn 위치 늘려갈 변수\nDim rngC As Range\n'각 셀(C)ell 영역(r)a(ng)e 넣을 변수\nFor c = 1 To 3\n'3회 반복\nSet rngCol = Cells(5, (c - 1) * 6 + 3).Resize(18)\n'요일 영역을 개체 변수에 넣음\nFor Each rngC In rngCol.Cells\n'요일영역 각 셀을 순환\nIf\nFormat\n(rngC, \"\naaa\n\") = Cells(2, 3) Then\n'요일이 서로 일치하면\nrngC.Offset(, 1).Resize(, 3) = Cells(2, 5)\n'입력할 값을 자료에 뿌리\nEnd If\nNext rngC\nNext c\nEnd Sub\n\nSub delete_Data()\nDim rngCol As Range\n'요일 열(Col)umn 영역(r)a(ng)e을 넣을 변수\nDim c As Integer\n'열(c)olumn 위치 늘려갈 변수\nFor c = 1 To 3\n'3회 반복\nSet rngCol = Cells(5, (c - 1) * 6 + 3).Resize(18)\n'요일 영역을 개체 변수에 넣음\nrngCol.Offset(, 1).Resize(, 3).\nClearContents\n'기존 데이터 삭제\nNext c\nEnd Sub", "context": "지정한 위치에 일치하는 값을 반복하여 붙여 넣는 기능.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1707) 요일 복사하기 (엑셀 VBA 매크로)\n재생\n791\n공유하기\n재생 (space/k)\n재생\n00:24\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:24\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n요일을 적고 입력될 값을 넣은 다음 매크로 실행. => 값이 입..."}
{"instruction": "Excel VBA code for: (1708) 복수의 폴더 한 번에 생성하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub create_Multiple_Folders_1()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\neachFolder strPath\n'eachFolder 코드를 호출\nEnd Sub\n\nPrivate Function eachFolder(mainFolder As String)\nDim fSO As\nScripting.FileSystemObject\n'FileSystemObject를 넣을 변수\nDim rngAll As Range\n'B열 전체(All) 데이터 영역(r)a(ng)e을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell 영역(r)a(ng)e을 넣을 변수\nSet fSO = New Scripting.FileSystemObject\n'새로운 파일시스템개체를 변수에\nSet rngAll = Range(\"C2\", Cells(Rows.Count, \"C\").End(3)).Offset(0, -1)\n'B열 전체영역을 변수에 넣음\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nIf Len(rngC) > 0 Then\n'셀 값이 있는 경우\nfSO.\nCreateFolder\nmainFolder & \"\\\" & rngC\n'폴더 경로에 B열 폴더를 생성\nfSO.CreateFolder mainFolder & \"\\\" & rngC & \"\\\" & rngC.Next\n'폴더 경로에 C열 폴더를 생성\nElse\n'셀 값이 없는 경우\nfSO.CreateFolder mainFolder & \"\\\" & rngC.End(3) & \"\\\" & rngC.Next\nEnd If\n'폴더 경로에 C열 폴더를 생성\nNext rngC\nSet fSO = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngAll = Nothing\nEnd Function", "context": "주말에 FileSystemObject에 대해서 공부를 좀 해봤다.\n아래의 코드는 복수의 폴더를 한 번에 생성해주는 코드\n이다. 엑셀 시트에 생성하고자 하는 상위 폴더와 하위 폴더를 미리 입력하고, 매크로 실행 시 폴더를 한 번에 생성해 준다.\n아래 코드는 아무 검색도 없이, 자동저장 없이, 혼자 공부해서 만들었다. 역시 규칙을 알고 요령만 있으면 별거 아니다. 그런데,\n문제는\n처음에는\n그 규칙이 어렵고, 요령은 실력이 늘고나서 생긴다. ^^\n생성하려는 폴더들의 이름이 엑셀 시트내에 입력되어 있는 모습.      매크로 실행 후 생성된 폴더\n(물론 하위폴더도 생성)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1708) 복수의 폴더 한 번에 생성하기 (엑셀 VBA 매크로)\n재생\n1,072\n공유하기\n재생 (space/k)\n재생\n00:46\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:46\n실시간\n설정\n전체 ..."}
{"instruction": "Excel VBA code for: (1709) 연달아 일치하는 데이터 가져오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub bring_Matching_Data()\nDim s As Integer\n'시트(s)heet 반복구문에 사용할 변수\nDim rngB1 As Range\n'B1셀 영역(r)a(ng)e을 넣을 변수\nDim rngAll As Range\n'시트의 데이터영역(r)a(ng)e 모두(All) 넣을 변수\nDim rngC As Range\n'각 셀(C)ell 영역(r)a(ng)e 을 넣을 변수\nDim blnTF As Boolean\n'일치여부 판단할 변수\nDim cnt As Integer\n'카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트(일시) 정지\n'---------------------------------------------\n'검색조건 미입력 또는 잘못된 입력 시 메시지 출력\n'---------------------------------------------\nIf Range(\"B1\") < 1 Or Range(\"B1\") > 9 Then\n'시트이름 잘못 입력시\nMsgBox \"시트번호를 잘못 입력하셨습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nIf WorksheetFunction.\nCountA\n(Range(\"B2\").Resize(, 4)) = 0 Or _\nRange(\"B1\") = \"\" Then\n'글자입력/시트번호가 빈셀이면\nMsgBox \"데이터 입력 후 매크로 실행\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\n'---------------------------------------\n'기존 색칠해진 셀 또는 기존 결과 값을 삭제\n'---------------------------------------\nFor s = 2 To 10\n'두번째 시트부터 마지막 시트까지\nSheets(s).Range(\"A1\").Resize(, 20).Interior.ColorIndex =\nxlNone\nNext s\n'내부 색칠을 모두 초기값(흰색)으로\nRange(\"B3\").Resize(, 4).ClearContents\n'기존 데이터 삭제\nSet rngAll = Sheets(\nCStr\n(Range(\"B1\"))).Range(\"A1\").Resize(, 16)\n'각 시트 데이터 전체 영역\nFor Each rngC In rngAll\n'각 시트 데이터 영역 각 셀을 순환\ncnt = cnt + 1\n'카운터 1씩 늘려감\nIf cnt = 13 Then Exit For\n'L열까지만 비교후 중단\nIf Range(\"B2\") = rngC Then\n'두 글자가 일치할 경우\n'----------------------------------------------------\n'일치하는 값을 찾으면 나머지 3개도 모두 일치하는 지 확인\n'----------------------------------------------------\nWith Application\n'엑셀에서\nIf\nJoin\n(.\nTranspose\n(.\nTranspose\n(Range(\"B2\").Resize(, 4))), \"\") = _\nJoin(.Transpose(.Transpose(rngC.Resize(, 4))), \"\") Then\n'4개의 셀을 합쳐서 비교하여 모두 같으면\nrngC.Offset(, 4).Resize(, 4).Interior.ColorIndex = 6\n'일치영역 오른편 4셀에 노란색칠\nRange(\"B3\").Resize(, 4) = rngC.Offset(, 4).Resize(, 4).Value\n'결과 영역에 값을 입력\nblnTF = True\n'일치여부 판단 변수를 참 값으로\nExit For\n'For 구문 종료\nEnd If\nEnd With\nEnd If\nNext rngC\nIf blnTF = False Then\n'일치여부 확인 변수가 거짓이면\nMsgBox \"일치하는 데이터가 없습니다.\"\n'메시지 출력\nEnd If\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. 첫 시트 제외한 1 ~ 9의 시트에 가 나 가 나 ... 가 불규칙하게 들어 있음.\n2. 첫 시트에 4개의 가 또는 나를 입력.\n3. 지정한 시트에서 4개의 값이 연달아 일치하면, 일치한 값의 다음에 오는 4개의 값을 가져옴.\n4. 지정한 시트에서 가져올 4개의 값을 색칠로표 시.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1709) 연달아 일치하는 데이터 가져오기 (엑셀 VBA 매크로)\n재생\n1,582\n공유하기\n재생 (space/k)\n재생\n00:49\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:49\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도..."}
{"instruction": "Excel VBA code for: (1710) FileSystemObject으로 텍스트 다루는 기본코드 (엑셀 VBA 매크로)", "input": "", "output": "Sub create_Text()\nDim fso As Object\nDim txtStream As Scripting.\nTextStream\nSet fso =\nCreateObject\n(\"Scripting.FileSystemObject\")\nSet txtStream = fso.\nCreateTextFile\n(ActiveWorkbook.Path & \"\\\" & \"text.txt\", True)\ntxtStream.WriteLine (\"This is a test.\")\ntxtStream.Close\nEnd Sub\n\nSub text_Stream()\nDim fso As Scripting.FileSystemObject\n'파일시스템개체넣을 변수\nDim txtStream As Scripting.TextStream\n'텍스트스트림 넣을 변수\nDim rngC As Range\n'각 셀 영역을 넣을 변수\nDim str As String\n'합친 문자를 넣을 변수\nDim varD() As String\n'배열로 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim j As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트(일시) 정지\nSet fso = New Scripting.FileSystemObject\n'새로운 파일시스템개체 인스턴스 생성\nSet txtStream = fso.\nOpenTextFile\n(ActiveWorkbook.Path & \"\\\" & \"text.txt\", ForAppending, True)\n'텍스트 파일 생성하고 append\nFor Each rngC In Range(\"A1:A11\")\n'A1:A11 영역 각셀을 순환\nWith Application\n'엑셀 프로그램에서\nstr = Join(.Transpose(.Transpose(rngC.Resize(, 5))), vbTab)\n'1행씩 tab로 합침\n'            txtStream.\nWrite\nstr\n'같은 행에 append\ntxtStream.\nWriteLine\nstr\n'다른 행에 append\n'\ntxtStream.\nWriteBlankLines\n(1)\n'빈행 추가\n'            str = txtStream.\nRead\n(100)\n'100문자씩 읽음\n'            str = txtStream.\nReadLine\n'ForAppending대신 ForReading과 함께 이용\n'            str = txtStream.\nReadAll\n'모두 읽어옴\nEnd With\nNext rngC\n'    varD = Split(txtStream.ReadLine, vbTab)\n'tab으로 구분하여 1행씩 읽어옴\n'    Do Until txtStream.\nAtEndOfStream\n'파일마지막까지 무한 반복\n'        For i = LBound(varD) To UBound(varD)\n'배열 하한값에서 상한값까지 반복\n'            Cells(i + 1, j + 1) = varD(i)\n'배열 값을 셀에 뿌림\n'        Next i\n'    Loop\ntxtStream.Close\n'생성한 텍스트파일 닫기\nSet fso = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet txtStream = Nothing\nEnd Sub\n\nSub open_TextFile()\n'    ChDir \"C:\\Users\\user\\Desktop\"\nWorkbooks.OpenText Filename:=ActiveWorkbook.Path & \"\\\" & \"text.txt\"\n'    , Origin:=949 _\n, StartRow:=1, DataType:=xlDelimited, TextQualifier:=xlDoubleQuote, _\nConsecutiveDelimiter:=False, Tab:=True, Semicolon:=False, Comma:=False _\n, Space:=False, Other:=False, FieldInfo:=Array(Array(1, 1), Array(2, 1), _\nArray(3, 1), Array(4, 1), Array(5, 1)), TrailingMinusNumbers:=True\nEnd Sub\n\nSub open_TextFile2()\nChDir \"C:\\Users\\user\\Desktop\"\nWorkbooks.OpenText Filename:=ActiveWorkbook.Path & \"\\\" & \"text.txt\", Origin:=949 _\n, StartRow:=1, DataType:=xlDelimited, TextQualifier:=xlDoubleQuote, _\nConsecutiveDelimiter:=False, Tab:=True, Semicolon:=False, Comma:=False _\n, Space:=False, Other:=False, FieldInfo:=Array(Array(1, 1), Array(2, 1), _\nArray(3, 1), Array(4, 1), Array(5, 1)), TrailingMinusNumbers:=True\nEnd Sub", "context": "FileSystemObject 공부하면서 나중에 텍스트파일 다룰 때 사용하기 위해 기본코드에 저장해 둠.\n아래의 코드는 Microsoft Scripting Runtime 타입 라이브러리가 참조되어야 한다.\nOption Explicit\nSub create_Text()\nDim fso As Object\nDim txtStream As Scripting.\nTextStream\nSet fso =\nCreateObject\n(\"Scripting.FileSystemObject\")\nSet txtStream = fso.\nCreateTextFile\n(ActiveWorkbook.Path & \"\\\" & \"text.txt\", True)\ntxtStream.WriteLine (\"This is a test.\")\ntxtStream.Close\nEnd Sub\nSub text_Stream()\nDim fso As Scripting.FileSystemObject\n'파일시스템개체넣을 변수\nDim txtStream As Script..."}
{"instruction": "Excel VBA code for: (1711) 다중조건으로 고급필터 적용하기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub advanced_Filter_Multiple_Conditions_5()\nDim rngCri As Range\n'필터링 조건 영역을 넣을 변수\nDim rngData As Range\n'전체 데이터 영역을 넣을 변수\nDim rngT As Range\n'필터된 결과 복사될 위치 넣을 변수\nDim intCol As Integer\n'전체 열 개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nintCol =\n14\n'전체 14개 열을 가진 데이터\n'-------------------------------------\n' 가져올 데이터가 없는 경우 매크로 종료\n'-------------------------------------\nIf Sheets(\"Data\").Range(\"A2\") = \"\" Then\n'A1셀에 데이터가 없을 경우\nMsgBox \"데이터시트에 데이터가 없습니다. 종료합니다.\", vbExclamation\nExit Sub\n'매크로 종료\nEnd If\nSet rngCri = Range(\"B1:E2\")\n'고급필터 criteria 영역을 변수에 넣음\n'------------------------------\n' 고급필터 후 복사될 지점을 지정\n'------------------------------\nWith Sheets(\"Data\")\n'데이터 시트에서\nSet rngData = .Range(\"A1\").CurrentRegion\n'사용영역을 변수에 넣음\nSet rngT = Sheets(\"Main\").Cells(4, 1).Resize(, intCol)\n'복사가 될 지점을 변수에 넣음\nEnd With\n'--------------\n' 고급필터 실행\n'--------------\nrngData.\nAdvancedFilter\n_\nAction:=xlFilterCopy, _\nCriteriaRange:=rngCri, _\nCopyToRange:=rngT, _\nUnique:=False\n'각 조건에 따라 고급필터 적용\nSet rngData = Nothing\n'개체변수(들) 초기화\nSet rngT = Nothing\nEnd Sub\n\nSub delete_Data()\nActiveSheet.UsedRange.Offset(4).ClearContents\n'4행 건너뛰고 삭제\nEnd Sub\n\nSub delete_Criteria()\nRange(\"B2\").Resize(, 4).ClearContents\n'검색조건 삭제\nEnd Sub", "context": "앞서 올린 복수의 조건으로 고급필터를 적용하는 것은 조금 복잡해서 잘 활용을 하지 못하는 분이 있는거 같아서, 최고 단순한 고급필터 기능을 올립니다. (어떤 분이 이렇게 해달라 요청해서요.)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1711) 다중조건으로 고급필터 적용하기 5 (엑셀 VBA 매크로)\n재생\n3,057\n공유하기\n재생 (space/k)\n재생\n01:24\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:24\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능..."}
{"instruction": "Excel VBA code for: (1714) 다중조건으로 고급필터 적용하기 6 (엑셀 VBA 매크로)", "input": "", "output": "Sub bring_DataFile()\nDim wks As Worksheet\n'시트를 넣을 변수\nDim wksName As String\n'시트이름 넣을 변수\nDim rngDataT As Range\n'데이터가 복사될 위치 넣을 변수\nDim strFilter As String\n'필터링될 파일 확장자 넣을 변수\nDim fileName As Variant\n'각 파일을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nwksName = \"\nSheet1\n\"\n'Sheet1\n에서 데이터 가져옴\nSet rngDataT = Sheets(\"Data\").Range(\"A1\")\n'Data시트 데이터가 복사될 위치\n'--------------------------------\n'파일창을 열어 파일 선택하는 코드\n'--------------------------------\nstrFilter = \"Excel Files (*.xls*),*.xls\"\n'엑셀파일 선택 시 활성화\nfileName = Application.\nGetOpenFilename\n(strFilter, , _\n\"엑셀 파일(들)을 선택\", MultiSelect:=False)\n'엑셀 파일(들)을 선택\nIf\nTypeName\n(fileName) = \"Boolean\" Then Exit Sub\n'취소 선택 시 매크로 종료\n'--------------------------------\n'파일열어 데이터를 가져오는 코드\n'--------------------------------\nWorkbooks.Open fileName\n'데이터 파일 열기\nOn Error Resume Next\n'(시트없어)에러 발생해도 다음 코드 진행\nSet wks = Sheets(wksName)\n'지정된 시트를 변수에 넣음\nIf\nErr\nThen\n'만일 일치하는 시트 없어 에러발생하면\nMsgBox \"지정한 시트명을 가진 시트가 없습니다.\", vbExclamation\nExit Sub\n'메시지 출력 후 매크로 종료\nEnd If\nOn Error GoTo 0\n'에러 검출기능 초기화\nwks.Activate\n'시트 활성화\nRange(\"A1\").CurrentRegion.Copy rngDataT\n'데이터를 복사해 옴\nActiveWorkbook.Close False\n'데이터 파일 저장 없이 닫음\nMsgBox \"데이터를 Data파일에 가져왔습니다.\"\n'메시지 출력\nSet rngDataT = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet wks = Nothing\nEnd Sub\n\nSub advanced_Filter_Multiple_Conditions_6()\nDim rngCri As Range\n'필터링 조건 영역을 넣을 변수\nDim rngData As Range\n'전체 데이터 영역을 넣을 변수\nDim rngT As Range\n'필터된 결과 복사될 위치 넣을 변수\nDim intCol As Integer\n'전체 열 개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nintCol =\n7\n'전체\n7\n개 열을 가진 데이터\n'-------------------------------------\n' 가져올 데이터가 없는 경우 매크로 종료\n'-------------------------------------\nIf Sheets(\"Data\").Range(\"A2\") = \"\" Then\n'A1셀에 데이터가 없을 경우\nMsgBox \"데이터시트에 데이터가 없습니다. 종료합니다.\", vbExclamation\nExit Sub\n'매크로 종료\nEnd If\nSet rngCri = Range(\"B1:E2\")\n'고급필터 criteria 영역을 변수에 넣음\n'------------------------------\n' 고급필터 후 복사될 지점을 지정\n'------------------------------\nWith Sheets(\"Data\")\n'데이터 시트에서\nSet rngData = .Range(\"A1\").CurrentRegion\n'사용영역을 변수에 넣음\nSet rngT = Sheets(\"Main\").Cells(4, 1).Resize(, intCol)\n'복사가 될 지점을 변수에 넣음\nEnd With\n'--------------\n' 고급필터 실행\n'--------------\nrngData.\nAdvancedFilter\n_\nAction:=xlFilterCopy, _\nCriteriaRange:=rngCri, _\nCopyToRange:=rngT, _\nUnique:=False\n'각 조건에 따라 고급필터 적용\nSet rngData = Nothing\n'개체변수(들) 초기화\nSet rngT = Nothing\nEnd Sub\n\nSub delete_Data()\nActiveSheet.UsedRange.Offset(4).ClearContents\n'4행 건너뛰고 삭제\nEnd Sub\n\nSub delete_Criteria()\nRange(\"B2\").Resize(, 4).ClearContents\n'검색조건 삭제\nEnd Sub", "context": "앞서 올린 내용은 동일한 파일의 다른 시트에 데이터가 있었는데, 이번에는 다른 엑셀 파일에 있는 데이터를 가져와서 고급필터를 수행하는 기능이다. 앞에서는 14열이었지만, 지금은 7열로 줄었다. 자신이 가진 데이터의 열 개수에 맞추어 아래 코드를 변형할 수 있어야 한다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1714) 다중조건으로 고급필터 적용하기 6 (엑셀 VBA 매크로)\n재생\n1,997\n공유하기\n재생 (space/k)\n재생\n00:50\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:50\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움..."}
{"instruction": "Excel VBA code for: (1715) 셀병합된 셀에 연번 입력하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_To_Merged_Cells()\nDim rngAll As Range\n'선택영역 전체(All)를 넣을 영역(r)a(ng)e 변수\nDim rngC As Range\n'각 셀을 순환 시 사용할 영역변수\nDim rngSel As Range\n'선택영역을 넣을 영역변수\nDim rngT As Range\n'복사될 위치 넣을 영역변수\nSet rngAll = Selection\n'선택영역을 변수에 넣음\nIf Selection.\nCells\n.Count = 1 Then\n'깜빡하고 1셀만 선택할 경우\nMsgBox \"2셀 이상 먼저 영역 선택하고 매크로 실행하세요.\", vbExclamation\nExit Sub\n'메시지창 출력하고 매크로 중단\nEnd If\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel = Application.\nInputBox\n(\"마우스로 복사될 위치를 선택하시오!\", Type:=8)\nIf rngSel\nIs Nothing\nThen Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n'이 코드가 InputBox 함수 윗쪽에 있으면 영역선택 안됨\nSet rngT = rngSel.Cells(1)\n'마우스로 선택한 영역을 복사위치로 설정\nFor Each rngC In rngAll\n'선택영역 각 셀을 순환\nrngT = rngC\n'셀 값을 복사위치에 넣음\nSet rngT = rngT.Offset(1)\n'복사위치 한 구역 아래로 건너 뜀\nNext rngC\nSet rngSel = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngT = Nothing\nEnd Sub", "context": "아래의 코드는\n병합된 셀에 연번을 넣는 기능\n을 한다. 셀병합은 엑셀 특히 데이터베이스의 적(敵)이다. 살면서 몇 번정도 Bill형한테 전화를 해봐야겠다고 생각한 것중의 하나가 셀병합니다. 엑셀 시트상에서는 셀병합이 불가능하도록 하고, 인쇄창 또는 양식창을 별도로 만들어 거기에서만 셀병합이 가능하도록 했으면 좋겠다. 너무도 많은 사람들이 셀병합을 하고, 자신이 저지른 죄(?)로 인하여 고통받는다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1715) 셀병합된 셀에 연번 입력하기 2 (엑셀 VBA 매크로)\n재생\n3,566\n공유하기\n재생 (space/k)\n재생\n00:29\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:29\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자..."}
{"instruction": "Excel VBA code for: (1717) 폴더내 모든 파일의 특정행 불러오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_Row_In_Folder_1()\nDim strSht As String\n'시트 이름을 넣을 변수\nDim strRow As String\n'가져올 열 넣을 변수\nDim strAddr As String\n'행의 주소를 절대주소로 하여 넣을 변수\nDim rngData As Range\n'가져올 데이터 영역 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim rngT As Range\n'각 열이 복사될 위치 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Offset(, 1).ClearContents\n'기존데이터 삭제\nstrSht = \"\nSheet1\n\"\n'데이터가 저장된\n시트\n의 이름\nstrRow =\n1\n'\n가져올 행\n을 변수에 넣음\nstrAddr = \"$\" & strRow & \":$\" & strRow\n'가져올 행을 절대주소로 만듬\n'----------------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'----------------------------------------------------\nWith Application..\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더를 선택한 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'-----------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'-----------------------------------\nfileName =\nDir\n(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nSet rngT = Cells(Rows.Count, \"A\").End(3)(2)\n'각 행이 복사되는 기준위치를 변수에\n'-------------------------------------------------------------\n' 배열수식을 이용하여 데이터 가져오고 수식을 값으로 변환하는 코드\n'-------------------------------------------------------------\nrngT.Formula = \"=\nCOUNTA\n('\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & strAddr & \")\"\n'1행의 데이터 개수를 찾아 변수에 넣음\nSet rngData = Cells(strRow, 1).Resize(, rngT.Value)\n'가져올 행 주소를 변수에 넣음\nWith rngT.Offset(, 1).Resize(1, rngT.Value)\n'각 행의 데이터\n.\nFormulaArray\n= \"='\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & rngData.Address(1, 1, 1)\n'데이터 영역을 배열 이용하여 가져옴\n.Value = .Value\n'셀의 수식을 값으로 바꿈\nEnd With\nrngT = fileName\n'1행에 파일 이름을 넣음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nColumns.AutoFit\n'열너비 자동 맞춤\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nSet rngT = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngData = Nothing\nEnd Sub", "context": "이 코드는 진작 올린지 알았더니 유사한 것들만 올렸었다. 아래 코드를 올림으로써 폴더내 복수의 엑셀 파일 특정시트로 부터 자신이 원하는 영역의 데이터를 가져올 수 있게 되었다.\n1. 폴더내 모든파일 특정시트의 특정\n행\n불러오기 : 아래코드\n2. 폴더내 모든파일 특정시트의 특정\n열\n불러오기 :\nhttps://blog.naver.com/rosa0189/60209471570\n3. 폴더내 모든파일 특정시트의\n복수열\n불러오기 :\nhttps://blog.naver.com/rosa0189/221473821549\n4. 폴더내 모든파일 특정시트의 특정\n영역\n불러오기 :\nhttps://blog.naver.com/rosa0189/60211082564\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1717) 폴더내 모든 파일의 특정행 불러오기 (엑셀 VBA 매크로)\n재생\n2,256\n공유하기\n재생 (space/k)\n재생\n00:31\n0:00:00\n재생 (space/k..."}
{"instruction": "Excel VBA code for: (1718) 누적잔량 계산하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub input_Remaining_Qty()\nDim rngT As Range\n'A열의 병합셀 하나씩 내려갈 변수\nDim intM As Integer\n'아래 병합셀 셀개수 넣을 변수\nDim intU As Integer\n'위 병합셀 셀개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nSet rngT = Range(\"A5\")\n'A5셀을 변수에 넣음\nintM = rngT.\nMergeArea\n.\nCells.Count\n'병합셀 개수를 변수에 넣음\nrngT.Offset(, 5) = rngT.Offset(, 1) - _\nApplication.\nSum\n(rngT.Offset(, 2).Resize(intM, 3))\n'첫 행 예외처리로 잔량구함\nDo\n'실행\nSet rngT = rngT.Offset(1, 0)\n'A열 아래셀로 이동\nintU = rngT.Offset(-1).MergeArea.Cells.Count\n'위 셀병합셀 개수 구함\nintM = rngT.MergeArea.Cells.Count\n'아래 셀병합셀 개수 구함\nIf rngT.Row > Cells(Rows.Count, \"A\").End(xlUp).Row Then Exit Sub\n'전체 행개수보다 많으면 Do 탈출\nrngT.Offset(, 5) = rngT.Offset(, 1) - _\nApplication.Sum(rngT.Offset(, 2).Resize(intM, 3)) + _\nrngT.Offset(, 5).Offset(-intU)\n'총수량 - 사용량 + 잔량 계산해 입력\nLoop\n'무한 반복\nSet rngT = Nothing\n'개체변수 초기화\nEnd Sub", "context": "매크로 실행 전                                                       매크로 실행 후 결과\n1. 총수량 - (1차, 2차, 3차)의 합을 '잔량'에 넣음  :                     10 - 8 = 2\n2. 잔량은 윗 잔량 + 현 잔량의 합을 넣음 :              20 - 7 = 13.   13 + 2 = 15\n20 - 3 = 17. 17  +15 = 32\n........\nOption Explicit\nSub input_Remaining_Qty()\nDim rngT As Range\n'A열의 병합셀 하나씩 내려갈 변수\nDim intM As Integer\n'아래 병합셀 셀개수 넣을 변수\nDim intU As Integer\n'위 병합셀 셀개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nSet rngT = Range(\"A5\")\n'A5셀을 변수에 넣음\nintM = rng..."}
{"instruction": "Excel VBA code for: (1719) 잔량 계산하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub input_Remaining_Qty2()\nDim rngT As Range\n'A열 병합셀 하나씩 내려갈 변수\nDim intM As Integer\n'아래 병합(Merge)셀 셀개수 넣을 변수\nDim rngArea As Range\n'E열 병합셀 영역(Area)을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim lngSum As Long\n'1차, 2차, 3차 마지막 값 합쳐갈(Sum) 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nSet rngT = Range(\"A4\")\n'A셀을 변수에 넣음\nDo\n'실행\nSet rngT = rngT.Offset(1, 0)\n'A열 아래셀로 이동\nIf rngT.Row > ActiveSheet.UsedRange.\nRows.Count\n+ 3 Then\nExit Sub\n'마지막행 + 3행(1~3행 보정) 보다 크면 매크로 종료\nEnd If\nintM = rngT.\nMergeArea\n.Cells.Count\n'아래 셀병합셀 개수 구함\nSet rngArea = rngT.Offset(, 4).Resize(intM)\n'A열 병합셀 행개수 만큼 E열 선택\nFor Each rngC In rngArea\n'E열 병합셀 개수만큼 각 셀을 순환\nIf rngC <> \"\" Then\n'3차가 공백이 아니면\nlngSum = lngSum + rngC\n'마지막 차수의 합을 더해감\nElseIf rngC.Offset(, -1) <> \"\" Then\n'2차가 공백이 아니면\nlngSum = lngSum + rngC.Offset(, -1)\n'마지막 차수의 합을 더해감\nElseIf rngC.Offset(, -2) <> \"\" Then\n'1차가 공백이 아니면\nlngSum = lngSum + rngC.Offset(, -2)\n'마지막 차수의 합을 더해감\nEnd If\nNext rngC\nrngT.Offset(, 5) = rngT.Offset(, 1) - lngSum\n'총수량 - 차수합계를 잔량에 넣음\nlngSum = 0\n'재사용 위하여 초기화\nLoop\n'무한 반복\nSet rngT = Nothing\n'개체변수 초기화\nSet rngArea = Nothing\nEnd Sub", "context": "매크로 실행 전                                                     매크로 실행 후 결과\n1. 이번은 누적 잔량이 아닌 각 구역의 잔량을 계산.\n2. 각 구역의 (빨간 동그라미로 표시한) 높은 차수의 또는 마지막 차수의 숫자만을 총수량에서 뺀다.\n가 : 10 - 1 -1 -2 = 6\n나 : 20 - 2 - 1 = 17\n다 : 20 - 3 = 17\n라 : 30 - 2 - 1 - 3 - 0 - 1 = 23   .................\nOption Explicit\nSub input_Remaining_Qty2()\nDim rngT As Range\n'A열 병합셀 하나씩 내려갈 변수\nDim intM As Integer\n'아래 병합(Merge)셀 셀개수 넣을 변수\nDim rngArea As Range\n'E열 병합셀 영역(Area)을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim lngSum As Long\n'1차, ..."}
{"instruction": "Excel VBA code for: (1720) 제목행 반복하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub repeat_Rows()\nDim intNum As Integer\n'제목행의 행 개수(Num)ber 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim lastRow As Long\n'마지막(last) 행(Row) 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nintNum =\ninputbox_Function\n'제목행을 입력받는 하위 함수 실행\nlastRow = Cells(Rows.Count, \"A\").End(xlUp).\nRow\n'마지막 행을 변수에 넣음(반복행 빼줌)\nFor r = 4 To lastRow Step intNum\n'4행부터 마지막 열까지 반복\nCells(1, 1).Resize(3, ActiveSheet.UsedRange.Columns.Count).Copy _\nSheets(2).Cells(Rows.Count, \"A\").End(xlUp).Offset(1)\n'제목행 복사\nCells(r, 1).Resize(intNum, ActiveSheet.UsedRange.Columns.Count).Copy _\nSheets(2).Cells(Rows.Count, \"A\").End(xlUp).Offset(1)\n'데이터행 복사\nNext r\nEnd Sub\n\nFunction = input_Value\n'입력값을 함수에 되돌려줌\nOn Error GoTo 0\n'에러 검출기능 초기화\nIf IsNumeric(input_Value) Then\n'입력값이 숫자이면\nIf input_Value >= intMin And input_Value <= intMax Then\nExit Do\n'입력값이 최솟값보다 크거나 같고, 최댓값보다 작거나 같으면 Do 구문 종료\nEnd If\nEnd If\nmsg = \"번호입력 오류.\" &\nvbNewLine\n& vbNewLine\n'메시지창 내용 + 줄바꿈 2번\nmsg = msg & intMin & \" 과(와) \" & intMax & \" 사이의 숫자를 입력.\"\n'메시지창 내용\nMsgBox msg, 64, \"입력오류\"\nLoop\n'무한 반복\nEnd Function", "context": "이 기능은 긴 설명이 필요 없다. 아래 그림과 동영상을 보면 충분하다.^^ 제목이 1행인 경우에는 첨부된 \"제목1행_repeat_Rows.xlsm\"파일 참조.\n매크로 실행 전\n​\n매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1720) 제목행 반복하기 (엑셀 VBA 매크로)\n재생\n494\n공유하기\n재생 (space/k)\n재생\n00:39\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:39\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다..."}
{"instruction": "Excel VBA code for: (1721) 사진(그림)을 파일로 저장하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub export_Pictures()\nDim shp As\nShape\n'도형(sh)a(p)e을 넣을 변수\nDim picName As String\n'사진(pic)ture 이름(Name)을 넣을 변수\nDim chtObj As\nChartObject\n'차트(ch)ar(t) 개체(Obj)ect 넣을 변수\nDim cht As Chart\n'차트(ch)ar(t) 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveSheet\n'활성화된 시트에서\nFor Each shp In .Shapes\n'모든 도형을 순환\nIf shp.Name <> \"Run Macro\" Then\n'도형 이름이 (매크로 실행하는) Run Macro아니면\npicName = .Cells(shp.\nTopLeftCell\n.Row, 1).Value\n'사진 이름 추출\nshp.Select\n'사진을 선택\nSelection.\nCopyPicture\n'선택된 사진을 사진복사\nSet chtObj = .ChartObjects.Add(0, 0, shp.Width, shp.Height)\nchtObj.Chart.Paste\n'         사진이 들어갈 프레임 역할을 할 차트개체를 변수에\nSet cht = chtObj.Chart\n'차트개체의 차트를 변수에\nchtObj.Activate\n'차트개체 활성화\nWith cht\n'차트에서\n.ChartArea.Select\n'차트영역을 선택\n.Paste\n'붙여 넣기\n.\nExport\n(ThisWorkbook.Path & \"\\\" & picName & \".jpg\")\n'같은 경로에 .jpg로 저장\nEnd With\nchtObj.Delete\n'차트 개체 삭제\nEnd If\nNext shp\nEnd With\nSet chtObj = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet cht = Nothing\nEnd Sub", "context": "질문한 사람이 있어 찾아보니 당연히 있을 거라고 생각한 이 코드도 없다. 사실, 내 블로그에 내가 찾는 코드가 실제 없는건지 아니면 내가 못찾는 건지에 대한 확신이 없다.^^  찾아보니 선택영역을 사진으로 내보내는 것만 올린것 같다. 그 코드와 방식은 같은데 다만, 영역이 아닌 삽입된 사진을 별도의 사진파일(.jpg)로 내보낸다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1721) 사진(그림)을 파일로 저장하기 1 (엑셀 VBA 매크로)\n재생\n6,305\n공유하기\n재생 (space/k)\n재생\n00:11\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:11\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0..."}
{"instruction": "Excel VBA code for: (1722) 사진(그림)을 파일로 저장하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub export_Pictures_2()\nDim pic As\nPicture\n'사진(pic)ture을 넣을 변수\nDim picName As String\n'사진(pic)ture 이름(Name)을 넣을 변수\nDim chtObj As ChartObject\n'차트(ch)ar(t) 개체(Obj)ect 넣을 변수\nDim cht As Chart\n'차트(ch)ar(t) 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each pic In ActiveSheet.\nPictures\n'현재시트 모든 사진을 순환\nIf pic.\nTopLeftCell\n.Offset(, -1).Value <> \"\" Then\n'사진 왼쪽셀이 공백이 아니라면\npicName = pic.TopLeftCell.Offset(, -1).Value\n'사진 이름 추출\npic.Select\n'사진을 선택\nSelection.\nCopyPicture\n'선택된 사진을 사진복사\nSet chtObj = ActiveSheet.ChartObjects.\nAdd\n(0, 0, pic.Width, pic.Height)\nchtObj.Chart.Paste\n'사진이 들어갈 프레임 역할을 할 차트개체를\n변수에\nSet cht = chtObj.Chart\n'차트개체의 차트를 변수에\nchtObj.Activate\n'차트개체 활성화\nWith cht\n'차트에서\n.ChartArea.Select\n'차트영역을 선택\n.Paste\n'붙여 넣기\n.\nExport\n(ThisWorkbook.Path & \"\\\" & picName & \".jpg\")\n'같은 경로에 .jpg로 저장\nEnd With\nchtObj.Delete\n'차트 개체 삭제\nEnd If\nNext pic\nSet chtObj = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet cht = Nothing\nEnd Sub", "context": "조금전 올린 내용을 약간 개선했다. 엑셀에 삽입된 사진을 파일로 저장하는 기능.\n사진 왼쪽 셀에 이름이 있는 경우에만 사진파일로 내보낸다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1722) 사진(그림)을 파일로 저장하기 2 (엑셀 VBA 매크로)\n재생\n1,400\n공유하기\n재생 (space/k)\n재생\n00:30\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:30\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 ..."}
{"instruction": "Excel VBA code for: (1723) 사진(그림)을 파일로 저장하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub export_Pictures_2()\nDim wks As Worksheet\n'시트(w)or(ks)heet 넣을 변수\nDim pic As\nPicture\n'사진(pic)ture을 넣을 변수\nDim picName As String\n'사진(pic)ture 이름(Name)을 넣을 변수\nDim chtObj As ChartObject\n'차트(ch)ar(t) 개체(Obj)ect 넣을 변수\nDim cht As Chart\n'차트(ch)ar(t) 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each wks In ActiveWorkbook.Worksheets\nwks.Select\n'시트를 선택\nFor Each pic In ActiveSheet.\nPictures\n'현재시트 모든 사진을 순환\nIf pic.\nTopLeftCell\n.Offset(, -1).Value <> \"\" Then\n'사진 왼쪽셀이 공백이 아니라면\npicName = pic.TopLeftCell.Offset(, -1).Value\n'사진 이름 추출\npic.Select\n'사진을 선택\nSelection.\nCopyPicture\n'선택된 사진을 사진복사\nSet chtObj = ActiveSheet.ChartObjects.\nAdd\n(0, 0, pic.Width, pic.Height)\nchtObj.Chart.Paste\n'사진이 들어갈 프레임 역할을 할 차트개체를\n변수에\nSet cht = chtObj.Chart\n'차트개체의 차트를 변수에\nchtObj.Activate\n'차트개체 활성화\nWith cht\n'차트에서\n.ChartArea.Select\n'차트영역을 선택\n.Paste\n'붙여 넣기\n.\nExport\n(ThisWorkbook.Path & \"\\\" & picName & \".jpg\")\n'같은 경로에 .jpg로 저장\nEnd With\nchtObj.Delete\n'차트 개체 삭제\nEnd If\nNext pic\nNext wks\nSheets(\"Sheet1\").Select\n'제일 앞의 시트 선택\nSet chtObj = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet cht = Nothing\nEnd Sub", "context": "이왕 하는거 시트가 아닌\n모든 시트에 있는 사진을 내보내어 사진파일(.jpg)로 저장\n하는 것도 해봤다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1723) 사진(그림)을 파일로 저장하기 3 (엑셀 VBA 매크로)\n재생\n1,046\n공유하기\n재생 (space/k)\n재생\n00:17\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:17\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별..."}
{"instruction": "Excel VBA code for: (1724) 사진(그림) 영구삽입 2 (엑셀 매크로 VBA)", "input": "", "output": "Sub bring_A_Picture()\nDim rngT As Range\n'사진들어갈 셀위치 넣을 변수\nDim strFilter As String\n'필터링될 파일 확장자 넣을 변수\nDim fileName As String\n'선택한 파일을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nIf TypeName(Selection) = \"Range\" Then\n'선택한 것이 영역이면\nSet rngT = Selection\n'선택영역을 개체변수에 넣음\nstrFilter = \"JPG Files (*.jpg*;*.gif;*.bmp;*.png;*.wmf;*.cur;*.ico),*.jpg*\"\n'가져올 사진의 종류\nfileName = Application.\nGetOpenFilename\n(strFilter, , _\n\"엑셀 파일을 선택\", MultiSelect:=False)\n'사진 파일을 선택\nIf fileName = \"False\" Then Exit Sub\n'취소 선택 시 매크로 종료\nActiveSheet.Shapes.\nAddPicture\n(fileName, 1, 1, 1, 1, 100, 100).Select\n'사진 가져와 선택함.\n'                ActiveSheet.Pictures.\nInsert\n(strPath & fileName).Select\n'링크로 삽입하기 원할 경우 윗행 삭제후 이 코드 주석제거\nWith Selection\n'선택된 사진파일에서\n.ShapeRange.LockAspectRatio = msoFalse\n'가로세로고정비율 해제\n.Left = rngT.Left + 2\n'그림왼쪽위치를 현재셀 왼쪽 + 2 위치에\n.Top = rngT.Top + 2\n'그림위쪽 위치를 현재셀 윗쪽 + 2 위치에\n.Height = rngT.Height - 4\n'그림 높이를 현재셀 -4 크기로\n.Width = rngT.Width - 4\n'그림 폭을 현재셀 -4 크기로\nEnd With\nElse\n'선택한 것이 영역이 아니라면\nMsgBox \"영역을 선택하고 재실행\"\n'메시지 출력\nEnd If\nEnd Sub", "context": "기존에 올렸던 동일한 기능을 하는 코드는 매크로 실행 시\n위와 같은 MS사의 사진선택 창이 중복으로 떠서 불편하여 이 창이 나타나지 않고 바로 사진선택 폴더가 나타나도록 코드를 수정하였다. 아래의 코드는\n사진이 들어갈 영역을 선택하고 매크로 실행 시 선택영역 크기보다 약간 작게 사진을 영구 삽입하는 기능을 하는 코드\n이다.\n영구삽입이 아닌 링크로 삽입하기 원하면 아래 코드를 삭제하고\nActiveSheet.Shapes.AddPicture(fileName, 1, 1, 1, 1, 100, 100).Select\n주석처리 되어 있는 아래 코드의 주석을 제거하면 된다. 즉, 앞의 ' 를 삭제\n'                ActiveSheet.Pictures.Insert(strPath & fileName).Select\n장점\n단점\n영구삽입 : 아무곳에서나 사진 보임     파일 크기가 커짐\n링크삽입 : 파일크기가 작음               링크삽입한 컴퓨터에서만 보임. (이메일로 보내면 사진..."}
{"instruction": "Excel VBA code for: (1725) 라벨(메일머지) 인쇄 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub print_Product()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'반복구문에서 행을 넣을 변수\nDim cnt As Long\n'위아래 셀값 달라질때까지 숫자 더해갈 변수\nDim str As String\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'A열 마지막 행번호를 변수에 넣음\nr = 4\n'4행부터 시작\nDo\n'실행\nIf Cells(r + 1, 1) <> \"\" Then\n'아래 셀이 빈셀 아니면(1행 데이터의 경우)\n​\nWith Sheets(2)\n.Range(\"A1\") = Cells(r, 1)\n'A열값 입력\n.Range(\"A2\") = Cells(r, 2)\n'B열값 입력\n.Range(\"A3\") = Cells(r, 3)\n'C열값 입력\nEnd With\nr = r + 1\nElse\n'아래셀이 빈셀이면\nDo\n'실행\ncnt = cnt + 1\n'카운터를 하나씩 늘려감\nr = r + 1\n'행번호를 하나씩 늘려감\nLoop Until\nCells(r, 1).Value <> Cells(r + 1, 1).Value _\nOr r >= lastRow - 1\n'A열 값이 달라질 때까지 또는 마지막 행까지 반복\nWith Sheets(2)\n.Range(\"A1\") = Cells(r - cnt, 1)\n'A열을 추출하여 입력\n.Range(\"A2\") = Cells(r - cnt, 2)\n'B열을 추출하여 입력\nstr =\nJoin\n(Application.\nTranspose\n(Cells(r - cnt, 3).Resize(cnt + 1)), \" \")\n'컬러를 공백과 함께 합침\n.Range(\"A3\") = str\n'합친 문자를 C열에 입력\nEnd With\ncnt = 0\n'재사용위해 카운터 초기화\nr = r + 1\n'행 1씩 늘려감\nEnd If\nSheets(2).\nPrintOut\n'Sheet2 인쇄\nLoop Until\nr >= lastRow - 1\n'마지막행 도달할 때까지 반복\nEnd Sub", "context": "라벨(메일머지, mail merge\n) 인쇄\n를 하는 기능. 이런 그룹별 작업은 Do 중첩구문을 이용하면 대부분 된다. 바깥 Do는 전체를 무한반복, 안쪽의 Do는 각 그룹별 반복.^^\n매크로 실행 전 데이터(Sheet1)                  매크로 실행 후 결과(Sheet2)\nOption Explicit\nSub print_Product()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'반복구문에서 행을 넣을 변수\nDim cnt As Long\n'위아래 셀값 달라질때까지 숫자 더해갈 변수\nDim str As String\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'A열 마지막 행번호를 변수에 넣음\nr = 4\n'4행부터 시작\nDo\n'실행\nIf Cells(r + 1, 1) <> \"\" Then\n'아래 셀이 빈셀 아니..."}
{"instruction": "Excel VBA code for: (1726) 숫자와 금액 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_each_Letter()\nDim rngAll As Range\n'전체(All)영역을 넣을 영역변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역변수\nDim i As Integer\n'셀의 문자길이만큼 반복할 변수\nDim strEach As String\n'추출한 각(Each) 문자 넣을 변수\nDim strU As String\n'문자를 합쳐(U)nion 넣을 변수\nDim c As Integer\n'열(c)olumn 개수 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range([A1], Cells(Rows.Count, \"A\").End(xlUp))\n'A열 데이터를 개체(영역)변수에\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nFor i = 1 To Len(rngC)\n'각셀의 문자 길이 만큼 반복\nstrEach =\nMid\n(rngC, i, 1)\n'셀의 각 문자를 변수에 넣음\nIf strEach\nLike\n\"\n[0-9,.%$\\€]\n\" Then\n'문자가 숫자,콤마,점,퍼센트,달러,원화,유로중 하나면\nDo\n'실행\nIf Mid(rngC, i, 1) = \",\" Then\n'문자가 콤마(,)이면\nstrU = strU\n'콤마는 합치지 않음\nElse\n'문자가 콤마가 아니면\nstrU = strU & Mid(rngC, i, 1)\n'추출한 문자를 합쳐감\nEnd If\ni = i + 1\n'문자위치 1씩 늘려감\nLoop Until\nNot\nMid(rngC, i, 1)\nLike\n\"[0-9,.%$\\€]\"\n'지정문자 아닐때까지 반복\nc = c + 1\n'열 개수 1씩 늘려감\nIf Right(strU, 1) = \"%\" Then\n'%로 끝나면\nrngC.Offset(, c).\nNumberFormatLocal\n= \"0.00%\"\n'셀 서식을 %로\nEnd If\nIf Left(strU, 1) = \"$\" Or _\nLeft(strU, 1) = \"\\\" Or _\nLeft(strU, 1) = \"€\" Then\n'달러, 원화, 유로로 시작하면\nrngC.Offset(, c).NumberFormatLocal = Left(strU, 1) & \"#,##0.00\"\nEnd If\n'셀서식을 지정 화폐단위로\nrngC.Offset(, c) = strU\n'합친 문자를 셀에 뿌림\nstrU = \"\"\n'재사용 위하여 초기화\nEnd If\nNext i\nc = 0\n'재사용 위하여 초기화\nNext rngC\nFor Each rngC In ActiveSheet.UsedRange.Offset(, 1).Cells\n'A열 오른쪽 각셀 순환\nrngC = rngC.Value * 1\n'각 셀에 1을 곱함(문자를 수식으로 인식시키기 위함)\nIf rngC = 0 Then rngC = \"\"\n'0이 입력된 셀은 0 삭제\nNext rngC\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. 숫자뒤 콤마 있으면 콤마 없이 숫자만 추출\n2. $, \\, €는 금액과 함께 소숫점 2자리까지 추출하여, 숫자로 오른쪽 정렬\n3. %는 소수점 2자리까지 %로 표시\n4. (추출한 문자를 숫자로 바꿔주기 위해 각 셀에 1을 곱하고 생성된 0을 제거함)\n매크로 실행전 데이터가 입력된 상황\n​\n매크로 실행 후 결과\nOption Explicit\nSub extract_each_Letter()\nDim rngAll As Range\n'전체(All)영역을 넣을 영역변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역변수\nDim i As Integer\n'셀의 문자길이만큼 반복할 변수\nDim strEach As String\n'추출한 각(Each) 문자 넣을 변수\nDim strU As String\n'문자를 합쳐(U)nion 넣을 변수\nDim c As Integer\n'열(c)olumn 개수 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (..."}
{"instruction": "Excel VBA code for: (1727) 참조표에 대응하는 문자넣기 (엑셀 VBA 매크로)", "input": "", "output": "Sub special_Characters_Combination()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim wkb As Workbook\n'각 파일을 넣을 변수\nDim varCht\n'참조표를 넣을 배열 변수\nDim r As Long\n'행 개수 늘려갈 변수\nDim i As Integer\n'3열 반복할 변수\nDim j As Integer\n'21행 반복할 변수\nDim strU As Integer\n'참조기호 합칠변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n'------------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'------------------------------------------------\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'---------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'---------------------------------\nfileName =\nDir\n(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nvarCht = Range(\"A1:B21\")\n'참조표를 배열에 넣음\n'------------------------------------------------------\n'파일을 열고 조건에 맞는 값을 찾아 넣고 파일 저장 후 닫음\n'------------------------------------------------------\nDo\nWhile fileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nSet wkb = Workbooks.\nOpen\n(strPath & \"\\\" & fileName)\n'파일을 열고 변수에 넣음\nr = 1\n'1행 부터 시작\n​\nDo\n'실행\nr = r + 1\n'1행씩 늘려감\nFor i = 1 To 3\n'3회(구분 1, 2, 3) 반복\nFor j = 1 To 21\n'21회(참조표 행개수) 반복\nIf Cells(r, i) = varCht(j, 1) Then\n'구분기호가 참조표와 일치하면\nstrU = strU & varCht(j, 2)\n'숫자를 합쳐감\nEnd If\nNext j\nNext i\nCells(r, 4) = strU\n'합쳐진 숫자를 셀(D열)에 뿌리\nstrU = 0\n'재사용 위하여 초기화\nLoop Until\nCells(r + 1, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nr = 0\n'재사용 위하여 초기화\nwkb.\nSave\n'열러진 각 파일을 저장\nwkb.\nClose\n'열려진 각 파일을 닫음\nfileName =\nDir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nMsgBox \"매크로가 종료 되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "한 폴더내에 수백개의 왼쪽 아래와 같은 파일이 있고, 아래 참조표에 대응하는 문자를 조합하여 D열에 합쳐진 문자를 넣는 기능.\n매크로 실행 전                                                          매크로 실행 후 결과\n​\n참조표\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1727) 참조표에 대응하는 문자넣기 (엑셀 VBA 매크로)\n재생\n389\n공유하기\n재생 (space/k)\n재생\n00:54\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:54\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n..."}
{"instruction": "Excel VBA code for: (1728) 그룹별로 합치기 (엑셀 VBA 매크로)", "input": "", "output": "Sub when_Names_Change1()\n'A 또는 B열의 중복작업에 주로 사용\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngArea As Range\n'중복 영역을 넣을 영역변수\nDim rngT As Range\n'복사될 위치를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"F:G\").NumberFormat =\n\"@\"\n'F:G열 서식을 텍스트(Text)로\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nSet rngArea = Cells(r - i, 1).Resize(i + 1)\n'중복 구역을 변수에 넣음\nSet rngT = Cells(Rows.Count, \"F\").End(3)(2)\n'복사될 위치를 변수에 넣음\nIf i = 0 Then\n'중복 없는 1행의 데이터일 경우\nrngT = Cells(r, 2)\nrngT.Offset(, 1) = Cells(r, 3)\nElse\n'중복 데이터일 경우\nWith Application\n'엑셀에서\nrngT =\nJoin\n(.\nTranspose\n(rngArea.Offset(, 1)), \",\")\n'행열 변환하여 콤마로 합쳐 넣음\nrngT.Offset(, 1) = Join(.Transpose(rngArea.Offset(, 2)), \",\")\n'행열 변환하여 콤마로 합쳐 넣음\nEnd With\nEnd If\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until Cells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nColumns(\"F:G\").AutoFit\n'F:G열 열너비 자동맞춤\nSet rngArea = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "각 그룹별로 사이즈 및 수량을 콤마로 연결하여 넣는 기능.\n매크로 실행 전\n​\n매크로 실행 후 결과\nOption Explicit\nSub when_Names_Change1()\n'A 또는 B열의 중복작업에 주로 사용\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngArea As Range\n'중복 영역을 넣을 영역변수\nDim rngT As Range\n'복사될 위치를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"F:G\").NumberFormat =\n\"@\"\n'F:G열 서식을 텍스트(Text)로\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nSet rngArea = Cell..."}
{"instruction": "Excel VBA code for: (1729) 데이터 더 많은행 추출 (엑셀 VBA 매크로)", "input": "", "output": "Sub data_With_More_Info()\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor i = 2 To Sheets.Count\n'2번째 시트부터 마지막 시트까지 반복\nSheets(i).UsedRange.Clear\n'기존 사용영역 데이터 삭제\nNext i\nCells.Copy\nSheets(2).Range(\"A1\")\n'시트전체 복사하여 2번째 시트에 붙여넣기\nSheets(2).Activate\n'2번째 시트 활성화\nWith ActiveSheet.\nSort\n'현재 활성화된 시트의 정렬\n.SortFields.Clear\n'기존 정렬필드 삭제\nFor i = 1 To 6\n'6회 반복\n.\nSortFields.Add2\nKey:=Cells(1, i), Order:=xlAscending\n'모든열 오름차순으로 정렬\nNext i\n.SetRange ActiveSheet.UsedRange\n'현재시트 사용여역을 필터 영역으로\n.Header = xlYes\n'제목행 있음\n.Orientation = xlTopToBottom\n'위에서 아래로\n.\nApply\n'정렬 실행\nEnd With\nDo\n'실행\nr = r + 1\n'1행부터 시작하여 1씩 늘려감\nIf Cells(r, 1) <> Cells(r + 1, 1) Then\n'A열 위아래 셀값이 다르면\nSheets(4).Cells(Rows.Count, \"A\").End(3)(2).Resize(, 6) = _\nCells(r, 1).Resize(, 6).Value\n'4번째 시트에 종단셀 윗방향 기능으로 값 복사\nElse\nSheets(3).Cells(Rows.Count, \"A\").End(3)(2).Resize(, 6) = _\nCells(r, 1).Resize(, 6).Value\n'3번째 시트에 종단셀 윗방향 기능으로 값 복사\nEnd If\nLoop Until Cells(r + 1, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nSheets(3).Columns.\nAutoFit\n'3번째 시트 열너비 자동맞춤\nSheets(4).Columns.AutoFit\n'4번째 시트 열너비 자동맞춤\nSheets(1).Select\n'1번째 시트 선택\nMsgBox \"매크로 종료, Sheet3, Sheet4시트의 데이터를 확인하세요.\"\n'종료 메시지 출력\nEnd Sub", "context": "매크로 실행전 데이터가 입력된 모습\n​\n매크로 실행 후 Sheet3에 추출된 데이터\n​\nSheet3에 추출된 이외의 데이터\nOption Explicit\nSub data_With_More_Info()\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor i = 2 To Sheets.Count\n'2번째 시트부터 마지막 시트까지 반복\nSheets(i).UsedRange.Clear\n'기존 사용영역 데이터 삭제\nNext i\nCells.Copy\nSheets(2).Range(\"A1\")\n'시트전체 복사하여 2번째 시트에 붙여넣기\nSheets(2).Activate\n'2번째 시트 활성화\nWith ActiveSheet.\nSort\n'현재 활성화된 시트의 정렬\n.SortFields.Clear\n'기존 정렬필드 삭제\nFor i = 1 To 6\n'6회 반복\n.\nSo..."}
{"instruction": "Excel VBA code for: (1730) 필드명(제목행) 뒤섞인 데이터 통합 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_Data_Matching_Field()\nDim strPath As String\n'폴더의 경로(Path)를 넣을 변수\nDim fileName As String\n'각 파일(file) 이름을(Name) 넣을 변수\nDim wkb As Workbook\n'각 파일(w)or(kb)ook을 넣을 변수\nDim rngT As Range\n'복사될 위치(T)arget 넣을 영역(r)a(ng)e변수\nDim varData\n'각 파일의 데이터(Data)를 배열(var)iant 변수\nDim r As Long\n'행(r)ow 개수 늘려갈 변수\nDim c As Integer\n'배열내 열(c)olumn방향 늘려갈 변수\nDim rngFind As Range\n'검색(Find)에 일치한 영역(r)a(ng)e을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n'----------------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'----------------------------------------------------\nWith Application..\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더를 선택한 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'-----------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'-----------------------------------\nfileName =\nDir\n(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\n'---------------------------------\n'파일을 열고 배열에 넣은뒤 파일 닫음\n'---------------------------------\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nSet wkb = Workbooks.\nOpen\n(strPath & \"\\\" & fileName)\n'파일을 열고 변수에 넣음\nvarData = Range(\"A1\").CurrentRegion\n'A1셀과 연결된 영역을 배열변수에 넣음\nwkb.\nClose\nFalse\n'열려진 각 파일을 저장없이 닫음\n'-------------------------------------------------\n'제목이 일치하는 위치를 찾아 각 데이터를 시트에 뿌림\n'-------------------------------------------------\nFor r = 2 To UBound(varData, 1)\n'데이터 개수만큼 반복\nSet rngT = Cells(Rows.Count, \"A\").End(3)(2)\n'복사될 A열 위치를 변수에 넣음\nrngT = varData(r, 1)\n'대표자(이름)를 넣음\nFor c = 2 To UBound(varData, 2)\n'2열부터 배열 상한값까지 반복\nSet rngFind = Range(\"A1\", Cells(1, Columns.Count).End(1)).\nFind\n(varData(1, c))\n'일치한 데이터 영역을 변수에 넣음\nCells(rngT.Row, rngFind.Column) = varData(r, c)\n'배열내 값을 셀에 뿌림\nNext c\nNext r\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nActiveSheet.UsedRange.\nSort\n[A2], 1, Header:=xlYes\n'현재시트 A열 기준 오름차순 정렬\nMsgBox \"매크로가 종료 되었습니다.\"\n'종료 메시지 출력\nSet wkb = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngT = Nothing\nSet rngFind = Nothing\nEnd Sub\n\nSub delete_Data()\nActiveSheet.UsedRange.Offset(1).Clear\n'기존 데이터 삭제\nEnd Sub", "context": "폴더에 저장된 엑셀파일의 필드명(제목행)의 개수가 다르고, 더군다나 뒤죽박죽 뒤섞인 데이터를 통합하는 기능. 어느 파일에는 대표자 이름이 중복된 데이터도 있음.\n매크로 실행 전 'Data1'.xlsx파일                                            매크로 실행 전 'Data2'.xlsx파일\n매크로 실행 후 통합된 데이터\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1730) 필드명(제목행) 뒤섞인 데이터 통합 (엑셀 VBA 매크로)\n재생\n765\n공유하기\n재생 (space/k)\n재생\n00:44\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:44\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기..."}
{"instruction": "Excel VBA code for: (1732) 그룹별 데이터 각 시트로 분류하기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub split_Each_Group_2()\nDim msg As String\n'출력할 메시지(m)e(s)sa(g)e를 넣을 변수\nDim intCol As Integer\n'선택한 열(Col)umn 번호 넣을 변수\nDim colsCnt As Integer\n'전체 열(col)umn 개수 넣을 변수\nDim s As Long\n'시트(s)heet 개수만큼 반복할 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'그룹별 이름 중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n'-------------------------------------------\n' 선택영역이 1개의 열, 전체행만 선택하도록 함.\n'-------------------------------------------\nmsg = \"1열 전체행만 선택하고 매크로 실행하시오.\" & vbCrLf & _\nvbNewLine\n& _\n\"매크로를 중단합니다.\"\nWith Selection\n'선택영역\nIf .Columns.Count > 1 Or _\n.Rows.Count <> Rows.Count Or _\n.Areas.Count > 1 Then\n'잘못된 영역 선택 시 경고창 출력\nMsgBox msg, vbExclamation, \"영역선택 오류\"\n'경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nEnd With\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열 개수 추출\nintCol = Selection.Column\n'선택영역 열 번호 추출\n'----------------------------\n'Data 시트만 남기고 모두 삭제\n'----------------------------\nFor s = Sheets.Count To 2 Step -1\n'Data시트 제외한 전체시트 순환\nApplication.\nDisplayAlerts\n= False\n'화면 경고기능 중지\nSheets(s).Delete\n'각 시트 삭제\nApplication.DisplayAlerts = True\n'화면 경고기능 복원\nNext s\n'------------------------------------\n'임시시트 삽입후 데이터 복사하고 정렬\n'------------------------------------\nSheets.Add After:=Sheets(Sheets.Count)\n'시트를 제일 뒤에 추가\nSheets(1).\nCells.Copy\nRange(\"A1\")\n'시트 전체를 A1위치에 복사\nActiveSheet.UsedRange.\nSort\nCells(2, intCol), 1, Header:=xlYes\n'선택열을 기준 오름차순 정렬\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, intCol) = Cells(r + 1, intCol) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\n'---------------------------------\n'각 그룹별 시트 추가 후 데이터 복사\n'---------------------------------\nSheets.Add\nAfter:=Sheets(Sheets.Count)\n'시트를 제일 뒤에 추가\nSheets(2).Select\n'2번째 시트 선택\nWith Sheets(Sheets.Count)\n.\nName\n= Cells(r, intCol)\n'시트 이름을 각 그룹 이름으로 변경\n.Range(\"A2\").Resize(i + 1, colsCnt) = Cells(r - i, 1).Resize(i + 1, colsCnt).\nValue\nEnd With\n'각 그룹별 데이터 각 시트에 복사\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\nLoop Until Cells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\n'---------------------\n'각 시트에 제목행 복사\n'---------------------\nFor s = 3 To Sheets.Count\n'처음 2개 시트 제외한 전체시트 순환\nCells(1, 1).Resize(, colsCnt).Copy Sheets(s).Range(\"A1\")\n'제목행 복사\nNext s\n'----------------------\n'임시로 사용한 시트 삭제\n'----------------------\nApplication.DisplayAlerts = False\n'화면 경고기능 중지\nSheets(2).Delete\n'임시로 사용한 2번째 시트 삭제\nApplication.DisplayAlerts = True\n'화면 경고기능 복원\nSheets(1).Select\n'Data시트 선택\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "많은 엑셀 사용자들 중 매크로 코드가 어디에 있는지도 몰라서 내 매크로의 \"B\"를 자기 데이터 열에 맞추어 \"C\" 또는 \"D\"로 단 1자만 수정하라고 하여도 부담을 느끼고 코드를 사용하지 못하는 경우가 있어 단순히 전체열만 선택하고 매크로 실행하도록 코드를 수정.\n아래의 코드는\n자신이 선택한 열을 기준으로 각 그룹별 시트를 생성해주는 기능\n을 한다. 아래 동영상에서 처럼 먼저 전체열 하나만 선택하고 매크로를 실행하여야 한다.\n매크로 실행 전 데이터가 입력되어 있음. 매크로 실행전 B열 선택\n매크로 실행 후 결과. 선택한 열에 있는 대표자별로 시트를 생성.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1732) 그룹별 데이터 각 시트로 분류하기 4 (엑셀 VBA 매크로)\n재생\n3,666\n공유하기\n재생 (space/k)\n재생\n00:48\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:48\n실시간\n설정\n전체 화..."}
{"instruction": "Excel VBA code for: (1733) 동적피벗 생성 (엑셀 VBA 매크로)", "input": "", "output": "Sub pivot_Table_Various_Rows()\nDim pvtName As String\n'피벗테이블 이름 넣을 변수\nDim shtName As String\n'날짜(시트이름) 넣을 변수\nDim srcData As String\n'데이터 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\npvtName = \"PivotTable1\"\n'PivotTable1 으로 피벗생성\nshtName = Range(\"E1\").Value\n'E1에 입력된 시트명을 변수에 넣음\nsrcData = shtName & \"!R1C1:\" & _\nSheets(shtName).Cells(Rows.Count, \"B\").End(3).\nAddress\n(1, 1, 0)\n'A1셀에서 B열 마지막 행까지 데이터 영역으로 지정\nActiveWorkbook.PivotCaches.Create(SourceType:=xlDatabase, _\nSourceData:=srcData, Version:=6).CreatePivotTable _\nTableDestination:=ActiveSheet.\nName\n& \"!\" & \"R1C1\", _\nTableName:=pvtName, _\nDefaultVersion:=6\n'피벗 테이블 생성\nWith ActiveSheet.PivotTables(pvtName)\n'현재시트 피벗테이블에서\nWith .PivotFields(\"기준2\")\n'피벗필드\n.Orientation =\nxlRowField\n'행방향\n.Position = 1\n'1번 위치에\nEnd With\n.\nAddDataField\n.PivotFields(\"기준1\"), \"기준1 합계\", xlSum\n'데이터 필드에 합계 넣음\nEnd With\nEnd Sub\n\nSub delete_AB_Columns()\nColumns(\"A:B\").Clear\n'A:B열 데이터 삭제\nEnd Sub", "context": "VBA(매크로) 이용하여 피벗테이블을 만드는 것은 그리 어렵지 않다. 다만, 자동기록 장치가 생성한 코드를 자신의 데이터 영역에 맞추고, 피벗테이블이 사용하는 R1C1 주소로 코드를 바꿔주는게 살짝 까다롭다.\n아래의 코드는 2가지 조건을 반영하여 피벗 테이블을 생성한다.\n1. 날짜별로 생성되는 데이터의 행 개수가 가변적인 상황.\n2. 데이터 필드(제목행)은 일정\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1733) 동적피벗 생성 (엑셀 VBA 매크로)\n재생\n1,893\n공유하기\n재생 (space/k)\n재생\n00:24\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:24\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1..."}
{"instruction": "Excel VBA code for: (1734) 입문/출문 시간 계산 (엑셀 VBA 매크로)", "input": "", "output": "Sub in_Out_Time()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"E\").\nNumberFormatLocal\n= \"\nh:mm;@\n\"\n'E열 서식을 시간으로\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 3) <> \"출문\" Then\n'C열 값이 \"출문\"이 아니면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nCells(r, 5) = Cells(r, 4) - Cells(r - i, 4)\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nEnd Sub", "context": "매크로 실행 전 입/출문 데이터가 기록됨\n매크로 실행 후 결과\nOption Explicit\nSub in_Out_Time()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"E\").\nNumberFormatLocal\n= \"\nh:mm;@\n\"\n'E열 서식을 시간으로\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 3) <> \"출문\" Then\n'C열 값이 \"출문\"이 아니면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nCells(r, 5) = Cells(r, 4) - Cells(r - i, 4)\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nEnd Sub..."}
{"instruction": "Excel VBA code for: (1736) 선택영역에 빈행 삽입하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Blank_Rows_3()\nDim rngRow As Range\n'선택영역 전체행(Row) 데이터영역(r)a(ng)e\nDim rngC As Range\n'각 셀(C)ell 순환시 사용할 변수\nDim cntCell As Long\n'선택영역 셀(Cell) 개수(c)ou(nt) 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim j As Long\n'반복구문에 사용할 변수\nDim lngCountA As Long\n'빈셀 아닌 셀의 개수(CountA) 넣을 변\n수\nDim lngBlank As Long\n'빈셀(Blank)의 개수 넣을 변수\nDim rngBottom As Range\n'선택영역 아래(Bottom)에 삽입할 빈행 영역\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n'------------------------------------------\n' 선택영역이 1개의 열만 선택하도록 하는 코드\n'------------------------------------------\nWith Selection\n'선택영역에서\nIf .Columns.Count > 1 Or _\n.Rows.Count = Rows.Count Or _\n.\nAreas\n.Count > 1 Then                                  '\nMsgBox \"1개의 열만 선택(전체행 또는 다중영역 선택하면 안됨)\", _\nvbExclamation, \"영역선택 오류\"  '경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nEnd With\n'--------------------------------------\n' 선택영역 같은 행에 셀병합셀 있는지 확인\n'--------------------------------------\nSet rngRow = Selection.Offset(0, -(Selection.Column - 1)).Resize(, _\nActiveSheet.UsedRange.Columns.Count)\n'선택영역 전체행을 영역변수에 넣음\nFor Each rngC In rngRow\n'선택영역 전체 데이터 영역 각셀 순환\nIf rngC.\nMergeCells\nThen\n'셀병합 셀이 있으면\nMsgBox \"선택영역 같은 행에 셀병합된 셀이 있습니다.\", _\nvbExclamation, \"셀병합 오류\"\n'경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nNext rngC\ncntCell = Selection.Cells.Count\n'선택영역 셀 개수를 변수에 넣음\nColumns(Selection.Column).Insert\n'임시로 사용할 빈열 삽입\n'--------------------------------------\n'선택영역이 모두 빈셀인 경우의 예외 처리\n'--------------------------------------\nWith Application.WorksheetFunction\n'엑셀 함수\nlngCountA = .\nCountA\n(Selection.Offset(, 1))\n'값이 있는 셀의 개수를 변수에\nIf lngCountA = 0 Then\n'선택영역이 모두 빈셀이면\nWith Selection\n.EntireRow.Insert\n'선택영역에 전체행 삽입\n.EntireColumn.Delete\n'임시열 삭제\nExit Sub\n'매크로 종료\nEnd With\nEnd If\nlngBlank = .\nCountBlank\n(Selection.Offset(, 1))\n'값이 없는 빈셀의 개수를 변수에\nEnd With\n'--------------------------------------------------------------------------\n'선택영역에 빈셀 없는 경우 선택영역 x 2배 행에 정렬기준 숫자 2번 구분하여 넣음\n'--------------------------------------------------------------------------\nIf lngBlank = 0 Then\n'빈셀이 하나도 없는 경우\nSelection.Offset(cntCell).\nEntireRow\n.Insert\n'선택영역 행 개수만큼 빈행 삽입\nFor Each rngC In Selection.Resize(cntCell * 2)\n'선택영역 행 x 2배 영역 각셀 순환\nIf rngC.Offset(, 1) <> \"\" Then\n'빈셀이 아니면\ni = i + 1\n'숫자를 늘려감\nrngC = i\n'셀에 값을 넣음\nElse\n'빈셀이라면\nj = j + 1\n'숫자를 늘려감\nrngC = j\n'셀에 값을 넣음\nEnd If\nNext rngC\nSelection.Cells(1).Resize(cntCell * 2).Select\n'선택영역 x 2배 영역을 선택\n'-------------------------------------------------------------------------\n'선택영역에 빈셀 있는 경우 선택영역 + lngCountA 영역에 숫자 3번 구분하여 넣음\n'-------------------------------------------------------------------------\nElse\nSelection.Offset(cntCell).Resize(lngCountA).EntireRow.Insert\n'선택영역 아래쪽에 lngCountA 개수만큼 빈행 삽입\nSet rngBottom = Selection.Offset(cntCell).Resize(lngCountA)\n'선택영역 아래에 삽입된 빈셀행을 변수에\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nIf rngC.Offset(, 1) <> \"\" Then\n'빈셀이 아니라면\ni = i + 1\n'숫자를 늘려감\nrngC = i\n'셀에 값을 넣음\nEnd If\nNext rngC\ni = 0\n'재사용 위하여 초기화\nFor Each rngC In Selection.\nSpecialCells(4).Areas\n'선택영역 빈셀구역 순환\ni = i + 1\n'숫자를 늘려감\nrngC = i\n'셀에 값을 넣음\nNext rngC\ni = 0\n'재사용 위하여 초기화\nFor Each rngC In rngBottom\n'선택영역 아래 빈행 삽입된 빈행 각셀순환\ni = i + 1\n'숫자를 늘려감\nrngC = i\n'셀에 값을 넣음\nNext rngC\nSelection.Cells(1).Resize(cntCell + lngCountA).Select\n'선택영역 + lngCountA 영역을 선택\nEnd If\n'------------------------------------------------\n' 오름차순 정렬로 빈행 각행으로 나눈 후 임시열 삭제\n'------------------------------------------------\nWith Selection.EntireRow\n'선택영역 전체행\nIf lngBlank = 0 Then\n'선택영역에 빈셀 없는 경우\n.\nSort\nSelection.Cells(1), 1, Header:=False\n'선택영역 첫 셀을 기준으로 오름차순 정렬\nElse\n'선택영역에 빈셀 있는 경우\n.Sort Selection.Cells(1), 1, Header:=False\n'선택영역 첫 셀을 기준으로 오름차순 정렬\nEnd If\nEnd With\nSelection.EntireColumn.Delete\n'임시로 사용한 열 삭제\nEnd Sub", "context": "아래의 코드는 ,\n1열의 영역을 선택 후 매크로를 실행하면 빈 행을 삽입해주는\n기능\n을 한다. 역시나, 빈행을 빠르게 삽입하기 위해 상당히 고심해서 만든 코드이다. 몇 만행도 금방 삽입한다. 이 보다 더 쉽게, 더 빠르게 빈행을 삽입하기는 어렵다. ^^\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1736) 선택영역에 빈행 삽입하기 3 (엑셀 VBA 매크로)\n재생\n864\n공유하기\n재생 (space/k)\n재생\n00:42\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:42\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도..."}
{"instruction": "Excel VBA code for: (1739) DoEvents가 있고 없고 차이 (엑셀 VBA 매크로)", "input": "", "output": "Sub without_DoEvents()                Sub with_DoEvents()\nDim r As Long                               Dim r As Long\nApplication.ScreenUpdating = 2       Application.ScreenUpdating = 2\nFor r = 1 To 1000000                       For r = 1 To 1000000\nDoEvents\nNext r                                           Next r\nEnd Sub", "context": "오늘 어떤분이 2 ~ 3일 답을 찾지 못해 고생했는데 제가 DoEvents의 사용을 권장해서 그 문제가 해결되었습니다. DoEvents는 엑셀이 윈도우에게 제어권을 넘겨주는 것을 말합니다. 즉, 이 코드가 없으면 윈도우는 매크로가 끝날 때까지 무한정 기다려야 합니다. 하지만, DoEvents가 있으면, 윈도우는 매크로 돌리다가, 사용자가 다른 프로그램을 사용하면 그것도 처리하다가, 매크로 돌리다가를 반복합니다.\n그러므로, 당연히 DoEvents를 사용하면 매크로의 속도가 떨어집니다. 문제는 얼마나 인데 그걸 확인해 봤습니다.\n반복 횟수 : 1,000,000번\nwithout_DoEvents\nWith_DoEvents\n소요시간 :\n0.01초\n31.91초\nSub without_DoEvents()                Sub with_DoEvents()\nDim r As Long                               Dim r As Long\nApplication.Scree..."}
{"instruction": "Excel VBA code for: (1740) 주소록 합치기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_User_Info()\nDim varData\n'데이터(Data) 넣을 배열(var)iant 변수\nDim rowsCnt As Long\n'전체 행(rows)의 개수(C)ou(nt) 넣을 변수\nDim colsCnt As Integer\n'전체 열(columns)의 개수(C)ou(nt) 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'이름 중복개수 구할 변수\nDim rngArea As Range\n'중복 영역(Area)을 넣을 영역변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim x As Long\n'열방향 즉 x방향 늘려갈 변수\nDim y As Long\n'행방향 즉 y방향 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet\n.\nCopy\nafter:=Sheets(Sheets.Count)\n'현재시트를 제일 뒤에 복사\nCall\napply_Sort\n'정렬하는 하위코드 호출\nWith Range(\"A1\").\nCurrentRegion\n'A1과 연결영역에서\nrowsCnt = .Rows.Count\n'전체 행의 개수 넣을 변수\ncolsCnt = .Columns.Count\n'전체 열의 개수 넣을 변수\nEnd With\nReDim\nvarData(1 To rowsCnt, 1 To colsCnt)\n'배열크기 재지정\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nIf Cells(r, 2) = Cells(r + 1, 2) And Cells(r, 3) = Cells(r + 1, 3) Then\n'이름과 전화번호가 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'이름과 전화번호 다르면\nSet rngArea = Cells(r - i, 1).Resize(i + 1)\n'중복 구역을 변수에 넣음\ny = y + 1\n'rngArea의 행 1씩 늘려감\nvarData(y, 1) = Cells(r, 1)\n'지역을 변수에 넣음\nFor x = 2 To colsCnt\n'두 번째 열부터 마지막 열까지\nSet rngArea = rngArea.Offset(, 1)\n'중복 구역을 오른쪽으로 1열씩 이동\nFor Each rngC In rngArea\n'중복구역 각 셀을 순환\nIf rngC <> \"\" Then\n'빈 셀이 아니라면\nvarData(y, x) = rngC\n'배열에 값을 넣음\nExit For\n'For 구문 탈출\nEnd If\nNext rngC\nNext x\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nIsEmpty\n(Cells(r, 1))\n'A열에 빈셀 나올때까지 무한 반복\nSheets.\nAdd\nafter:=Sheets(Sheets.Count)\n'빈 시트 제일 뒤에 삽입\nCells(1, 1).Resize(rowsCnt, colsCnt) = varData\n'배열값을 셀에 뿌림\nColumns.AutoFit\n'열너비 자동맞춤\nCall\nadd_Hyperlink(\"E\")\n'E열에 하이퍼링크 적용하는 하위코드 호출\nSet rngArea = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nPrivate Sub apply_Sort()\n'2~5열까지 오름차순 정렬\nDim r As Long\n'행(r)ow 늘려갈 변수\nWith ActiveSheet.\nSort\n'현재 시트 정렬\n.SortFields.Clear\n'기존 정렬필드 제거\nFor r = 2 To Range(\"A1\").CurrentRegion.Columns.Count\n'2번 열부터 열 개수만큼 반복\n.SortFields.Add2 Key:=Cells(1, r), Order:=xlAscending\n'오름차순 정렬\nNext r\n.SetRange ActiveSheet.UsedRange\n'현재시트 사용영역\n.Header = xlYes\n'제목행 있음\n.MatchCase = False\n'대소문자구분 안함\n.Orientation = xlTopToBottom\n'위에서 아래 방향으로 정렬\n.SortMethod = xlPinYin\n'정렬방법\n.Apply\n'정렬실행\nEnd With\nEnd Sub\n\nPrivate Sub add_Hyperlink(ByVal strCol As String)\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nIf Application.WorksheetFunction.\nCountA\n(Columns(strCol)) Then\n'데이터가 있으면\nSet rngAll = Columns(strCol).SpecialCells(2)\n'E열 데이터 입력셀을 변수에 넣음\nFor Each rngC In rngAll\n'전체영역(rngAll)의 각셀(rngC)을 순환\nrngC.\nHyperlinks\n.Add Anchor:=rngC, Address:=\"\", SubAddress:= _\nrngC.Value, TextToDisplay:=rngC.Value\n'입력된 값으로 하이퍼링크 적용\nNext\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd If\nEnd Sub", "context": "예전 아웃룩의 주소록이 3개(노트북, 회사 컴퓨터, 집 컴퓨터)가 있을 때 세 개를 합치고 싶었다. 그 때 이코드가 있었으면 유용했을텐데 ... 사람들마다 데이터의 구조가 달라서 활용성이 있을지 약간은 의문시 되지만 이런 기능이 필요하다고 한 분이 있어서 한 번 시도해봄.\n매크로 실행 전 데이터\n​\n매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1740) 주소록 합치기 (엑셀 VBA 매크로)\n재생\n1,485\n공유하기\n재생 (space/k)\n재생\n00:29\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:29\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습..."}
{"instruction": "Excel VBA code for: (1741) 가로 데이터 세로로 취합 (엑셀 VBA 매크로)", "input": "", "output": "Sub trans_Data()\nDim c As Integer\n'열(c)olumn 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(\"Data\").Select\n'Data시트 선택\nc = 2\n'2열부터 시작\nDo\n'실행\nIf\nNot IsEmpty\n(Cells(2, c))0 Then\n'빈 셀이 아니라면\nWith Sheets(\"통합\")\n'통합 시트에서\nCells(2, c).CurrentRegion.Copy .Cells(.UsedRange.Rows.Count + 1, \"B\")\nEnd With\n'마지막행 + 1 위치 B열에 데이터 복사\nEnd If\n'열결영역 데이터를 통합 시트에 종단셀 윗방향으로 데이터 복사\nc = c + 5\n'열 위치 늘려감\nLoop Until c > ActiveSheet.UsedRange.Columns.Count\n'현재시트 열개수 보다 크면 종료\nSheets(\"통합\").Select\n'통합시트 선택\nEnd Sub", "context": "가로로 건너뛰며 입력된 데이터를 세로로 취합하는 기능\n매크로 실행 전 Data 시트내의 데이터\n​\n매크로 실행 후 결과\nOption Explicit\nSub trans_Data()\nDim c As Integer\n'열(c)olumn 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(\"Data\").Select\n'Data시트 선택\nc = 2\n'2열부터 시작\nDo\n'실행\nIf\nNot IsEmpty\n(Cells(2, c))0 Then\n'빈 셀이 아니라면\nWith Sheets(\"통합\")\n'통합 시트에서\nCells(2, c).CurrentRegion.Copy .Cells(.UsedRange.Rows.Count + 1, \"B\")\nEnd With\n'마지막행 + 1 위치 B열에 데이터 복사\nEnd If\n'열결영역 데이터를 통합 시트에 종단셀 윗방향으로 데이터 복사\nc = c + 5\n'열 위치 늘려감\nLoop Until c > Activ..."}
{"instruction": "Excel VBA code for: (1742) 데이터 쪼개어 이동하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub eight_4_Nine()\nDim b As Long\n'b열 늘려갈 변수\nDim c As Long\n'c열 늘려갈 변수\nDim d As Long\n'd열 늘려갈 변수\nb = 3\n'b열 첫 행위치\nc = 3\n'c열 첫 행위치\nd = 3\n'd열 첫 행위치\nDo\n'실행\nIf\nNot IsEmpty(\nCells(b, 2)) Then\n'b열의 데이터가 빈셀 아니면\nCells(3, Columns.Count).End(1)(1, 2).\nResize\n(8) = _\nCells(b, 2).Resize(8)\n.\nValue\n'8행씩 건너뛰며 종단셀 왼쪽 3행 위치에 복사\nb = b + 8\n'행을 8행씩 더해감\nEnd If\nIf Not IsEmpty(Cells(c, 3)) Then\n'c열의 데이터가 빈셀 아니면\nCells(3, Columns.Count).End(1)(1, 2).Resize(4) = _\nCells(c, 3).Resize(4).Value\n'4행씩 건너뛰며 종단셀 왼쪽 3행 위치에 복사\nc = c + 4\n'행을 4행씩 더해감\nEnd If\nIf Not IsEmpty(Cells(d, 4)) Then\n'd열의 데이터가 빈셀 아니면\nCells(3, Columns.Count).End(1)(1, 2).Resize(9) = _\nCells(d, 4).Resize(9).Value\n'9행씩 건너뛰며 종단셀 왼쪽 3행 위치에 복사\nd = d + 9\n'행을 9행씩 더해감\nEnd If\nLoop Until c > ActiveSheet.UsedRange.\nRows.Count\n'(c열의 데이터 개수가 제일 많으므로)c열에 빈셀 나올때까지 무한 반복\nEnd Sub\n\nSub delete_Data()\nActiveSheet.UsedRange.Offset(, 3).\nClearContents\n'현재데이터 오른쪽으로 3열 건너뛰고 삭제\nEnd Sub", "context": "길게 세로로 저장되어 있는 B, C, D열의 데이터를 각각 8, 4, 9행씩 나누어 행으로 저장해주는 기능. 예제 파일에서는 B3:D1002 영역에 1 ~ 3000 까지의 숫자가 들어가 있다.\n매크로 실행전 데이터가 입력된 상황\n매크로 실행 후 결과 (8, 4, 9 행씩 나누어 오른쪽으로 계속 저장해감)\nOption Explicit\nSub eight_4_Nine()\nDim b As Long\n'b열 늘려갈 변수\nDim c As Long\n'c열 늘려갈 변수\nDim d As Long\n'd열 늘려갈 변수\nb = 3\n'b열 첫 행위치\nc = 3\n'c열 첫 행위치\nd = 3\n'd열 첫 행위치\nDo\n'실행\nIf\nNot IsEmpty(\nCells(b, 2)) Then\n'b열의 데이터가 빈셀 아니면\nCells(3, Columns.Count).End(1)(1, 2).\nResize\n(8) = _\nCells(b, 2).Resize(8)\n.\nValue\n'8행씩 건너뛰며 종단셀 왼쪽 3행 위치에 복사\nb =..."}
{"instruction": "Excel VBA code for: (1743) 폴더내 모든파일 모든시트 특정열 가져오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_All_Columns_In_Folder_1()\nDim varName As Variant\n'시트이름 넣을 배열 변수\nDim strSht As String\n'시트 이름을 넣을 변수\nDim strCol As String\n'가져올 열 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim rngT As Range\n'각 열이 복사될 위치 넣을 영역변수\nDim c As Long\n'열 개수 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.ClearContents\n'기존데이터 삭제\nstrCol = \"\nC\n\"\n'가져올 열(\nC열\n)을 변수에 넣음\nstrCol = \"$\" & strCol & \":$\" & strCol\n'가져올 열을 절대($)주소로 변경\n​\n'-------------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'-------------------------------------------------\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더를 선택한 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'-------------------------------------\n' 폴더내 엑셀파일 유무를 확인하는 코드\n'-------------------------------------\nfileName =\nDir\n(strPath & \"*.xls*\")\n(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 엑셀 파일이 없음.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nvarName = get_Sheet_Names(strPath, fileName)\n'폴더경로와 파일이름 함수로 건넴\nFor c = 1 To\nUBound\n(varName)\n'배열 상한값 만큼 반복\nstrSht = varName(c)\n'시트이름을 변수에 넣음\n'--------------------------------------------------------------\n' 배열수식을 이용하여 데이터 가져오고 수식을 값으로 변환하는 코드\n'--------------------------------------------------------------\nSet rngT = Cells(1, Columns.Count).End(1)(1, 2)\n'각 열이 복사되는 기준위치를 변수에\nrngT.Formula = \"=\nCOUNTA\n('\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & strCol & \")\"\n'C열의 데이터 개수를 찾아 변수에 넣음\nIf rngT > 0 Then\n'열에 데이터가 존재할 경우\nWith rngT.Offset(2).Resize(rngT.Value)\n'각 열의 데이터\n.\nFormulaArray\n= \"='\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & Cells(1, strCol).Resize(rngT.Value).Address(1, 1, 1)\n'데이터 영역을 배열 이용하여 가져옴\n.Value = .Value\n'셀의 수식을 값으로 바꿈\nEnd With\nEnd If\nrngT = fileName\n'1행에 파일 이름을 넣음\nrngT.Offset(1) = varName(c)\n'시트 이름을 2행에 넣음\nNext c\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nColumns.AutoFit\n'열너비 자동 맞춤\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub\n\nPrivate Function get_Sheet_Names\n(ByVal strPath As String, ByVal fileName As String)\n'파일 열지 않고 시트명만 가져오는 코드\n'----------------------------------------------\n'Microsoft ActiveX Data Objects 2.8 Library 참조\n'Microsoft ADO Ext. 2.8 for DDL and Security 참조\n'----------------------------------------------\nDim strConn As ADODB.Connection\nDim ctlg As ADOX.Catalog\nDim tbl As ADOX.Table\nDim r As Long\nDim varShtName()\nSet strConn = New ADODB.Connection\nstrConn.Open \"Provider=MSDASQL.1;Data Source=Excel Files;\" _\n& \"Initial Catalog=\" & strPath & fileName\nSet ctlg = New ADOX.Catalog\nSet ctlg.ActiveConnection = strConn\nFor Each tbl In ctlg.Tables\nr = r + 1\nReDim Preserve varShtName(1 To r)\nvarShtName(r) = Left(tbl.Name, Len(tbl.Name) - 1)\nNext tbl\nSet ctlg = Nothing\nstrConn.Close\nSet strConn = Nothing\nget_Sheet_Names = varShtName\nEnd Function", "context": "아래의 코드는 엑셀 파일들이 한 폴더내에 저장되어 있는 상황에서, 그\n파일들을 열고닫지 않고\n, ADOX.Table의 table이름을 이용하여 파일내의 모든 시트명을 추출하고, 그 추출한 파일명과 배열함수 기능을 이용하여,\n폴더내 모든파일 모든시트 특정\n열\n을 가져오는 기능\n을 한다. 아래의 코드는 C열을 가져온다. 자신의 데이터에 맞추어 가져올 열 이름으로 수정하여 사용하면 된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1743) 폴더내 모든파일 모든시트 특정열 가져오기 (엑셀 VBA 매크로)\n재생\n1,801\n공유하기\n재생 (space/k)\n재생\n00:49\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:49\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기..."}
{"instruction": "Excel VBA code for: (1744) 나누고 셀병합해 합쳐넣기 (엑셀 VBA 매크로)", "input": "", "output": "Sub split_And_Merge()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngArea As Range\n'중복 영역(Area)을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.Copy after:=Sheets(Sheets.Count)\n'통합시트 제일 뒤에 복사\nColumns(\"A\").HorizontalAlignment = xlCenter\n'A열 가운데 정렬\nr = 1\n'1행 부터 시작\nDo\n'실행\nIf Split(Cells(r, 1), \" \")(0) =\nSplit\n(Cells(r + 1, 1), \" \")\n(0)\nThen\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nIf i <> 0 Then\n'중복 데이터의 경우\nSet rngArea = Cells(r - i, 1).Resize(i + 1)\n'중복 구역을 변수에 넣음\nCall perform_Merge(rngArea)\n'셀합병하는 하위코드 실행\nEnd If\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nIf IsEmpty(Cells(r + 1, 1)) Then\n'A열 현재행 다음행이 빈셀이면\nSet rngArea = Cells(r - i, 1).Resize(i + 1)\n'중복 구역을 변수에 넣음\nCall perform_Merge(rngArea)\n'셀합병하는 하위코드 실행\nEnd If\nLoop Until Cells(r + 1, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nSet rngArea = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nSub perform_Merge(ByVal rngArea As Range)\n'중복영역을 매개변수로 받음\nDim rngC As Range\n'각 셀을 넣을 변수\nDim strU As String\n'문자를 합쳐갈 변수\nFor Each rngC In rngArea\n'중복영역 각 셀을 순환\nIf strU = \"\" Then\n'strU가 비어 있으면\nstrU = rngC\n'있는 그대로 넣고\nElse\n'strU에 뭔가 입력되었다면\nstrU = strU &\nChr(10)\n& Split(rngC, \" \")(1)\n'문자를 쪼개어 뒤쪽을 합쳐감\nEnd If\nNext rngC\nApplication.DisplayAlerts = False\n'(셀병합시 뜨는) 경고창 일시 중단\nrngArea.Merge\n'중복영역 셀병합\nApplication.DisplayAlerts = False\n'경고창 기능 복원\nrngArea = strU\n'합친 문자를 셀에 넣음\nEnd Sub", "context": "제목이 좀 웃기다. 나누고 셀병합해 합쳐넣기. 하지만, 실제 그런 기능을 하는 코드이다.\n매크로 실행 전                                                   매크로 실행 후 결과\nOption Explicit\nSub split_And_Merge()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngArea As Range\n'중복 영역(Area)을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.Copy after:=Sheets(Sheets.Count)\n'통합시트 제일 뒤에 복사\nColumns(\"A\").HorizontalAlignment = xlCenter\n'A열 가운데 정렬\nr = 1\n'1행 부터 시작\nDo\n'실행\nIf Split(Cells(r, 1), \" \")(0) =\nSplit\n(Cells(r ..."}
{"instruction": "Excel VBA code for: (1745) 폴더내 모든파일 모든시트 특정행 가져오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_All_Rows_In_Folder_1()\nDim varName As Variant\n'시트이름 넣을 배열 변수\nDim strRow As String\n'가져올 행 넣을 변수\nDim strAddr As String\n'행의 주소를 절대주소로 하여 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim rngT As Range\n'각 열이 복사될 위치 넣을 영역변수\nDim c As Long\n'열 개수 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.ClearContents\n'기존데이터 삭제\nstrRow = \"\n3\n\"\n'가져올 행(\n3행\n)을 변수에 넣음\nstrAddr = \"$\" & strRow & \":$\" & strRow\n'가져올 행을 절대($)주소로 변경\n'-------------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'-------------------------------------------------\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더를 선택한 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'-------------------------------------\n' 폴더내 엑셀파일 유무를 확인하는 코드\n'-------------------------------------\nfileName =\nDir\n(strPath & \"*.xls*\")\n(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 엑셀 파일이 없음.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nvarName = get_Sheet_Names(strPath, fileName)\n'폴더경로와 파일이름 함수로 건넴\nFor c = 1 To\nUBound\n(varName)\n'배열 상한값 만큼 반복\nstrSht = varName(c)\n'시트이름을 변수에 넣음\n'--------------------------------------------------------------\n' 배열수식을 이용하여 데이터 가져오고 수식을 값으로 변환하는 코드\n'--------------------------------------------------------------\nSet rngT = Cells(Rows.Count, \"A\").End(3)(2)\n'각 행의 복사되는 기준위치를 변수에\nrngT.Formula = \"=\nCOUNTA\n('\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & strAddr & \")\"\n'3행의 데이터 개수를 찾아 변수에 넣음\nIf rngT > 0 Then\n'행에 데이터가 존재할 경우\nWith rngT.Offset(, 2).Resize(1, rngT.Value)\n'각 행의 데이터\n.\nFormulaArray\n= \"='\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & Cells(strRow, 1).Resize(, rngT.Value).Address(1, 1, 1)\n'데이터 영역을 배열 이용하여 가져옴\n.Value = .Value\n'셀의 수식을 값으로 바꿈\nEnd With\nEnd If\nrngT = fileName\n'1열에 파일 이름을 넣음\nrngT.Offset(, 1) = varName(c)\n'시트 이름을 2열에 넣음\nNext c\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nColumns.AutoFit\n'열너비 자동 맞춤\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub\n\nPrivate Function get_Sheet_Names\n(ByVal strPath As String, ByVal fileName As String)\n'파일 열지 않고 시트명만 가져오는 코드\n'----------------------------------------------\n'Microsoft ActiveX Data Objects 2.8 Library 참조\n'Microsoft ADO Ext. 2.8 for DDL and Security 참조\n'----------------------------------------------\nDim strConn As ADODB.Connection\nDim ctlg As ADOX.Catalog\nDim tbl As ADOX.Table\nDim r As Long\nDim varShtName()\nSet strConn = New ADODB.Connection\nstrConn.Open \"Provider=MSDASQL.1;Data Source=Excel Files;\" _\n& \"Initial Catalog=\" & strPath & fileName\nSet ctlg = New ADOX.Catalog\nSet ctlg.ActiveConnection = strConn\nFor Each tbl In ctlg.Tables\nr = r + 1\nReDim Preserve varShtName(1 To r)\nvarShtName(r) = Left(tbl.Name, Len(tbl.Name) - 1)\nNext tbl\nSet ctlg = Nothing\nstrConn.Close\nSet strConn = Nothing\nget_Sheet_Names = varShtName\nEnd Function", "context": "아래의 코드는 엑셀 파일들이 한 폴더내에 저장되어 있는 상황에서, 그\n파일들을 열고닫지 않고\n, ADOX.Table의 table이름을 이용하여 파일내의 모든 시트명을 추출하고, 그 추출한 파일명과 배열함수 기능을 이용하여,\n폴더내 모든파일 모든시트 특정\n행\n을 가져오는 기능\n을 한다. 아래의 코드는 3행을 가져온다. 자신의 데이터에 맞추어 가져올 행 이름으로 수정하여 사용하면 된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1745) 폴더내 모든파일 모든시트 특정행 가져오기 (엑셀 VBA 매크로)\n재생\n2,438\n공유하기\n재생 (space/k)\n재생\n00:43\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:43\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기..."}
{"instruction": "Excel VBA code for: (1746) S자 형으로 데이터 채우기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_S_Shape_1()\nDim r As Long\n'행 1씩 늘려갈 변수\nDim c As Integer\n'열방향 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'2행부터 시작\nDo\n'실행\nFor c = 4 To 9 Step 2\n'4부터 2씩 증가하며 3회 반복\nCells(Rows.Count, c).End(3)(2).Resize(, 2) = _\nCells(r, 1).Resize(, 2).Value\n'종단셀 윗방향 2셀에 값을 입력\nr = r + 1\n'행을 1씩 늘려감\nNext c\nFor c = 8 To 3 Step -2\n'8부터 2씩 감소하며 3회 반복\nCells(Rows.Count, c).End(3)(2).Resize(, 2) = _\nCells(r, 1).Resize(, 2).Value\n'종단셀 윗방향 2셀에 값을 입력\nr = r + 1\n'행을 1씩 늘려감\nNext c\nLoop Until IsEmpty(Cells(r, 1))\n'빈행 나올때까지 무한 반복\nEnd Sub\n\nSub delete_Data()\nRange(\"D1\").CurrentRegion.Offset(1).ClearContents\n'D1 연결영역 1행 건너뛰고 삭제\nEnd Sub", "context": "A:B열의 데이터를 E:I열에 S자 모양으로 채우는 기능. 이런 독특한 모양으로 데이터 채우는 것을 연습하다 보면 셀 영역에 대한 이해도가 높아진다.\n매크로 실행 전\n​\n매크로 실행 후 결과\nOption Explicit\nSub fill_S_Shape_1()\nDim r As Long\n'행 1씩 늘려갈 변수\nDim c As Integer\n'열방향 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'2행부터 시작\nDo\n'실행\nFor c = 4 To 9 Step 2\n'4부터 2씩 증가하며 3회 반복\nCells(Rows.Count, c).End(3)(2).Resize(, 2) = _\nCells(r, 1).Resize(, 2).Value\n'종단셀 윗방향 2셀에 값을 입력\nr = r + 1\n'행을 1씩 늘려감\nNext c\nFor c = 8 To 3 Step -2\n'8부터 2씩 감소하며 3회 반복\nCells(Rows.Count, c..."}
{"instruction": "Excel VBA code for: (1747) S자 형으로 데이터 채우기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_S_Shape_2()\nDim rngC As Range\n'복사될 위치 넣을 변수\nDim r As Long\n'행 1씩 늘려갈 변수\nDim c As Integer\n'열방향 늘려갈 변수\n​\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'2행부터 시작\nc = 1\n'열방향 1부터 시작\nSet rngC = Cells(2, 2)\n'B2열 기준으로\nDo\nIf c = 4 Then\n'4번째 열이면\nr = r + 3\n'3행을 추가\nc = 1\n'1열로 초기화\nSet rngC = rngC.Offset(2, -6)\n'아래두칸, 왼쪽 6칸 위치로\nEnd If\nSet rngC = rngC.Offset(, 2)\n'오른쪽으로 2열 이동\nrngC.Resize(, 2) = Cells(r, 1).Resize(, 2).Value\n'설정된 위치에 2셀값 뿌림\nc = c + 1\n'열을 1씩 늘려감\nr = r + 1\n'행을 1씩 늘려감\nLoop Until\nIsEmpty(Cells(r, 1))\n'빈셀 나올때까지 무한 반복\nr = 5\nc = 1\nSet rngC = Cells(3, 10)\nDo\nIf c = 4 Then\nr = r + 3\nc = 1\nSet rngC = rngC.Offset(2, 6)\nEnd If\nSet rngC = rngC.Offset(, -2)\nrngC.Resize(, 2) = Cells(r, 1).Resize(, 2).Value\nc = c + 1\nr = r + 1\nLoop Until\nIsEmpty\n(Cells(r, 1))\nEnd Sub\n\nSub delete_Data()\nRange(\"D1\").CurrentRegion.Offset(1).ClearContents\n'D1 연결영역 1행 건너뛰고 삭제\nEnd Sub", "context": "A:B열의 데이터를 E:I열에 S자 모양으로 채우는 기능. 이번에는 왼쪽에서 오른쪽으로 데이터 입력하는 행과, 오른쪽에서 왼쪽으로 입력하는\n행을 구분하여 채우는 방법\n으로 해봤다.\n매크로 실행 전\n​\n매크로 실행 후 결과\nOption Explicit\nSub fill_S_Shape_2()\nDim rngC As Range\n'복사될 위치 넣을 변수\nDim r As Long\n'행 1씩 늘려갈 변수\nDim c As Integer\n'열방향 늘려갈 변수\n​\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'2행부터 시작\nc = 1\n'열방향 1부터 시작\nSet rngC = Cells(2, 2)\n'B2열 기준으로\nDo\nIf c = 4 Then\n'4번째 열이면\nr = r + 3\n'3행을 추가\nc = 1\n'1열로 초기화\nSet rngC = rngC.Offset(2, -6)\n'아래두칸, 왼쪽 6칸 위치로\nEnd If\nSet rngC = rngC.Of..."}
{"instruction": "Excel VBA code for: (1749) S자 형으로 데이터 채우기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_S_Shape_5()\nDim blnTF As Boolean\n'참거짓 넣을 변수\nDim rngC As Range\n'복사될 위치 넣을 변수\nDim r As Long\n'행 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'2행부터 시작\nSet rngC = Range(\"B2\")\n'시작영역을 변수에\nDo\nIf rngC.Column = 8 And blnTF =\nFalse\nThen\n'8번째열이고 거짓일때\nSet rngC = rngC.Offset(1)\n'아래로 1칸 건너뜀\nblnTF = True\n'참거짓은 거짓으로 (방향전환)\nElseIf rngC.Column = 4 And blnTF =\nTrue\nThen\n'8번째열이고 거짓일때\nSet rngC = rngC.Offset(1)\n'아래로 1칸 건너뜀\nblnTF = False\n'참거짓은 거짓으로 (방향전환)\nElseIf blnTF = False Then\n'거짓이면\nSet rngC = rngC.Offset(, 2)\n'오른쪽으로 2칸 건너뜀\nElseIf blnTF = True Then\n'참이면\nSet rngC = rngC.Offset(, -2)\n'왼쪽으로 2칸 건너뜀\nEnd If\nrngC.Resize(, 2) = Cells(r, 1).Resize(, 2).Value\n'각 구역에 값 입력\nr = r + 1\n'행을 1씩 늘려감\nLoop Until\nIsEmpty(Cells(r, 1))\n'무한반복\nEnd Sub\n\nSub delete_Data()\nRange(\"D1\").CurrentRegion.Offset(1).ClearContents\n'D1 연결영역 1행 건너뛰고 삭제\nEnd Sub", "context": "A:B열의 데이터를 E:I열에 S자 모양으로 채우는 기능.\nBoolean을\n이용한 로직\n으로 데이터가 복사될 영역을 순차적으로 선택한 후 값을 채우는 방식을 해봤다.\n매크로 실행 전\n​\n매크로 실행 후 결과\nOption Explicit\nSub fill_S_Shape_5()\nDim blnTF As Boolean\n'참거짓 넣을 변수\nDim rngC As Range\n'복사될 위치 넣을 변수\nDim r As Long\n'행 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'2행부터 시작\nSet rngC = Range(\"B2\")\n'시작영역을 변수에\nDo\nIf rngC.Column = 8 And blnTF =\nFalse\nThen\n'8번째열이고 거짓일때\nSet rngC = rngC.Offset(1)\n'아래로 1칸 건너뜀\nblnTF = True\n'참거짓은 거짓으로 (방향전환)\nElseIf rngC.Column = 4 And b..."}
{"instruction": "Excel VBA code for: (1750) S자 형으로 데이터 채우기 6 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_S_Shape_6()\nDim rngTop As Range\n'윗쪽데이터행 기준영역\nDim rngBottom As Range\n'아래쪽데이터행 기준영역\nDim rngC As Range\n'복사될 위치 넣을 변수\nDim r As Long\n'행 1씩 늘려갈 변수\nDim c As Integer\n'열을 1씩 늘려갈 변수\nDim lastR As Long\n'마지막 행을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastR = Cells(Rows.Count, \"A\").End(3).Row\n'마지막행을 변수에\nr = 1\n'1행부터 시작\nSet\nrngTop\n= Range(\"A2:B4\")\n'윗쪽데이터행 기준영역\nSet\nrngBottom\n= Range(\"A7, B7, A6, B6, A5, B5\")\n'아래쪽데이터행 기준영역\nDo\nc = 4\n'4열부터 시작\nr = r + 1\n'행을 1씩 늘려감\nFor Each rngC In rngTop\n'윗쪽 데이터행 각셀 순환\nCells(Rows.Count, c).End(3)(2) = rngC\n'종단셀 윗방향으로 올라가 값 입력\nc = c + 1\n'열을 1씩 늘려감\nIf r > lastR Then Exit Sub\n'마지막 행보다 크면 종료\nNext rngC\nc = 4\nr = r + 1\nSet rngTop = rngTop.Offset(6)\nFor Each rngC In rngBottom\n'아래쪽 데이터행 각셀 순환\nCells(Rows.Count, c).End(3)(2) = rngC\nc = c + 1\nIf r > lastR Then Exit Sub\nNext rngC\nSet rngBottom = rngBottom.Offset(6)\nLoop\nEnd Sub\n\nSub delete_Data()\nRange(\"D1\").CurrentRegion.Offset(1).ClearContents\n'D1 연결영역 1행 건너뛰고 삭제\nEnd Sub", "context": "A:B열의 데이터를 E:I열에 S자 모양으로 채우는 기능. 좌에서 우로 데이터가 입력될 행과, 우에서 좌로 데이터가 입력될 행을 구분하여 입력하는 방법으로 해봤다.\n매크로 실행 전\n​\n매크로 실행 후 결과\nOption Explicit\nSub fill_S_Shape_6()\nDim rngTop As Range\n'윗쪽데이터행 기준영역\nDim rngBottom As Range\n'아래쪽데이터행 기준영역\nDim rngC As Range\n'복사될 위치 넣을 변수\nDim r As Long\n'행 1씩 늘려갈 변수\nDim c As Integer\n'열을 1씩 늘려갈 변수\nDim lastR As Long\n'마지막 행을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastR = Cells(Rows.Count, \"A\").End(3).Row\n'마지막행을 변수에\nr = 1\n'1행부터 시작\nSet\nrngTop\n= Range(\"A2:B4\")\n'윗쪽데이터행 ..."}
{"instruction": "Excel VBA code for: (1751) S자 형으로 데이터 채우기 7 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_S_Shape_7()\nDim lastR As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'행 1씩 늘려갈 변수\nDim rngArea As Range\n'선택영역을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim j As Long\n'반복구문에 사용할 변수\nDim c As Long\n'열을 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nIf Selection.Areas.Count <> 6 Then\n'영역선택 오류시\nMsgBox \"영역선택 오류\", vbExclamation\n'메시지창 출력\nExit Sub                                                  '매크로 중단\nEnd If\nlastR = Cells(Rows.Count, \"A\").End(3).Row + 6\n'마지막행 + 6(마지막 데이터용)을 변수에\nr = 2\n'2행부터 시작\nSet rngArea =\nSelection\n'선택영역을 변수에\nDo\nFor i = 1 To 2\n'2회 반복\nFor j = 4 To 9 Step 2\n'2씩 건너뛰며 3회 반복\nc = c + 1\n'열을 1씩 늘려감\nCells(Rows.Count, j).End(3)(2).Resize(, 2) = _\nrngArea.Areas(c).Value\n'종단셀 윗방향으로 올라가 값 입력\nr = r + 1\n'행을 1씩 늘려감\nIf r > lastR Then Exit Sub\n'마지막 행보다 크면 종료\nNext j\nNext i\nc = 0\n'재사용 위하여 초기화\nSet rngArea = rngArea.Offset(6)\n'6행 아래로 건너뜀\nLoop\nEnd Sub\n\nSub delete_Data()\nRange(\"D1\").CurrentRegion.Offset(1).ClearContents\n'아래쪽 데이터행 각셀 순환\nEnd Sub", "context": "A:B열의 데이터를 E:I열에 S자 모양으로 채우는 기능.\n데이터를 Ctrl + 마우스로 영역 선택\n하여 입력하는 방법으로 해봤다.\n매크로 실행 전\n​\n매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1751) S자 형으로 데이터 채우기 7 (엑셀 VBA 매크로)\n재생\n119\n공유하기\n재생 (space/k)\n재생\n00:17\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:17\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 ..."}
{"instruction": "Excel VBA code for: (1752) 폴더내 특정시트 특정데이터 가져오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub Bring_Data_In_Folder()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim strSht As String\n'시트 이름을 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nstrPath = Range(\"F1\") & \"\\\"\n'폴더 경로를 변수에 넣음\nstrSht = Range(\"F2\")\n'데이터가 저장된 시트의 이름\nfileName =\nDir\n(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nr = 6\n'6행부터 시작\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nCells(r, 2) = fileName\n'파일이름 입력\nWith Cells(r, 3)\n'C열 데이터 위치\n.Value = \"='\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & Range(\"C3\")\n'데이터를 수식으로 가져옴\n.Value = .Value\n'셀의 수식을 값으로 바꿈\nEnd With\nWith Cells(r, 4)\n'D열 데이터 위치\n.Value = \"='\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & Range(\"D3\")\n'데이터를 수식으로 가져옴\n.Value = .Value\n'셀의 수식을 값으로 바꿈\nEnd With\nr = r + 1\n'행 1씩 늘려감\nfileName =\nDir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub\n\nSub delete_Data()\nActiveSheet.UsedRange.Offset(5).ClearContents\n'데이터삭제\nEnd Sub", "context": "폴더내 특정시트 특정데이터 2개를 가져오는 기능.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1752) 폴더내 특정시트 특정데이터 가져오기 (엑셀 VBA 매크로)\n재생\n4,061\n공유하기\n재생 (space/k)\n재생\n00:56\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:56\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n시트내에 가져올 파일들이 있는 경로, 시트이..."}
{"instruction": "Excel VBA code for: (1753) 일치하는 데이터 선 연결하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub add_Connector()\nDim rngL As Range\n'왼쪽 영역을 넣을 변수\nDim rngR As Range\n'오른쪽 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each rngL In Range(\"A1:A10\")\n'왼쪽영역 각 셀을 순환\nFor Each rngR In Range(\"D1:D10\")\n'오른쪽영역 각 셀을 순환\nIf rngL = rngR Then\n'두 값이 일치하면\nActiveSheet.\nShapes\n.AddConnector(msoConnectorStraight, _\nrngL.Offset(, 1).Left, rngL.Offset(, 1).Top + rngL.Height / 2, _\nrngR.Left, rngR.Top + rngR.Height / 2).Select\n'(왼쪽 일치한셀) 오른쪽 셀의 왼쪽, 오른쪽셀의 위쪽 + 오른쪽셀 높이의 반,\n'(오른쪽 일치한셀) 왼쪽, 일치한셀 위쪽 + 일치한셀 높이의 반 위치에 선 연결\nEnd If\nNext rngR\nNext rngL\nEnd Sub\n\nSub delete_Connector()\nDim shp As\nShape\n'도형을 넣을 변수\nFor Each shp In ActiveSheet.Shapes\n'현재시트 각 도형을 순환\nIf shp.Name <> \"Run Macro\" Then\n'도형이 매크로버튼 이름이 아니면\nshp.Delete\n'도형 삭제\nEnd If\nNext shp\nEnd Sub", "context": "장난삼아 한 번 해봤는데 너무 쉽게 되어 그냥 올려 둔다.\n매크로 실행 전\n​\n매크로 실행 후 결과\nOption Explicit\nSub add_Connector()\nDim rngL As Range\n'왼쪽 영역을 넣을 변수\nDim rngR As Range\n'오른쪽 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each rngL In Range(\"A1:A10\")\n'왼쪽영역 각 셀을 순환\nFor Each rngR In Range(\"D1:D10\")\n'오른쪽영역 각 셀을 순환\nIf rngL = rngR Then\n'두 값이 일치하면\nActiveSheet.\nShapes\n.AddConnector(msoConnectorStraight, _\nrngL.Offset(, 1).Left, rngL.Offset(, 1).Top + rngL.Height / 2, _\nrngR.Left, rngR.Top + rngR.Height / 2).Sel..."}
{"instruction": "Excel VBA code for: (1755) 특정 단어 넣어 단어 무작위(랜덤) 추출 (엑셀 VBA 매크로)", "input": "", "output": "Sub mix_And_Join_Words_Randomly_2()\nDim intNo As Integer\n'추출할 문자 개수\nDim lngR As Long\n'생성할 데이터 개수(R)ow 넣을 변수\nDim varData\n'A열의 데이터(Data) 넣을 변수\nDim varTemp()\n'섞지 않은 값을 넣을 임시(Temp)orary 배열\nDim varR()\n'결과(R)esult 값을 넣을 결과배열\nDim y As Long\n'생성할 데이터 개수만큼 반복할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim j As Long\n'반복구문에 사용할 변수\nDim strU As String\n'문자를 합쳐갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlngR = Range(\"D2\")\n'생성할 데이터의 개수\nintNo = Range(\"E2\")\n''특정1'포함 무작위 추출한 문자 개수\nReDim\nvarData(1 To Cells(Rows.Count, \"A\").End(3).Row)\n'A열 데이터 개수크기로\nReDim varTemp(1 To lngR, 1 To intNo)\n'임시배열의 크기 재지정\nReDim varR(1 To lngR, 1 To 1)\n'결과배열의 크기 재지정\nFor y = 1 To lngR\n'데이터 개수만큼 반복\nFor i = 1 To Cells(Rows.Count, \"A\").End(3).Row\n'A열 데이터 개수만큼 반복\nvarData(i) = Cells(i, 1)\n'데이터배열에 순차적 값을 넣음\nNext i\nRandomize\n'랜덤 발생기 초기화\nvarTemp(y, 1) = Range(\"B1\")\n'임시배열 첫 번째에 B1값을 넣음\n​\nFor i = intNo + 1 To 3 Step -1\n'제일 큰 열에서 부터 1씩 빼며 반복\nj = Int(\nRnd\n* i) + 1\n'무작위 값을 추출\nvarTemp(y, i - 1) = varData(j)\n'임시배열에 순차적으로 값을 넣음\nvarData(j) = varData(i)\n'데이터 배열의 무작위 위치에 제일 뒷값 넣음\nNext i\nNext y\nFor y = 1 To lngR\n'데이터 개수만큼 반복\nFor i = intNoTo 1 Step -1\n'제일 큰 열에서 부터 1씩 빼며 반복\nj = Int(Rnd * i) + 1\n'무작위 값을 추출\nstrU = varTemp(y, j)\n'무작위 위치의 데이터를 임시로 넣어둠\nvarTemp(y, j) = varTemp(y, i)\n'임시배열내의 제일 뒷값을 무작위 위치에 넣음\nvarTemp(y, i) = strU\n'무작위로 얻은 값을 제일 뒤에 넣음\nNext i\nstrU = \"\"\n'재사용 위하여 초기화\nFor i = 1 To  intNo\n'단어개수 만큼 반복\nIf strU = \"\" Then\n'비어 있을 경우\nstrU = varTemp(y, i)\n'배열의 값을 넣음\nElse\n'비어 있지 않으면\nstrU = strU & \" \" & varTemp(y, i)\n'기존 문자 + 배열문자\nEnd If\nNext i\nvarR(y, 1) = strU\n'배열에 합쳐진 문자 넣음\nNext y\nCells(1, 3).Resize(lngR) = varR\n'배열내 값을 셀에 뿌림\nColumns(\"C\").AutoFit\n'C열 열너비 자동맞춤\nEnd Sub", "context": "1. 추출할 행의 개수 및 단어개수(A열 데이터 개수 미만) 입력하고 매크로 실행.\n2. 아래 예제는, A영역의 20개 단어 중 4개 무작위 추출\n3. B영역의 특정단어는 항시 포함, 총 5개의 단어 나열.\n매크로 실행 전\n매크로 실행 후 결과\n특정 단어가 2개 들어간 경우는 첨부한 \"특정단어2개.xlsm\"파일 참조\nOption Explicit\nSub mix_And_Join_Words_Randomly_2()\nDim intNo As Integer\n'추출할 문자 개수\nDim lngR As Long\n'생성할 데이터 개수(R)ow 넣을 변수\nDim varData\n'A열의 데이터(Data) 넣을 변수\nDim varTemp()\n'섞지 않은 값을 넣을 임시(Temp)orary 배열\nDim varR()\n'결과(R)esult 값을 넣을 결과배열\nDim y As Long\n'생성할 데이터 개수만큼 반복할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim j As Long\n'반복구문에 사용할..."}
{"instruction": "Excel VBA code for: (1756) 일치하는 패턴 찾아 색칠하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Matching_Pattern()\nDim blnTF As Boolean\n'초록/파랑 색 번갈아가며 바꿀 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim c As Integer\n'열(c)olumn 늘려갈 변수\nDim y As Long\n'y축(즉 행)방향 일치하는 수 넣을 변수\nDim x As Long\n'x축(즉 열)방향 6회 반복할 변수\nDim cnt As Integer\n'카운터(일치하는 행의 개수)로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor c = 1 To 4\n'열방향 4회 반복\nblnTF = False\n'참/거짓 시작을 거짓으로\nr = 2\n'2행부터 시작\nDo\n'실행\nIf Cells(r, c) = Cells(4, 6) Then\n'셀값이 '찾을 패턴'의 첫 셀값과 일치하면\nFor x = 1 To 6\n'6회 반복\ny = y + 1\n'y축 방향 즉, 행 일치횟수 더해감\nIf Cells(r + y, c) = Cells(4 + y, 6) Then\n'반과 찾을 패턴이 일치하면\ncnt = cnt + 1\n'카운터를 늘려감\nEnd If\nIf cnt = 6 Then\n'카운터가 6 즉, 6회 모두 일치시\nblnTF = Not blnTF\n'초록/파랑 색 참/거짓을 뒤바꿈\nWith Cells(r, c).Resize(7).Interior\n'7개 열의 내부\nIf blnTF = False Then\n'blnTF가 거짓이면\n.ColorIndex = 3\n'초록색\nElse\n'blnTF가 참이면\n.ColorIndex = 4\n'빨간색\nEnd If\nEnd With\ncnt = 0\n'카운터 재사용 위하여 초기화\nExit For\n'For 구문 탈출\nEnd If\nNext x\ny = 0\n'반복횟수에 사용한 y값 초기화\ncnt = 0\n'카운터 초기화\nEnd If\nr = r + 1\n'행을 1씩 늘려감\nLoop Until\nIsEmpty\n(Cells(r, c))\n'각 열에서 빈셀 나올때까지 무한 반복\nNext c\nEnd Sub\n\nSub delete_Color()\nRange(\"A1\").CurrentRegion.Offset(1).Interior.Color = xlNone\n'색칠 삭제\nEnd Sub", "context": "1. '찾을 패턴'과 일치하는 데이터를 찾음.\n2. 찾은 영역을 초록색과 빨간색으로 번갈아 가면서 색칠\n(아래 C열의 경우 C5:C11, C7:C13, C9:C15 영역의 패텬이 일치하는 것임)\n매크로 실행 전\n​\n매크로 실행 후 결과\nOption Explicit\nSub find_Matching_Pattern()\nDim blnTF As Boolean\n'초록/파랑 색 번갈아가며 바꿀 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim c As Integer\n'열(c)olumn 늘려갈 변수\nDim y As Long\n'y축(즉 행)방향 일치하는 수 넣을 변수\nDim x As Long\n'x축(즉 열)방향 6회 반복할 변수\nDim cnt As Integer\n'카운터(일치하는 행의 개수)로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor c = 1 To 4\n'열방향 4회 반복\nblnTF = False\n'참/거짓 시작을..."}
{"instruction": "Excel VBA code for: (1757) 엑셀파일 년도 업데이트 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub update_Year_1()\nDim wks As Worksheet\n'각 시트를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nFor Each wks In ActiveWorkbook.Worksheets\n'활성화된 파일의 각 시트를 순환\nWith wks.Range(\"A1\")\n'A1셀의\n.\nValue\n= 2020 &\nRight\n(.Value, Len(.Value) - 4)\n'값을 2020 + 나머지 날짜로 넣음\nEnd With\nNext wks\nMsgBox \"완료되었습니다.\"                                            '종료 메시지 출력\nEnd Sub", "context": "매년 년초에 이런 코드를 요청하는 사람들이 많은데 지식인에 요청하는 분이 있어 만들어 보았습니다.\n1. 다수의 시트 A1셀에 2018년으로 된 데이터가 있음.\n2. 모든 시트의 A1셀 년도를 2020년으로 업데이트.\n매크로 실행 전 Sheet1                                          매크로 실행 전 Sheet2\n​\n매크로 실행 전 Sheet3                                          매크로 실행 전 Sheet4\n-------------------------------------------------------------------------------------------\n매크로 실행 후 Sheet1 결과                                   매크로 실행 후 Sheet2 결과\n매크로 실행 후 Sheet3 결과                                    매크로 실행 후 Shee..."}
{"instruction": "Excel VBA code for: (1758) 엑셀파일 년도 업데이트 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub update_Year_2()\nDim wks As Worksheet\n'각 워크(w)or(k)시트(s)heet를 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 순환 시 사용할 영역(r)a(ng)e 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nFor Each wks In ActiveWorkbook.Worksheets\n'활성화된 파일의 각 시트를 순환\nFor Each rngC In wks.UsedRange\n'각 시트 사용영역 각 셀을 순환\nWith rngC\n'각 셀의\nIf Left(.Value, 4) = \"2019\" Then\n'왼쪽 4자리가 2019이면\n.\nValue\n= 2020 &\nRight\n(.Value,\nLen\n(.Value) - 4)\n'값을 2020 + 나머지 날짜로 넣음\nEnd If\nEnd With\nNext rngC\nNext wks\nMsgBox \"완료되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "2019년으로 된 날짜\n데이터만 2020년으로 업데이트\n하는 기능. 생각해보니 내년초에도 예외 없이 A1셀이 아닌 전체 파일내의 2019를 2020으로 바꿔달라고 할 분들이 있을 것으로 생각되어, 전체 파일에 적용되도록 해보았다. 이러니까 올해도 벌써 며칠 안남은 느낌.^^\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1758) 엑셀파일 년도 업데이트 2 (엑셀 VBA 매크로)\n재생\n323\n공유하기\n재생 (space/k)\n재생\n00:32\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:32\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음..."}
{"instruction": "Excel VBA code for: (1759) 엑셀파일 년도 업데이트 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub update_Year_2()\nDim wks As Worksheet\n'각 워크(w)or(k)시트(s)heet를 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 순환 시 사용할 영역(r)a(ng)e 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nFor Each wks In ActiveWorkbook.Worksheets\n'활성화된 파일의 각 시트를 순환\nFor Each rngC In wks.UsedRange\n'각 시트 사용영역 각 셀을 순환\nWith rngC\n'각 셀의\nIf Left(.Value, 4) = \"2019\" And\nMid\n(.Value, 5, 1) = \"-\" Then\n'왼쪽 4자리가 2019이고 다섯번째는 \"-\"즉 서식이 년도라면\n.\nValue\n= 2020 &\nRight\n(.Value,\nLen\n(.Value) - 4)\n'값을 2020 + 나머지 날짜로 넣음\nEnd If\nEnd With\nNext rngC\nNext wks\nMsgBox \"완료되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "2019년으로 된 날짜\n데이터만 2020년으로 업데이트\n하는 기능. 생각해보니 셀에 숫자 201930 또는 문자 '2019회 작업' 등과 같이 왼쪽 4자리가 2019로 시작하는 셀들이 있을 수 있어 앞서 올린 코드를 일부 수정함. 즉, 2019로 시작하는 날짜 데이터에만 적용되도록 함.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1759) 엑셀파일 년도 업데이트 3 (엑셀 VBA 매크로)\n재생\n195\n공유하기\n재생 (space/k)\n재생\n00:30\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:30\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요..."}
{"instruction": "Excel VBA code for: (1760) 엑셀파일 년도 업데이트 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub update_Year_2()\nDim wks As Worksheet\n'각 워크(w)or(k)시트(s)heet를 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 순환 시 사용할 영역(r)a(ng)e 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nFor Each wks In ActiveWorkbook.Worksheets\n'활성화된 파일의 각 시트를 순환\nFor Each rngC In wks.UsedRange\n'각 시트 사용영역 각 셀을 순환\nWith rngC\n'각 셀의\nIf\nLen\n(.Value) > 7 Then\n'셀의 값이 7자 이상일 경우\nIf\nLeft\n(.Value, 4) = \"2019\" Then\n'왼쪽 4자리가 2019이면\nIf\nMid\n(.Value, 5, 1) = \"-\" Or Mid(.Value, 5, 1) = \"/\" Or _\nMid(.Value, 5, 1) = \"년\" Or Mid(.Value, 5, 1) = \"年\" Then\n' 다섯번째는 \"-\"즉 서식이 년도 또는 문자 /, 년, 年 이라면\n'                            If IsNumeric(Mid(.Value, 7, 1)) Then\n'왼쪽 7번째 자리가 숫자라면\n.Value = 2020 &\nRight\n(.Value, Len(.Value) - 4)\n'값을 2020 + 나머지 날짜로 넣음\n'                            End If\nEnd If\nElseIf Right(.Value, 4) = \"2019\" And _\nMid(.Value, Len(.Value) - 4, 1) = \" \" Then\n'오른쪽 4자리가 2019이고, 오른쪽 5번째가 공백이면\n.Value = Left(.Value, Len(.Value) - 4) & 2020\n'오른쪽 4자리만 2020 으로 바꿔 넣음\nEnd If\nEnd If\nEnd With\nNext rngC\nNext wks\nMsgBox \"완료되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "2019년으로 된 날짜\n데이터만 2020년으로 업데이트\n하는 기능. 생각해보니, 날짜를 날짜서식이 아닌 문자로 입력하는 경우가 있을 수 있어서 코드를 또 다시 업데이트함. 간단하게 생각했는데, 이것 저것 생각할게 많음. 왠지, 다른 경우의 수가 또 있을 것만 같지만 우선은 올려둠.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1760) 엑셀파일 년도 업데이트 4 (엑셀 VBA 매크로)\n재생\n465\n공유하기\n재생 (space/k)\n재생\n00:45\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:45\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도..."}
{"instruction": "Excel VBA code for: (1761) 메일머지 예제 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub mail_Merge_Sample_4()\nDim rngAll As Range\n'B열 전체(All) 데이터 영역(r)a(ng)e을 넣을 변수\nDim rngC As Range\n'B열 순환시 각 셀(C)ell 영역(r)a(ng)e 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Worksheets(\"발생내역\")\n'발생내역 시트에서\nIf .Range(\"B5\") <> \"\" Then\n'B5셀에 데이터 있으면\nSet rngAll = .Range(\"B5\", .Cells(Rows.Count, \"B\").End(3))\n'B5 셀부터 B열 마지막 셀까지 변수에\nSet rngAll = rngAll.SpecialCells(\nxlCellTypeVisible\n)\nFor Each rngC In rngAll\n'전체이름 1개씩 순환\nRange(\"A10\") = rngC\n'A10셀에 이름 순환 입력\nActiveSheet.\nPrintPreview\n'현재(명세서)시트 화면인쇄\n'               ActiveSheet.\nPrintOut\n'현재(명세서)시트 실제인쇄\nNext rngC\nMsgBox \"인쇄가 완료되었습니다.\"\n'인쇄 완료 메시지 출력\nElse\n'B5셀이 비어 있으면\nMsgBox \"인쇄목록 시트에 데이터가 없습니다.\", vbExclamation\nEnd If\n'데이터 없음 메시지 출력\nEnd With\n'필터링된 뒤 화면에 보이는 데이터만 변수에\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "예전에 여러번 해봤던 메일 머지(mail merge) 기능. 즉,\n동일한 내용에 제목, 이름, 날짜 또는 금액 등을 바꿔가면서 인쇄를 하는 기능\n. 초대장, 월급명세 또는 청첩장 등에서 자주 사용하는 기능.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1761) 메일머지 예제 5 (엑셀 VBA 매크로)\n재생\n1,808\n공유하기\n재생 (space/k)\n재생\n00:55\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:55\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능..."}
{"instruction": "Excel VBA code for: (1762) 메일머지 예제 6 (엑셀 VBA 매크로)", "input": "", "output": "Sub mail_Merge_Sample_5()\nDim rngAll As Range\n'B열 전체(All) 데이터 영역(r)a(ng)e을 넣을 변수\nDim rngC As Range\n'B열 순환시 각 셀(C)ell 영역(r)a(ng)e 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Worksheets(\"Data\")\n'Data 시트에서\nIf .Range(\"B2\") <> \"\" Then\n'B2셀에 데이터 있으면\nSet rngAll = .Range(\"B2\", .Cells(Rows.Count, \"B\").End(3))\n'B2 셀부터 B열 마지막 셀까지 변수에\nSet rngAll = rngAll.SpecialCells(\nxlCellTypeVisible\n)\n'화면에 보이는 셀만 변수에\nFor Each rngC In rngAll\n'전체이름 1개씩 순환\nRange(\"C10\") = rngC\n'C10셀에 이름 순환 입력\nActiveSheet.\nPrintPreview\n'현재(Form)시트 화면인쇄\n'               ActiveSheet.\nPrintOut\n'현재(Form)시트 실제인쇄\nNext rngC\nMsgBox \"인쇄가 완료되었습니다.\"\n'인쇄 완료 메시지 출력\nElse\n'B2셀이 비어 있으면\nMsgBox \"인쇄목록 시트에 데이터가 없습니다.\", vbExclamation\nEnd If\n'데이터 없음 메시지 출력\nEnd With\n'필터링된 뒤 화면에 보이는 데이터만 변수에\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "동일한 내용에 제목, 이름, 날짜 또는 금액 등을 바꿔가면서 인쇄를 하는 기능.\n초대장, 월급명세 또는 청첩장 등에서 자주 사용하는 기능. (나는 예전에 엑셀이 없던 DOS시절부터 DM발송시에 독학으로 메일머지(mail merge) 기능을 공부하여 활용했는데, 지금은 막강한 엑셀의 기능과 이렇게 많은 자료와 예제가 있어도 이를 활용하지 못한다면 ... 그러시면 아니되옵니다....)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1762) 메일머지 예제 6 (엑셀 VBA 매크로)\n재생\n2,896\n공유하기\n재생 (space/k)\n재생\n00:50\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:50\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5..."}
{"instruction": "Excel VBA code for: (1763) 그룹별 색으로 구분하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub paint_Every_Other()\nDim colsCnt As Integer\n'사용영역 열 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim blnTF As Boolean\n'참/거짓(색깔 전환)에 사용할 변수\nDim rngArea As Range\n'중복 영역을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n​\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 사용영역 열개수 변수에 넣음\nr = 2\n'2행 부터 시작\n​\nDo\nIf Cells(r, 2) = Cells(r + 1, 2) Then\n'B열이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nSet rngArea = Cells(r - i, 1).Resize(i + 1, colsCnt)\n'중복 구역을 변수에 넣음\nblnTF = Not blnTF\n'색깔 전환\nIf blnTF = False Then\n'blnTF가 거짓이면\nrngArea.Interior.\nColorIndex\n= 6\n'초록색으로 칠함\nElse\n'blnTF가 참이면\nrngArea.Interior.ColorIndex = xlNone\n'색칠하지 않음\nEnd If\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nIsEmpty(Cells(r, 1))\n'A열에 빈셀 나올때까지 무한 반복\nSet rngArea = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nSub delete_Data()\nActiveSheet.UsedRange.Offset(1).EntireRow.Interior.ColorIndex = xlNone\n'색모두 제거\nEnd Sub", "context": "B열을 기준\n으로 값이 달라질 때마다 건너 뛰며\n색으로 칠해주는 기능\n.\n매크로 실행 전                                                            매크로 실행 후 결과\nOption Explicit\nSub paint_Every_Other()\nDim colsCnt As Integer\n'사용영역 열 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim blnTF As Boolean\n'참/거짓(색깔 전환)에 사용할 변수\nDim rngArea As Range\n'중복 영역을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n​\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 사용영역 열개수 변수에 넣음\nr = 2\n'2행 부터 시작\n​\nDo\nIf Cells(r, 2) = C..."}
{"instruction": "Excel VBA code for: (1764) 폴더내 모든파일 특정시트의 복수행 불러오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_Multiple_Rows_In_Folder_1()\nDim strRow As String\n'가져올 열 넣을 변수\nDim strAddr As String\n'행의 주소를 절대주소로 하여 넣을 변수\nDim rngData As Range                                   '\n가져올 데이터 영역 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strSht As String\n'시트 이름을 넣을 변수\nDim rngC As Range\n'각 셀을 순환할 때 사용할 영역 변수\nDim rngT As Range\n'각 열이 복사될 위치 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n'----------------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'----------------------------------------------------\nWith Application..\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더를 선택한 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'-----------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'-----------------------------------\nfileName =\nDir\n(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nstrSht = Range(\"B1\")\n'데이터가 저장된 시트의 이름\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nFor Each rngC In Range(Range(\"B2\"), Cells(2, Columns.Count).End(1))\n'B2부터 오른쪽 열의 각셀 순환\nstrRow = rngC\n'가져올 행을 변수에 넣음\nstrAddr = \"$\" & strRow & \":$\" & strRow\n'가져올 행을 절대주소로 만듬\nSet rngT = Cells(Rows.Count, \"A\").End(3)(2)\n'각 행이 복사되는 기준위치를 변수에\n'--------------------------------------------------------------\n' 배열수식을 이용하여 데이터 가져오고 수식을 값으로 변환하는 코드\n'--------------------------------------------------------------\nrngT.Formula = \"=\nCOUNTA\n('\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & strAddr & \")\"\n'1행의 데이터 개수를 찾아 변수에 넣음\nIf rngT > 0 Then\n'데이터가 있을 경우\nSet rngData = Cells(strRow, 1).Resize(, rngT.Value)\n'가져올 행 주소를 변수에 넣음\nWith rngT.Offset(, 1).Resize(1, rngT.Value)\n'각 행의 데이터\n.\nFormulaArray\n= \"='\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & rngData.\nAddress\n(1, 1, 1)\n'데이터 영역을 배열 이용하여 가져옴\n.Value = .Value\n'셀의 수식을 값으로 바꿈\nEnd With\nEnd If\nrngT = fileName\n'1행에 파일 이름을 넣음\nNext rngC\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nColumns.AutoFit\n'열너비 자동 맞춤\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nSet rngT = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngData = Nothing\nEnd Sub\n\nSub delete_Data()\nActiveSheet.UsedRange.Offset(2).ClearContents\n'기존 데이터 삭제\nEnd Sub", "context": "﻿\n만들거 다 만들었다 생각해도 계속 나온다 ... 아래의 코드는\n폴더내 모든파일 특정시트의 복수행\n(예제에서는 1, 3, 6행)\n을\n파일이름과\n함께\n불러오는 기능\n을 한다.\n1. 폴더내 모든파일 특정시트의\n복수\n행\n불러오기 : 아래코드\n2. 폴더내 모든파일 특정시트의 특정\n행\n불러오기 :\nhttps://blog.naver.com/rosa0189/221487123154\n3. 폴더내 모든파일 특정시트의\n복수열\n불러오기 :\nhttps://blog.naver.com/rosa0189/221473821549\n4. 폴더내 모든파일 특정시트의 특정\n열\n불러오기 :\nhttps://blog.naver.com/rosa0189/60209471570\n5. 폴더내 모든파일 특정시트의 특정\n영역\n불러오기 :\nhttps://blog.naver.com/rosa0189/60211082564\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1764) 폴더내 모든파일 특정시트의..."}
{"instruction": "Excel VBA code for: (1765) 데이터 정리후 빈행 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_Data_And_Delete()\nDim varText\n'삭제할 문자 넣을 배열변수\nDim varEach\n'For Each구문에 사용할 배열변수\nDim r As Long\n'행을 늘려갈 변수\nDim str As String\n'문자를 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nvarText =\nArray\n(\"임대평:\", \"실평:\", \"관리:\", \"건물주:\")\n'삭제할 문자 배열에 넣음\nFor Each varEach In varText\n'배열내 각 값을 순환\nActiveSheet.UsedRange.\nReplace\nvarEach, \"\"\n'일치하는 값을 삭제\nNext varEach\nr = 2\n'2행부터 시작\nDo\n'실행\nIf Cells(r, 2) = \"\" Then\n'B열에 빈셀이 있으면\nCells(r - 1, 1) = Cells(r - 1, 1) & \" \" & Cells(r, 1)\n'아래셀과 공백으로 연결\nCells(r - 1, 3) = Cells(r - 1, 3) & \"/\" & Cells(r, 3)\n'C열 아래셀과 / 으로 연결\nstr = \"'\" & Cells(r - 1, 4) & \"/\" & Cells(r - 1, 5) & \"/\" & Cells(r - 1, 6)\n'D:F열까지 문자 합칩\nWith Application\n'엑셀에서\n.\nDisplayAlerts\n= False\n'(셀합병시 뜨는)경고창 뜨지 않도록 설정\nCells(r - 1, 4).Resize(, 3).\nMerge\n'D:F까지 셀병합\n.DisplayAlerts = True\n'경고창 복원\nEnd With\nCells(r - 1, 4) = str\n'D열에 합친 문자 넣음\nstr = \"\"\n'재사용 위하여 초기화\nCells(r - 1, 7) = Cells(r - 1, 8) & \"/\" & Cells(r - 1, 7)\n'G열에 H열과 G열을 / 과 함께 합쳐 넣음\nCells(r - 1, 8) = Cells(r - 1, 9)\n'H열에 '관리'연락처\nCells(r - 1, 9) = Cells(r, 9)\n'I열에 '건물주'연락처\nEnd If\nr = r + 1\n'행을 1씩 늘려감\nLoop Until\nIsEmpty\n(Cells(r, 1))\n'1열에 빈셀 나올때까지 무한 반복\nFor r = Cells(Rows.Count, \"A\").End(3).Row To 2 Step -1\n'마지막행부터 2행까지 1씩 줄여가며 반복\nIf Cells(r, 2) = \"\" Then\n'B열이 빈셀이면\nCells(r, 2).\nEntireRow\n.Delete\n'전체행 삭제\nEnd If\nNext r\nEnd Sub", "context": "매크로 실행 전\n​\n매크로 실행 후 결과\nOption Explicit\nSub combine_Data_And_Delete()\nDim varText\n'삭제할 문자 넣을 배열변수\nDim varEach\n'For Each구문에 사용할 배열변수\nDim r As Long\n'행을 늘려갈 변수\nDim str As String\n'문자를 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nvarText =\nArray\n(\"임대평:\", \"실평:\", \"관리:\", \"건물주:\")\n'삭제할 문자 배열에 넣음\nFor Each varEach In varText\n'배열내 각 값을 순환\nActiveSheet.UsedRange.\nReplace\nvarEach, \"\"\n'일치하는 값을 삭제\nNext varEach\nr = 2\n'2행부터 시작\nDo\n'실행\nIf Cells(r, 2) = \"\" Then\n'B열에 빈셀이 있으면\nCells(r - 1, 1) = Cells(r - 1..."}
{"instruction": "Excel VBA code for: (1766) 하이퍼링크 이용하여 사진(그림) 삽입하기 (엑셀 VBA 매크로)", "input": "", "output": "Private Sub Worksheet_\nFollowHyperlink\n(ByVal Target As Hyperlink)\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'선택한 파일을 넣을 변수\nDim addr As String\n'셀주소 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nstrPath = ActiveWorkbook.Path & \"\\\"\n'폴더 경로를 변수에 넣음\nfileName =\nTarget\n.Range.Value\n'파일이름을 변수에 넣음\naddr = Target.Range.\nAddress\n(0, 0)\n'셀주소를 변수에 넣음\nIf\nDir\n(strPath & fileName & \".jpg\") = \"\" Then\n'파일 이름이 폴더에 없을 경우\nMsgBox \"일치하는 사진이 없습니다.\", vbCritical\n'에러 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nActiveSheet.Shapes.\nAddPicture\n(strPath & fileName & \".jpg\", 1, 1, 1, 1, 100, 100).Select\n'사진 가져와 선택함.\nWith Selection\n'선택된 사진파일에서\n.ShapeRange.LockAspectRatio = msoFalse\n'가로세로고정비율 해제\n.Left = Range(addr).Left + 2\n'그림왼쪽위치를 현재셀 왼쪽 + 2 위치에\n.Top = Range(addr).Top + 2\n'그림위쪽 위치를 현재셀 윗쪽 + 2 위치에\n.Height = Range(addr).Height - 4\n'그림 높이를 현재셀 -4 크기로\n.Width = Range(addr).Width - 4\n'그림 폭을 현재셀 -4 크기로\nEnd With\nEnd Sub", "context": "아래의 코드는\n하이퍼 링크를 이용하여 사진을 삽입하는 기능\n이다. 왜그런지 모르겠지만, 의외로 많은 사람들이 고정된 위치에, 고정된 이름으로 \"힘겨운\" 방법으로 사진을 삽입하고 있는걸 알게되었다. 그래서, 하이퍼링크를 이용하여 사진(그림) 삽입하는 것을 만들어 보았다.\n매크로 실행 전                                                   매크로 실행 후 결과\n아래의 코드는 하이퍼링크 이벤트를 사용하므로 모듈이 아니라 시트에 들어간다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1766) 하이퍼링크 이용하여 사진(그림) 삽입하기 (엑셀 VBA 매크로)\n재생\n2,877\n공유하기\n재생 (space/k)\n재생\n00:51\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:51\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표..."}
{"instruction": "Excel VBA code for: (1768) 특정시간 선배치 후 무작위로 채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub random_Reshuffle_6()\nDim rngA As Range\n'각 area를 넣을 변수\nDim rowsCnt As Long\n'전체 행의 개수 넣을 변수\nDim colsCnt As Integer\n'전체 열의 개수 넣을 변수\nDim maxNo As Long\n'선택영역 셀 개수 넣을 변수\nDim varTemp()\n'임시배열로 사용할 배열변수\nDim varR()\n'결과 값을 넣을 동적배열 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nDim x As Integer\n'열 방향 늘려갈 변수\nDim y As Long\n'행 방향 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n​\nRange(\"B8:F13\").Select\n'이름영역을 선택\nFor Each rngA In Selection.\nAreas\n'선택영역 각 area를 순환\nRandomize\n'랜덤값 발생기 초기화\n'(계속 새로운 랜덤 기준값 생성)\nWith rngA\n'각 area에서\nrowsCnt = .Rows.Count\n'전체 행 개수를 변수에 넣음\ncolsCnt = .Columns.Count\n'전체 열 개수를 변수에 넣음\nmaxNo = .Count\n'선택영역 셀 개수를 변수에 넣음\nEnd With\nReDim\nvarTemp(1 To maxNo)\n'임시배열의 크기 재지정\nReDim varR(1 To rowsCnt, 1 To colsCnt)\n'결과 열의 크기 재지정\nFor Each rngC In rngA\n'가 area의 각 셀을 순환\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = rngC\n'각 셀을 배열에 넣음\nNext rngC\nFor y = 1 To rowsCnt\n'area 의 행 개수 만큼 반복\nFor x = 1 To colsCnt\n'area의 열 개수 만큼 반복\nr = Int(\nRnd\n() * maxNo) + 1\n'무작위 값을 추출\nvarR(y, x) = varTemp(r)\n'배열에 랜덤값을 채워감\nvarTemp(r) = varTemp(maxNo)\n'배열 윗값을 추출된 위치에 채움\nmaxNo = maxNo - 1\n'전체 셀 개수 1개씩 줄여감\nNext x\nNext y\nrngA = varR\n'결과배열 값을 각 area에 뿌림\nr = 0\n'재사용 위하여 초기화\nNext rngA\nEnd Sub", "context": "1. 30명 5개의 조가 있음\n2. 그 중 몇 명은 개인사정으로 특정시간 작업이 불가능한 시간이 있음.\n3. 윗 사람들을 가능한 시간으로 선배정.\n4. 나머지 사람들은 무작위로 시간 배정\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1768) 특정시간 선배치 후 무작위로 채우기 (엑셀 VBA 매크로)\n재생\n789\n공유하기\n재생 (space/k)\n재생\n00:31\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:31\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영..."}
{"instruction": "Excel VBA code for: (1769) 라벨(메일머지) 인쇄 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub mail_Merge_Sample_6()\nDim r As Long\n'Filter시트 행(r)ow 1씩 늘려갈 변수\nDim x As Integer\n'x축방향 즉 열 2회 반복할 변수\nDim y As Integer\n'y축방향 즉 행 4회 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'2행부터 시작\nDo\n'실행\nActiveSheet.UsedRange.ClearContents\n'Form시트 기존 데이터 삭제\nFor y = 1 To 17\nStep\n5\n'5씩 건너 뛰며 4회 반복\nFor x = 1 To 4 Step 2\n'2씩 건너 뛰며 2회 반복\nWith Sheets(\"Filter\")\n'Filter시트에서\nCells(y, x + 1) = .Cells(r, 1)\n'기수 입력\nCells(y + 1, x) = .Cells(r, 2)\n'기업명 입력\nCells(y + 2, x) = .Cells(r, 3)\n'성명 입력\nCells(y + 3, x + 1) = .Cells(r, 4)\n'직함 입력\nr = r + 1\n'행 1씩 늘려감\nIf\nIsEmpty\n(Sheets(\"Filter\").Cells(r, 1)) Then\n'A열에 빈셀 나오면\nActiveSheet.\nPrintPreview\n'현재(Form)시트 화면인쇄\n'ActiveSheet.\nPrintOut\n'현재(Form)시트 실제인쇄\nExit Do\n'Do구문 종료\nEnd If\nEnd With\nNext x\nNext y\nActiveSheet.\nPrintPreview\n'현재(Form)시트 화면인쇄\n'        ActiveSheet.PrintOut\n'현재(Form)시트 실제인쇄\nLoop Until IsEmpty(Sheets(\"Filter\").Cells(r, 1))\n'Filter시트 A열 빈셀 나올때까지 무한반복\nMsgBox \"인쇄가 완료되었습니다.\"\n'인쇄 완료 메시지 출력\nEnd Sub\n\nSub forward_Filtered_Data()\nDim rngAll As Range\n'A열 전체\n데이터 영역(r)a(ng)e을 넣을 변수\nWith Sheets(\"Filter\")\n'Filter시트에서\n.UsedRange.Offset(1).ClearContents\n'Filter시트 기존 데이터 삭제\nSet rngAll = Range(\"A1\", Cells(Rows.Count, \"B\").End(3))\n'A열 데이터를 변수에 넣음\nSet rngAll = rngAll.Resize(, 4).SpecialCells(\nxlCellTypeVisible\n)\n'보이는 셀만 변수에 넣음\nrngAll.Copy .Range(\"A1\")\n'필터된 데이터 Filter시트 A2에 복사\n.Columns.AutoFit\n'열너비 자동맞춤\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"데이터가 옮겨 졌습니다.\"\nEnd Sub", "context": "﻿\n전형적인 라벨인쇄 기능.\nData시트의 데이터를 필터쳐서 Filter 시트에 보내고 이 Filter시트의 데이터를 Form시트에 번갈아가며 입력하고 인쇄하는 기능. 엑셀에도 레이블인쇄 마법사가 있지만, 아래 기능을 익히면 더 쉽고 편하게 내가 원하는 라벨을 자유자재로 출력할 수 있다.\n제 블로그 들어오시는 분들은 이제 모두 이정도는 손쉽게 다들 하시죠? 너무 쉬워서 따라도 안하시고, 쳐다도 안보시겠죠? 그럴거라 믿으면서 올려봅니다.^^\n매크로 실행 전 Data시트에 있는 데이터                                  매크로 실행 전 Filter시트는 비어있음\n매크로 실행 전 Form 시트. 한 페이지에 8명의 이름을 번갈아 입력하며 인쇄할 예정\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1769) 라벨(메일머지) 인쇄 3 (엑셀 VBA 매크로)\n재생\n1,539\n공유하기\n재생 (space/k)\n재생\n00:43\n0:00..."}
{"instruction": "Excel VBA code for: (1770) 시간 합친 후 행열변환 (엑셀 VBA 매크로)", "input": "", "output": "Sub time_Conversion()\nDim varTime\n'입력시간을 합쳐넣을 배열변수\nDim varC\n'배열 순환시 사용할 배열변수\nDim str As String\n'시간 문자 합쳐넣을 변수\nDim blnTF As\nBoolean\n'콤마 삽입 전환을 위한 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nvarTime = Range(\"A3\", Cells(Rows.Count, \"A\").End(3))\n'A3:A18 영역을 변수에 넣음\nFor Each varC In varTime\n'변수내 각 값을 순환\nblnTF =\nNot\nblnTF\n'참/거짓(콤마 있고 없음) 매회 반전\nIf str = \"\" Then\n'str이 비어 있을 경우\nstr =\nSplit\n(varC, \"=\")\n(0)\n'=이용 문자분리하고 앞 문자를 추출\nElse\n'str에 뭔가 입력되어 있을 경우\nIf blnTF = False Then\n'blnTF가 거짓이면\nstr = str & \"-\" & Split(varC, \"=\")(0)\n'하이픈(-)을 이용하여 문자 연결\nElse\n'blnTF가 참이면\nstr = str & \",\" & Split(varC, \"=\")(0)\n'콤마(,)를 이용하여 문자 연결\nEnd If\nEnd If\nNext varC\nRange(\"B1\") = str\n'B1셀에 추출한 문자를 뿌림\nEnd Sub", "context": "1. 00:01:07=67 처럼 입력된 시간에서 =와 뒤는 버림\n2. 시간시작과 끝은 \"-\"로 연결\n3. 시간구분 분리는 \",\"로 연결\n4. 합친 문자 행열 변환하여 입력\n매크로 실행 전 시간 입출력이 기록된 모습\n​\n매크로 실행 후 결과\n매크로 실행 후 결과\nOption Explicit\nSub time_Conversion()\nDim varTime\n'입력시간을 합쳐넣을 배열변수\nDim varC\n'배열 순환시 사용할 배열변수\nDim str As String\n'시간 문자 합쳐넣을 변수\nDim blnTF As\nBoolean\n'콤마 삽입 전환을 위한 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nvarTime = Range(\"A3\", Cells(Rows.Count, \"A\").End(3))\n'A3:A18 영역을 변수에 넣음\nFor Each varC In varTime\n'변수내 각 값을 순환\nblnTF =\nNot\nblnTF\n'참/거짓(콤마 있..."}
{"instruction": "Excel VBA code for: (1771) 엑셀 다단인쇄 (엑셀 VBA 매크로)", "input": "", "output": "Sub multi_Columns_Print()\nDim intCol As Integer\n'데이터 시트의 데이터 열 개수\nDim intSht1 As Integer\n'데이터 시트의 인덱스\nDim intSht2 As Integer\n'결과 시트의 인덱스\nDim intCnt As Integer\n'사용자가 지정한 열 개수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngPge As Range\n'1페이지 넣을 변수\nDim j As Integer\n'열방향 데이터 열개수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nintCol = Range(\"A1\").CurrentRegion.Columns.Count\n'A1셀 연결영역 열개수를 변수에\nintSht1 = ActiveSheet.\nIndex\n'데이터 시트 인덱스를 변수에\nSheets.\nAdd\nafter:=Sheets(Sheets.Count)\n'제일 뒤에 빈 시트 추가\nintSht2 = ActiveSheet.Index\n'빈 시트 인덱스를 변수에\nSheets(intSht1).Select\n'데이터시트 선택\n'-----------------------------------------------\n'행 높이가 기본이 아닌 사용자 지정 높이일 경우 대비\n'-----------------------------------------------\nCells\n.Copy\n'전체셀 복사\nSheets(intSht2).Cells.PasteSpecial Paste:=\nxlPasteFormats\n'서식 복사\nintCnt = inputbox_Function\n'열 개수 결정하는 하위 함수 호출\nSet rngPge = Range(Range(\"A1\"), _\nActiveSheet.\nHPageBreaks\n(1).\nLocation\n.Offset(-1)).Resize(, intCol)\n'A1에서 첫 페이지 제일 마지막행 A열까지의 영역을 개체변수에 넣음\nFor i = 1 To ActiveSheet.HPageBreaks.Count\nStep\nintCnt\n'페이지 개수만큼 반복\nFor j = 1 To intCnt\n'사용자가 지정한 열 개수만큼 반복\nWith Sheets(intSht2).Cells(Rows.Count, (j - 1) * (intCol + 1) + 1)\n'결과시트 종단셀 윗방향에 rngPge의 행개수, 데이터 열 개수 +1 만큼 늘려감\nIf i = 1 Then\n'첫 페이지 데이터는\n'-------------------------\n'복사될 위치의 열너비 맞춤\n'-------------------------\nCells(1, 1).Resize(, intCol).Copy\n'데이터 (열너비 통일위해\n) 복사\nSheets(intSht2).Cells(Rows.Count, (j - 1) * (intCol + 1) + 1).\nPasteSpecial\nPaste:=\n8\n'결과시트에\n열너비\n복사\nIf j > 1 Then .Offset(, -1).\nColumnWidth = 4\n'공백열의 열 너비 지정\n.End(3).Resize(rngPge.Rows.Count, intCol) = rngPge.Value\n'종단셀 윗방향 제일 윗행에 복사\nElse\n'첫 페이지 이후는\n.End(3)(2).Resize(rngPge.Rows.Count, intCol) = rngPge.Value\nEnd If\n'종단셀 윗방향 바로 아래행에 복사\nEnd With\nSet rngPge = rngPge.Offset(rngPge.Rows.Count)\n'페이지 영역을 1페이지 건너뜀\nNext j\n'--------------------------------------------------\n'아래 코드 삽입하지 않으면 1페이지에서 1행씩 넘어감\n'--------------------------------------------------\nSheets(intSht2).HPageBreaks.Add _\nBefore:=Sheets(intSht2).Cells(Rows.Count, \"A\").End(3)(2)\n'페이지 나누기 삽입\nNext i\nSheets(intSht2).Select\n'결과시트 선택\nSet rngPge = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"데이터 이동이 완료되었습니다.\"\n'메시지창 출력\nEnd Sub\n\nPrivate Function inputbox_Function()\nDim input_Value As String\n'입력값을 넣을 변수\nDim msg As String\n'메시지 넣을 문자 변수\nConst intMin As Integer = 2\n'최솟값을 넣을 변수\nConst intMax As Integer = 10\n'최댓값을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nDo\n'다음을 실행\nOn Error Resume Next\n'취소 눌렀을 때 계속 진행\ninput_Value =\nInputBox\n(intMin & \" 과 \" & intMax & \" 사이의 숫자를 입력.\", , \"숫자만 입력.\")\n'입력창 값을 변수에 넣음\nIf input_Value = \"\" Then\nApplication.\nDisplayAlerts\n= False\n'경고 안함\nSheets(Sheets.Count).Delete\n'생성한 임시시트 삭제\nApplication.DisplayAlerts = True\n'경고 복원\nEnd\n'입력값 없으면 매크로 중단\nEnd If\nOn Error GoTo 0\n'에러 검출기능 초기화\nIf\nIsNumeric\n(input_Value) Then\n'입력값이 숫자이면\nIf input_Value >= intMin And input_Value <= intMax Then\nExit Do\n'입력값이 최솟값보다 크거나 같고, 최댓값보다 작거나 같으면 Do 구문 종료\nEnd If\nEnd If\nmsg = \"번호입력 오류.\" & vbCr & vbCr\n'메시지창 내용 + 줄바꿈 2번\nmsg = msg & intMin & \" 과(와) \" & intMax & \" 사이의 숫자를 입력.\"\n'메시지창 내용\nMsgBox msg, 64, \"입력오류\"\nLoop\n'무한 반복\ninputbox_Function = input_Value                      '입력창 값을 함수로 돌려줌\nEnd Function", "context": "엑셀의 수식 계산은 완벽하다. (하긴, 수식 하나만 오류가 있어도 전세계 금융시작에서 수십조원이 왔다 갔다 할테니 마이크로소프트 소프트웨어 엔지니어들의 스트레스도 장난이 아닐 것이다.)\n하지만, 사진, 서식, 폰트, 도형, 인쇄와 같은 이미지 관련 에러는 상당히 많다. 그러므로, 아래와 같은 코드를 올리는 것은 각 컴퓨터마다, 버전마다 또는 해상도에 따라서 약간씩 오차가 날 수 있어 조심스럽지만, 그래도 내 컴퓨터로는 잘 되기 때문에 올려 본다. 나름 상당히 시간과 공을 들인 코드이다.\n1열 또는 두 서너개의 열로 많은 데이터가 있을 때 이를 인쇄하면 인쇄용지가 많이 낭비된다.\n아래의 코드는 데이터를 다단으로 옮겨주는\n기능\n을 한다. 프린터 설정에 다중페이지 인쇄 옵션이 있지만, 아래와 같은 기능은 없다. 아래 코드는 다음과 같은 기능을 가지고 있다.\n반드시\n인쇄전 화면보기 인쇄로 데이터가 제대로 옮겨졌는지 꼼꼼하게 확인 후 인쇄할 것을 권장한다.)\n매크로 실행 전 데이터      ..."}
{"instruction": "Excel VBA code for: (1772) 회의명패 인쇄(라벨인쇄) (엑셀 VBA 매크로)", "input": "", "output": "Sub mail_Merge_Sample_7()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'2행 부터 시작\nDo\n'실행\nWith Sheets(\"출력\")\n'출력 시트에서\nFor i = 1 To 5 Step 4\n'1부터 시작하여 4씩 건너뛰며 2회 반복\n.Shapes(i).\nTextFrame2.TextRange.Text\n= Cells(r, 2).Value\n'이름 입력\n.Shapes(i + 1).TextFrame2.TextRange.Text = Cells(r, 3).Value\n'소속 입력\nNext i\nFor i = 3 To 7 Step 4\n'3부터 시작하여 4씩 건너뛰며 2회 반복\n.Shapes(i).TextFrame2.TextRange.Text = Cells(r + 1, 2).Value\n'이름 입력\n.Shapes(i + 1).TextFrame2.TextRange.Text = Cells(r + 1, 3).Value\n'소속 입력\nNext i\n.PrintPreview\n'인쇄 미리보기\n'            .PrintOut                                               '인쇄하기\nEnd With\nFor i = 1 To 8\n'8회 반복\nSheets(\"출력\").TextFrame2.TextRange.Text\n= \"\"\n'삭제\nNext i\nr = r + 2\n'행을 2씩 증가\nApplication.\nWait\nNow +\nTimeValue\n(\"00:00:01\")\n'시간지연 1초(프린터에게 시간 벌어줌)\nLoop Until\nIsEmpty\n(Cells(r, 1))\n'A열에 빈셀 나올때까지 무한 반복\nEnd Sub", "context": "회의 명패 인쇄기능\n. 전형적인 라벨인쇄 기능 중의 하나. 앞으로는 라벨인쇄나 메일머지 기능을 올릴 때에는 지금처럼 화면 미리보기 버튼과 실제 인쇄 버튼 2개를 넣어야겠다.\n매크로 실행 전 '명단'시트                                                매크로 실행 전 '출력'양식 시트\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1772) 회의명패 인쇄(라벨인쇄) (엑셀 VBA 매크로)\n재생\n1,610\n공유하기\n재생 (space/k)\n재생\n00:33\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:33\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가..."}
{"instruction": "Excel VBA code for: (1773) [ROW(1:100000)]와 배열에 넣어 뿌리기 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_No_With_Evaluate()                                        Sub fill_No_With_ForNext()\nDim i As Long                                                            Dim i As Long\nDim var1(1 To 100000, 1 To 1)\nFor i = 1 To 100                                                          For i = 1 To 100000\nCells(1, i).Resize(100000) = [Row(1:100000)]               var1(i, 1) = i\nNext i                                                                       Next i\nEnd Sub", "context": "VBA 세계를 유람하다 보면 [A1] = 5, [A3:B5] = 7 과 같은 소위\nEvaluate\n매서드를 사용한 구문을 자주 보게 된다.\nEvaluate(\"A1\").Value = 7\n: Evaluate매서드의 전체표기\n[A1].Value = 7\n: Evaluate매서드의 초기값(default)인 .Value와 함께 표기\n[A1]\n= 7\n: Evaluate매서드의 약식 표기\n위 세개의 구문은 모두 동일한 기능, 즉, A1셀에 7을 출력하는 기능을 한다.\nEvaluate매서드는\nApplication.Sum([이름정의된영역]) 즉, Application.Sum([A1:D5]) 등과 같이 또는 문자로된 숫자를 숫자로 변환 시 유용하게 쓰일 때가 있다. 하지만, 이 Evaluation 매서드는 값을 평가/계산하여 결과를 가져오므로 동일한 기능을 하는 코드들보다 속도가 조금이라도 떨어진다.\n아래의 두 코드는 A1:CV100000 까지 1 ~ 100,000까지의 숫자로 채우는 동일한 기능을 한..."}
{"instruction": "Excel VBA code for: (1775) 선택영역 빈셀 전체행 삭제 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Row_Of_Blank_Cell_1()\nDim rngRow As Range\n'전체행(Row) 영역을 넣을 변수\nDim rngC As Range\n'선택영역(r)a(ng)e 각셀(C)ell을 넣을 변수\nDim rngDel As Range\n'삭제(Del)ete 영역(r)a(ng)e 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n'------------------------------------------\n' 선택영역이 1개의 열만 선택하도록 하는 코드\n'------------------------------------------\nWith Selection\n'선택 영역에서\nIf .Cells.Count = 1 Or _\n.Columns.\nCount\n> 1 Or _\n.Rows.Count = Rows.Count Or _\n.Areas.Count > 1 Then\n'영역선택 오류시\nMsgBox \"1개영역, 2셀이상, 전체열 아닌 1 열만선택\", _\nvbExclamation, \"영역선택 오류\"\n'경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nEnd With\n'------------------------------------------------\n'빈셀이 없으면 중단하고, 모두 빈셀이면 전체행 삭제\n'------------------------------------------------\nWith WorksheetFunction\n'엑셀 함수에서\nIf .\nCountBlank\n(Selection) = 0 Then\n'데이터 입력 셀의 개수가 0이면\nMsgBox \"선택영역에 빈셀이 없습니다.\", vbExclamation\nExit Sub\n'메시지 출력 후 매크로 중단\nElseIf .CountA(Selection) = 0 Then\n'선택영역이 모두 빈셀이면\nSelection.\nEntireRow\n.Delete\n'선택영역 전체행을 삭제\nExit Sub\n'매크로 종료\nEnd If\nEnd With\nSet rngRow = Selection.Offset(0, -(Selection.Column - 1)).Resize(, _\nActiveSheet.UsedRange.Columns.Count)\n'선택영역을 전체 영역으로 확대해 변수에 넣음\n'(셀 병합된 셀이 있는지 확인할 목적)\n'----------------------------------------\n' 선택영역 같은 행에 셀병합셀 있는지 확인\n'----------------------------------------\nFor Each rngC In rngRow\n'전체영역 각 셀을 순환\nIf rngC.\nMergeCells\nThen\n'셀병합 영역이 있을 경우\nMsgBox \"선택영역 같은 행에 셀병합된 셀이 있습니다.\", _\nvbExclamation, \"셀병합 오류\"\n'경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nNext rngC\nSelection.Cells(1).EntireRow.Insert\n'선택영역 첫번째 셀에 전체행 삽입\n'-------------------------------------\n' 자동필터 보이는 셀기능으로 빈행 삭제\n'-------------------------------------\nWith Selection\n.AutoFilter\n'(1행 추가된)선택영역 자동필터\nActiveSheet.Range(.Address).\nAutoFilter\nField:=1, Criteria1:=\"=\"\n'빈행 기준으로 자동필터 필터링\nSet rngDel = .SpecialCells(\nxlCellTypeVisible\n)\n'삭제할 영역을 개체변수에\n.AutoFilter\n'필터제거\nEnd With\nrngDel.EntireRow.Delete\n'필터된 전체행 삭제\nSelection.Cells(1).Select\n'첫셀 선택\nSet rngRow = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nEnd Sub", "context": "아래의 코드는\n선택영역의 빈셀이 있는 곳 전체행을 삭제하는 기능\n이다. 기존 코드보다 조금이라도 더 빠르게 빈행을 삭제하는 방법을 생각하다가 책에 있는 내용과 결합하여 만듬.\n몇 만행의 데이터에서도 빈행이 빠르게 삭제\n된다. 공백의 삭제를 원하는 영역을 1열만 선택 후 매크로 실행.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1775) 선택영역 빈셀 전체행 삭제 2 (엑셀 VBA 매크로)\n재생\n656\n공유하기\n재생 (space/k)\n재생\n00:36\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:36\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요..."}
{"instruction": "Excel VBA code for: (1776) 선택한 데이터행 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Specific_Data()\nDim msg As String\n'출력할 메시지(m)e(s)sa(g)e를 넣을 변수\nDim colNo As Integer\n'선택영역 열(col)umn 번호(No.) 넣을 변수\nDim rngA As Range\n'각 구역(A)rea를 넣을 영역 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim v As Long\n'배열(v)ariant 크기 늘려갈 변수\nDim varData()\n'동적배열로 사용할 변수\nDim lastR As Long\n'마지막(last) 행(R)ow 개수 넣을 변수\nDim rngCol As Range\n'정렬시 사용할 열(Col)umn\nDim rngDel As Range\n'전체 삭제(Del)ete할 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nmsg = \"1개의 열만 선택, \" & vbCrLf & _\n\"Ctrl + 마우스로 다중영역 선택시에도 1열만 선택, \" & vbCrLf & _\n\"다중영역은 모두 같은 열이어야 함\" & vbCrLf & _\nvbNewLine & vbNewLine & _\n\"매크로를 중단합니다.\"\ncolNo = Selection.\nAreas\n(1).Column\n'선택영역 첫 구역의 열번호를 변수에\n'------------------------\n'영역선택 오류 검증 코드\n'------------------------\nFor Each rngA In Selection.Areas\n'선택 영역의 각 구역을 순환\nIf rngA.Columns.Count > 1 Then\n'각 구역의 열을 2개 이상 선택 시\nMsgBox msg, vbExclamation\n'메시지창 출력\nExit Sub\n'매크로 종료\nElseIf rngA.Column <> colNo Then\n'열 번호가 다르면\nMsgBox msg, vbExclamation\n'메시지창 출력\nExit Sub\n'매크로 종료\nEnd If\nNext rngA\n'-------------------------\n'삭제할 값들을 배열에 넣음\n'-------------------------\nFor Each rngA In Selection.Areas\n'선택영역의 각 구역을 순환\nFor Each rngC In rngA.Cells\n'각 구역의 각 셀을 순환\nv = v + 1\n'배열값 1씩 늘려감\nReDim Preserve\nvarData(1 To v)\n'기존값 유지하며 동적배열 크기 재지정\nvarData(v) =\nCStr\n(rngC)\n'배열에 값을 채움(\n중요\n: 반드시\n형변환\n해야됨)\nNext rngC\nNext rngA\n'-----------------------\n'임시행 삽입 후 자동필터\n'-----------------------\nRows(1).Insert\n'임시행 삽입\nCells(1, colNo) = \"Temp\"\n'임시 문자 삽입\nWith ActiveSheet.UsedRange\n'현재 시트 사용 영역에서\nlastR = .SpecialCells(\nxlCellTypeLastCell\n).Row\n'마지막행을 변수에\nSet rngCol = Range(Cells(1, colNo), Cells(lastR, colNo))\n'선택영역 전체열을 개체변수에\nrngCol.\nAutoFilter\nField:=1, Criteria1:=\nArray\n(varData), Operator:=xlFilterValues\n'자동필터로 선택한 값들 필터링\n'------------------------------------------\n'보이는 행만 선택하고 개체변수에 넣어 행삭제\n'------------------------------------------\nSet rngDel = rngCol.SpecialCells(\nxlCellTypeVisible\n)\n'삭제할 영역을 개체변수에\nrngCol.AutoFilter\n'필터제거\nrngDel.EntireRow.Delete\n'필터된 전체행 삭제\nEnd With\nSet rngCol = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngDel = Nothing\nEnd Sub", "context": "선택한 데이터의 전체행을 삭제하는 기능\n이다. 1개의 셀, 또는 Ctrl + 마우스로 다중영역 선택시에도 같은 열에서만 영역을 선택해야 정상 작동한다. 자동필터의 Array사용시 반드시 CStr해야 되는걸 배웠다. 이 코드는 공백행 삭제에도 유용하다. 행을 하나씩 삭제하거나, Union을 사용하는 다른 코드들은, 셀에 수식이 많이 걸려 있을 경우, 몇 백 또는 몇 천 행까지는 별차이 없지만 몇 만행을 넘어가면 엄청나게 속도가 떨어진다. 아래의 코드는 자동필터를 기반으로 하므로 속도가 상다히 빠르다. 많은 데이터가 있을 때 삭제해보면 체감할 수 있다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1776) 선택한 데이터행 삭제하기 (엑셀 VBA 매크로)\n재생\n1,515\n공유하기\n재생 (space/k)\n재생\n00:30\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:30\n실시간\n설정\n전체 화면 (f)\n해상도\n..."}
{"instruction": "Excel VBA code for: (1779) 병합셀 내의 *이후 문자 삭제 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_After_Asterisk()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim strU As String\n'문자를 합쳐갈(U)nion 변수\nDim varS\n'문자를 나누어(S)plit 넣을 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 1\n'1행부터 시작\nDo\n'실행\nvarS = Split(Cells(r, 1),\nChr(10)\n)\n'Alt + 엔터를 구분자로 하여 나누어 배열에 넣음\nFor i =\nLBound\n(varS) To\nUBound\n(varS)\n'배열 하한선에서 상한선까지 반복\nIf strU = \"\" Then\n'strU이 비어 있으면\nstrU =\nSplit\n(varS(i), \"*\")\n(0)\n'*로 나눈 제일 앞문자를 변수에\nElse\n'strU 비어 있지 않다면\nstrU = strU & Chr(10) & Split(varS(i), \"*\")(0)\n'strU + (Alt +Enter) + *로 나눈 앞문자를 변수에\nEnd If\nNext i\nCells(r, 2) = strU\n'B열에 값을 뿌림\nstrU = \"\"\n'재사용 위하여 초기화\nr = r + 1\n'행 1씩 늘려감\nLoop Until IsEmpty(Cells(r, 1))\n'A열에 빈셀 나올때까지 무한 반복\nEnd Sub", "context": "병합될 셀 내의 데이터에서 *이후 문자를 삭제하는 기능.\n매크로 실행 전                                       매크로 실행 후 결과\nOption Explicit\nSub delete_After_Asterisk()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim strU As String\n'문자를 합쳐갈(U)nion 변수\nDim varS\n'문자를 나누어(S)plit 넣을 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 1\n'1행부터 시작\nDo\n'실행\nvarS = Split(Cells(r, 1),\nChr(10)\n)\n'Alt + 엔터를 구분자로 하여 나누어 배열에 넣음\nFor i =\nLBound\n(varS) To\nUBound\n(varS)\n'배열 하한선에서 상한선까지 반복\nIf strU = \"\" Then\n'strU이 비어 있으면\nstrU =\n..."}
{"instruction": "Excel VBA code for: (1780) ArrayList 클래스 기본코드 (엑셀 VBA 매크로)", "input": "", "output": "Sub array_List()\n'-------------------------------------------------\n'1) 숫자/문자 혼용시 비교에러 발생\n'2) .Contains(\"Apple\") 으로 점검가능\n'3) varR = arrList.ToArray 으로 배열로 복사가능\n'4) Dim arrList2 As Object: Set arrList2 - arrList.Clone 으로 복사가능\n'5) arrList.Insert 0, \"Apple\" 과 같이 삽입가능\n'6) .Clear로 모두 삭제\n'7) .RemoveAt 0  으로 특정 항목 삭제가능\n'8) .Remove \"Apple\" 처럼 삭제 가능 (중복되었을 때에는?)\n'9) .Reverse 로 뒤집기 가능\n'Early Binding : Dim arrList As New ArrayList\n'-------------------------------------------------\nDim arrList As Object\n'ArrayList 넣을 개체\nDim varS As Variant\n'값을 넣을 배열\nDim a As Long\n'반복구문에 사용할 변수\nSet arrList = CreateObject(\"\nSystem.Collections.ArrayList\n\")\n'ArrayList 클래스를 개체변수에\nvarS = Array(\"무\", \"경\", \"갑\", \"신\", \"계\", \"정\")\n'값을 배열에 넣음\nFor a = LBound(varS) To UBound(varS)\n'배열 하한값에서 상한값까지 반복\narrList.\nAdd\nvarS(a)\n'arrList에 목록 추가\nNext a\narrList.\nSort\n'(오름차순)정렬\nFor a = 0 To arrList.Count - 1\n'배열처럼 0부터시작\nCells(a + 1, 1) = arrList(a)\n'값을 셀에 뿌림\nNext a\nEnd Sub", "context": "시스템 컬렉션에 포함된 ArrayList 클래스. 배열내의 데이터를 오름차순/내림차순 정렬 시 상당히 복잡한 코드를 사용해야 하는데, ArrayList 클래스를 사용하면 그 문제가 확실히 해결되는 것 같다. 다만, 문자나 숫자가 서로 섞여 있으면 에러. 즉, 데이터가 모두 문자이거나, 모두 숫자일 때 사용가능하다.\n아래의 코드는 mscorlib.dll 타입 라이브러리가 참조되어야 한다.\nOption Explicit\nSub array_List()\n'-------------------------------------------------\n'1) 숫자/문자 혼용시 비교에러 발생\n'2) .Contains(\"Apple\") 으로 점검가능\n'3) varR = arrList.ToArray 으로 배열로 복사가능\n'4) Dim arrList2 As Object: Set arrList2 - arrList.Clone 으로 복사가능\n'5) arrList.Insert 0, \"Apple\" 과 같이 삽입가능\n'..."}
{"instruction": "Excel VBA code for: (1781) 데칼코마니(대칭복사) (엑셀 VBA 매크로)", "input": "", "output": "Sub Decalcomanie()\nDim rngR As Range\n'선택영역 행(R)ow을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim varR()\n'값을 넣을 동적배열 변수\nDim r As Long\n'선택영역 행(r)ow을 반복할 변수\nDim c As Long\n'선택영역 열(c)olumn을 반복할 변수\nDim a As Long\n'배열(a)rray 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n​\nIf Selection.\nCells.Count\n= 1 Then\n'1셀만 선택한 경우\nMsgBox \"매크로 실행전 먼저 영역을 선택\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nWith Selection\n'선택영역에서\n.Copy .Offset(, .Columns.Count + 1)\n'선택영역을 오른쪽으로 복사\nFor r = .Rows.Count To 2\nStep -1\n'선택영역 행개수에서 1씩 줄여감\nFor c = WorksheetFunction.\nCountA\n(.Rows(r)) - 1 To 1 Step -1\n'(문자개수 -1)에서 1씩 줄여감\na = a + 1\n'1씩 늘려감\nReDim Preserve\nvarR(1 To a)\n'동적배열 크기 재지정\nvarR(a) = .Rows(r).Cells(c)\n'배열에 값을 넣음\nNext c\nNext r\na = 0\n'재사용 위하여 초기화\nFor Each rngR In .Offset(, .Columns.Count + 1)\n'선택영역 각 열을 순환\nFor Each rngC In rngR\n'각 행의 각 셀을 순환\nIf\nIsEmpty\n(rngC) Then\n'빈셀이면\na = a + 1\n'1씩 늘려감\nrngC = varR(a)\n'셀에 배열 값을 넣음\nEnd If\nNext rngC\nNext rngR\nEnd With\nEnd Sub", "context": "데칼코마니 즉 대칭복사하는 기능.\n매크로 실행 전                                          매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1781) 데칼코마니(대칭복사) (엑셀 VBA 매크로)\n재생\n688\n공유하기\n재생 (space/k)\n재생\n00:21\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:21\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n0..."}
{"instruction": "Excel VBA code for: (1782) 선택영역 바꿔가며 사진 연속삽입 (엑셀 VBA 매크로)", "input": "", "output": "Sub bring_Pictures_With_Selection()\nDim strFilter As String\n'필터링될 파일 확장자 넣을 변수\nDim rngSel As Range\n'선택영역을 넣을 변수\nDim fullPath As String\n'파일이름 포함한 전체경로 넣을 변수\nDim fileName As String\n'선택한 파일을 넣을 변수\nDim rngT As Range\n'사진들어갈 셀위치 넣을 변수\nstrFilter = \"JPG Files (*.jpg*;*.gif;*.bmp;*.png;*.wmf;*.cur;*.ico),*.jpg*\"\n'가져올 사진의 종류\nDo\n'-----------------------\n'영역선택 창 띄우는 코드\n'-----------------------\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel = Application.\nInputBox\n(\"사진이 삽입될 영역을 마우스로 선택하시오!\",\nType:=8\n)\nSet rngSel = rngSel.\nMergeArea\n'선택영역을 셀병합영역으로\n확장\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n'-----------------------\n'사진선택 창 띄우는 코드\n'-----------------------\nfullPath = Application.GetOpenFilename(strFilter, , _\n\"엑셀 파일을 선택\", MultiSelect:=False)\n'사진 파일을 선택\nIf fullPath = \"False\" Then Exit Sub\n'취소 선택 시 매크로 종료\nSet rngT = rngSel\n'선택영역을 개체변수에 넣음\nActiveSheet.Shapes.\nAddPicture\n(fullPath, 1, 1, 1, 1, 100, 100).Select\n'사진 가져와 선택함.\n'       ActiveSheet.Pictures.Insert(strPath & fileName).Select\n'       링크로 삽입하기 원할 경우 윗행 삭제후 이 코드 주석제거\n'-----------------------\n'사진위치 지정하는 코드\n'-----------------------\nWith Selection\n'선택된 사진파일에서\n.ShapeRange.LockAspectRatio = msoFalse\n'가로세로고정비율 해제\n.Left = rngT.Left + 2\n'그림왼쪽위치를 현재셀 왼쪽 + 2 위치에\n.Top = rngT.Top + 2\n'그림위쪽 위치를 현재셀 윗쪽 + 2 위치에\n.Height = rngT.Height - 4\n'그림 높이를 현재셀 -4 크기로\n.Width = rngT.Width - 4\n'그림 폭을 현재셀 -4 크기로\nEnd With\nfileName = Right(fullPath, Len(fullPath) -\nInStrRev\n(fullPath, \"\\\"))\n'확장자포함 파일이름 추출\nfileName =\nSplit\n(fileName, \".\")(0)\n'확장자 제거하고 파일이름만 추출\n'-------------------------------------------------\n'셀병합 여부에 따라 파일이름 넣는 위치 달리하는 코드\n'-------------------------------------------------\nIf rngSel.\nMergeCells\nThen\n'선택영역이 셀병합 셀일 경우\nrngSel.Offset(1) = fileName\n'파일이름 삽입\nElse\n'셀병합 셀이 아닐 경우\nrngSel.Offset(rngSel.Rows.Count).Cells(1) = fileName\n'파일이름 삽입\nEnd If\nSet rngSel = Nothing\n'재사용하기 위하여 초기화\nApplication.ScreenUpdating = True\n'화면 업데이트 실행\nLoop\nEnd Sub", "context": "취소버튼을 클릭할 때까지 '사진이 삽입될 영역선택' → '사진선택' → '사진이 삽입될 영역선택' → '사진선택' .... 을 무한 반복하는 코드. 왼손은 Enter 키에 올려놓고, 오른손으로 마우스를 클릭하면 삽입되는 위치와 삽입할 사진을 하나씩 확인해 가며 비교적 빠르게 사진을 삽입할 수 있다.\n사진은 선택한 영역을 기준으로 삽입\n된다. 아래 동영상에서는 처음에 단일셀, 두 번째에는 세로 3셀 셀병합 영역, 세 번째에는 5행/3열 셀병합 영역, 마지막으로는 6열/3행 영역을 선택하고 사진을 삽입\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1782) 선택영역 바꿔가며 사진 연속삽입 (엑셀 VBA 매크로)\n재생\n1,722\n공유하기\n재생 (space/k)\n재생\n00:25\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:25\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x ..."}
{"instruction": "Excel VBA code for: (1783) 폴더내 사진 행방향 건너 뛰며 연속삽입 (엑셀 VBA 매크로)", "input": "", "output": "Sub bring_Pictures_With_Offset()\nDim strPath As String\n'폴더의 경로(Path)를 넣을 변수\nDim fileName As String\n'각 파일(file) 이름(Name)을 넣을 변수\nDim rngSel As Range\n'선택(Sel)ection 영역(r)a(ng)e을 넣을 변수\nDim skipRow As Integer\n'건너뛸(skip) 행(Row)의 개수\nDim rngT As Range\n'사진들어갈 타겟(T)arget 셀위치 넣을 변수\n'-----------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'-----------------------------------------------\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)  '폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName =\nDir\n(strPath)\n'(폴더내)각 그림파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\n'-------------------------------\n' 첫 사진의 위치를 지정하는 코드\n'-------------------------------\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel = Application.\nInputBox\n(\"사진이 삽입될 첫 위치를 마우스로 선택하시오!\",\nType:=8\n)\nSet rngSel = rngSel.\nMergeArea\n'선택영역을 셀병합 영역으로 확장\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nskipRow = inputbox_Function\n'함수로 부터 입력값 가져옴\nSet rngT = rngSel\n'선택영역을 사진삽입될 위치변수에 넣음\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nActiveSheet.Shapes.\nAddPicture\n(strPath & \"\\\" & fileName, 1, 1, 1, 1, 100, 100).Select\n'사진 가져와 선택함.\n'ActiveSheet.Pictures.Insert(strPath & fileName).Select\n'링크로 삽입하기 원할 경우 윗행 삭제후 이 코드 주석제거\n'----------------------\n'사진위치 지정하는 코드\n'----------------------\nWith Selection\n'선택된 사진파일에서\n.ShapeRange.LockAspectRatio = msoFalse\n'가로세로고정비율 해제\n.Left = rngT.Left + 2\n'그림왼쪽위치를 현재셀 왼쪽 + 2 위치에\n.Top = rngT.Top + 2\n'그림위쪽 위치를 현재셀 윗쪽 + 2 위치에\n.Height = rngT.Height - 4\n'그림 높이를 현재셀 -4 크기로\n.Width = rngT.Width - 4\n'그림 폭을 현재셀 -4 크기로\nEnd With\nfileName =\nSplit\n(fileName, \".\")\n(0)\n'파일명을 추출\nrngT.Offset(1).Offset(, 1) = fileName\n'파일명 시트에 뿌림\nSet rngT = rngT.Offset(skipRow)\n'건너뛰어 (사진삽입될 영역)변수에 넣음\nSet rngT = rngT.MergeArea\n'사진삽입될 영역을 셀병합 영역으로 확장\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\nEnd Sub\n\nPrivate Function inputbox_Function()\n'----------------------------\n'건너뛸 행 개수 입력받는 함수\n'----------------------------\nDim input_Value As String\n'입력값을 넣을 변수\nDim msg As String\n'메시지 넣을 문자 변수\nConst\nintMin As Integer = 1\n'최솟값을 넣을 변수\nConst intMax As Integer = 100\n'최댓값을 넣을 변수\nDo\n'다음을 실행\nOn Error Resume Next\n'취소 눌렀을 때 계속 진행\ninput_Value =\nInputBox\n(intMin & \" 과 \" & intMax & \" 사이의 숫자를 입력.\", , \"숫자만 입력.\")\n'입력창 값을 변수에 넣음\nIf input_Value = \"\" Then End\n'입력값 없으면 매크로 중단\nOn Error GoTo 0\n'에러 검출기능 초기화\nIf\nIsNumeric\n(input_Value) Then\n'입력값이 숫자이면\nIf input_Value >= intMin And input_Value <= intMax Then\nExit Do\n'입력값이 최솟값보다 크거나 같고, 최댓값보다 작거나 같으면 Do 구문 종료\nEnd If\nEnd If\nmsg = \"번호입력 오류.\" & vbCr & vbCr\n'메시지창 내용 + 줄바꿈 2번\nmsg = msg & intMin & \" 과(와) \" & intMax & \" 사이의 숫자를 입력.\"\n'메시지창 내용\nMsgBox msg, 64, \"입력오류\"\nLoop\n'무한 반복\ninputbox_Function = input_Value\n'함수값 반환\nEnd Function", "context": "엑셀 파일에 사진을 여러장 삽입하는 소위 '사진대지'를 요청하는 분들의 파일을 보면, 대개 사진이 삽입될 위치는 여러개의 셀들이 셀병합 되어 있고, 파일이름을 사진 아래 두 번째 칸에 넣으며, 사진과 사진사이는 보통 3 ~ 4칸 정도 건너 뛰는 것들이 대부분이다.\n아래의 코드를 실행하면\n사진이 저장된 폴더를 선택하라는 폴더 선택창이 나타나고,\n첫 사진이 삽입될 위치를 선택하라는 영역선택 창이 나타나고,\n사진과 사진사이가 몇 행씩 띄어져 있는지 입력하라는 창이 나타난다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1783) 폴더내 사진 행방향 건너 뛰며 연속삽입 (엑셀 VBA 매크로)\n재생\n4,554\n공유하기\n재생 (space/k)\n재생\n00:33\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:33\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시..."}
{"instruction": "Excel VBA code for: (1784) 한글/영어/숫자만 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_each_Letter()\nDim rngAll As Range\n'전체(All)영역을 넣을 영역변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역변수\nDim i As Integer\n'셀의 문자길이만큼 반복할 변수\nDim strEach As String\n'추출한 각(Each) 문자 넣을 변수\nDim strK As String\n'한글(K)orean을 합쳐 넣을 변수\nDim strE As String\n'영어(E)nglish를 합쳐 넣을 변수\nDim strN As String\n'숫자(N)umber를 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"A1\", Cells(Rows.Count, \"A\").End(3))\n'A열 전체 데이터 영역을 변수에\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nFor i = 1 To\nLen\n(rngC)\n'각셀의 문자 길이 만큼 반복\nstrEach =\nMid\n(rngC, i, 1)\n'셀의 각 문자를 변수에 넣음\nIf strEach\nLike\n\"\n[가-힣]\"\nThen\n'한글만 추출\nstrK = strK & Mid(rngC, i, 1)\n'추출한 문자를 합쳐감\nElseIf strEach Like \"\n[a-zA-Z]\n\" Then\n'영어만 추출\nstrE = strE & Mid(rngC, i, 1)\n'추출한 문자를 합쳐감\nElseIf strEach Like \"\n[0-9]\n\" Then\n'숫자만 추출\nstrN = strN & Mid(rngC, i, 1)\n'추출한 문자를 합쳐감\nEnd If\nNext i\nWith rngC\n'각 셀에서\n.Offset(, 1) = strK\n'한글 셀에 복사\n.Offset(, 2) = strE\n'영어 셀에 복사\n.Offset(, 3) = strN\n'숫자 셀에 복사\nEnd With\nstrK = \"\"\n'재사용 위하여 초기화\nstrE = \"\"\n'재사용 위하여 초기화\nstrN = \"\"\n'재사용 위하여 초기화\nNext rngC\nColumns(\"B:D\").AutoFit\n'B:D열 열너비 자동맞춤\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "이미 수없이 해본 기능이다. Like와 특정 문자들의 처음과 끝만 알면 어렵지 않다.\n매크로 실행 전 A열에 데이터 입력                            매크로 실행 후 결과(한글/영문/숫자 추출)\nOption Explicit\nSub extract_each_Letter()\nDim rngAll As Range\n'전체(All)영역을 넣을 영역변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역변수\nDim i As Integer\n'셀의 문자길이만큼 반복할 변수\nDim strEach As String\n'추출한 각(Each) 문자 넣을 변수\nDim strK As String\n'한글(K)orean을 합쳐 넣을 변수\nDim strE As String\n'영어(E)nglish를 합쳐 넣을 변수\nDim strN As String\n'숫자(N)umber를 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet r..."}
{"instruction": "Excel VBA code for: (1785) 이름 바뀔때마다 다른 페이지에 인쇄 (엑셀 VBA 매크로)", "input": "", "output": "Sub print_Same_Name_Preview()\n'\n미리보기\n에 연결된 프로시저\nDim r As Long\n'행을 하나씩 늘려갈 변수\nDim i As Long\n'인쇄 페이지 더해갈 변수\n'    Application.ScreenUpdating = False\n'활성화시 다음페이지 미리보기 안되므로 주의\nr = 1\n'첫행을 건너뛰고 2행 부터 실행\ni = 1\n'첫페이지 건너뛰므로 1부터 시작\nWith ActiveSheet\n'현재 시트에서\n.\nResetAllPageBreaks\n'기존 설정한 페이지 나누기 모두 없애기\nDo\nIf Cells(r, 3) <> Cells(r + 1, 3) Then\n이름이 바로 아래 셀과 다르면\ni = i + 1\n.\nHPageBreaks\n.Add Cells(r + 1, 1)\n'페이지나누기 삽입\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until IsEmpty(Cells(r + 1, 1))\n'A열에 빈셀 나올때까지 무한 반복\n.PageSetup.\nPrintArea\n= ActiveSheet.UsedRange.Offset(1).\nAddress(1, 1)\n'전체 인쇄될 인쇄영역을 설정\n.\nPrintPreview\n'인쇄 미리보기\n.ResetAllPageBreaks\n'설정한 페이지 나누기 되돌려 놓기\n.PageSetup.PrintArea = \"\"\n'인쇄영역 설정을 초기화\nEnd With\nEnd Sub\n\nSub print_Same_Name_Print()\n'실제\n인쇄하기\n에 연결된 프로시저\nDim r As Long\n'행을 하나씩 늘려갈 변수\nDim i As Long\n'인쇄 페이지 더해갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nr = 1\n'첫행을 건너뛰고 2행 부터 실행\ni = 1\n'첫페이지 건너뛰므로 1부터 시작\nWith ActiveSheet\n'현재 시트에서\n.ResetAllPageBreaks\n'기존 설정한 페이지 나누기 모두 없애기\nDo\nIf Cells(r, 3) <> Cells(r + 1, 3) Then\n이름이 바로 아래 셀과 다르면\ni = i + 1\n.HPageBreaks.Add Cells(r + 1, 1)\n'페이지나누기 삽입\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until IsEmpty(Cells(r + 1, 1))\n'A열에 빈셀 나올때까지 무한 반복\n.PageSetup.PrintArea = ActiveSheet.UsedRange.Offset(1).Address(1, 1)\n'전체 인쇄될 인쇄영역을 설정\n.\nPrintOut\nFrom:=2, To:=i\n'인쇄\n.ResetAllPageBreaks\n'설정한 페이지 나누기 되돌려 놓기\n.PageSetup.PrintArea = \"\"\n'인쇄영역 설정을 초기화\nEnd With\nEnd Sub", "context": "이름 바뀔때마다 다른 페이지에 인쇄하는 기능. 아래 예제에서는 C열에 이름이 저장되어 있다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1785) 이름 바뀔때마다 다른 페이지에 인쇄 (엑셀 VBA 매크로)\n재생\n1,607\n공유하기\n재생 (space/k)\n재생\n00:20\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:20\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n..."}
{"instruction": "Excel VBA code for: (1786) 클릭시마다 도형 문자와 색바꾸기 (엑셀 VBA 매크로)", "input": "", "output": "Sub change_Text_With_Color()\nDim shp As Shape\n'도형을 넣을 개체 변수\nSet shp = ActiveSheet.Shapes(\nApplication\n.\nCaller\n)\n'매크로를 실행한 도형을 개체변수에 넣음\nWith shp.\nTextFrame2.TextRange\n'도형의 텍스트 프레임 영역\nSelect Case .Text\n'문자\nCase \"A\"\n'문자가 A인 경우\n.\nText\n= \"B\"\n'문자를 B로 변경\nshp.Fill.ForeColor.\nRGB\n= RGB(0, 0, 0)\n'채우기 배경 RGB색상을 검정\nCase \"B\"\n'문자가 B인 경우\n.Text = \"C\"\n'문자를 C로 변경\nshp.Fill.ForeColor.RGB = RGB(0, 0, 255)\n'채우기 배경 RGB색상을 파랑\nCase \"C\"\n'문자가 C인 경우\n.Text = \"D\"\n'문자를 D로 변경\nshp.Fill.ForeColor.RGB = RGB(144, 238, 144)\n'채우기 배경 RGB색상을 연두\nCase \"D\"\n'문자가 D인 경우\n.Text = \"E\"\n'문자를 E로 변경\nshp.Fill.ForeColor.RGB = RGB(255, 0, 0)\n'채우기 배경 RGB색상을 빨강\nCase \"E\"\n'문자가 E인 경우\n.Text = \"A\"\n'문자를 A로 변경\nshp.Fill.ForeColor.RGB = RGB(0, 128, 0)\n'채우기 배경 RGB색상을 초록\nEnd Select\nEnd With\nEnd Sub", "context": "클릭시마다 도형에 입력된 문자와 배경색을 바꾸는 기능.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1786) 클릭시마다 도형 문자와 색바꾸기 (엑셀 VBA 매크로)\n재생\n1,989\n공유하기\n재생 (space/k)\n재생\n00:12\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:12\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\nOption Explicit\nSub change_Text_With_..."}
{"instruction": "Excel VBA code for: (1787) 사진 열방향으로 연속삽입 (엑셀 VBA 매크로)", "input": "", "output": "Sub bring_Pictures_With_Selection2()\nDim rngSel As Range\n'선택영역을 넣을 변수\nDim rngT As Range\n'사진들어갈 셀위치 넣을 변수\nDim strFilter As String\n'필터링될 파일 확장자 넣을 변수\nDim fileNames As Variant\n'모든 파일 넣을 배열 변수\nDim varC As Variant\n'각 사진을 넣을 변수\nDim strName As String\n'파일 이름만 넣을 변수\nstrFilter = \"JPG Files (*.jpg*;*.gif;*.bmp;*.png;*.wmf;*.cur;*.ico),*.jpg*\"\n'파일선택 창에 필터링될 확장자\nDo\n'------------------------\n'영역선택 창 띄우는 코드\n'------------------------\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel = Application.\nInputBox\n(\"사진이 삽입될 영역을 마우스로 1셀만 선택하시오!\",\nType:=8\n)\nSet rngSel = rngSel.\nMergeArea\n'선택영역을 셀병합영역으로 확장\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nSet rngT = rngSel\n'선택영역을 개체변수에 넣음\nfileNames = Application.\nGetOpenFilename\n(strFilter, , _\n\"엑셀 파일(들)을 선택\",\nMultiSelect:=True\n)\n'사진 파일(들)을 선택\nIf TypeName(fileNames) = \"Boolean\" Then Exit Sub\n'취소 선택 시 매크로 종료\nFor Each varC In fileNames\n'선택한 각 엑셀 파일을 순환\nActiveSheet.Shapes.\nAddPicture\n(varC, 1, 1, 1, 1, 100, 100).Select\n'사진 가져와 선택함.\n'ActiveSheet.Pictures.Insert(varC).Select\n'링크로 삽입하기 원할 경우 윗행 삭제후 이 코드 주석제거\n'-----------------------\n'사진위치 지정하는 코드\n'-----------------------\nWith Selection\n'선택된 사진파일에서\n.ShapeRange.LockAspectRatio = msoFalse\n'가로세로\n고정비율 해제\n.Left = rngT.Left + 2\n'그림왼쪽위치를 현재셀 왼쪽 + 2 위치에\n.Top = rngT.Top + 2\n'그림위쪽 위치를 현재셀 윗쪽 + 2 위치에\n.Height = rngT.Height - 4\n'그림 높이를 현재셀 -4 크기로\n.Width = rngT.Width - 4\n'그림 폭을 현재셀 -4 크기로\nEnd With\nstrName = Right(varC, Len(varC) -\nInStrRev\n(varC, \"\\\"))\n'확장자포함 파일이름 추출\nstrName =\nSplit\n(strName, \".\")(0)\n'확장자 제거하고 파일이름만 추출\n'-------------------------------------------------\n'셀병합 여부에 따라 파일이름 넣는 위치 달리하는 코드\n'-------------------------------------------------\nIf rngT.\nMergeCells\nThen\n'선택영역이 셀병합 셀일 경우\nrngT.Offset(1) = strName\n'파일이름 삽입\nElse\n'셀병합 셀이 아닐 경우\nrngT.Offset(rngT.Rows.Count).Cells(1) = strName\n'파일이름 삽입\nEnd If\nSet rngT = rngT.Offset(, 1).MergeArea\n'사진 복사될 위치 오른쪽으로 1칸 이동\nSet rngSel = Nothing\n'재사용하기 위하여 초기화\nApplication.ScreenUpdating = True\n'화면 업데이트 실행\nNext varC\nLoop\nEnd Sub", "context": "아래의 코드는\n사진을 열방향으로\n연속삽입\n하는 기능을 한다. 사진 아래에 파일이름도 함께 가져온다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1787) 사진 열방향으로 연속삽입 (엑셀 VBA 매크로)\n재생\n2,232\n공유하기\n재생 (space/k)\n재생\n00:59\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:59\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n폴더..."}
{"instruction": "Excel VBA code for: (1788) 데이터 재배치하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub transfer_Data()\nDim blnTF As\nBoolean\n'A/B 반전에 사용할 변수\nDim rngArea As Range\n'가로3/세로3 영역(Area) 넣을 변수\nDim rngT As Range\n'복사될 위치(T)arget를 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim r As Long\n'행(r)ow 3행씩 늘려갈 변수\nDim x As Integer\n'열(x축)방향 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nr = 12\n'12행부터 시작\nDo\n'실행\nIf blnTF =\nFalse\nThen\n'blnTF가 거짓이면\nSet rngArea = Cells(r, 3).Resize(3, 3)\n'가로3/세로3 영역을 C열 기준\nblnTF =\nTrue\n'blnTF 반전\nElse\n'blnTF가 참이면\nSet rngArea = Cells(r, 6).Resize(3, 3)\n'가로3/세로3 영역을 F열 기준\nr = r + 3\n'행을 3씩 늘려감\nblnTF = False\n'blnTF 반전\nEnd If\nSet rngT = Sheets(2).Cells(Rows.Count, \"C\").End(3)(2)\n'2번째 시트, C열 종단셀 윗방향 바로 아래셀을 복사될 위치로\nFor Each rngC In rngArea\n'가로3/세로3 구역의 각 셀을 순환\nx = x + 1\n'열 위치 1씩 늘려감\nrngT.Offset(, x - 1) = rngC\n'각 셀 값을 복사\nNext rngC\nx = 0\n'재사용 위하여 초기화\nLoop Until\nIsEmpty(Cells(r, 1))\n'A열에 빈셀 나올때까지 무한 반복\nSheets(2).Select\n'2번째 시트 선택\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "A/B를 3행/3열씩 1행으로 재배치하는 기능. 데이터가 정상적으로 옮겨지는지 알아보기 쉽게 숫자를 순차적으로 넣음.\n매크로 실행 전 Sheet1\n​\n(데이터가 옮겨질) Sheet2  (A:B열은 끌어당겨 복사하면 되므로 매크로 적용 안함)\n​\n매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub transfer_Data()\nDim blnTF As\nBoolean\n'A/B 반전에 사용할 변수\nDim rngArea As Range\n'가로3/세로3 영역(Area) 넣을 변수\nDim rngT As Range\n'복사될 위치(T)arget를 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim r As Long\n'행(r)ow 3행씩 늘려갈 변수\nDim x As Integer\n'열(x축)방향 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nr = 12\n'12행부터 시작\nDo\n'실행\nIf blnT..."}
{"instruction": "Excel VBA code for: (1789) 데이터 재배치하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub transfer_Data_2()\nDim blnTF As\nBoolean\n'A/B 반전에 사용할 변수\nDim rngArea As Range\n'가로3/세로3 영역(Area) 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim r As Long\n'행(r)ow 3행씩 늘려갈 변수\nDim x As Integer\n'열(x축)방향 늘려갈 변수\nDim y As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nr = 12\n'Sheet1 12행부터 시작\ny = 2\n'Sheet2 2행 부터 시작\n​\nDo\n'실행\nIf blnTF =\nFalse\nThen\n'blnTF가 거짓이면\nSet rngArea = Sheets(1).Cells(r, 3).Resize(3, 3)\n'가로3/세로3 영역을 F열 기준\nblnTF =\nTrue\n'blnTF 반전\nElse\n'blnTF가 참이면\nSet rngArea =Sheets(1).Cells(r, 6).Resize(3, 3)\n'가로3/세로3 영역을 C열 기준\nr = r + 3\n'행을 3씩 늘려감\nblnTF = False\n'blnTF 반전\nEnd If\nFor Each rngC In rngArea\n'가로3/세로3 구역의 각 셀을 순환\nx = x + 1\n'열 위치 1씩 늘려감\nrngC = Cells(y, x + 2)\n'각 셀 값을 복사\nNext rngC\ny = y + 1\n'Sheet2 행을 1씩 늘려감\nx = 0\n'재사용 위하여 초기화\nLoop Until\nIsEmpty(Cells(r, 1))\n'B열에 빈셀 나올때까지 무한 반복\nSheets(1).Select\n'1번째 시트 선택\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "앞서 (1788)에서 올렸던 내용과 반대로, 즉 Sheet2의 데이터를 Sheet1에 3행/3열씩 옮겨주는 기능 + A/B 위치를 바꿈. 데이터가 정상적으로 옮겨지는지 알아보기 쉽게 숫자를 순차적으로 넣음.\n매크로 실행 전 Sheet2 (Sheet1은 비어 있는 상태)\n매크로 실행 후 Sheet1의 결과\nOption Explicit\nSub transfer_Data_2()\nDim blnTF As\nBoolean\n'A/B 반전에 사용할 변수\nDim rngArea As Range\n'가로3/세로3 영역(Area) 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim r As Long\n'행(r)ow 3행씩 늘려갈 변수\nDim x As Integer\n'열(x축)방향 늘려갈 변수\nDim y As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nr = 12\n'Sheet1 12행부터 시작\ny = 2\n'S..."}
{"instruction": "Excel VBA code for: (1791) 셀병합된 영역의 합계 구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub sum_Of_Merge_Area()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim cntArea As Long\n'셀병합 영역(Area)의 셀 개수(c)ou(nt) 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nr = 2\n'2행부터 시작\nDo\n'실행\nCells(Rows.Count, \"D\").End(3)(2) = Cells(r, 1)\n'종단셀 D열 윗방향 바로 아래셀에 제목\nIf Cells(r, 1).\nMergeCells\nThen\n'셀병합 되어 있다면\ncntArea = Cells(r, 1).\nMergeArea\n.Cells.Count\n'셀병합 영역의 셀 개수를 변수에 넣음\nCells(Rows.Count, \"E\").End(3)(2) = _\nApplication.\nSum\n(Cells(r, 1).Offset(, 1).Resize(cntArea))\n'셀병합셀 개수만큼 B열의 영역합을 구하여 종단셀 E열 윗방향 바로 아래셀에 값\n​\nr = r + cntArea - 1\n'행 + 셀병합 영역 셀개수 - 1 만큼 행 늘려감\nElse\n'셀병합 안되어 있으면\nCells(Rows.Count, \"E\").End(3)(2) = Cells(r, 2)\n'종단셀 E열 윗방향 바로 아래셀에 값\nEnd If\nr = r + 1\n'행을 1씩 늘려감\nLoop Until IsEmpty(Cells(r, 2))\n'B열에 빈셀 나올때까지 무한 반복\nEnd Sub", "context": "매크로 실행 전                                                     매크로 실행 후 결과\nOption Explicit\nSub sum_Of_Merge_Area()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim cntArea As Long\n'셀병합 영역(Area)의 셀 개수(c)ou(nt) 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nr = 2\n'2행부터 시작\nDo\n'실행\nCells(Rows.Count, \"D\").End(3)(2) = Cells(r, 1)\n'종단셀 D열 윗방향 바로 아래셀에 제목\nIf Cells(r, 1).\nMergeCells\nThen\n'셀병합 되어 있다면\ncntArea = Cells(r, 1).\nMergeArea\n.Cells.Count\n'셀병합 영역의 셀 개수를 변수에 넣음\nCells(Rows.Count, \"E\").End(3)(2) = _\nApplication..."}
{"instruction": "Excel VBA code for: (1792) 문자로 입력된 숫자를 숫자셀의 숫자로 변환 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub convert_Text_To_Numbers_2()\n'문자로 입력된 숫자 숫자로 변환\nDim rngC As Range\n'각 셀을 순환할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nFor Each rngC In ActiveSheet.UsedRange\n'현재시트 사용영역 각 셀을 순환\nIf rngC.Errors.Item(\nxlNumberAsText\n).Value = True Then\n'셀의 숫자가 문자로 입력된 경우라면\nrngC.\nNumberFormatLocal\n= \"0_ \"\n'셀서식을 숫자로\nrngC = rngC * 1\n'(숫자로 변환하기 위해)셀에 1을 곱함\nEnd If\nNext rngC\nEnd Sub", "context": "예전에 이를 구현하기 위해 상당히 복잡한 코드를 사용했는데, 옛날 매크로 책을 보다가 아주 간단한 방법을 알게 되었다.\n엑셀 작업을 하다보면 다양한 이유로 숫자로 입력해야 할 셀들이 문자로 입력되어 있어 곤욕을 치르곤 한다. 아래 코드는\n현재시트에 있는 모든 문자셀에 입력된 숫자를 숫자셀의 숫자로 변환\n하는 코드이다. 현재 시트에서만 작동된다. 필요 시 각 시트를 순환하는 코드를 만들고 아래 코드를 하위(sub) 프로시저로 만들면 모든 시트에도 적용이 가능할 것이다.\n단순히 1을 복사하여 B열에 곱하기 하면 '시간'셀(B6)에 문제가 생기고, 더하기 하면 '수식'셀(B13)이 깨지고, 문자 나누기 하면 공백이 있는 셀(B6, B12)에 문제가 생기고, 단순히 서식을 '일반'으로 바꾸어도 B2, B11셀의 값이 숫자로 바뀌지 않는다.\n매크로 실행 전                                            매크로 실행 후 결과 (숫자가 12개로 늘어남)\nB17셀에는..."}
{"instruction": "Excel VBA code for: (1793) 데이터 재배치하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub trans_Data()\nDim rngAll As Range\n'전체 영역을 넣을 영역변수\nDim varD()\n'데이터를 넣을 배열 변수\nDim rngCol As Range\n'전체영역 각 열을 넣을 영역변수\nDim r As Long\n'배열의 행 늘려갈 변수\nDim rngC As Range\n'\n각 셀을 순환할 영역 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nWith [A1].CurrentRegion\n'A1과 연결영역\nSet rngAll = .Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 1)\nEnd With\n'첫행/첫열 제외한 영역을 변수에 넣음\nReDim\nvarD(1 To rngAll.Cells.Count, 1 To 3)\n'배열크기 재지정\nFor Each rngCol In rngAll.\nColumns\n'전체영역 각 열을 순환\nFor Each rngC In rngCol.\nCells\n'각 열의 각 셀을 순환\nr = r + 1\n'배열내 행을 1씩 늘려감\nvarD(r, 1) = Cells(1, rngC.Column)\n'A/B/C/D를 배열에 넣음\nvarD(r, 2) = Cells(rngC.Row, 1)\n'1/2/3/4를 배열에 넣음\nvarD(r, 3) = rngC\n'Y/N를 배열에 넣음\nNext rngC\nNext rngCol\n[G1].Resize(rngAll.Cells.Count, 3) = varD\n'배열내 값을 셀에 뿌림\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "왼쪽의 데이터를 오른쪽과 같이 재배치하는 기능.\nOption Explicit\nSub trans_Data()\nDim rngAll As Range\n'전체 영역을 넣을 영역변수\nDim varD()\n'데이터를 넣을 배열 변수\nDim rngCol As Range\n'전체영역 각 열을 넣을 영역변수\nDim r As Long\n'배열의 행 늘려갈 변수\nDim rngC As Range\n'\n각 셀을 순환할 영역 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nWith [A1].CurrentRegion\n'A1과 연결영역\nSet rngAll = .Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 1)\nEnd With\n'첫행/첫열 제외한 영역을 변수에 넣음\nReDim\nvarD(1 To rngAll.Cells.Count, 1 To 3)\n'배열크기 재지정\nFor Each rngCol In rngAll.\nColumns..."}
{"instruction": "Excel VBA code for: (1794) 랜덤 제품선택 (엑셀 VBA 매크로)", "input": "", "output": "Sub random_Selection_And_Count()\nDim x As Integer\n'열(x축)방향 10번 반복할 변수\nDim rngCol As Range\n'제품 열(Col)umn 넣을 영역(r)a(ng)e변수\nDim intR As Integer\n'랜덤(R)andom한 숫자 넣을 변수\nDim intN As Integer\n'새로운(N)ew 랜덤한 숫자 넣을 변수\nDim y As Integer\n'행(y축)방향 4번 반복할 변수\nDim rngRow As Range\n'제품 행(Row) 넣을 영역(r)a(ng)e변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim intSum As Integer\n'반복횟수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nRandomize\n'랜덤값 발생기 초기화\nFor x = 1 To 10\n'10회 반복\nSet rngCol = Cells(3, x + 1).Resize(4)\n'3행 x+1 번째열부터 4행을 변수에\nintR = Int(Rnd() * 4) + 1\n'1 ~ 4 까지의 무작위 숫자 추출\nIf x\nMod\n2 = 1 Then\n'각 그룹 첫 번째 열이라면\nrngCol.Cells(intR).Interior.\nColorIndex\n= 6\n'추출한 무작위 셀을 노란색으로 표시\nElse\n'각 그룹 두 번째 열이라면\nIf rngCol.Cells(intR).\nPrevious\n.Interior.ColorIndex = 6 Then\n'앞 그룹과 같은 행이라면\nDo\n'실행\nintN = Int(\nRnd\n()\n* 4) + 1\n'새로운 무작위 숫자를 추출\nLoop Until intR <> intN\n'기존 무작위 숫자와 다를 때까지 반복\nrngCol.Cells(intN).Interior.ColorIndex = 6\n'새로 추출한 무작위 셀을 노란색 표시\nElse\n'앞 그룹과 다른 행이라면\nrngCol.Cells(intR).Interior.ColorIndex = 6\n'추출한 무작위 셀을 노란색으로 표시\nEnd If\nEnd If\nNext x\nFor y = 1 To 4\n'4회 반복\nFor Each rngC In Cells(y + 2, 2).Resize(, 10)\n'y + 2행 B열부터 오른쪽 10개열 각셀 순환\nIf rngC.Interior.ColorIndex = 6 Then\n'셀이 노란색이면\nintSum = intSum + 1\n'숫자를 1씩 더해감\nEnd If\nNext rngC\nCells(y + 2, 12) = intSum & \"개\"\n'더한 숫자를 L열 셀에 뿌림\nintSum = 0\n'재사용 위하여 초기화\nNext y\nSet rngCol = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngRow = Nothing\nEnd Sub\n\nSub delete_Data()\nRange(\"B3:K6\").Interior.ColorIndex =\nxlNone\n'B3:K6 영역의 색을 삭제\nRange(\"L3:L6\") = \"\"\n'L3:L6 영역의 값을 삭제\nEnd Sub", "context": "1. 아래 표에서 랜덤하게 제품을 뽑음\n2. 같은 그룹에 묶인 항목끼리는 같은 제품을 선택할 수 없음.\n3. 4가지 제품 중 한가지만 골라 총 10개의 제품을 선택하려 함.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1794) 랜덤 제품선택 (엑셀 VBA 매크로)\n재생\n1,062\n공유하기\n재생 (space/k)\n재생\n00:34\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:34\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n360p\n270p\n144p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경..."}
{"instruction": "Excel VBA code for: (356) 동일데이터 통합(consolidate)하여 합계내기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_Data_As_Per_Name()\nDim rngAll As Range\n'전체 데이터를 넣을 변수\nDim rngName As Range\n'B열 전체 이름을 넣을 변수\nDim rngC As Range\n'B열 모든 데이터의 각셀을 넣을 변수\nDim X As New Collection\n'중복없는 이름을 구할 컬렉션 변수\nDim varItem\n'컬렉션의 각 데이터 넣을 변수\nDim rngT As Range\n'각 이름별 데이터를 복사할 위치넣을 변수\nDim rngEach As Range\n'C열(가격)을 넣을 변수\nIf Sheets.Count > 1 Then\n'현재 Sheet 갯수가 1개 초과 시 중단\nMsgBox \"Data 시트 이외의 다른 sheet는 모두 삭제 후 재실행\", 64, \"시트개수 에러\"\nExit Sub\nEnd If\nSet rngAll = [A1].\nCurrentRegion\n'각 작업영역 설정\nSet rngName = Range([B2], Cells(Rows.Count, \"B\").End(3))\nFor Each rngC In rngName\n'각 이름을 순환\nOn Error Resume Next\n'에러 발생해도 계속 진행\nX.Add rngC.Value, CStr(rngC.Value)\n'중복없이 컬렉션에 데이터 넣기\nNext rngC\nOn Error GoTo 0\n'에러 검출기능 복원\nSheets\n.Add\nafter:=Sheets(Sheets.Count)\n'새로운 sheet의 추가\nSheets(1).Rows(1).SpecialCells(2).Copy Range(\"A1\")\n'제목 복사\nFor Each varItem In X\n'컬렉션의 각 값을 순환\nWith Sheets(1)\nrngAll.\nAutoFilter\nfield:=2, Criteria1:=varItem\n'이름 별로 필터링을 해서\nSet rngEach = .Range(.Cells(2, 3), .Cells(Rows.Count, \"C\").End(3)).\nSpecialCells(12)\nSet rngT = Cells(Rows.Count, \"A\").End(3)(2)\n'복사영역 설정\n.UsedRange.SpecialCells(12).Areas(2).Rows(1).Copy rngT\n'각 이름별 복사\nCells(Rows.Count, \"C\").End(3) =\nWorksheetFunction.Sum\n(rngEach)\n'합계 복사\nIf .AutoFilterMode Then\n'자동필터 되어 있으면\n.AutoFilter.Range.AutoFilter\n'자동필터 해제\nEnd If\nEnd With\nNext varItem\nColumns.\nAutoFit\n'각 열너비 자동 정렬\nSheets(\"Data\").Activate\n'Data 시트를 활성화\nSet rngAll = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngName = Nothing\nSet rngT = Nothing\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 (새로운 시트를 생성하여 각 이름별로 옮기고, 가격은 그 이름의 합계를 넣음)\n엑셀의 통합(Consolidation)의 합계 기능을 사용하면 각 코드별 합계금액은 얻어지지만 \"이름\", \"참고사항\"등이 복사되지 않는다.\nOption Explicit\nSub combine_Data_As_Per_Name()\nDim rngAll As Range\n'전체 데이터를 넣을 변수\nDim rngName As Range\n'B열 전체 이름을 넣을 변수\nDim rngC As Range\n'B열 모든 데이터의 각셀을 넣을 변수\nDim X As New Collection\n'중복없는 이름을 구할 컬렉션 변수\nDim varItem\n'컬렉션의 각 데이터 넣을 변수\nDim rngT As Range\n'각 이름별 데이터를 복사할 위치넣을 변수\nDim rngEach As Range\n'C열(가격)을 넣을 변수\nIf Sheets.Count > 1 Then\n'현재 Sheet 갯수가 1개 초과 시 중..."}
{"instruction": "Excel VBA code for: (804) 열방향 누적된 숫자의 중복개수 구하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub count_Of_Dupes()\nDim c As Integer\n'열개수 많큼 반복할 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'마지막 행을 변수에 넣음\ncolsCnt = ActiveSheet.UsedRange.\nColumns.Count\n'전체 열 개수를 변수에 넣음\nCells(lastRow + 2, 1).Resize(, colsCnt) = \"S\"\n'임시로 문자삽입\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nr = 1\n'1행 부터 시작\nDo\nIf Cells(r, c) = Cells(r + 1, c) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nCells(Rows.Count, c).End(3)(2) = i + 1\n'반복횟수를 셀에 뿌림\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = vbNullString\n'각 열에 빈셀 나올때까지 무한 반복\nNext c\nRows(lastRow + 2).Delete\n'임시로 문자삽입한 행 삭제\nEnd Sub", "context": "매크로 실행 전                                                    매크로 실행 후\nOption Explicit\nSub count_Of_Dupes()\nDim c As Integer\n'열개수 많큼 반복할 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'마지막 행을 변수에 넣음\ncolsCnt = ActiveSheet.UsedRange.\nColumns.Count\n'전체 열 개수를 변수에 넣음\nCells(lastRow + 2, 1).Resize(, colsCnt) = \"S\"\n'임시로 문자삽입..."}
{"instruction": "Excel VBA code for: (805) 열방향 누적된 숫자의 중복개수 구하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub count_Of_Dupes2()\nDim c As Integer\n'열개수 많큼 반복할 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, 1).End(3).Row\n'마지막 행을 변수에 넣음\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열 개수를 변수에 넣음\nCells(lastRow + 2, 1).Resize(, colsCnt) = \"S\"\n'임시로 문자삽입\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nDo\nDo\ni = i + 1\n'카운터를 하나씩 늘려감\nr = r + 1\n'행번호를 하나씩 늘려감\nLoop Until\nCells(r, c).Value <> Cells(r + 1, c).Value\n'위아래 값이 달라질때까지 반복\nCells(Rows.Count, c).End(3)(2) = i\n'반복횟수를 셀에 뿌림\ni = 0\n'재사용위해 카운터 초기화\nLoop Until\nr = lastRow\n'마지막행 도달할 때까지 반복\nr = 0\n'재사용 위하여 (행)초기화\nNext c\nRows(lastRow + 2).Delete\n'임시로 문자삽입한 행 삭제\nEnd Sub", "context": "앞서\nDo .. Loop 구문을 사용했다.\n아래의 코드에서는 Do .. Loop 구문을 중첩(Do .. Loop 내에 Do .. Loop가 들어가는 구조)하여 동일한 결과를 얻어보았다.\n매크로 실행 전                                                    매크로 실행 후\nOption Explicit\nSub count_Of_Dupes2()\nDim c As Integer\n'열개수 많큼 반복할 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, 1).End(3).Row\n'마지막 행을 변수에 넣음\ncolsCnt = Activ..."}
{"instruction": "Excel VBA code for: (806) 열방향 누적된 숫자의 중복개수 구하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub count_Of_Dupes3()\nDim c As Integer\n'열(c)olumn 증가에 사용할 넣을 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, 1).End(3).Row\n'마지막 행을 변수에 넣음\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열 개수를 변수에 넣음\nCells(lastRow + 2, 1).Resize(, colsCnt) = \"S\"\n'임시로 문자삽입\nDo\nc = c + 1\n'열을 1씩 늘려감\nDo\nDo\ni = i + 1\n'카운터를 하나씩 늘려감\nr = r + 1\n'행번호를 하나씩 늘려감\nLoop Until\nCells(r, c).Value <> Cells(r + 1, c).Value\n'위아래 값이 달라질때까지 반복\nCells(Rows.Count, c).End(3)(2) = i\n'반복횟수를 셀에 뿌림\ni = 0\n'재사용위해 카운터 초기화\nLoop Until\nr = lastRow\n'마지막행 도달할 때까지 반복\nr = 0\n'재사용 위하여 (행)초기화\nLoop Until\nc = colsCnt\n'c가 colscnt 될 때까지 무한 반복\nRows(lastRow + 2).Delete\n'임시로 문자삽입한 행 삭제\nEnd Sub", "context": "앞서,\nDo .. Loop 구문사용,\nDo .. Loop를 중첩 사용하여 누적된 숫자의 중복개수를 구하여 보았다.\n이번에는 Do .. Loop를 2번 중첩하여 동일한 기능을 구현해 보았다.\n갑자기 For .. Next 중첩구문과 어느 것이 얼마나 더 빠른지 궁금해졌다(내가 알기로는 For .. Next 구문이 For Each .. Next 구문 또는 Do .. Loop 보다 (조금) 더 빠르다고 들었다. 아직 확인은 못해봤다.)\n매크로 실행 전                                                    매크로 실행 후\nOption Explicit\nSub count_Of_Dupes3()\nDim c As Integer\n'열(c)olumn 증가에 사용할 넣을 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As..."}
{"instruction": "Excel VBA code for: (807) 열방향 누적된 숫자의 중복개수 구하기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub count_Of_Dupes4()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim rngData As Range\n'복사영역 전체를 넣을 변수\nDim c As Integer\n'열개수 많큼 반복할 변수\nDim rngC As Range\n'각 셀을 넣을 영역\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = ActiveSheet.UsedRange\n'전체영역을 변수에 넣음\ncolsCnt = rngAll.Columns.Count\n'전체 열 개수를 변수에 넣음\nrngAll.Offset(rngAll.Rows.Count + 1) = rngAll.Value\n'전체영역 복사\nSet rngData = Cells(Rows.Count, 1).End(3).CurrentRegion\n'복사영역을 변수에 넣음\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nrngData.Columns(c).\nRemoveDuplicates\n1, 2\n'복사영역 각 열의 중복제거\nFor Each rngC In rngData.Columns(c).\nCells\n'복사영역 각 열의 각셀 순환\nIf\nNot IsEmpty\n(rngC) Then\n'각 셀이 빈셀이 아니라면\nrngC = WorksheetFunction.\nCountIf\n(rngAll.Columns(c), rngC)\nEnd If\n'중복 개수를 각 셀에 넣음\nNext rngC\nNext c\nSet rngAll = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngData = Nothing\nEnd Sub", "context": "앞서,\nDo .. Loop 구문사용,\nDo .. Loop의 중첩사용,\nDo .. Loop의 2번 중첩사용을 이용하여 누적된 숫자의 중복개수를 구하여 보았다.\n이번에는\n중복제거(Remove Duplicates)\nmethod와\nCountIf 함수\n를 이용하여 동일한 기능을 구현해 보았다.\n매크로 실행 전                                                    매크로 실행 후\nOption Explicit\nSub count_Of_Dupes4()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim rngData As Range\n'복사영역 전체를 넣을 변수\nDim c As Integer\n'열개수 많큼 반복할 변수\nDim rngC As Range\n'각 셀을 넣을 영역\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll..."}
{"instruction": "Excel VBA code for: (808) 열방향 누적된 숫자의 중복개수 구하기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub count_Of_Dupes5()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rowsCnt  As Long\n'전체 행의 개수를 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim c As Integer\n'열(c)olumn 늘려갈 변수\nDim r As Long\n'배열 열 크기 늘려갈 변수\nDim varTemp()\n'동적배열로 사용할 변수\nDim i As Long\n'행(r)ow 늘려갈 변수\nDim j As Long\n'중복횟수 넣을 변수\nDim k As Long\n'배열 행 크기 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = ActiveSheet.UsedRange\n'전체영역을 변수에 넣음\nrowsCnt = rngAll.Rows.Count\n'전체 행의 개수를 변수에 넣음\ncolsCnt = rngAll.Columns.Count\n'전체 열 개수를 변수에 넣음\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nr = r + 1\n'배열 열크기 1씩 늘려감\nReDim Preserve\nvarTemp(1 To rowsCnt, 1 To r)\n'배열크기 재지정\nFor i = 1 To rowsCnt\n'행 개수 만큼 반복\nj = j + 1\n'중복 횟수 넣을 변수\nIf\nStrComp\n(Cells(i, c), Cells(i + 1, c), 0)\n<> 0\nThen\n'만약 위아래가 다르면\nk = k + 1\n'해열 행 크기 늘려감\nvarTemp(k, r) = j\n'배열에 중복횟수를 넣음\nj = 0\n'재사용 위하여 초기화\nEnd If\nNext i\nk = 0\n'배열 행 위치 초기화\nNext c\nCells(rowsCnt + 2, 1).Resize(\nUBound\n(varTemp, 2), colsCnt) = varTemp\n'배열 값을 셀에 뿌림\nSet rngAll = Nothing\n'개체변수 초기화 (메모리 비우기)\nEnd Sub", "context": "앞서,\nDo .. Loop 구문사용,\nDo .. Loop의 중첩사용,\nDo .. Loop의 2번 중첩사용,\n중복제거(Remove Duplicates) method와 CountIf 함수를 사용하여 누적된 숫자의 중복개수를 구하여 보았다.\n이번에는\nStrComp function과 동적배열\n을 이용하여 동일한 기능을 구현해 보았다.\n매크로 실행 전                                                    매크로 실행 후\nOption Explicit\nSub count_Of_Dupes5()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rowsCnt  As Long\n'전체 행의 개수를 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim c As Integer\n'열(c)olumn 늘려갈 변수\nDim r As Long\n'배열 열 크기 늘려갈 변수\nDim varTemp()\n'동적배열로 사용할 변수\nDim i ..."}
{"instruction": "Excel VBA code for: (810) 열방향 누적된 숫자의 중복개수 구하기 7 (엑셀 VBA 매크로)", "input": "", "output": "Sub count_Of_Dupes7()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rowsCnt  As Long\n'전체 행의 개수를 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim c As Integer\n'열(c)olumn 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = ActiveSheet.UsedRange\n'전체영역을 변수에 넣음\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열 개수를 변수에 넣음\nrowsCnt = rngAll.Rows.Count\n'전체 행의 개수를 변수에 넣음\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nWith Sheets(2)\n'Sheet2에서\n.Cells(1, 1).Resize(rowsCnt) = rngAll.Columns(c).Value\n'Sheet2에 각 열을 복사\nApplication.\nDisplayAlerts = False\n'화면 경고 중단\n.Columns(1).\nSubtotal\nGroupBy:=1, Function:=\nxlCount\n, TotalList:=Array(1)\n'부분합으로 중복개수를 추출\nApplication.DisplayAlerts = True\n'화면경고 복원\n.Cells(Rows.Count, 1).End(3).Resize(, 2).ClearContents\n'합계행 삭제\n.Columns(1).SpecialCells(2).Offset(, 1).\nCopy\nCells(Rows.Count, c).\nEnd(3)(3)\n'추출한 중복 개수를 Sheet1 각 열에 복사\n.Cells.\nClear\n'Sheet2의 임시 데이터 삭제\nEnd With\nNext c\nSet rngAll = Nothing\n'개체변수 초기화 (메모리 비우기)\nEnd Sub", "context": "앞서,\nDo .. Loop 구문사용,\nDo .. Loop의 중첩사용,\nDo .. Loop의 2번 중첩사용,\n중복제거(Remove Duplicates) method와 CountIf 함수를 사용,\nStrComp function과 동적배열을 사용,\n피벗(pivot)테이블을 사용하여 누적된 숫자의 중복개수를 구하여 보았다.\n이번에는\n부분합(sub-total)\n을 이용하여 동일한 기능을 구현해 보았다.\n매크로 실행 전                                                    매크로 실행 후\nOption Explicit\nSub count_Of_Dupes7()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rowsCnt  As Long\n'전체 행의 개수를 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim c As Integer\n'열(c)olumn 늘려갈 변수\nApplication.ScreenUpdating..."}
{"instruction": "Excel VBA code for: (811) 열방향 누적된 숫자의 중복개수 구하기 8 (엑셀 VBA 매크로)", "input": "", "output": "Sub count_Of_Dupes8()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim rowsCnt  As Long\n'전체 행의 개수를 넣을 변수\nDim c As Integer\n'열개수 많큼 반복할 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim rngA As Range\n'columndifferences 영역 넣을 변수\nDim lngNo As Long\n'columndifferences 영역의 셀 개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = ActiveSheet.UsedRange\n'전체영역을 변수에 넣음\nrowsCnt = rngAll.Rows.Count\n'전체 행의 개수를 변수에 넣음\ncolsCnt = rngAll.Columns.Count\n'전체 열 개수를 변수에 넣음\nCells(rowsCnt + 2, 1).Resize(, colsCnt) = \"S\"\n'임시로 문자삽입\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nr = 1\n'1행 부터 시작\nDo\nIf Cells(r, c) <> Cells(r + 1, c) Then\n'각 셀이 바로 아래 셀과 다르면\nSet rngA = rngAll.Columns(c).\nColumnDifferences\n(Cells(r, c))\n'각 셀과 열 값이 일치하지 않는 영역을 변수에 넣음\nlngNo =\nWorksheetFunction.Count\n(rngA)\n'각 셀과 열값이 일치하지 않는 셀의 개수\nCells(Rows.Count, c).End(3)(2) = rowsCnt - lngNo\n'반복횟수를 셀에 뿌림\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until Cells(r, 1) = vbNullString\n'각 열에 빈셀 나올때까지 무한 반복\nNext c\nRows(rowsCnt + 2).Delete\n'임시로 문자삽입한 행 삭제\nSet rngAll = Nothing\n'개체변수 초기화 (메모리 비우기)\nEnd Sub", "context": "앞서,\nDo .. Loop 구문사용,\nDo .. Loop의 중첩사용,\nDo .. Loop의 2번 중첩사용,\n중복제거(Remove Duplicates) method와 CountIf 함수를 사용,\nStrComp function과 동적배열을 사용,\n피벗(pivot)테이블을 사용,\n부분합(sub-total)을 사용하여 누적된 숫자의 중복개수를 구하여 보았다.\n이번에는\nWorksheetFunction.Count\nmethod와\nColumnDifferences\nmethod를 이용하여 동일한 기능을 구현해 보았다\n매크로 실행 전                                                    매크로 실행 후\nOption Explicit\nSub count_Of_Dupes8()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim rowsCnt  As Long\n'전체 행의 개수를 넣을 변수\nD..."}
{"instruction": "Excel VBA code for: (812) 열방향 누적된 숫자의 중복개수 구하기 9 (엑셀 VBA 매크로)", "input": "", "output": "Sub count_Of_Dupes9()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim rowsCnt  As Long\n'전체 행의 개수를 넣을 변수\nDim c As Integer\n'열개수 많큼 반복할 변수\nDim rngA As Range\n'각 (A)rea를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nRows(1).Insert\n'임시행 삽입\nSet rngAll = ActiveSheet.UsedRange\n'전체영역을 변수에 넣음\nrowsCnt = rngAll.Rows.Count\n'전체 행의 개수를 변수에 넣음\ncolsCnt = rngAll.Columns.Count\n'전체 열 개수를 변수에 넣음\nCells(rowsCnt + 2, 1).Resize(, colsCnt) = \"S\"\n'임시로 문자삽입\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nFor Each rngC In rngAll.Columns(c).\nCells\n'각 열의 각셀을 순환\nWith Cells(Rows.Count, c + colsCnt)\n'각 셀이 복사될 지점\nIf rngC = rngC.Offset(-1) Then\n'각 셀이 윗값하고 같으면\n.\nEnd(3)(2)\n= rngC\n'연속하여 데이터 복사\nElse\n'각 셀이 윗값하고 다르면\n.\nEnd(3)(3)\n= rngC\n'1행씩 건너 뛰면서 복사\nEnd If\nEnd With\nNext rngC\nFor Each rngA In Columns(c + colsCnt).SpecialCells(2).\nAreas\n'복사영역 각 열의 각 area 순환\nCells(Rows.Count, c).End(3)(2) =\nrngA.Count\n'각 영역의 개수를 셀에 뿌림\nNext rngA\nNext c\nCells(1, colsCnt + 1).Resize(, colsCnt).EntireColumn.ClearContents\n'임시로 복사한 데이터들 삭제\nRows(rowsCnt + 2).ClearContents\n'임시로 문자삽입한 행 삭제\nRows(1).Delete\n'임시로 삽입한 행 삭제\nSet rngAll = Nothing\n'개체변수 초기화 (메모리 비우기)\nEnd Sub", "context": "앞서,\nDo .. Loop 구문사용,\nDo .. Loop의 중첩사용,\nDo .. Loop의 2번 중첩사용,\n중복제거(Remove Duplicates) method와 CountIf 함수를 사용,\nStrComp function과 동적배열을 사용,\n피벗(pivot)테이블을 사용,\n부분합(sub-total)을 사용,\nWorksheetFunction.Count method와 ColumnDifferences method를 사용하여 누적된 숫자의 중복개수를 구하여 보았다.\n이번에는\nItem\nproperty(End(3)(2)와 End(3)(3) 사용) 및\nAreas\ncollection을 이용하여 동일한 기능을 구현해 보았다\n매크로 실행 전                                                    매크로 실행 후\nOption Explicit\nSub count_Of_Dupes9()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rngC As Ra..."}
{"instruction": "Excel VBA code for: (814) 열방향 누적된 숫자의 중복개수 구하기 10 (엑셀 VBA 매크로)", "input": "", "output": "Sub count_Of_Dupes10()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rngCol As Range\n'각 열을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim rowsCnt  As Long\n'전체 행의 개수를 넣을 변수\nDim c As Integer\n'열개수 많큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nRows(1).Insert\n'임시행 삽입\nCells(1, 1).Resize(, ActiveSheet.UsedRange.Columns.Count) = \"S\"\n'임시로 문자삽입\nSet rngAll = ActiveSheet.UsedRange\n'전체영역을 변수에 넣음\nrowsCnt = rngAll.Rows.Count\n'전체 행의 개수를 변수에 넣음\ncolsCnt = rngAll.Columns.Count\n'전체 열 개수를 변수에 넣음\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nFor Each rngCol In rngAll.Columns(c)\n'각 열을 순환\nrngCol.SpecialCells(2).\nAdvancedFilter\n2, rngCol, Cells(rowsCnt + 2, c), 1\n'고급필터를 이용 유일한 목록만 추출\nNext rngCol\nWith Columns(c).SpecialCells(2).\nAreas(2)\n'각 열의 2번째 영역에서\nFor Each rngC In .Offset(1).Resize(.Rows.Count - 1)\n'복사영역 각열의 각 셀을 순환\nrngAll.Columns(c).\nAutoFilter\n1, rngC, , , 1\n'각 열을 셀값에 따라 필터링\nrngC = rngAll.Columns(c).\nSpecialCells(12)\n.Cells.Count - 1\n'보이는 셀 개수 - 1을 각 셀에 입력\nNext rngC\nEnd With\nNext c\nRows(rowsCnt + 2).Delete\n'불필요한 문자행 삭제\nRows(1).Delete\n'임시로 삽입한 행 삭제\nCells(Rows.Count, 1).End(3).CurrentRegion.\nBorders.LineStyle = 0\n'(불필요하게 복사된 )외곽선 테두리 삭제\nSet rngAll = Nothing\n'개체변수 초기화 (메모리 비우기)\nEnd Sub", "context": "앞서,\nDo .. Loop 구문사용,\nDo .. Loop의 중첩사용,\nDo .. Loop의 2번 중첩사용,\n중복제거(Remove Duplicates) method와 CountIf 함수를 사용,\nStrComp function과 동적배열을 사용,\n피벗(pivot)테이블을 사용,\n부분합(sub-total)을 사용,\nWorksheetFunction.Count method와 ColumnDifferences method를 사용,\nItem property(End(3)(2)와 End(3)(3) 사용) 및 Areas collection을 사용하여 누적된 숫자의 중복개수를 구하여 보았다.\n이번에는\n고급필터(A\ndvancedF\nilter)\n와\n자동필터(AutoFilter)\n를 이용하여 동일한 기능을 구현해 보았다\n매크로 실행 전                                                    매크로 실행 후\nOption Explicit\nSub count_Of_Dupes10()..."}
{"instruction": "Excel VBA code for: (815) 열방향 누적된 숫자의 중복개수 구하기 11 (엑셀 VBA 매크로)", "input": "", "output": "Sub count_Of_Dupes11()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim rowsCnt  As Long\n'전체 행의 개수를 넣을 변수\nDim c As Integer\n'열개수 많큼 반복할 변수\nDim rngEach As Range\n'(조건부서식 적용 판단시)각 셀을 넣을 변수\nDim cnt As Long\n'카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = ActiveSheet.UsedRange\n'전체영역을 변수에 넣음\nrowsCnt = rngAll.Rows.Count\n'전체 행의 개수를 변수에 넣음\ncolsCnt = rngAll.Columns.Count\n'전체 열 개수를 변수에 넣음\nCells(rowsCnt + 1, 1).Resize(, colsCnt) = \"S\"\n'임시로 문자삽입\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nWith rngAll.Columns(c)\n'전체영역 각 열에서\nFor Each rngC In .Cells\n'각 셀을 순환\nIf rngC <> rngC.Offset(1) Then\n'아래위 셀값이 다르면\n.\nFormatConditions.Add\nType:=2, Formula1:=\n\"=\" & _\n.Cells(1).Address(0, 0) & \"=\" & rngC\n'조건부 서식을 적용\n.FormatConditions(1).Interior.ColorIndex = 3\n'내부 색을 빨간색으로 채움\nFor Each rngEach In .Cells\n'각 열의 각 셀을 순환\nIf rngEach.\nDisplayFormat\n.Interior.\nColorIndex <> xlNone\nThen\n'각 셀에 색이 채워져 있으면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nEnd If\nNext rngEach\nCells(Rows.Count, c).End(3)(2) = cnt\n'카운터의 값을 셀에 뿌림\n.\nFormatConditions.Delete\n'조건부서식을 제거\ncnt = 0\n'재사용 위하여 카운터 초기화\nEnd If\nNext rngC\nEnd With\nNext c\nRows(rowsCnt + 1).ClearContents\n'임시로 삽입한 문자 삭제\nSet rngAll = Nothing\n'개체변수 초기화 (메모리 비우기)\nEnd Sub", "context": "앞서,\nDo .. Loop 구문사용,\nDo .. Loop의 중첩사용,\nDo .. Loop의 2번 중첩사용,\n중복제거(Remove Duplicates) method와 CountIf 함수를 사용,\nStrComp function과 동적배열을 사용,\n피벗(pivot)테이블을 사용,\n부분합(sub-total)을 사용,\nWorksheetFunction.Count method와 ColumnDifferences method를 사용,\nItem property(End(3)(2)와 End(3)(3) 사용) 및 Areas collection을 사용,\n고급필터와 자동필터를 사용하여 누적된 숫자의 중복개수를 구하여 보았다.\n이번에는\n조건부서식\n및\nDisplayFormat\nproperty를 이용하여 동일한 기능을 구현해 보았다\n매크로 실행 전                                                    매크로 실행 후\nOption Explicit\nSub count_Of_Dupes..."}
{"instruction": "Excel VBA code for: (817) 사이사이에 선택영역 셀값 삽입하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Alternative_Line()\nDim rngT As Range\n'복사위치를 넣을 변수\nDim i As Long\n'선택영역의 셀 개수만큼 반복할 변수\nDim r As Long\n'복사될 위치에서 건너뛸(offset) 행의 개수 넣을 변수\nIf Selection.Columns.Count > 1 Then\n'1열 초과하여 열을 선택 시\nMsgBox \"1개의 열만 선택해야합니다.\", 64, \"영역선택 오류\"\n'에러메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet rngT = Application.\nInputBox\n(\"마우스로 복사위치를 선택하시오!\", Type:=8)\nIf\nrngT Is Nothing\nThen Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor i = 1 To Selection.Count\n'선택영역 셀 개수만큼 반복\nIf r = 0 Then\n'r이 0이면\nr = r + 1\n'r의 값을 1씩 늘려가고\nElse\n'r이 0이 아니면\nr = r + 2\n'r의 값을 2씩 늘려간다\nEnd If\nrngT.Offset(r).\nInsert\nshift:=\nxlDown\n'셀을 아래로 밀면서 삽입\nrngT.Offset(r) = Selection.\nCells(i)\n'각 셀에 선택영역의 셀값을 복사\nNext i\nEnd Sub", "context": "선택한 영역을 복사위치에 한 행씩 건너 뛰면서 삽입해주는 기능. 선택영역은 1개의 열만 선택해야함.\n매크로 실행 전 (영역을 먼저 선택)      매크로 실행후 입력창 나타남      선택영역 값을 사이사이 삽입\n(선택영역이 삽입될 위치 선택)\n매크로 실행 전 (영역을 먼저 선택)      매크로 실행후 입력창 나타남      선택영역 값을 사이사이 삽입\n(선택영역이 삽입될 위치 선택)\nOption Explicit\nSub insert_Alternative_Line()\nDim rngT As Range\n'복사위치를 넣을 변수\nDim i As Long\n'선택영역의 셀 개수만큼 반복할 변수\nDim r As Long\n'복사될 위치에서 건너뛸(offset) 행의 개수 넣을 변수\nIf Selection.Columns.Count > 1 Then\n'1열 초과하여 열을 선택 시\nMsgBox \"1개의 열만 선택해야합니다.\", 64, \"영역선택 오류\"\n'에러메시지 출력\nExit Sub\n'매크로 중단\nEn..."}
{"instruction": "Excel VBA code for: (820) 마지막 시트에 앞의 시트내용 모두넣기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_Sheets_All()\nDim i As Long\n'시트 개수만큼 반복할 변수\nDim rngC As Range\n'각 시트의 각 셀을 넣을 변수\nDim vbYN As Integer\n'에러 발생시 msgbox 응답 결과 넣을 변수\nFor i = 1 To Sheets.Count - 1\n'전체시트 개수 -1 만큼 반복\nFor Each rngC In Sheets(i).UsedRange.SpecialCells(2)\n'각 시트의 데이터 입력된 각 셀을 순환\nWith Sheets(Sheets.Count)\n'마지막 시트에서\nIf\nIsEmpty\n(.Range(rngC.\nAddress\n)) Then\n'각 셀이 빈셀일 경우에는\nrngC.Copy .Range(rngC.Address)\n'각 시트의 값을 마지막 시트에 복사\nElse\n'각 셀이 빈셀이 아닐 경우에는\nvbYN =\nMsgBox\n(\"통합시트 셀 \" & rngC.Address(0, 0) & \"에 이미\"\n& vbCr\n_\n& \" 데이터가 있습니다. 덮어쓸까요?\",\n64 + vbYesNo + 256\n, \"오류\")\n'덮어쓸지 사용자 의견을 물음\nIf vbYN = 6 Then\n'사용자가 Yes를 선택 시\nrngC.Copy .Range(rngC.Address)\n'기존 데이터에 덮어씀\nElse\n'사용자가 No를 선택 시\nMsgBox \"매크로를 중단합니다.\"\n'중단 메시지 출력\nExit Sub\n'매크로를 중단함\nEnd If\nEnd If\nEnd With\nNext rngC\nNext i\nEnd Sub", "context": "마지막 시트에 (앞에 시트가 몇 개가 있던지, 또는 어디에 데이터가 입력되어 있던지) 앞에 있는 시트들의 내용을 모두 합쳐 넣는 기능. 서식도 함께 복사되어야 함.\n매크로 실행 전 Sheet1                             매크로 실행전 Sheet2\n매크로 실행 전 Sheet3                             매크로 실행전 Sheet4\n매크로 실행후 결과 (Sheet4)                          이미 데이터 있을 경우 덮어쓸지 묻는 메시지창 출력\nOption Explicit\nSub combine_Sheets_All()\nDim i As Long\n'시트 개수만큼 반복할 변수\nDim rngC As Range\n'각 시트의 각 셀을 넣을 변수\nDim vbYN As Integer\n'에러 발생시 msgbox 응답 결과 넣을 변수\nFor i = 1 To Sheets.Count - 1\n'전체시트 개수 -1 만큼 반복\nFor Each rngC ..."}
{"instruction": "Excel VBA code for: (821) 문자 분리후 개수 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Plus_And_Count()\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim i As Long\n'각 셀의 문자길이 만큼 반복할 변수\nDim str As String\n'각 문자를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"B:C\").ClearContents\n'기존 데이터 삭제\nFor Each rngC In Columns(\"A\").SpecialCells(2)\n'A열 각 셀을 순환\nFor i = 1 To Len(rngC)\n'각 셀의 문자길이 만큼 반복\nstr = Mid(rngC, i, 1)\n'각 문자를 변수에 넣음\nIf str <> \"+\" Then\n'각 문자가 \"+\"가 아닐 경우\nCells(Rows.Count, 2).End(3)(2).Resize(, 2) = str\n'B:C열에 각 숫자를 넣음\nEnd If\nNext i\nNext rngC\nWith Columns(\"C\").SpecialCells(2)\n'C열의 각 문자를\n.\nRemoveDuplicates\n1, xlNo\n'제목없이 중복 제거\n.\nSort\n[C1], 1\n'오름차순으로 정렬\nFor Each rngC In Columns(\"C\").SpecialCells(2)\n'C열 각 문자를 순환\nrngC.Next = Application.\nCountIf\n(Columns(\"B\").SpecialCells(2), rngC)\n'각 셀의 중복개수를 추출하여 셀에 뿌림\nNext rngC\nEnd With\nColumns(\"B\").Delete\n'임시로 사용한 데이터 삭제\nEnd Sub", "context": "(오늘은 본업인 시험장비 영업을 위해 분주했던 하루였다. \"자본주의 사상에 입각하여\" 이 돈안되는 VBA에 투자하는 시간을 본업에 쏟아부어야 하는데 ........ 가끔 VBA를 열심히 공부하는 나보다 가만 내버려두는 집사람이 사실 더 존경스럽다는 생각이 든다. 물론 못하게 해도 하겠지만 ... ^^)\nSplit function을 사용해 배열에 넣거나 다른 여러가지 방법이 있겠지만 아래와 같이 해봤다. 별 특별한 코드가 없는 평이한 방식을 사용함.\n매크로 실행 전                                              매크로 실행 후\nOption Explicit\nSub remove_Plus_And_Count()\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim i As Long\n'각 셀의 문자길이 만큼 반복할 변수\nDim str As String\n'각 문자를 넣을 변수\nApplication.ScreenUpdating = False\n'화면..."}
{"instruction": "Excel VBA code for: (822) 따옴표로 표시된 셀을 윗셀값으로 채우기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_Delivery_Place()\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each rngC In Columns(\"B\").SpecialCells(2)\n'B열의 각 셀을 순환\nIf rngC =\n\"\"\"\"\nThen\n'각 셀값이 큰 따옴표일 경우\nrngC = rngC.Offset(-1)\n'윗 셀의 값을 복사\nEnd If\nNext rngC\nEnd Sub", "context": "윗셀과 동일한 값이라 표시하기 위하여 많은 셀에 큰 따옴표가 입력되어 있는 상황. B열에 큰 따옴표가 있을 경우 이를 윗셀값으로 채우는 기능. 아래 코드는 너무 단순해 설명할게 전혀 없지만, 코드창에서 큰 따옴표 검출시\n\"\"\"\"\n라고 4번이나 연속으로 넣은 것 참조.\n매크로 실행 전                                                         매크로 실행 후 결과\nOption Explicit\nSub fill_Delivery_Place()\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each rngC In Columns(\"B\").SpecialCells(2)\n'B열의 각 셀을 순환\nIf rngC =\n\"\"\"\"\nThen\n'각 셀값이 큰 따옴표일 경우\nrngC = rngC.Offset(-1)\n'윗 셀의 값을 복사\nEnd If\nNext rngC\nE..."}
{"instruction": "Excel VBA code for: (823) 따옴표로 표시된 셀을 윗셀값으로 채우기 2 (엑셀 VBA 매크로)", "input": "", "output": "function 및\nFilldown\nmethod를 이용하여 동일한 결과를 아래와 같이 구하여 보았다. 물론 앞서한 1번 코드가 정답이지만 응용력을 기르기 위해 다양한 방식으로 동일한 결과를 구해보는 것임.\n매크로 실행 전                                                         매크로 실행 후 결과\nOption Explicit\nSub fill_Delivery_Place1()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'A열의 각 번호별 개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, 1).End(3).Row\n'마지막 행을 변수에 넣음\nFor r = lastRow To 2\nStep -1\n'마지막 행부터 2행까지 위로 1씩 올라가며 반복\ni = i + 1\n'A열의 각 번호별 개수를 하나씩 늘려감\nIf\nLen\n(Cells(r, 1))\n> 8\nAnd\nLen\n(Cells(r - 1, 1))\n< 8\nThen\n'아랫셀은 8보다 길고, 윗셀은 8보다 작으면\nCells(r, 1).Resize(i).Offset(, 1).\nFillDown\n'B열을 아래로 채우기\ni = 0\n'재사용 위하여 초기화\nEnd If\nNext r\nEnd Sub", "context": "(윗셀과 동일한 값이라 표시하기 위하여 많은 셀에 큰 따옴표가 입력되어 있는 상황. B열에 큰 따옴표가 있을 경우 이를 윗셀값으로 채우는 기능.)\n앞서,\n가장 기본 기능인  If rngC = \"\"\"\" Then 을 이용하여 원하는 결과를 얻었다.\n이번에는\nFor .. Next\n구문,\nLen\nfunction 및\nFilldown\nmethod를 이용하여 동일한 결과를 아래와 같이 구하여 보았다. 물론 앞서한 1번 코드가 정답이지만 응용력을 기르기 위해 다양한 방식으로 동일한 결과를 구해보는 것임.\n매크로 실행 전                                                         매크로 실행 후 결과\nOption Explicit\nSub fill_Delivery_Place1()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'A열의 각 번호별 개수 구할 변수\nApplic..."}
{"instruction": "Excel VBA code for: (824) 따옴표로 표시된 셀을 윗셀값으로 채우기 3 (엑셀 VBA 매크로)", "input": "", "output": "function 및 Filldown method를 이용하여 동일한 결과를 구하여 보았다.\n아래에서는\nDo 중첩\n및\nLike operator\n를 사용해 동일한 결과를 구해보았다. (물론 앞서한 1번 코드가 정답이지만 응용력을 기르기 위해 다양한 방식으로 동일한 결과를 구해보는 것임.)\n매크로 실행 전                                                         매크로 실행 후 결과\nOption Explicit\nSub fill_Delivery_Place2()\nDim r As Long\n'행 늘려갈 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 1\n'1행부터 시작\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nIf Cells(r, 2)\nLike\n\"[A-Z]\"\nThen\n'각 셀값이 A-Z 문자일 경우\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nCells(r, 2) = Cells(r - 1, 2)\n'아랫셀에 윗셀값 복사\nLoop Until\nCells(r + 1, 2) Like \"[A-Z]\" Or Cells(r + 1, 2) = vbNullString\n'다음 A-Z 나오거나 빈셀 나올때까지 무한 반복\nEnd If\nLoop Until\nCells(r, 1) = vbNullString\n'빈셀 나올때까지 무한 반복\nEnd Sub", "context": "(윗셀과 동일한 값이라 표시하기 위하여 많은 셀에 큰 따옴표가 입력되어 있는 상황. B열에 큰 따옴표가 있을 경우 이를 윗셀값으로 채우는 기능.)\n앞서,\n가장 기본 기능인  If rngC = \"\"\"\" Then 을 이용,\nFor .. Next 구문, Len function 및 Filldown method를 이용하여 동일한 결과를 구하여 보았다.\n아래에서는\nDo 중첩\n및\nLike operator\n를 사용해 동일한 결과를 구해보았다. (물론 앞서한 1번 코드가 정답이지만 응용력을 기르기 위해 다양한 방식으로 동일한 결과를 구해보는 것임.)\n매크로 실행 전                                                         매크로 실행 후 결과\nOption Explicit\nSub fill_Delivery_Place2()\nDim r As Long\n'행 늘려갈 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdati..."}
{"instruction": "Excel VBA code for: (825) 따옴표로 표시된 셀을 윗셀값으로 채우기 4 (엑셀 VBA 매크로)", "input": "", "output": "function 및 Filldown method를 이용,\nDo 중첩 및 Like operator를 이용하여 동일한 결과를 구하여 보았다.\n아래에서는 좌우 셀의 길이가 같은 것을 이용해\nLen function\n과\nItem\nproperty를 사용해 동일한 결과를 구해보았다. (물론 앞서한 1번 코드가 정답이지만 응용력을 기르기 위해 다양한 방식으로 동일한 결과를 구해보는 것임.)\n매크로 실행 전                                                         매크로 실행 후 결과\nOption Explicit\nSub fill_Delivery_Place3()\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each rngC In Columns(\"B\").SpecialCells(2)\n'B열의 각 셀을 순환\nIf\nLen(rngC.Previous) = Len(rngC)\nThen\n'좌우 셀의 문자길이가 같을 경우\nrngC = rngC\n(0, 1)\n'윗 셀의 값을 복사\nEnd If\nNext rngC\nEnd Sub", "context": "(윗셀과 동일한 값이라 표시하기 위하여 많은 셀에 큰 따옴표가 입력되어 있는 상황. B열에 큰 따옴표가 있을 경우 이를 윗셀값으로 채우는 기능.)\n앞서,\n가장 기본 기능인  If rngC = \"\"\"\" Then 을 이용,\nFor .. Next 구문, Len function 및 Filldown method를 이용,\nDo 중첩 및 Like operator를 이용하여 동일한 결과를 구하여 보았다.\n아래에서는 좌우 셀의 길이가 같은 것을 이용해\nLen function\n과\nItem\nproperty를 사용해 동일한 결과를 구해보았다. (물론 앞서한 1번 코드가 정답이지만 응용력을 기르기 위해 다양한 방식으로 동일한 결과를 구해보는 것임.)\n매크로 실행 전                                                         매크로 실행 후 결과\nOption Explicit\nSub fill_Delivery_Place3()\nDim rngC As Range\n'각 셀을 넣..."}
{"instruction": "Excel VBA code for: (826) 따옴표로 표시된 셀을 윗셀값으로 채우기 5 (엑셀 VBA 매크로)", "input": "", "output": "function 및 Filldown method를 이용,\nDo 중첩 및 Like operator를 이용,\nLen function과 Item property를 사용해 동일한 결과를 구하여 보았다.\n아래에서는\nAsc function\n을 사용해 동일한 결과를 구해보았다. (물론 앞서한 1번 코드가 정답이지만 응용력을 기르기 위해 다양한 방식으로 동일한 결과를 구해보는 것임.)\n매크로 실행 전                                                         매크로 실행 후 결과\nOption Explicit\nSub fill_Delivery_Place4()\nDim rngAll As Range\n'B열 전체영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Range([B2], Cells(Rows.Count, \"B\").End(3))\n'전체영역을 변수에 넣음\nFor Each rngC In rngAll\n'B열의 각 셀을 순환\nIf\nAsc\n(Left(rngC, 1))\n< 65\nOr\n_\nAsc(Left(rngC, 1))\n> 90\nThen\n'만일 각 셀이 알파벳 대문자가 아닐경우\nrngC = rngC.Offset(-1).Value\n'윗 셀의 값을 복사\nEnd If\nNext rngC\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "(윗셀과 동일한 값이라 표시하기 위하여 많은 셀에 큰 따옴표가 입력되어 있는 상황. B열에 큰 따옴표가 있을 경우 이를 윗셀값으로 채우는 기능.)\n앞서,\n가장 기본 기능인  If rngC = \"\"\"\" Then 을 이용,\nFor .. Next 구문, Len function 및 Filldown method를 이용,\nDo 중첩 및 Like operator를 이용,\nLen function과 Item property를 사용해 동일한 결과를 구하여 보았다.\n아래에서는\nAsc function\n을 사용해 동일한 결과를 구해보았다. (물론 앞서한 1번 코드가 정답이지만 응용력을 기르기 위해 다양한 방식으로 동일한 결과를 구해보는 것임.)\n매크로 실행 전                                                         매크로 실행 후 결과\nOption Explicit\nSub fill_Delivery_Place4()\nDim rngAll As Range\n'B열 전체영역..."}
{"instruction": "Excel VBA code for: (827) 따옴표로 표시된 셀을 윗셀값으로 채우기 6 (엑셀 VBA 매크로)", "input": "", "output": "function 및 Filldown method를 이용,\nDo 중첩 및 Like operator를 이용,\nLen function과 Item property를 이용,\nAsc function을 사용해 동일한 결과를 구하여 보았다.\n아래에서는\nReplace\nfunction과\nSpecialCells(4)\nmethod, 즉 공백셀 선택 기능을 사용해 동일한 결과를 구해보았다. (물론 앞서한 1번 코드가 정답이지만 응용력을 기르기 위해 다양한 방식으로 동일한 결과를 구해보는 것임.)\n매크로 실행 전                                                         매크로 실행 후 결과\nOption Explicit\nSub fill_Delivery_Place5()\nDim rngC As Range                             '각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"B\").\nReplace\n\"\"\"\", \"\"\n'B열의 따옴표를 모두 삭제\nFor Each rngC In Columns(\"B\").\nSpecialCells(4)\n'B열의 빈 셀을 순환\nIf rngC = \"\" Then\n'각 셀이 빈셀이면\nrngC = rngC.Offset(-1).Value\n'윗 셀의 값을 복사\nEnd If\nNext rngC\nEnd Sub", "context": "(윗셀과 동일한 값이라 표시하기 위하여 많은 셀에 큰 따옴표가 입력되어 있는 상황. B열에 큰 따옴표가 있을 경우 이를 윗셀값으로 채우는 기능.)\n앞서,\n가장 기본 기능인  If rngC = \"\"\"\" Then 을 이용,\nFor .. Next 구문, Len function 및 Filldown method를 이용,\nDo 중첩 및 Like operator를 이용,\nLen function과 Item property를 이용,\nAsc function을 사용해 동일한 결과를 구하여 보았다.\n아래에서는\nReplace\nfunction과\nSpecialCells(4)\nmethod, 즉 공백셀 선택 기능을 사용해 동일한 결과를 구해보았다. (물론 앞서한 1번 코드가 정답이지만 응용력을 기르기 위해 다양한 방식으로 동일한 결과를 구해보는 것임.)\n매크로 실행 전                                                         매크로 실행 후 결과\nOption Explic..."}
{"instruction": "Excel VBA code for: (828) 따옴표로 표시된 셀을 윗셀값으로 채우기 7 (엑셀 VBA 매크로)", "input": "", "output": "function 및 Filldown method를 이용,\nDo 중첩 및 Like operator를 이용,\nLen function과 Item property를 이용,\nAsc function을 사용,\nReplace 와 SpecialCells(4)를 사용해 동일한 결과를 구하여 보았다.\n아래에서는\nReplace,\nSpecialCells(4)\n및\nFormulaR1C1 property\n를 사용해 동일한 결과를 구해보았다. (물론 앞서한 1번 코드가 정답이지만 응용력을 기르기 위해 다양한 방식으로 동일한 결과를 구해보는 것임.)\n매크로 실행 전                                                         매크로 실행 후 결과\nOption Explicit\nSub fill_Delivery_Place6()\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"B\").\nReplace\n\"\"\"\", \"\"\n'B열의 따옴표를 모두 삭제\nColumns(\"B\").SpecialCells(4).\nFormulaR1C1\n=\n\"=R[-1]C\n\"\n'B열의 빈 셀을 윗셀로 복사\nEnd Sub", "context": "(윗셀과 동일한 값이라 표시하기 위하여 많은 셀에 큰 따옴표가 입력되어 있는 상황. B열에 큰 따옴표가 있을 경우 이를 윗셀값으로 채우는 기능.)\n앞서,\n가장 기본 기능인  If rngC = \"\"\"\" Then 을 이용,\nFor .. Next 구문, Len function 및 Filldown method를 이용,\nDo 중첩 및 Like operator를 이용,\nLen function과 Item property를 이용,\nAsc function을 사용,\nReplace 와 SpecialCells(4)를 사용해 동일한 결과를 구하여 보았다.\n아래에서는\nReplace,\nSpecialCells(4)\n및\nFormulaR1C1 property\n를 사용해 동일한 결과를 구해보았다. (물론 앞서한 1번 코드가 정답이지만 응용력을 기르기 위해 다양한 방식으로 동일한 결과를 구해보는 것임.)\n매크로 실행 전                                                        ..."}
{"instruction": "Excel VBA code for: (829) 따옴표로 표시된 셀을 윗셀값으로 채우기 8 (엑셀 VBA 매크로)", "input": "", "output": "function 및 Filldown method를 이용,\nDo 중첩 및 Like operator를 이용,\nLen function과 Item property를 이용,\nAsc function을 사용,\nReplace 와 SpecialCells(4)를 사용,\nReplace, SpecialCells(4), FormulaR1C1를 사용해 동일한 결과를 구하여 보았다.\n아래에서는\nDo\n..\nLoop\n와\nFind method\n를 사용해 동일한 결과를 구해보았다. (물론 앞서한 1번 코드가 정답이지만 응용력을 기르기 위해 다양한 방식으로 동일한 결과를 구해보는 것임.)\n매크로 실행 전                                                         매크로 실행 후 결과\nOption Explicit\nSub fill_Delivery_Place7()\nDim C As Range\n'검색하여 찾은 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n﻿\nDo\n'다음을 실행\nSet C = Columns(\"B\").\nFind\n(What:=\"\"\"\", LookAt:=xlWhole)\n'일치하는 데이터를 B열에서 찾아 C에 넣고\nIf C Is Nothing Then\n'만약 일치하는 데이터가 없으면\nExit Sub\n'매크로 중단\nElse\n'일치하는 데이터 있을 경우\nC = C.Offset(-1)\n'검색으로 찾은 셀에 윗셀값 복사\nEnd If\nLoop\nEnd Sub", "context": "(윗셀과 동일한 값이라 표시하기 위하여 많은 셀에 큰 따옴표가 입력되어 있는 상황. B열에 큰 따옴표가 있을 경우 이를 윗셀값으로 채우는 기능.)\n앞서,\n가장 기본 기능인  If rngC = \"\"\"\" Then 을 이용,\nFor .. Next 구문, Len function 및 Filldown method를 이용,\nDo 중첩 및 Like operator를 이용,\nLen function과 Item property를 이용,\nAsc function을 사용,\nReplace 와 SpecialCells(4)를 사용,\nReplace, SpecialCells(4), FormulaR1C1를 사용해 동일한 결과를 구하여 보았다.\n아래에서는\nDo\n..\nLoop\n와\nFind method\n를 사용해 동일한 결과를 구해보았다. (물론 앞서한 1번 코드가 정답이지만 응용력을 기르기 위해 다양한 방식으로 동일한 결과를 구해보는 것임.)\n매크로 실행 전                                    ..."}
{"instruction": "Excel VBA code for: (831) 따옴표로 표시된 셀을 윗셀값으로 채우기 10 (엑셀 VBA 매크로)", "input": "", "output": "function 및 Filldown method를 이용,\nDo 중첩 및 Like operator를 이용,\nLen function과 Item property를 이용,\nAsc function을 이용,\nReplace 와 SpecialCells(4)를 이용,\nReplace, SpecialCells(4), FormulaR1C1를 이용,\nDo .. Loop와 Find method를 이용,\n조건부서식(Conditional Formating)을 이용해 동일한 결과를 구하여 보았다.\n아래에서는\nReplace\n,\nSpecialCells(4)\n,\nAreas\ncollection\n을 사용해 동일한 결과를 구해보았다. (물론 앞서한 1번 코드가 정답이지만 응용력을 기르기 위해 다양한 방식으로 동일한 결과를 구해보는 것임.)\n매크로 실행 전                                                         매크로 실행 후 결과\nOption Explicit\nSub fill_Delivery_Place9()\nDim rngA As Range\n'각 area를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"B\").\nReplace\n\"\"\"\"\n, \"\"\n'B열의 따옴표를 모두 삭제\nFor Each rngA In Columns(\"B\").SpecialCells(4).\nAreas\n'B열의 빈 셀 area를 순환\nrngA = rngA.Cells(1).Offset(-1)\n'각 빈셀 area의 윗셀 값을 area에 복사\nNext rngA\nEnd Sub", "context": "(윗셀과 동일한 값이라 표시하기 위하여 많은 셀에 큰 따옴표가 입력되어 있는 상황. B열에 큰 따옴표가 있을 경우 이를 윗셀값으로 채우는 기능.)\n앞서,\n가장 기본 기능인  If rngC = \"\"\"\" Then 을 이용,\nFor .. Next 구문, Len function 및 Filldown method를 이용,\nDo 중첩 및 Like operator를 이용,\nLen function과 Item property를 이용,\nAsc function을 이용,\nReplace 와 SpecialCells(4)를 이용,\nReplace, SpecialCells(4), FormulaR1C1를 이용,\nDo .. Loop와 Find method를 이용,\n조건부서식(Conditional Formating)을 이용해 동일한 결과를 구하여 보았다.\n아래에서는\nReplace\n,\nSpecialCells(4)\n,\nAreas\ncollection\n을 사용해 동일한 결과를 구해보았다. (물론 앞서한 1번 코드가 정답이지만 ..."}
{"instruction": "Excel VBA code for: (832) 복수의 자동필터(autofilter) 조건 설정하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub multiple_Filter1()\nDim tbl As\nListObject\n'각 차트를 넣을 변수\nFor Each tbl In ActiveSheet.\nListObjects\n'현재시트의 각 차트를 순환\ntbl.Range.\nAutoFilter\nField:=1, Criteria1:=\"<=\" & [G1], _\nOperator:=xlFilterValues\n'각 차트의 1번 열(필드)에 자동필터 적용\nNext tbl\nEnd Sub\n\nSub release_Autofilter()\nDim tbl As ListObject\n'각 차트를 넣을 변수\nFor Each tbl In ActiveSheet.ListObjects\n'현재시트의 각 차트를 순환\ntbl.Range.AutoFilter Field:=1\n'각 차트의 필터를 해제\nNext tbl\nEnd Sub", "context": "한 시트에서 자동필터(autofilter)는 하나만 적용이 된다. 복수의 자동필터를 적용하려면 여러 개의 표(table)을 이용하는 방법 이외에는 없다고 알고 있다. 그런데 표의 조건(criteria)이 개수가 많을 경우 자신이 원하는 조건의 데이터만을 선택할 때 일일이 필터 창을 열어 마우스로 하나 하나 클릭하거나 조건을 변경하는 것은 상당히 귀찮은 작업이다. 매크로를 사용하면 조금 더 손쉽게 작업할 수 있다.\n문자 조건(갑, 을, ..)을 기준으로 필터링하기 원한 경우 아래와 같이 숫자와 문자를 병행해 입력하고 숫자를 기준으로 필터링을 하면 된다. 테이블은 인쇄영역 밖이므로 이렇게 해도 상관없다. 아래의 시트에는 3개의 표(table)를 사용함. G1셀에 숫자 입력하고 \"필터 적용\" 버튼을 클릭하면 된다.\n매크로 실행 전 (모두 펼쳐진 상태) \"필터 제거\" 버튼 클릭 시 모든 필터링이 해제된다.\n매크로 실행 후 (1을 선택하였을 때)                      매크로 ..."}
{"instruction": "Excel VBA code for: (833) 복수의 자동필터 개별적으로 필터링 조건 설정 (엑셀 VBA 매크로)", "input": "", "output": "Sub multiple_Filter2()\nDim tbl As\nListObject\n'각 차트를 넣을 변수\nFor Each tbl In ActiveSheet.ListObjects\n'현재시트의 각 차트를 순환\ntbl.Range.\nAutoFilter\nField:=1, Criteria1:=\"\n<=\n\" &\ntbl.Range.Cells(1).Offset(, 3)\n, _\nOperator:=xlFilterValues\n'각 차트의 1번 필드제목 오른쪽 3칸 떨어진 곳의 숫자 기준으로 자동필터 적용\nNext tbl\nEnd Sub\n\nSub release_Autofilter()\nDim tbl As ListObject\n'각 차트를 넣을 변수\nFor Each tbl In ActiveSheet.ListObjects\n'현재시트의 각 차트를 순환\ntbl.Range.AutoFilter Field:=1\n'각 차트의 필터를 해제\nNext tbl\nEnd Sub", "context": "한 시트에서 자동필터(autofilter)는 하나만 사용 가능하다. 그러므로, 복수의 자동필터를 적용하려면 여러 개의 표(table)를 이용해야 한다. 한 개의 자동필터로 시트 전체를 필터링 할 경우 모든 데이터를 일률적으로 동일하게 필터링하므로, 자신이 원하는 데이터만을 추출하기 어렵다. 아래와 같이 하면 여러 개의 자동필터를 자신이 원하는 조건으로 개별적으로 필터링 할 수 있다.\n매크로 실행 전 (모두 펼쳐진 상태) \"필터 제거\" 버튼 클릭 시 모든 필터링이 해제된다\n매크로 실행 후 (각 숫자에 따라 필터링 됨)          매크로 실행 후 (각 숫자에 따라 필터링 됨)\nOption Explicit\n'\"필터 적용\" 버튼에 연결된 매크로\nSub multiple_Filter2()\nDim tbl As\nListObject\n'각 차트를 넣을 변수\nFor Each tbl In ActiveSheet.ListObjects\n'현재시트의 각 차트를 순환\ntbl.Range.\nAutoFilter\n..."}
{"instruction": "Excel VBA code for: (835) 셀안의 숫자만큼 행 늘리고 셀병합하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_And_Merge_Cells()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim varTemp\n'전체영역을 넣을 배열 변수\nDim i As Long\n'배열 숫자만큼 반복할 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Range([A2], Cells(Rows.Count, \"B\").End(3))\n'제목 제외한 전체영역을 변수에\nvarTemp = rngAll\n'전체영역을 배열에 넣음\nrngAll.ClearContents\n'기존 데이터 삭제\nr = 2\n'2행부터 시작\nFor i = 1 To UBound(varTemp)\n'배열의 개수만큼 반복\nWith Cells(r, 1)\n'각 데이터가 복사될 셀위치\n.\nValue\n= varTemp(i, 1)\n'배열의 1열 값을 입력\n.Resize(varTemp(i, 2)).\nMerge\n'각 숫자만큼 A열 셀병합\n.\nNext\n.Value = varTemp(i, 2)\n'배열의 2열 값을 입력\n.Offset(, 1).Resize(varTemp(i, 2)).Merge\n'각 숫자만큼 B열 셀병합\nr = r + varTemp(i, 2)\n'행을 배열내 숫자만큼 늘려감\nEnd With\nNext i\n[A1].CurrentRegion.\nBorders.LineStyle = 1\n'전체 데이터에 외곽 테두리\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                                 매크로 실행 후\n위와 같은 작업 시 각 셀의 숫자 만큼 실제로 행을 삽입하는 것은 좋은 코드가 아니다. 전체행을 또는 일부 행을 삽입하는 것은 항상 속도가 떨어진다. 아래와 같이 배열에 넣는 것처럼 실제 행삽입을 하지 않고 행삽입 효과를 내는 다른 코드를 사용하는 것이 속도가 빠르다.\n아래와 같이 셀값을 바로 배열에 넣으면 1차원 배열이 아닌\n2차원 배열\n이 생성되는 것을 잊지말것.\nOption Explicit\nSub insert_And_Merge_Cells()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim varTemp\n'전체영역을 넣을 배열 변수\nDim i As Long\n'배열 숫자만큼 반복할 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Ra..."}
{"instruction": "Excel VBA code for: (837) 중복데이터 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Matching_Data4()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngData As Range\n'D열을 넣을 변수\nDim C As Range\n'검색하여 일치한 셀을 넣을 변수\nDim r As Long\n'배열을 늘려갈 변수\nDim varTemp()\n'배열로 사용할 변수\nWith Application\n.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\n.Calculation =\nxlCalculationManual\n'수동계산으로 전환\nSheets(2).UsedRange.ClearContents\n'Sheet2의 기존데이터 삭제\nSet rngAll = Range([B2], Cells(Rows.Count, \"B\").End(3))\n'전체영역을 변수에 넣음\nSet rngData = Range([D2], Cells(Rows.Count, \"D\").End(3))\nlastRow = Cells(Rows.Count, \"A\").End(3).Row\n'마지막 행을 변수에 넣음\nrngAll.Offset(, 1).\nFormulaR1C1\n= _\n\"=COUNTIF\n(R2C4:R\" & lastRow & \"C4, RC[-1])\"\n'C열에 Countif 수식을 입력\nWith rngAll.Offset(, 1)\n'전체영역 오른쪽 열, 즉 C열\n.Value = .Value\n'C열의 수식을 값으로 변환\nEnd With\nFor Each rngC In rngAll.Offset(, 1)\n'C열을 순환\nIf rngC > 0 Then\n'동일한 데이터 존재하면\nSet C = rngData.\nFind\n(rngC.Offset(, -1), , , xlWhole)\n'일치하는 이름을 찾아 변수에 넣음\nr = r + 1\n'배열크기 1씩 늘려감\nReDim Preserve\nvarTemp(1 To 4, 1 To r)\n'배열을 2차원 배열로 크기 재지정\nvarTemp(1, r) = rngC.Offset(, -2)\n'번호를 배열에 넣음\nvarTemp(2, r) = rngC.Offset(, -1)\n'이름을 배열에 넣음\nvarTemp(3, r) = C.Offset(, 1)\n'주소를 배열에 넣음\nvarTemp(4, r) = C.Offset(, 2)\n'학년을 배열에 넣음\nEnd If\nNext rngC\nrngAll.Offset(, 1).ClearContents\n'임시 데이터 삭제\nWith Sheets(2)\n'Sheet2에서\n.[A1].Resize(, 4) =\nArray\n(\"번호\", \"이름\", \"주소\", \"학년\")  '제목 복사\nOn Error Resume Next\n'(데이터 없어) 에러 발생해도 다음코드 진행\nIf UBound(varTemp, 2) > 0 Then\n'일치하는 데이터가 하나라도 있을 경우\nIf\nErr <> 0\nThen\n'(데이터 없어)에러가 발생했을 경우\nMsgBox \"일치하는 데이터 없음\", 64, \"데이터 불일치\"\n'에러메시지 출력\nExit Sub\n'매크로 중단\nEnd If\n.[A2].Resize(\nUBound\n(varTemp, 2), 4) = Application.Transpose(varTemp)\nEnd If\n'배열 값을 셀에 뿌림\n.Columns.AutoFit\n'열너비 자동맞춤\nEnd With\n.Calculation =\nxlCalculationAutomatic\n'자동계산으로 전환\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화 (메모리 비우기)\nEnd Sub", "context": "Sheet1의 B열에 있는 이름과 D열에 있는 이름을 비교하여 양쪽에 중복되는 데이터만 Sheet2에 추출하는 기능. \"번호\"를 추출하지 않으면 \"CountIf + 필터\" 또는 고급필터를 사용할 수도 있지만, 아래와 같은 경우 그럴 수 없으며, 단순히 Find를 이용하면 B열 전체의 각 셀을 D열 전체의 각 셀과 1:1 비교를 해야하므로 엄청나게 시간이 소요된다. 아래의 코드로 B열과 D열에 각각 50,000행의 데이터를 넣고 매크로 돌렸을 때 (컴퓨터 속도와 데이터 위치에 따라 다르지만)\n약 48초 정도가 소요\n되었다. Find를 사용하여 시간 비교를 하려다 시간이 너무 오래걸려 그냥 중단하였다.\n별 특별한 코드가 아닌 것 같지만, 검색속도를 증가시키기 위하여 상당히 고심한 코드이다.\n매크로 실행 전 (Sheet2는 비어 있는 상태)                               매크로 실행 후 결과\nOption Explicit\nSub find_Matching_Data4()..."}
{"instruction": "Excel VBA code for: (838) 다른시트를 팝업창처럼 열기 (엑셀 VBA 매크로)", "input": "", "output": "Sub open_NewWindow()\nSheets(\"Sheet2\").\nVisible\n= True\n'숨겨진 창을 활성화\nActiveWindow.\nNewWindow\n'새창열기\nSheets(\"Sheet2\").Select\nWith ActiveWindow\n'활성화된 창에서\n.\nWindowState\n= xlNormal\n'창의 설정을 일반으로\n.Width = 300\n'창의 폭을 200으로\n.Height = 200\n'창의 높이를 150으로\n.Top = 100\n'창의 윗쪽 위치를 100에\n.Left = 100\n'창의 왼쪽 위치를 100에\nEnd With\nEnd Sub\n\nSub close_NewWindow()\nSheets(\"Sheet2\").Visible =\nFalse\n'활성화된 Sheet2를 숨기기\nActiveWindow.\nClose\n'Sheet2창을 닫음\nActiveWindow.WindowState = xlMaximized\n'창 크기를 최대로\nEnd Sub", "context": "1. Sheet2는 항상 숨겨두고, Sheet1에 있는 버튼을 클릭시 팝업창처럼 나타나도록 하고자 함.\n2. Sheet2에 있는 매크로 버튼을 클릭 시 팝업창처럼 나타난 Sheet2창이 닫힘\n(새로운 창열기 기능으로 Sheet2창이 나타나도록 함. Sheet1의 버튼 클릭 시 나타난 Sheet2는 새로운 엑셀창이 열린 것이 아니고 동일한 엑셀파일이 두 개의 창으로 열린 것임. 창의 크기나 위치는 자신이선호하는 값으로 코드에서 수정을 하면 된다.)\n매크로 실행 전 Sheet1                                   매크로 실행 전 (Sheet2가 보이기로 된 상태)\n매크로 실행 전 (Sheet2를 숨김)     매크로 실행후 (Sheet2가 Sheet1 앞에 새로운 창으로 나타남)\nSheet2에 있는 \"닫기\"버튼을 클릭시 팝업창처럼 나타난 Sheet2창이 닫힘.\n'\"열기\" 버튼에 연결된 매크로\nSub open_NewWindow()\nSheets(\"Sheet2\").\n..."}
{"instruction": "Excel VBA code for: (840) 제품명 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Product_Name()\nDim rngAll As Range\nDim rngC As Range\nSet rngAll = Range(\"A1\", Cells(Rows.Count, \"A\").End(3))\nFor Each rngC In rngAll\nWith rngC.Offset(0, 2)\n.Value = rngC\n.\nReplace\nWhat:=\"<b>\", Replacement:=\"\"\n.Replace What:=\"<br>\n*\n\", Replacement:=\"\"\nEnd With\nNext rngC\nEnd Sub\n\nSub extract_Product_Name1()\nDim rngAll As Range\nDim rngC As Range\nSet rngAll = Range(\"A1\", Cells(Rows.Count, \"A\").End(3))\nrngAll.Copy rngAll.Offset(, 2)\nWith rngAll.Offset(, 2)\n.Replace What:=\"<b>\", Replacement:=\"\"\n.Replace What:=\"<br>*\", Replacement:=\"\"\nEnd With\nEnd Sub\n\nSub extract_Product_Name()\nCells\n.\nReplace\nWhat:=\"<b>\", Replacement:=\"\"\nCells.Replace What:=\"<br>*\", Replacement:=\"\"\nEnd Sub", "context": "수식 적용 전\n수식 적용 후\n아래의 수식을 B1셀에 입력 후 아래로 복사 :\n=LEFT(\nSUBSTITUTE\n(A1,\"<b>\",\"\"),\nFIND\n(\"<\", SUBSTITUTE(A1,\"<b>\",\"\"), 1)-1)\n수식 적용 후 복사한 결과\n아래 코드를 사용하여서도 가능하다.\nSub extract_Product_Name()\nDim rngAll As Range\nDim rngC As Range\nSet rngAll = Range(\"A1\", Cells(Rows.Count, \"A\").End(3))\nFor Each rngC In rngAll\nWith rngC.Offset(0, 2)\n.Value = rngC\n.\nReplace\nWhat:=\"<b>\", Replacement:=\"\"\n.Replace What:=\"<br>\n*\n\", Replacement:=\"\"\nEnd With\nNext rngC\nEnd Sub\n아래와 같이 하여도 동일한 결과를 얻는다.\nSub extract_Product_Name1()\nDim r..."}
{"instruction": "Excel VBA code for: (841) 태그(tag) 사이의 제품명 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Product_Name()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim str As String\n'<b> 삭제한 각 셀의 문자를 넣을 변수\nFor Each rngC In Columns(1).SpecialCells(2)\n'A열의 각 문자셀을 순환\nstr =\nReplace\n(rngC, \"<b>\", \"\")\n'<b> 삭제한 뒤 변수에 넣음\nrngC.Next = Left(str,\nInStr\n(1, str, \"<\") - 1)\n'< 앞 문자까지 추출하여 B열에 넣음\nNext rngC\nColumns(\"B\").AutoFit\n'B열 열너비 자동맞춤\nEnd Sub\n\nSub extract_Product_Name()\nCells.Replace\nWhat:=\"<b>\", Replacement:=\"\"\nCells.Replace What:=\"<br>*\", Replacement:=\"\"\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub extract_Product_Name()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim str As String\n'<b> 삭제한 각 셀의 문자를 넣을 변수\nFor Each rngC In Columns(1).SpecialCells(2)\n'A열의 각 문자셀을 순환\nstr =\nReplace\n(rngC, \"<b>\", \"\")\n'<b> 삭제한 뒤 변수에 넣음\nrngC.Next = Left(str,\nInStr\n(1, str, \"<\") - 1)\n'< 앞 문자까지 추출하여 B열에 넣음\nNext rngC\nColumns(\"B\").AutoFit\n'B열 열너비 자동맞춤\nEnd Sub\n또는\nSub extract_Product_Name()\nCells.Replace\nWhat:=\"<b>\", Replacement:=\"\"\nCells.Replace What:=\"<br>*\", Replacement:=\"\"\nEnd Sub..."}
{"instruction": "Excel VBA code for: (842) A열에 있는 공백영역 선택하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub select_Difference_ColumnAB1()\nColumns(1).SpecialCells(4).Select\n'A열 데이티영역 공백셀을 모두 선택\nEnd Sub\n\nSub select_Difference_ColumnAB2()\nRange(Cells(Rows.Count, \"A\").\nEnd(3)(2)\n, _\nCells(Rows.Count, \"B\").\nEnd(3)(1, 0)\n).Select\n'A열 마지막 데이터 바로 아래 B열 마지막데이터 왼쪽까지 선택\nEnd Sub\n\nSub select_Difference_ColumnAB3()\nDim rngA As Range\n'A열 마지막 데이터 바로 아래영역을 넣을 변수\nDim rngB As Range\n'B열 마지막 데이터의 왼쪽 영역을 넣을 변수\nSet rngA = Cells(Rows.Count, \"A\").\nEnd(3)(2)\n'A열 마지막 데이터 바로 아래영역을 변수에 넣음\nSet rngB = Cells(Rows.Count, \"B\").\nEnd(3)(1, 0)\n'B열 마지막 데이터의 왼쪽 영역을 변수에 넣음\nRange(rngA, rngB).Select\n'두 영역 사이에있는 영역을 선택\nEnd Sub", "context": "A열의 마지막 데이터행 바로 아래에서 B열 데이터의 마지막행 까지의 영역을 선택하는 기능. A열과 B열의 데이터 개수가 바뀌어도 항상 동일한 방식으로 영역을 선택해야 함.\n매크로 실행 전             매크로 실행 후                  매크로 실행 전             매크로 실행 후\n'한 줄의 코드로 하였을 경우\nOption Explicit\nSub select_Difference_ColumnAB1()\nColumns(1).SpecialCells(4).Select\n'A열 데이티영역 공백셀을 모두 선택\nEnd Sub\n'종단셀 이용하였을 경우\nSub select_Difference_ColumnAB2()\nRange(Cells(Rows.Count, \"A\").\nEnd(3)(2)\n, _\nCells(Rows.Count, \"B\").\nEnd(3)(1, 0)\n).Select\n'A열 마지막 데이터 바로 아래 B열 마지막데이터 왼쪽까지 선택\nEnd Sub\n'개체변수에 넣어 코드를 이..."}
{"instruction": "Excel VBA code for: (843) 두 날짜 구간에 있는 데이터만 이동 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub between_Two_Days()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rngA As Range\n'제목영역을 넣을 변수\nDim dteStart As String\n'시작일을 넣을 변수\nDim dteEnd As String\n'종료일을 넣을 변수\nDim rowsCnt  As Long\n'전체 행의 개수를 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim C As Range\n'검색하여 일치한 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Offset(4).ClearContents\n'기존 데이터 삭제\nIf [E1] > [E2] Then\n'시작일이 종료일보다 클 경우\nMsgBox \"날짜입력 오류. 시작일이 작아야 합니다.\", 64, \"입력오류\"\n'오류 메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nWith Sheets(\"Data\")\n'Data 시트에서\nSet rngAll = .UsedRange\n'전체영역을 변수에 넣음\nSet rngA = .Rows(1).SpecialCells(2)\n'Data 시트의 제목을 변수에 넣음\ndteStart = \">=\" & Range(\"E1\")\n'시작일을 변수에 넣음\ndteEnd = \"<=\" & Range(\"E2\")\n'종료일을 변수에 넣음\nrngAll.\nAutoFilter\nField:=5, Criteria1:= _\ndteStart, Operator:=xlAnd, Criteria2:=dteEnd\n'Data 시트를 시작일과 종료일로 필터\nrowsCnt = .Columns(\"A\").\nSpecialCells(2).SpecialCells(12)\n.Count\n'필터 후 전체 행의 개수를 변수에 넣음\nIf rowsCnt = 1 Then\n'일치하는 데이터가 없을 경우\nMsgBox \"일치하는 데이터가 없습니다.\", 64, \"데이터 불일치\" '메시지 출력\nGoTo noData\n'(일치하는 데이터 없을 경우) noData로 이동\nEnd If\nFor Each rngC In Rows(4).SpecialCells(2)\n'필드 제목의 각 셀을 순환\nSet C = rngA.\nFind\n(rngC, , , xlWhole)\n'각 필드제목을 Data시트의 제목에서 찾음\nrngAll.Offset(1).Columns(C.Column).SpecialCells(12).Copy rngC.Offset(1)\nNext rngC\n'각 필드의 보이는 값만을 가져옴\nEnd With\nRange([E5], Cells(Rows.Count, \"E\").End(3)(2)).\nSort\n[E5], 1\n'오름차순 정렬\nnoData:\nrngAll.\nAutoFilter\n'자동필터 해제\nSet rngAll = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngA = Nothing\nSet rngC = Nothing\nEnd Sub", "context": "Data 시트에 데이터가 정리되어 있음\nFilter 시트에 시작일과 종료일을 입력하고 매크로 실행 시 Data시트에서 데이터를 가져옴\n날짜를 잘못 입력 시 에러 메시지 출력\n입력한 조건의 날짜와 일치하는 데이터 없을 경우 메시지 출력\nData 시트와 Filter 시트의 필드명(제목) 위치가 일치하지 않으므로 Filter시트에 있는 제목에 맞추어 Data시트에서 데이터를 가져옴\n필터링된 데이터는 날짜를 기준으로 오름차순 정렬\n매크로 실행 전 Data 시트\n매크로 실행 전 Filter 시트\n매크로 실행 후 결과 (Filter 시트)\nOption Explicit\nSub between_Two_Days()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rngA As Range\n'제목영역을 넣을 변수\nDim dteStart As String\n'시작일을 넣을 변수\nDim dteEnd As String\n'종료일을 넣을 변수\nDim rowsCnt  As Long\n'전체 행의 개..."}
{"instruction": "Excel VBA code for: (844) 특정 폴더내 모든 엑셀파일에 적용하는 기본코드 (엑셀 VBA 매크로)", "input": "", "output": "Sub allFiles_In_A_Folder()\nDim shtName As String\n'자신의시트 이름을 넣을 변수\nDim strRng As String\n'데이터 영역을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim wkb As Workbook\n'각 파일을 넣을 변수\nDim wks As Worksheet\n'각 시트를 넣을 변수\nDim rngT As Range\n'복사될 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n'-----------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'-----------------------------------------------\nChDir ThisWorkbook.Path\n'매크로 실행파일과 동일한 경로 기준\nWith Application.FileDialog(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더 선택시\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nshtName = \"\nSheet1\n\"\n'데이터가 들어 있는 시트의 이름\nstrRng = \"\nA2:J10\n\"\n'시트내의 가져올 데이터 위치\n'--------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'--------------------------------\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\n'---------------------------------------------------\n' 파일을 열고 시트명이 Sheet1인 시트만 복사해오는 코드\n'---------------------------------------------------\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nSet rngT = Cells(Rows.Count, \"A\").End(3)(2)\n'통합시트 복사될 위치를 변수에 넣음\nSet wkb = Workbooks.Open(strPath & fileName)\n'파일을 열고 변수에 넣음\nFor Each wks In wkb.Worksheets\n'열린파일 각 시트를 순환\nIf wks.Name = shtName Then\n'시트이름이 일치하면\n'시트이름이 정확히 일치하지 않고 7ShEeT, SHeeT5, 8shEET8 도 모두 가져오려면\n' 윗줄의 코드를 If InStr(1, wks.Name, shtName, vbTextCompare) Then 로 수정\nwks.Range(strRng).Copy rngT\n'데이터를 통합시트에 복사\nEnd If\nNext wks\nwkb.Close False\n'열려진 파일을 닫음\nfileName = Dir()\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nColumns.AutoFit\n'열크기 자동맞춤\nSet rngT = Nothing\n'개체변수(들) 초기화 : 메모리 비우기\nSet wkb = Nothing\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "특정 폴더내의 모든 엑셀 파일에 특정 작업을 하기 위한 코드를 가끔씩 사용하므로 추후 재사용 하기 위하여 기본코드를 만들어 놓음. 만일 .csv 파일만 열고 싶으면 *.csv 로 수정하면 됨.\n자신의 데이터에 아래 코드를 적용하기 위해서는 주황색으로 표시한 코드만 자신의 데이터에 맞추어 수정하여 사용하면 된다. 예를 들어, 자신의 파일내 시트이름이 \"\n가을노래\n\"이고, 그 시트안의 \"\nF3:M12\n\" 데이터 영역을 통합시트에 모두 가져오고 싶을 경우 아래와 같이 바꾸면 된다.\nshtName = \"\n가을노래\n\"\n'데이터가 들어 있는 시트의 이름\nstrRng = \"\nF3:M12\n\"\n'시트내의 가져올 데이터 위치\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(844) 특정 폴더내 모든 엑셀파일에 적용하는 기본코드 (엑셀 VBA 매크로)\n재생\n317\n공유하기\n재생 (space/k)\n재생\n00:40\n0:00:00\n재생 (space/k)\n재생\n음소거 (..."}
{"instruction": "Excel VBA code for: (845) 1열 데이터를 2열로 바꾸기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub one_Column_Into_Two_Columns1()\nDim rngT As Range\n'복사될 타겟(T)arget 지점 넣을 변수\nDim r As Long\n'행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 1\n'                    1행부터 시작\nDo\n'다음을 실행\nSet rngT = Cells(Rows.Count, \"B\").End(3)(2)\n'복사될 위치를 변수에 넣음\nrngT = Cells(r, 1)\n'홀수행을 B열에 복사\nrngT.\nNext\n= Cells(r + 1, 1)\n'짝수행을 C열에 복사\nr = r + 2\n'행을 2씩 늘려감\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nCells(1, 2).Resize(, 2).Delete shift:=\nxlUp\n'빈셀인 B:C 열의 첫 행을 제거\nEnd Sub", "context": "아래와 같은 코드는 여러 가지 방법으로 코딩이 가능하다. 아래는 쉬운 방법 중의 하나.\n매크로 실행 전                                            매크로 실행 후 결과\nOption Explicit\nSub one_Column_Into_Two_Columns1()\nDim rngT As Range\n'복사될 타겟(T)arget 지점 넣을 변수\nDim r As Long\n'행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 1\n'                    1행부터 시작\nDo\n'다음을 실행\nSet rngT = Cells(Rows.Count, \"B\").End(3)(2)\n'복사될 위치를 변수에 넣음\nrngT = Cells(r, 1)\n'홀수행을 B열에 복사\nrngT.\nNext\n= Cells(r + 1, 1)\n'짝수행을 C열에 복사\nr = r + 2\n'행을 2씩 늘려감\nLoop Until\nCell..."}
{"instruction": "Excel VBA code for: (846) 1열 데이터를 2열로 바꾸기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub one_Column_Into_Two_Columns2()\nDim r As Long\n'A열 행을 늘려갈 변수\nDim j As Long\n'B:C열 행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 1\n'1행부터 시작\nDo\n'다음을 실행\nj = j + 1\nCells(j, 2) = Cells(r, 1)\n'홀수행을 B열에 복사\nCells(j, 3) = Cells(r + 1, 1)\n'짝수행을 C열에 복사\nr = r + 2\n'행을 2씩 늘려감\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nEnd Sub", "context": "매크로 실행 전                                            매크로 실행 후 결과\nOption Explicit\nSub one_Column_Into_Two_Columns2()\nDim r As Long\n'A열 행을 늘려갈 변수\nDim j As Long\n'B:C열 행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 1\n'1행부터 시작\nDo\n'다음을 실행\nj = j + 1\nCells(j, 2) = Cells(r, 1)\n'홀수행을 B열에 복사\nCells(j, 3) = Cells(r + 1, 1)\n'짝수행을 C열에 복사\nr = r + 2\n'행을 2씩 늘려감\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nEnd Sub..."}
{"instruction": "Excel VBA code for: (848) 1열 데이터를 2열로 바꾸기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub one_Column_Into_Two_Columns4()\nDim lastRow As Long\n'A열 마지막 행을 넣을 변수\nDim r As Long\n'2개씩 행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, \"A\").End(3).Row\n'마지막 행을 변수에 넣음\nFor r = 1 To lastRow\nStep 2\n'마지막 행까지 행을 2씩 늘려감\nCells(r, 1).Resize(2).Copy\n'2개의 셀씩 복사\nCells(Rows.Count, \"B\").End(3)(2).\nPasteSpecial\nTranspose\n:=True\n'세로로 된 A열의 데이터를 B:C열에 가로로 복사\nNext r\nCells(1, 2).Resize(, 2).Delete shift:=xlUp\n'빈셀인 B:C 열의 첫 행을 제거\nEnd Sub", "context": "앞서,\nDo .. Loop Until 과 복사될 위치를 변수에 넣어,\nDo .. Loop Until을 이용해 셀에서 셀로 직접이동,\n배열과 For Each .. Next를 이용하여 A열의 데이터를 B:C열로 이동하였다.\n이번에는\nPasteSpecial\nmethod의\nTranpose\n를 사용하여 동일한 결과를 구해보았다.\n(시간을 측정해 보지 않았지만 복사(copy)를 사용하므로 이 코드는 다른 코드에 비하여 속도가 상당히 떨어질 것으로 추측된다. 하지만 어차피 공부를 위한 것이므로 올려둔다.)\n매크로 실행 전                                            매크로 실행 후 결과\nOption Explicit\nSub one_Column_Into_Two_Columns4()\nDim lastRow As Long\n'A열 마지막 행을 넣을 변수\nDim r As Long\n'2개씩 행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데..."}
{"instruction": "Excel VBA code for: (849) 1열 데이터를 2열로 바꾸기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub one_Column_Into_Two_Columns5()\nDim varTemp()\n'A열의 값을 넣을 배열변수\nDim lastRow As Long\n'A열 마지막 행을 넣을 변수\nDim r As Long\n'A열의 행을 2씩 늘려갈 변수\nDim i As Long\n'배열크기 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, \"A\").End(3).\nRow\n'마지막 행을 변수에 넣음\nReDim\nvarTemp(1 To lastRow / 2, 1 To 2)\n'배열크기 재지정\nFor r = 1 To lastRow Step 2\n'마지막 행까지 행을 2씩 늘려감\ni = i + 1\n'배열크기 1씩 늘려감\nvarTemp(i, 1) = Cells(r, 1)\n'배열 첫째 열에 A열 홀수행을 넣음\nvarTemp(i, 2) = Cells(r + 1, 1)\n'배열 둘째 열에 A열 짝수행을 넣음\nNext r\nCells(1, 2).Resize(\nUBound\n(varTemp, 1), 2) = varTemp\n'배열값을 셀에 뿌림\nEnd Sub", "context": "앞서,\nDo .. Loop Until 과 복사될 위치를 변수에 넣어,\nDo .. Loop Until을 이용해 셀에서 셀로 직접이동,\n배열과 For Each .. Next를 이용,\nPasteSpecial method의 Tranpose를 이용하여 A열의 데이터를 B:C열로 이동하였다.\n이번에는\n2차원 배열\n에 넣어 동일한 결과를 구해보았다.\n(전체 행의 크기를 알 수 있으므로 동적배열 대신에 정적배열을 이용함.)\n매크로 실행 전                                            매크로 실행 후 결과\nOption Explicit\nSub one_Column_Into_Two_Columns5()\nDim varTemp()\n'A열의 값을 넣을 배열변수\nDim lastRow As Long\n'A열 마지막 행을 넣을 변수\nDim r As Long\n'A열의 행을 2씩 늘려갈 변수\nDim i As Long\n'배열크기 1씩 늘려갈 변수\nApplication.ScreenUpdatin..."}
{"instruction": "Excel VBA code for: (850) 1열 데이터를 2열로 바꾸기 6 (엑셀 VBA 매크로)", "input": "", "output": "Sub one_Column_Into_Two_Columns6()\nDim rngC As Range\n'A열의 각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each rngC In Range([A1], Cells(Rows.Count, 1).End(3))\n'A열 각 셀을 순환\nIf\nLeft\n(rngC, 1)\nLike \"[1-9]\"\nThen\n'만약 각 셀의 첫 글자가 숫자면\nCells(Rows.Count, 3).End(3)(2) = rngC\n'B열에 각 셀값을 복사\nElse\n'각 셀의 첫 글자가 문자면\nCells(Rows.Count, 2).End(3)(2) = rngC\n'C열에 각 셀값을 복사\nEnd If\nNext rngC\nCells(1, 2).Resize(, 2).Delete shift:=xlUp\n'빈셀인 B:C 열의 첫 행을 제거\nEnd Sub", "context": "앞서,\nDo .. Loop Until 과 복사될 위치를 변수에 넣어,\nDo .. Loop Until을 이용해 셀에서 셀로 직접이동,\n배열과 For Each .. Next를 이용,\nPasteSpecial method의 Tranpose를 이용,\n2차원 배열을 이용하여 A열의 데이터를 B:C열로 이동하였다.\n이번에는\nLeft\nfunction과\nLike\noperator를 이용하여 동일한 결과를 구해보았다.\n매크로 실행 전                                            매크로 실행 후 결과\nOption Explicit\nSub one_Column_Into_Two_Columns6()\nDim rngC As Range\n'A열의 각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each rngC In Range([A1], Cells(Rows.Count, 1).End(3))\n'A열 각 셀을 순환\nIf\nL..."}
{"instruction": "Excel VBA code for: (851) 1열 데이터를 2열로 바꾸기 7 (엑셀 VBA 매크로)", "input": "", "output": "Sub one_Column_Into_Two_Columns7()\nColumns(\"A\").\nSpecialCells\n(\n2, 2\n).Copy [B1]\n'A열의 문자만 B열에 복사\nColumns(\"A\").SpecialCells(\n2, 1\n).Copy [C1]\n'A열의 숫자만 C열에 복사\nEnd Sub", "context": "앞서,\nDo .. Loop Until 과 복사될 위치를 변수에 넣어,\nDo .. Loop Until을 이용해 셀에서 셀로 직접이동,\n배열과 For Each .. Next를 이용,\nPasteSpecial method의 Tranpose를 이용,\n2차원 배열을 이용,\nLeft function과 Like operator를 이용하여 A열의 데이터를 B:C열로 이동하였다.\n이번에는\nSpecialcells\nmethod를 이용하여 동일한 결과를 구해보았다.\n매크로 실행 전                                            매크로 실행 후 결과\nSub one_Column_Into_Two_Columns7()\nColumns(\"A\").\nSpecialCells\n(\n2, 2\n).Copy [B1]\n'A열의 문자만 B열에 복사\nColumns(\"A\").SpecialCells(\n2, 1\n).Copy [C1]\n'A열의 숫자만 C열에 복사\nEnd Sub..."}
{"instruction": "Excel VBA code for: (854) 1열 데이터를 2열로 바꾸기 10 (엑셀 VBA 매크로)", "input": "", "output": "Sub one_Column_Into_Two_Columns10()\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Columns(1).SpecialCells(2)\n'A열의 문자\n.\nCopy\n[B1]\n'B열에 복사\n.Copy [C1]\n'C열에 복사\nEnd With\nColumns(\"B\").\nSpecialCells(2\n, 1).\nDelete\nshift:=\nxlUp\n'B열의 숫자만 삭제후 위로 끌어올림\nColumns(\"C\").\nSpecialCells(2, 2)\n.Delete shift:=xlUp\n'C열의 문자만 삭제후 위로 끌어올림\nEnd Sub", "context": "앞서,\nDo .. Loop Until 과 복사될 위치를 변수에 넣어,\nDo .. Loop Until을 이용해 셀에서 셀로 직접이동,\n배열과 For Each .. Next를 이용,\nPasteSpecial method의 Tranpose를 이용,\n2차원 배열을 이용,\nLeft function과 Like operator를 이용,\nSpecialcells method를 이용,\nFormulaR1C1 property와 Offset property를 이용,\nFormula property와 Offset property를 이용하여 A열의 데이터를 B:C열로 이동하였다.\n이번에는\nCopy\n와 앞서 사용한\nSpecialcells\nmethod를 이용하여 동일한 결과를 구해보았다.\n(이러한 유형의 작업에서 일반적으로 최고 빠른 코드는 배열을 사용하는 것이다. 물론 데이터의 양이 많이 않으면 다른 코드를 사용해도 큰 상관이 없지만 데이터가 몇 만행 이상 넘어가면 속도도 상당히 중요하다.)\n매크로 실행 전    ..."}
{"instruction": "Excel VBA code for: (855) 1열 데이터를 2열로 바꾸기 11 (엑셀 VBA 매크로)", "input": "", "output": "Sub one_Column_Into_Two_Columns11()\nDim lastRow As Long\n'A열 마지막 행을 넣을 변수\nDim r As Long\n'2개씩 행 늘려갈 변수\nDim varTemp\n'2셀씩 넣을 배열 변수\nDim i As Long\n'B:C열 행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, \"A\").End(3).Row\n'마지막 행을 변수에 넣음\nFor r = 1 To lastRow Step 2\n'마지막 행까지 행을 2씩 늘려감\nvarTemp\n= Cells(r, 1).Resize(2)\n'2개의 셀씩 배열에 넣음\ni = i + 1\n'B:C열 행을 1씩 늘려감\nCells(i, 2).Resize(, 2) = Application.\nTranspose\n(varTemp)\n'세로로 된 A열의 2개의 셀씩 행/열 변환하여 B:C열에 복사\nNext r\nEnd Sub", "context": "앞서,\nDo .. Loop Until 과 복사될 위치를 변수에 넣어,\nDo .. Loop Until을 이용해 셀에서 셀로 직접이동,\n배열과 For Each .. Next를 이용,\nPasteSpecial method의 Tranpose를 이용,\n2차원 배열을 이용,\nLeft function과 Like operator를 이용,\nSpecialcells method를 이용,\nFormulaR1C1 property와 Offset property를 이용,\nFormula property와 Offset property를 이용,\nCopy와 Specialcells method를 사용하여 A열의 데이터를 B:C열로 이동하였다.\n이번에는 2셀씩\n배열에 넣어 행/열변환(transpose)\n하여 동일한 결과를 구해보았다.\n매크로 실행 전                                            매크로 실행 후 결과\nOption Explicit\nSub one_Column_Into_Two_Col..."}
{"instruction": "Excel VBA code for: (857) 폴더속 모든파일, 모든시트의 데이터를 현 시트로 통합 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_All_Sheets_In_Folder3()\nDim strFolder As String\n'폴더 이름을 넣을 변수\nDim wkBk As Workbook\n'각 파일을 넣을 변수\nDim wkSht As Worksheet\n'각 시트를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim varTemp\n'각 항목을 넣을 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nThisWorkbook.ActiveSheet.UsedRange.Offset(1).ClearContents\n'Main 시트의 기존 데이터 삭제\nstrFolder = \"data\"\n'폴더명이 다를 경우 여기에 있는 폴더명을 바꿔주면 됨\nstrPath =\nThisWorkbook.Path\n& \"\\\" & strFolder & \"\\\"\n'폴더의 경로를 변수에 넣음\nfileName =\nDir\n(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nSet wkBk = Workbooks.\nOpen\n(strPath & \"\\\" & fileName)\n'파일을 열고 변수에 넣음\nFor Each wkSht In wkBk.Worksheets\n'열린파일 각 시트를 순환\nWith wkSht\nvarTemp =\nArray\n(.[B1], .[E2], .[E3], .[E1]\n, ,\n.[B2], .[H2], .[B3], .[H3], .[B4])\n'각 항목을 배열에 넣음(콤마 2개 있는 곳은 셀하나 건너뜀)\nThisWorkbook.ActiveSheet.Cells(Rows.Count, 1).End(3)(2).Resize(, 10) = varTemp\n'배열값을 셀에 뿌림\nEnd With\nNext wkSht\nwkBk.Close\n'열려진 파일을 닫음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nColumns.\nAutoFit\n'열너비 자동맞춤\nActiveSheet.UsedRange.Offset(1).\nSort\n[A2], 1\n'오름차순 정렬\nEnd Sub", "context": "특정 폴더(data)내에 복수의 엑셀 파일(.xls, .xlsx, xlsm ...)이 있고, 각 파일마다 복수의 시트가 존재하며, 각 시트마다 양식내에 여러 항목의 데이터가 존재하는 상황.\n모든 시트의 각 항목을 현재의 Main 시트로 가져옴\nMain 시트의 항목위치와 각 시트의 항목위치가 일치하지 않으므로 Main 시트의 항목 순서에 맞추어 데이터를 가져옴\n\"본적\" 필드는 빈셀로 데이터 없이 남겨둠(필드 추가시 사용할 목적)\n모든 데이터 가져온 뒤 열너비를 자동으로 맞추고 이름을 기준으로 오름차순으로 정렬\n(첨부한 압축파일을 아래 그림과 같이 한 폴더내에 압축을 푼 다음에 매크로 실행하면 됨)\n같은 폴더에 매크로 파일과 data폴더 있음.\n폴더내에는 여러개의 데이터 파일이 존재\n각 파일의 각 시트에는 정해진 양식에 따라 여러 항목의 데이터가 존재 (2003.xls 파일내 데이터)\n각 파일의 각 시트에는 정해진 양식에 따라 여러 항목의 데이터가 존재 (Book3.xlsx 파일내 데이..."}
{"instruction": "Excel VBA code for: (858) 한 시트를 그룹별로 나누어 별도 파일로 저장 (엑셀 VBA 매크로)", "input": "", "output": "Sub split_As_Per_Item_Name()\nDim rngAll As Range\n'모든 영역을 저장할 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim strName As String\n'파일명 넣을 변수\nDim rngA As Range\n'각 그룹별 영역을 넣을 변수\nDim colsCnt As Integer\n'전체 데이터의 열 개수 넣을 변수\nDim rowsCnt As Long\n'그룹별 데이터의 행 개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveSheet.UsedRange\n'현재시트의 사용영역에서\nSet rngAll = .Offset(1).Resize(.Rows.Count - 1)\n'사용전체영역을 변수에 넣음\nEnd With\ncolsCnt = rngAll.Columns.Count\n'전체 데이터의 열개수를 변수에 넣음\nrngAll.\nSort\n[A2], 1\n'\"파일명\"으로 오름차순 정렬\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nstrName = Cells(r, 1)\n'파일명을 변수에 넣음\nSet rngA = Cells(r - i, 1).Resize(i + 1, colsCnt)\n'각 그룹별 데이터를 변수에 넣음\nrowsCnt = rngA.Rows.Count\n'각 그룹별 데이터의 행 개수를 변수에 넣음\nWorkbooks.\nAdd\n'새로운 시트 추가\nCells(1, 1).Resize(, 4) =\nArray\n(\"파일명\", \"주문번호\", \"종류\", \"개수\")\n'제목복사\nRange(\"A2\").Resize(rowsCnt, colsCnt) = rngA.Value\n'각 그룹별 데이터를 복사\nColumns.AutoFit\n'열너비 자동 맞춤\nActiveWorkbook.\nSaveAs\nThisWorkbook.Path\n& \"\\\" & strName & \".xlsx\"\n'각 그룹별 데이터 별도 파일로 저장\nActiveWorkbook.\nClose\n'새로 생성한 파일 닫기\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\nThisWorkbook.\nClose False\n'매크로파일 저장하지 않고 닫기\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "시트를 \"파일명\" 이라고 되어 있는 A열의 그룹별로 나누어 여러파일로 저장하는 기능\n그룹별로 모으기 위해 \"파일명\"으로 원본 데이터를 오름차순 정렬하므로 사용자가 실수로 데이터를 저장하는 것을 막기 위해 매크로 완료 후 원본데이터는 저장하지 않고 닫음\n매크로 실행 전 데이터가 들어있는 파일\n매크로 실행 후 생성된 파일\nA.xlsx 파일내의 데이터                            D.xlsx 파일내의 데이터\nOption Explicit\nSub split_As_Per_Item_Name()\nDim rngAll As Range\n'모든 영역을 저장할 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim strName As String\n'파일명 넣을 변수\nDim rngA As Range\n'각 그룹별 영역을 넣을 변수\nDim colsCnt As Integer\n'전체 데이터의 열 개수 넣을 변수\nDim rowsCn..."}
{"instruction": "Excel VBA code for: (859) 두 숫자 사이의 난수 발생시키고 합계 400넘으면 멈추기 (엑셀 VBA 매크로)", "input": "", "output": "Sub make_Random_Sum_400()\nDim sngSum As\nSingle\n'난수의 합을 넣을 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Columns(\"A\")\n'A열에서\n.\nClear\n'기존 데이터 삭제\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nCells(r, 1) =\nRnd\n* (5 - 0.16) + 0.16\n'0.16과 5 사이의 난수를 셀에 입력\nsngSum = sngSum + Cells(r, 1)\n'발생시킨 난수를 더해감\nLoop Until\nsngSum > 400\n'난수의 합이 400을 넘을때까지 무한 반복\nWith Cells(Rows.Count, 1).End(3).Offset(2)\n'A열 마지막행의 2행 건너뛴 아래셀\n.Value = Application.\nSum\n(Columns(\"A\").SpecialCells(2))\n'A열의 합계를 입력\n.Interior.ColorIndex = 6\n'합계셀의 색을 노란색으로 채움\nEnd With\n.\nNumberFormatLocal\n= \"0.00000000000000_ \"\n'소수점 14자리까지 표시\n.AutoFit\n'열너비 자동맞춤\nEnd With\nEnd Sub", "context": "0.16과 5 사이의 난수를 발생시켜 셀에 뿌림\n난수의 합이 400을 넘으면 난수 생성을 종료\n마지막 행의 아래 두 번째 셀에 합계를 구하고 노란색으로 색채우기\n소수점은 자릿수 상관없이 모두 셀에 나타나도록\n매크로 실행 전                                       매크로 실행 후 결과\nOption Explicit\nSub make_Random_Sum_400()\nDim sngSum As\nSingle\n'난수의 합을 넣을 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Columns(\"A\")\n'A열에서\n.\nClear\n'기존 데이터 삭제\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nCells(r, 1) =\nRnd\n* (5 - 0.16) + 0.16\n'0.16과 5 사이의 난수를 셀에 입력\nsngSum = sngSum + Cells(r, 1)\n'발생시킨 난..."}
{"instruction": "Excel VBA code for: (861) 각 행의 가장 오른쪽 문자 찾아 넣기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub lastWord_In_Row()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rowsCnt As Long\n'사용영역의 전체행 개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"G\").\nClearContents\n'G열의 기존 데이터 삭제\nrowsCnt = ActiveSheet.UsedRange.\nRows.Count\n'전체사용 영역의 행 개수를 변수에\nFor Each rngC In Cells(1, \"G\").Resize(rowsCnt)\n'G열의 각 셀을 순환\nrngC.\nNumberFormat\n= rngC.\nEnd(1)\n.NumberFormat\n'각 셀에 가장 오른쪽 문자의 서식복사\nrngC = rngC.End(1)\n'각 셀에 가장오른쪽 문자 입력\nNext rngC\nColumns(\"G\").AutoFit\n'G열 열너비 자동 맞춤\nEnd Sub", "context": "1. 각 행의 가장 오른쪽 문자 찾아 넣기\n2. G열에 기존 셀의 서식을 유지\n매크로 실행 전\n매크로 실행 후\nOption Explicit\nSub lastWord_In_Row()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rowsCnt As Long\n'사용영역의 전체행 개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"G\").\nClearContents\n'G열의 기존 데이터 삭제\nrowsCnt = ActiveSheet.UsedRange.\nRows.Count\n'전체사용 영역의 행 개수를 변수에\nFor Each rngC In Cells(1, \"G\").Resize(rowsCnt)\n'G열의 각 셀을 순환\nrngC.\nNumberFormat\n= rngC.\nEnd(1)\n.NumberFormat\n'각 셀에 가장 오른쪽 문자의 서식복사\nrngC = rngC.End(1)\n'각 셀에 가장오른쪽 문자 입력\nNext ..."}
{"instruction": "Excel VBA code for: (863) 각 행의 가장 오른쪽 문자 찾아 넣기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub lastWord_In_Row2()\nDim rowsCnt As Long\n'사용영역의 전체행 개수 넣을 변수\nDim r As Long\n'행(r)ow 반복에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"G\").ClearContents\n'G열의 기존 데이터 삭제\nrowsCnt = ActiveSheet.UsedRange.Rows.Count\n'현재시트 사용영역 행 개수를 변수에\nFor r = 1 To rowsCnt\n'행 개수만큼 반복\nWith Rows(r).SpecialCells(2)\n'각 행의 문자셀에서\nWith .\nAreas\n(.\nAreas.Count\n)\n'각 행 마지막 area에서\nCells(r, \"G\").NumberFormat = .Cells(.\nCells.Count\n).NumberFormat\n'마지막 셀의 서식을 복사\nCells(r, \"G\") = .\nCells\n(.Cells.Count)\n'마지막 셀의 값을 복사\nEnd With\nEnd With\nNext r\nColumns(\"G\").AutoFit\n'G열 열너비 자동 맞춤\nEnd Sub", "context": "1. 각 행의 가장 오른쪽 문자 찾아 넣기\n2. G열에 기존 셀의 서식을 유지\n매크로 실행 전\n매크로 실행 후\nOption Explicit\nSub lastWord_In_Row2()\nDim rowsCnt As Long\n'사용영역의 전체행 개수 넣을 변수\nDim r As Long\n'행(r)ow 반복에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"G\").ClearContents\n'G열의 기존 데이터 삭제\nrowsCnt = ActiveSheet.UsedRange.Rows.Count\n'현재시트 사용영역 행 개수를 변수에\nFor r = 1 To rowsCnt\n'행 개수만큼 반복\nWith Rows(r).SpecialCells(2)\n'각 행의 문자셀에서\nWith .\nAreas\n(.\nAreas.Count\n)\n'각 행 마지막 area에서\nCells(r, \"G\").NumberFormat = .Cells(.\nCells.Count\n..."}
{"instruction": "Excel VBA code for: (864) 각 행의 가장 오른쪽 문자 찾아 넣기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub lastWord_In_Row3()\nDim rngR As Range\n'각 행을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim lastCell As Range\n'각 행의 마지막 문자 있는 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"G\").ClearContents\n'G열의 기존 데이터 삭제\nFor Each rngR In [A1].CurrentRegion.\nRows\n'A1 연결영역 각 행을 순환\nFor Each rngC In rngR.\nCells\n'각 행의 각 셀을 순환\nIf\nIsEmpty\n(rngC) Then\n'각 셀이 비어 있으면\nSet lastCell = lastCell\n'lastCell 값을 유지\nElse: Set lastCell = rngC\n'셀이 비어있지 않으면 lastCell에 각 셀값을 넣음\nEnd If\nNext rngC\nCells(lastCell.Row, \"G\").\nNumberFormat\n= lastCell.NumberFormat\n'일치한 셀의 서식을 복사\nCells(lastCell.Row, \"G\") = lastCell\n'일치한 셀의 값을 복사\nNext rngR\nColumns(\"G\").AutoFit\n'G열 열너비 자동 맞춤\nEnd Sub", "context": "1. 각 행의 가장 오른쪽 문자 찾아 넣기\n2. G열에 기존 셀의 서식을 유지\n매크로 실행 전\n매크로 실행 후\nOption Explicit\nSub lastWord_In_Row3()\nDim rngR As Range\n'각 행을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim lastCell As Range\n'각 행의 마지막 문자 있는 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"G\").ClearContents\n'G열의 기존 데이터 삭제\nFor Each rngR In [A1].CurrentRegion.\nRows\n'A1 연결영역 각 행을 순환\nFor Each rngC In rngR.\nCells\n'각 행의 각 셀을 순환\nIf\nIsEmpty\n(rngC) Then\n'각 셀이 비어 있으면\nSet lastCell = lastCell\n'lastCell 값을 유지\nElse: Set lastCell = ..."}
{"instruction": "Excel VBA code for: (865) 각 행의 가장 오른쪽 문자 찾아 넣기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub lastWord_In_Row4()\nDim colsCnt As Long\n'A1셀 연결영역의 전체열 개수 넣을 변수\nDim c As Integer\n'열(c)olumn 반복에 사용할 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"G\").ClearContents\n'G열의 기존 데이터 삭제\ncolsCnt = [A1].CurrentRegion.Columns.Count\n'A1 연결영역의 열개수를 변수에\nFor c = colsCnt To 1\nStep -1\n'큰 열부터 작은열로 내려가며 반복\nFor Each rngC In\nColumns(c).SpecialCells(2)\n'각 열의 문자셀을 순환\nIf Cells(rngC.Row, \"G\") = \"\" Then\n'만일 각 셀의 G열셀이 비어 있다면\nCells(rngC.Row, \"G\").\nNumberFormat\n= rngC.NumberFormat\n'각 셀의 서식을 복사\nCells(rngC.Row, \"G\") = rngC\n'각 셀의 값을 복사\nEnd If\nNext rngC\nNext c\nColumns(\"G\").AutoFit\n'G열 열너비 자동 맞춤\nEnd Sub", "context": "1. 각 행의 가장 오른쪽 문자 찾아 넣기\n2. G열에 기존 셀의 서식을 유지\n매크로 실행 전\n매크로 실행 후\nOption Explicit\nSub lastWord_In_Row4()\nDim colsCnt As Long\n'A1셀 연결영역의 전체열 개수 넣을 변수\nDim c As Integer\n'열(c)olumn 반복에 사용할 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"G\").ClearContents\n'G열의 기존 데이터 삭제\ncolsCnt = [A1].CurrentRegion.Columns.Count\n'A1 연결영역의 열개수를 변수에\nFor c = colsCnt To 1\nStep -1\n'큰 열부터 작은열로 내려가며 반복\nFor Each rngC In\nColumns(c).SpecialCells(2)\n'각 열의 문자셀을 순환\nIf Cells(rngC.Row, \"G\") ..."}
{"instruction": "Excel VBA code for: (866) 문자 중 한문만 추출하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Hanmun2()\nDim rngC As Range\n'선택영역의 각 셀을 넣을 변수\nDim r As Integer\n'셀의 문자길이만큼 반복할 변수\nDim str As String\n'추출한 각 문자 넣을 변수\nDim strU As String\n'문자를 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Columns(1).SpecialCells(2)\n'선택영역 각 셀을 순환\nFor r = 1 To Len(rngC)\n'각셀의 문자 길이 만큼 반복\nstr =\nMid\n(rngC, r, 1)\n'셀의 각 문자를 변수에 넣음\nIf str\nLike \"[伽-詰]\"\nThen\n'각 문자가 한문이면\nstrU = strU & Mid(rngC, r, 1)\n'문자를 합쳐간다\nEnd If\nNext r\nrngC.Next = strU\n'각셀의 오른쪽에 한문을 뿌림\nstrU = \"\"\n'재사용 위하여 초기화\nNext rngC\nEnd Sub", "context": "(아래 매크로는\n伽 ~ 詰\n까지로  한글 16진수 (Korean(hex)) 문자에 한함)\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub extract_Hanmun2()\nDim rngC As Range\n'선택영역의 각 셀을 넣을 변수\nDim r As Integer\n'셀의 문자길이만큼 반복할 변수\nDim str As String\n'추출한 각 문자 넣을 변수\nDim strU As String\n'문자를 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Columns(1).SpecialCells(2)\n'선택영역 각 셀을 순환\nFor r = 1 To Len(rngC)\n'각셀의 문자 길이 만큼 반복\nstr =\nMid\n(rngC, r, 1)\n'셀의 각 문자를 변수에 넣음\nIf str\nLike \"[伽-詰]\"\nThen\n'각 문자가 한문이면\nstrU = strU & Mid(rngC, r, ..."}
{"instruction": "Excel VBA code for: (867) 문자 중 한문만 추출하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Hanmun3()\nDim rngC As Range\n'선택영역의 각 셀을 넣을 변수\nDim r As Integer\n'셀의 문자길이만큼 반복할 변수\nDim str As String\n'추출한 각 문자 넣을 변수\nDim strU As String\n'문자를 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Columns(1).SpecialCells(2)\n'선택영역 각 셀을 순환\nFor r = 1 To Len(rngC)\n'각셀의 문자 길이 만큼 반복\nstr =\nMid\n(rngC, r, 1)\n'셀의 각 문자를 변수에 넣음\nSelect Case str\n'각 문자가\nCase \"伽\" To \"詰\n\":  strU = strU & Mid(rngC, r, 1)\nEnd Select\n'한문이면 문자를 합쳐간다\nNext r\nrngC.Next = strU\n'각셀의 오른쪽에 한문을 뿌림\nstrU = \"\"\n'재사용 위하여 초기화\nNext rngC\nEnd Sub", "context": "(아래 매크로는\n伽 ~ 詰\n까지로 표현되는 한글 16진수 (Korean(hex)) 문자에 한함)\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub extract_Hanmun3()\nDim rngC As Range\n'선택영역의 각 셀을 넣을 변수\nDim r As Integer\n'셀의 문자길이만큼 반복할 변수\nDim str As String\n'추출한 각 문자 넣을 변수\nDim strU As String\n'문자를 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Columns(1).SpecialCells(2)\n'선택영역 각 셀을 순환\nFor r = 1 To Len(rngC)\n'각셀의 문자 길이 만큼 반복\nstr =\nMid\n(rngC, r, 1)\n'셀의 각 문자를 변수에 넣음\nSelect Case str\n'각 문자가\nCase \"伽\" To \"詰\n\":  strU = strU & Mid(..."}
{"instruction": "Excel VBA code for: (868) 한글과 괄호친 한문만 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Hangul_Hanmun()\nDim rngC As Range\n'선택영역의 각 셀을 넣을 변수\nDim r As Integer\n'셀의 문자길이만큼 반복할 변수\nDim str As String\n'추출한 각 문자 넣을 변수\nDim strU As String\n'문자를 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Columns(1).SpecialCells(2)\n'선택영역 각 셀을 순환\nFor r = 1 To Len(rngC)\n'각셀의 문자 길이 만큼 반복\nstr = Mid(rngC, r, 1)\n'셀의 각 문자를 변수에 넣음\nSelect Case str\n'각 문자가\nCase \"ㄱ\" To \"힣\", \"(\", \")\", \" \"\n:  strU = strU & Mid(rngC, r, 1)\nEnd Select\n'한글, 한문, 괄호, 공백이면 문자를 합쳐간다\nNext r\nrngC.Next =\nWorksheetFunction\n.\nTrim\n(strU)\n'각셀의 공백 제거후 셀에 뿌림\nstrU = \"\"\n'재사용 위하여 초기화\nNext rngC\nColumns(\"B\").AutoFit\n'B열 열너비 자동맞춤\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub extract_Hangul_Hanmun()\nDim rngC As Range\n'선택영역의 각 셀을 넣을 변수\nDim r As Integer\n'셀의 문자길이만큼 반복할 변수\nDim str As String\n'추출한 각 문자 넣을 변수\nDim strU As String\n'문자를 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Columns(1).SpecialCells(2)\n'선택영역 각 셀을 순환\nFor r = 1 To Len(rngC)\n'각셀의 문자 길이 만큼 반복\nstr = Mid(rngC, r, 1)\n'셀의 각 문자를 변수에 넣음\nSelect Case str\n'각 문자가\nCase \"ㄱ\" To \"힣\", \"(\", \")\", \" \"\n:  strU = strU & Mid(rngC, r, 1)\nEnd Select\n'한글, 한문, 괄호..."}
{"instruction": "Excel VBA code for: (870) 특정 문자열의 행만 가져오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Specific_Data()\nDim wkSht As\nWorksheet\n'각 시트를 넣을 변수\nDim rngC As Range\n'(각 시트 B열의)각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"A\").\nNumberFormatLocal\n= \"mm\"\"월\"\" dd\"\"일\"\"\"\n'A열 서식을 날짜로\nFor Each wkSht In Worksheets\n'각 시트를 순환\nIf wkSht.Name <> \"out\" Then\n'시트의 이름이 out 아니면\nFor Each rngC In wkSht.Columns(\"B\").SpecialCells(2)\n'각 시트 B열 문자있는 각셀 순환\nIf rngC = \"홍길동\" Then\n'각 셀값이 \"홍길동\"이면\nWith Cells(Rows.Count, \"B\").End(3)(2)\n'out 시트의 위에서 아래로\nIf rngC.\nPrevious\n<> \"\" Then\n'각셀의 앞에 날짜가 있는 경우\n.Previous = rngC.Previous\n'각 셀의 앞의 날짜를 out시트에 복사\nElse\n'각 셀의 앞에 날짜가 없는 경우\n.Previous = rngC.Previous.End(3)\n'각 셀의 앞셀 윗쪽 날짜를 복사\nEnd If\n.Resize(, 2) = rngC.Resize(, 2).Value\n'각 셀의 이름 및 품목을 복사\nEnd With\nEnd If\nNext rngC\nEnd If\nNext wkSht\nColumns(\"A:C\").AutoFit\n'A:C열의 열너비 자동맞춤\nEnd Sub", "context": "s1 시트 및 s2 시트에서 \"홍길동\"이란 이름의 행만 out 시트로 가져오는 기능\n매크로 실행 전 s1 시트                                            매크로 실행 전 s2 시트\n매크로 실행 전 (데이터 통합할 out 시트)                     매크로 실행 후 결과\nOption Explicit\nSub extract_Specific_Data()\nDim wkSht As\nWorksheet\n'각 시트를 넣을 변수\nDim rngC As Range\n'(각 시트 B열의)각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"A\").\nNumberFormatLocal\n= \"mm\"\"월\"\" dd\"\"일\"\"\"\n'A열 서식을 날짜로\nFor Each wkSht In Worksheets\n'각 시트를 순환\nIf wkSht.Name <> \"out\" Then\n'시트의 이름이 out 아니면\nFor..."}
{"instruction": "Excel VBA code for: (871) 각 반원(班員)이 속한 반의 구성원 찾기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Group_Members()\nDim rngT As Range\n'복사된 데이터의 위치 넣을 변수\nDim rngAll As Range\n'Sheet1의 A열 전체를 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngData As Range\n'Sheet2의 A열 전체를 넣을 변수\nDim C As Range\n'검색에 일치하여 찾은 셀을 넣을 변수\nDim rngA As Range\n'검색 일치한 셀의 CurrentRegion을 넣을 변수\nDim rngR As Range\n'검색 일치한 셀영역의 각 행을 넣을 변수\nDim strAddr As String\n'검색 일치셀 셀의 주소를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSheets(\"Sheet3\").Cells.ClearContents\n'Sheet3의 기존 데이터 삭제\nOn Error\nResume Next\n'에러 발생해도 다음코드 진행\nColumns(\"D:E\").SpecialCells(2).CurrentRegion.ClearContents\n'D:E열에 있는 기존 데이터 삭제\nOn Error GoTo 0\n'에러 검출기능 복원\nSet rngAll = Range([A2], Cells(Rows.Count, \"A\").End(3))\n'A열 전체데이터를 변수에 넣음\nWith Sheets(\"Sheet2\")\n'Sheet2에서\nSet rngData = .Range(.[A2], .Cells(Rows.Count, \"A\").End(3))\nEnd With\n'A열 전체데이터를 변수에 넣음\nrngAll.Offset(, 2) = \"Stop\"\n'데이터 복사위치 설정 위한 임시문자 삽입\nFor Each rngC In rngData\n'Sheet2 A열의 각 셀을 순환\nWith Sheets(\"Sheet3\").Cells(Rows.Count, \"A\")\n'Sheet3의 복사될 위치\nIf rngC = \"+\" And rngC.Offset(-1) = \"-\"\nOr\n_\nrngC = \"+\" And rngC.Offset(-1) = \"+\" Then\n'윗셀이 - 아랫셀이 + 이거나 윗셀이 + 아랫셀이 + 인 경우\n.\nEnd(3)(3)\n.Resize(, 2) = rngC.Next.Resize(, 3).Value\n'한 칸 띠고 복사\nElse\n'아닐 경우\n.\nEnd(3)(2)\n.Resize(, 2) = rngC.Next.Resize(, 3).Value\n'연속하여 붙여서 복사\nEnd If\nEnd With\nNext rngC\nFor Each rngC In rngAll\n'Sheet1 A열의 각셀을 순환\nSet C = Sheets(\"Sheet3\").Columns(\"A\").SpecialCells(2).\nFind\n(rngC, , ,\nxlWhole\n)\n'각 셀을 Sheet3 A열에서 검색\nIf Not C Is Nothing Then\n'일치하는 셀이 존재하면\nstrAddr = C.Address\n'첫 일치하는 주소를 strAddr에 넣고\nDo\n'다음을 실행\nSet C = Sheets(\"Sheet3\").Columns(\"A\").SpecialCells(2).\nFindNext\n(C)\nIf rngC.Next = C.Next Then\n'주민번호가 일치하면\nSet rngA = C.CurrentRegion\n'일치한 셀의 현재영역을 변수에 넣음\nFor Each rngR In rngA.\nRows\n'rngA의 각 행을 순환\nCells(rngC.Row, Columns.Count).End(1)(1, 2).Resize(, 2) = rngR.Value\n'검색에 일치한 영역의 각 행을 복사\nNext rngR\nExit Do\n'Do 구문 탈출\nEnd If\nLoop While\nNot C Is Nothing And C.Address <> strAddr\n'일치하는 데이터 없을때까지, 처음 찾은 주소가 아닐때까지 반복\nEnd If\nNext rngC\nrngAll.Offset(, 2).ClearContents\n'임시문자 삭제\nColumns.AutoFit\n'열너비 자동맞춤\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "Sheet1 A열의 각 이름을 Sheet2 B열에서 찾음.\n이름과 주민번호 일치가 일치하면 각 이름이 속한 반장과 반원 전체 이름과 주민번호를 Sheet1의 D2셀 부터 행에 나열\n매크로 실행 전 Sheet1                               매크로 실행 전 Sheet2\n매크로 실행 후 결과\nOption Explicit\nSub find_Group_Members()\nDim rngT As Range\n'복사된 데이터의 위치 넣을 변수\nDim rngAll As Range\n'Sheet1의 A열 전체를 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngData As Range\n'Sheet2의 A열 전체를 넣을 변수\nDim C As Range\n'검색에 일치하여 찾은 셀을 넣을 변수\nDim rngA As Range\n'검색 일치한 셀의 CurrentRegion을 넣을 변수\nDim rngR As Range\n'검색 일치한 셀영역의 각 행을 넣을 변수\nDim..."}
{"instruction": "Excel VBA code for: (872) 행방향으로 공백제거 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Blanks_In_Row1()\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.\nSpecialCells(4)\n.Delete\nxlToLeft\n'현재시트 사용영역의 전체 빈셀을 왼쪽으로 밀면서 삭제\nEnd Sub", "context": "매크로 실행 전 공백이 여기 저기 있는 모습                   매크로 실행 후 결과 (행방향으로 공백 제거)\nOption Explicit\nSub remove_Blanks_In_Row1()\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.\nSpecialCells(4)\n.Delete\nxlToLeft\n'현재시트 사용영역의 전체 빈셀을 왼쪽으로 밀면서 삭제\nEnd Sub..."}
{"instruction": "Excel VBA code for: (873) 행방향으로 공백제거 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Blanks_In_Row2()\nDim rngAll As Range\n'전체 데이터영역을 넣을 변수\nDim i As Long\n'행 반복에 사용할 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'배열 늘려갈 변수\nDim varTemp()\n'배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveSheet.UsedRange\n'현재시트 사용영역\nSet rngAll = .Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 1)\n'전체 데이터영역을 변수에 넣음\nEnd With\nFor i = 1 To rngAll.Rows.Count\n'전체행 개수만큼 반복\nWith rngAll.\nRows\n(i)\n'각 행에서\nFor Each rngC In .\nCells\n'각 셀을 순환\nIf\nNot IsEmpty\n(rngC) Then\n'각 셀이 빈셀이 아니라면\nr = r + 1\n'배열크기 늘려감\nReDim Preserve\nvarTemp(1 To 1, 1 To r)\n'배열크기 재지정\nvarTemp(1, r) = rngC\n'배열에 값을 넣음\nEnd If\nNext rngC\n.ClearContents\n'기존 각 행의 데이터 삭제\n.Cells(1).Resize(,\nUBound\n(varTemp, 2)) = varTemp\n'배열값 행에 뿌림\nr = 0\n'재사용 위하여 초기화\nEnd With\nNext i\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전 공백이 여기 저기 있는 모습                   매크로 실행 후 결과 (행방향으로 공백 제거)\nOption Explicit\nSub remove_Blanks_In_Row2()\nDim rngAll As Range\n'전체 데이터영역을 넣을 변수\nDim i As Long\n'행 반복에 사용할 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'배열 늘려갈 변수\nDim varTemp()\n'배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveSheet.UsedRange\n'현재시트 사용영역\nSet rngAll = .Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 1)\n'전체 데이터영역을 변수에 넣음\nEnd With\nFor i = 1 To rngAll.Rows.Count\n'전체행 개수만큼 반복\nWith rngAl..."}
{"instruction": "Excel VBA code for: (874) 행방향으로 공백제거 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Blanks_In_Row3()\nDim rngR As Range\n'전체 데이터의 각 행을 넣을 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'행 반복에 사용할 변수\nDim c As Integer\n'열 개수 늘려갈 변수\nDim varTemp\n'배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngR = Range(\"B1\", \"H1\")\n'첫 행을 변수에 넣음\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'마지막 행을 변수에 넣음\nFor r = 1 To lastRow - 1\n'전체행 개수 -1 만큼 반복\nvarTemp = rngR.Offset(r)\n'각 행을 배열에 넣음\nrngR.Offset(r).ClearContents\n'기존 데이터 삭제\nFor c = 1 To\nUBound\n(varTemp, 2)\n'배열 개수만큼 반복\nIf varTemp(1, c) <> \"\" Then\n'배열내 값이 비어있지 않으면\nCells(r + 1, Columns.Count).End\n(1)(1, 2)\n= varTemp(1, c)\n'배열의 값을 셀에 뿌림\nEnd If\nNext c\nNext r\nSet rngR = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전 공백이 여기 저기 있는 모습                  매크로 실행 후 결과 (행방향으로 공백 제거)\nOption Explicit\nSub remove_Blanks_In_Row3()\nDim rngR As Range\n'전체 데이터의 각 행을 넣을 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'행 반복에 사용할 변수\nDim c As Integer\n'열 개수 늘려갈 변수\nDim varTemp\n'배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngR = Range(\"B1\", \"H1\")\n'첫 행을 변수에 넣음\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'마지막 행을 변수에 넣음\nFor r = 1 To lastRow - 1\n'전체행 개수 -1 만큼 반복\nvarTemp = rngR.Offset(r)\n'각 행을 배열에 넣음\nrng..."}
{"instruction": "Excel VBA code for: (876) 행방향으로 공백제거 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Blanks_In_Row5()\nDim rngAll As Range\n'전체 데이터영역을 넣을 변수\nDim rngR As Range\n'각 행을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveSheet.UsedRange\n'현재시트 사용영역\nSet rngAll = .Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 1)\nEnd With\n'전체 데이터영역을 변수에 넣음\nFor Each rngR In rngAll.\nRows\n'전체영역 각 행을 순환\nrngR.SpecialCells(2).\nCopy\nrngR.Cells(1).Offset(, rngR.Columns.Count)\n'각 행을 문자만 각 행의 오른쪽에 복사\nNext rngR\nrngAll.\nDelete\nxlToLeft\n'기존 데이터 삭제후 왼쪽으로 당김\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전 공백이 여기 저기 있는 모습                   매크로 실행 후 결과 (행방향으로 공백 제거)\nOption Explicit\nSub remove_Blanks_In_Row5()\nDim rngAll As Range\n'전체 데이터영역을 넣을 변수\nDim rngR As Range\n'각 행을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveSheet.UsedRange\n'현재시트 사용영역\nSet rngAll = .Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 1)\nEnd With\n'전체 데이터영역을 변수에 넣음\nFor Each rngR In rngAll.\nRows\n'전체영역 각 행을 순환\nrngR.SpecialCells(2).\nCopy\nrngR.Cells(1).Offset(, rngR.Columns.Count)\n'각 행을 문자만 각 행의 오른쪽에..."}
{"instruction": "Excel VBA code for: (879) 행방향으로 공백제거 7 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Blanks_In_Row4()\nDim rngAll As Range\n'전체 데이터영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveSheet.UsedRange\n'현재시트 사용영역\nSet rngAll = .Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 1)\nEnd With\n'전체 데이터영역을 변수에 넣음\nFor Each rngC In rngAll\n'전체영역 각셀을 순환\nIf rngC <> \"\" And rngC.\nPrevious\n= \"\" Then\n'각 셀에 값이 있고 왼쪽셀이 빈셀이면\nrngC.\nEnd(1)(1, 2)\n= rngC\n'종단셀 왼쪽방향에 각 셀값을 넣음\nrngC =\nvbNullString\n'각 셀값을 삭제\nEnd If\nNext rngC\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "어느 코드가 더 빠른지는 모르겠다. 단지 미래의 공부를 위해서 여러가지 접근 방법을 사용해보는 것일 뿐. 특정 코드가 \"느리다 또는 비효율적이다\"라고 딴지거는 분은 없으시기를. ^^\n매크로 실행 전 공백이 여기 저기 있는 모습                   매크로 실행 후 결과 (행방향으로 공백 제거)\nOption Explicit\nSub remove_Blanks_In_Row4()\nDim rngAll As Range\n'전체 데이터영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveSheet.UsedRange\n'현재시트 사용영역\nSet rngAll = .Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 1)\nEnd With\n'전체 데이터영역을 변수에 넣음\nFor Each rngC In rngAll\n'전체영역 각..."}
{"instruction": "Excel VBA code for: (881) 데이터 위치 각 숫자와 함께 재배치하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub distribute_Each_No()\nDim rngAll As Range\n'전체 데이터영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngT As Range\n'각 데이터 복사될 타겟(T) 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"H:K\").\nClear\n'기존 데이터 삭제\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\nSet rngAll = .Offset(1, 3).Resize(, .Columns.Count - 3)\nEnd With\n'전체 데이터영역을 변수에 넣음\nFor Each rngC In rngAll\n'전체영역 각셀을 순환\nIf\nLen(rngC) > 0\nThen\n'각 셀이 값이 있을 경우\nSet rngT = Cells(Rows.Count, \"H\").End(3)(2)\n'복사될 지점을 변수에 넣음\nWith rngT\n'복사될 지점에서\n.Resize(, 3) = Cells(rngC.Row, 1).Resize(, 3).Value\n'알파벳 문자 3열을 복사\n.Offset(, 3) = rngC\n'각 숫자를 복사\nEnd With\nEnd If\nNext rngC\nWith [H2].CurrentRegion\n'H2셀과 연결된 현재영역에서\n.\nBorders\n.\nLineStyle = 1\n'복사된 영역의 외곽에 테두리\n.Columns(\"A:C\").\nInterior.Color\n= 12379352\n'복사된 영역 알파벳에 색채우기\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub distribute_Each_No()\nDim rngAll As Range\n'전체 데이터영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngT As Range\n'각 데이터 복사될 타겟(T) 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"H:K\").\nClear\n'기존 데이터 삭제\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\nSet rngAll = .Offset(1, 3).Resize(, .Columns.Count - 3)\nEnd With\n'전체 데이터영역을 변수에 넣음\nFor Each rngC In rngAll\n'전체영역 각셀을 순환\nIf\nLen(rngC) > 0\nThen\n'각 셀이 값이 있을 경우\nSet rngT = Cells(Rows.Count, \"H\").End(3)(2)\n'복..."}
{"instruction": "Excel VBA code for: (882) 텍스트, .csv파일 import하는 기본코드 (엑셀 VBA 매크로)", "input": "", "output": "Sub import_Text_With_Offset()\n'특정 행을 건너 뛰며 데이터 가져오기\nDim strInput As String\n'각 행을 읽어서 저장할 변수\nDim cnt As Long\n'카운터로 사용할 변수\nDim strName As String\n'읽어들일 파일이름 넣을 변수\nDim r As Long\n'행번호 늘려갈 변수\nDim intNo As Integer\n'몇번째 행마다 출력 할지 결정할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nSheets(2).UsedRange.ClearContents\n'Sheet2의 기존 데이터 삭제\nstrName = Application.\nGetOpenFilename\n(\"텍스트파일,*.txt;*.\ncsv\n;*.prn\", _\nTitle:=\"텍스트파일\")\n'파일을 열어서 파일명을 변수에 넣음\nIf strName =\n\"False\"\nThen\n'취소(Cancel) 선택 시\nMsgBox \"취소(Cancel)하여 중단합니다.\", 64, \"파일선택 오류\"\n'오류메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nOpen\nstrName For\nInput As #1\n'선택한 파일 열기\ncnt = 1\n'카운트 1부터 시작\nr = 1\n'1행부터 시작\nintNo =\n3\n'3번째 행마다 출력.\nDo Until\nEOF(1)\n'파일의 마지막 행까지 실행\nLine Input #1\n, strInput\n'각 행을 읽어서 strInput에 저장\nIf cnt\nMod\nintNo = 0 Then\n'카운터를 intNo로 나눈 나머지가 0이면\nSheets(\"Sheet2\").Cells(r, 1) = strInput\n'입력받은 데이터를 각 셀에 뿌림\nr = r + 1\n'행번호 1씩 늘려감\nEnd If\ncnt = cnt + 1\n'카운터 1씩 늘려감\nLoop\n'무한 반복\nClose #1\n'파일 닫기\nEnd Sub\n\nSub import_Tab_Limited_Textfile()\nDim fileName As String\n'파일 이름을 넣을 변수\nDim strInput As String\n'각 행의 불러온 문자 넣을 변수\nDim varTemp As Variant\n'각 행을 tab으로 쪼개어 넣을 배열 변수\nDim r As Long\n'행(r)ow을 1씩 늘려갈 변수\nDim c As Integer\n'열(c)olumn을 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nfileName = Application.GetOpenFilename(\"Text Files (*.txt),*.txt\", , _\n\"탭으로 구분된 텍스트파일\")\n'파일을 열어서 파일명을 변수에 넣음\nIf fileName = \"False\" Then Exit Sub\n'취소를 선택시 매크로 종료\nOpen fileName For Input As #1\n'첫 번째 파일을 열기\nLine Input #1, strInput\n'각 행을 불러와 strInput에 넣음\nDo Until EOF(1)\n'파일의 마지막까지 실행\nvarTemp = Split(strInput,\nvbTab\n)\n'불러온 행을 tab으로 나누어 배열에 넣음\nr = r + 1\n'행을 1씩 늘려감\nFor c = LBound(varTemp) To UBound(varTemp)\n'배열 개수만큼 반복\nCells(r, c + 1) = Val(varTemp(c))\n'배열값을 셀에 뿌림\nNext c\n'Cells(r, UBound(varTemp) + 1) = varTemp\n'문자인 경우 윗줄의 코드 대신 사용\nLine Input #1, strInput\n'다음 행을 불러옴\nLoop\n'무한 반복\nClose #1\n'불러온 파일 닫기\nEnd Sub\n\nSub import_Textfiles_From_Certain_Row()\nDim strName As String\n'검색할 단어를 넣을 변수\nDim lngNo As Long\n'전체 가져올 행을 넣을 변수\nDim fileNames As Variant\n'모든 파일 넣을 배열 변수\nDim i As Integer\n'반복 구문에 사용할 변수\nDim strInput As String\n'각 행의 불러온 문자 넣을 변수\nDim varTemp As Variant\n'각 행을 tab으로 쪼개어 넣을 배열 변수\nDim r As Long\n'행(r)ow을 1씩 늘려갈 변수\nDim cnt As Integer\n'행 개수 카운터로 사용할 변수\nDim c As Integer\n'열(c)olumn을 1씩 늘려갈 변수\nDim blnTF As Boolean\n'시작행 판단한 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nActiveSheet.UsedRange.ClearContents\n'기존 데이터 삭제\nstrName = \"found\"\n'검색할 단어를 변수에 넣음\nlngNo = 3\n'검색 일치한 행부터 가져올 행개수\nfileNames = Application.\nGetOpenFilename\n(\"텍스트파일,*.txt;*.\ncsv\n;*.prn\", _\nTitle:=\"텍스트 파일을 선택\",\nMultiSelect:=True\n)\n'파일을 열어서 파일명을 변수에 넣음\nIf\nTypeName\n(fileNames) = \"Boolean\" Then Exit Sub\n'취소 선택 시 매크로 종료\nFor i = 1 To UBound(fileNames)\n'선택한 파일 개수만큼 반복\nOpen\nfileNames(i) For Input As #1\n'각 파일을 열기\nLine Input\n#1, strInput\n'각 행을 불러와 strInput에 넣음\nDo Until\nEOF(1)\n'파일의 마지막까지 실행\nIf\nInStr\n(strInput, strName) Then\n'행에 strName 포함되어 있으면\nblnTF = True\n'blnTF 를 참으로 바꿈\nEnd If\nIf blnTF = True Then\n'blnTF가 참인 경우에\nvarTemp = Split(strInput, vbTab)\n'불러온 행을 tab으로 나누어 배열에 넣음\nr = r + 1\n'행을 1씩 늘려감\ncnt = cnt + 1\n'카운터 1씩 늘려감\nFor c =\nLBound\n(varTemp) To\nUBound\n(varTemp)\n'배열 개수만큼 반복\nCells(r, c + 1) = varTemp(c)\n'배열값을 셀에 뿌림\nNext c\nEnd If\nIf cnt = lngNo Then Exit Do\n'lngNo 만큼 행을 가져오면 do 구문 종료\nLine Input #1, strInput\n'다음 행을 불러옴\nLoop\n'무한 반복\ncnt = 0\n'재사용 위하여 카운터 초기화\nblnTF = False\n'시작 판단행 변수를 초기화\nClose\n#1\n'열은 파일 닫기\nNext i\nEnd Sub", "context": "텍스트 파일 불러올 경우가 가끔 있으므로 미리 텍스트파일 불러오는 기본코드를 작성해 놓음.\nintNo = 1\n이라고 하면 모든 행을 불러오고, 1보다 클경우 intNo 숫자 만큼 행을 건너뛰면서 텍스트 파일을 불러온다.\n매크로 실행 전 (Sheet2는 비어 있는 상태임)           매크로 실행 후 결과 파일 (Sheet2)\n매크로 실행 후 나타나는 파일 선택창 (가져오려는 텍스트파일을 선택하면 됨)\nOption Explicit\nSub import_Text_With_Offset()\n'특정 행을 건너 뛰며 데이터 가져오기\nDim strInput As String\n'각 행을 읽어서 저장할 변수\nDim cnt As Long\n'카운터로 사용할 변수\nDim strName As String\n'읽어들일 파일이름 넣을 변수\nDim r As Long\n'행번호 늘려갈 변수\nDim intNo As Integer\n'몇번째 행마다 출력 할지 결정할 변수\nApplication.ScreenUpdating..."}
{"instruction": "Excel VBA code for: (884) 합계내고 자료 재 정리하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub sum_And_relocate()\nDim rngAll As Range\n'Sheet2의 제목제외한 데이터 영역 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngT As Range\n'Sheet3의 복사될 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSheets(2).UsedRange.ClearContents\n'기존 데이터 삭제\nSheets(3).UsedRange.ClearContents\n'기존 데이터 삭제\nRows(1).Copy Sheets(2).[A1]\n'제목을 Sheet2에 복사\nWith ActiveSheet.UsedRange.Offset(1)\n'현재시트 제목 제외한 사용영역\nSheets(2).[A2].\nConsolidate\nSources:=.\nAddress\n(1, 1, xlR1C1, 1), _\nFunction:=\nxlSum\n, LeftColumn:=True\n'데이터 통합하여 Sheet2에 복사\nEnd With\nWith Sheets(2).UsedRange\n'Sheet2의 사용영역에서\nSet rngAll = .Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 2)\nEnd With\n'제목과 끝행 제외한 데이터 영역을 변수에 넣음\nFor Each rngC In rngAll\n'rngAll의 각 셀을 순환\nIf\nLen(rngC) > 0\nThen\n'각 셀이 비어 있지 않다면\nSet rngT = Sheets(3).Cells(Rows.Count, 1).End(3)(2)\n'복사위치를 변수에 넣음\nrngT = Cells(rngC.Row, 1)\n'A열에 과일이름 넣음\nrngT.Next = rngC\n'B열에 합쳐진 과일 개수 넣음\nrngT.Offset(, 2) = Cells(1, rngC.Column)\n'C열에 가,나, 다...제목 넣음\nEnd If\nNext rngC\nSheets(3).Activate\n'Sheet3 활성화\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "Sheet1의 각 과일의 개수를 \"가, 나, 다...\"별로 합산하여 Sheet3와 같이 자료를 재 정리하는 기능.\n매크로 실행 전 (Sheet2 와 Sheet3는 비어 있는 상태)\n매크로 실행 후 데이터를 임시 복사한 Sheet2            매크로 실행 후 결과 데이터\nOption Explicit\nSub sum_And_relocate()\nDim rngAll As Range\n'Sheet2의 제목제외한 데이터 영역 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngT As Range\n'Sheet3의 복사될 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSheets(2).UsedRange.ClearContents\n'기존 데이터 삭제\nSheets(3).UsedRange.ClearContents\n'기존 데이터 삭제\nRows(1).Copy Sheets(2).[A1]\n'제목을 Sheet2에 복사\nWi..."}
{"instruction": "Excel VBA code for: (885) 꼬리처럼 나와 있는 각 열의 문자만 선택하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub select_Tails()\nDim lngA As Long\n'A열의 전체행 개수 넣을 변수\nDim lngB As Long\n'B열의 전체행 개수 넣을 변수\nlngA = Cells(Rows.Count, 1).End(3).\nRow\n'A열의 마지막 행을 변수에\nlngB = Cells(Rows.Count, 2).End(3).Row\n'B열의 마지막 행을 변수에\nIf lngA > lngB Then\n'A열의 행이 B보다 큰 경우\nRows(lngA & \":\" & lngB + 1).\nSpecialCells(2\n).\nSelect\n'A열 - B열 + 1 위치의 행에 있는 문자만 선택\nElseIf lngA = lngB Then\n'A열과 B열이 행이 같을 경우\nMsgBox \"A열과 B열의 행 개수가 동일합니다.\", 64, \"행 개수 동일\"\n'메시지 출력\nExit Sub\n'매크로 중단\nElse\n'B열의 행이 A열보다 크 경우\nRows(lngB & \":\" & lngA + 1).SpecialCells(2).Select\n'B열 - A열 + 1 위치의 행에 있는 문자만 선택\nEnd If\nEnd Sub", "context": "A열과 B열의 행 개수를 비교하여 각 열의 꼬리처럼 나와 있는 영역만을 모두 선택하는 것. 큰 유용성은 없을지 모르지만 영역선택을 자유롭게 할 수 있다면 매크로 작성 시 큰 도움이 되므로 다양한 영역선택 연습을 해보는 것임.\n매크로 실행 전                                                          매크로 실행 후\n매크로 실행 전                                                          매크로 실행 후\nOption Explicit\nSub select_Tails()\nDim lngA As Long\n'A열의 전체행 개수 넣을 변수\nDim lngB As Long\n'B열의 전체행 개수 넣을 변수\nlngA = Cells(Rows.Count, 1).End(3).\nRow\n'A열의 마지막 행을 변수에\nlngB = Cells(Rows.Count, 2).End(3).Row\n'B열의 마지막 행을 변수에\nIf lngA ..."}
{"instruction": "Excel VBA code for: (886) 꼬리처럼 나와 있는 각 열의 문자만 선택하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub select_Tails2()\nDim c As Integer\n'각 열을 순환하며 넣을 변수\nDim minRow As Long\n'가장 행이 작은 열의 마지막행 넣을 변수\nminRow = Rows.Count\n'minRow에 전체행의 숫자를 넣음\nWith ActiveSheet.UsedRange\n'현재시트 사용 영역에서\nFor c = 1 To .\nColumns.Count\n'각 열을 순환\nWith Cells(Rows.Count, c).End(3)\n'각 열의 종단셀에서 윗방향\nIf minRow > .\nRow\nThen\n'minRow가 각 열의 마지막 행보다 클경우\nminRow = .Row\n'minRow에 마지막 행을 넣음\nEnd If\nEnd With\nNext c\nIf minRow = 1 Then\n'빈 열이 있다면\n.Select\n'전체 영역을선택\nElse\n'빈 열이 없다면\n.Offset(minRow).SpecialCells(2).Select\n'minRow 만큼 행을 건너뛰고 문자만 선택\nEnd If\nEnd With\nEnd Sub", "context": "각 열의 가장 행이 적은 셀위치 아래의 꼬리처럼 나와 있는 영역만을 모두 선택하는 기능. 매크로 실행 시 다양한 데이터의 모양에 따라 아래와 같은 영역이 선택됨.\n매크로 실행 후                          매크로 실행 후                           매크로 실행 후\nOption Explicit\nSub select_Tails2()\nDim c As Integer\n'각 열을 순환하며 넣을 변수\nDim minRow As Long\n'가장 행이 작은 열의 마지막행 넣을 변수\nminRow = Rows.Count\n'minRow에 전체행의 숫자를 넣음\nWith ActiveSheet.UsedRange\n'현재시트 사용 영역에서\nFor c = 1 To .\nColumns.Count\n'각 열을 순환\nWith Cells(Rows.Count, c).End(3)\n'각 열의 종단셀에서 윗방향\nIf minRow > .\nRow\nThen\n'minRow가 각 열의 마지막 행보다 클경우\n..."}
{"instruction": "Excel VBA code for: (888) 검색한 사람이 속한 팀의 전체 팀원을 선택하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub select_Group_Members()\nDim rngTop  As Range\n'각 그룹 제일 위(+)의 셀을 넣을 변수\nDim rngBottom As Range\n'각 그룹 제일 아래(-) 위치를 넣을 변수\nDim C As Range\n'검색에 일치하여 찾은 셀을 넣을 변수\nDim r As Long\n'행을 1씩 늘리거나 줄여갈 변수\nSet C = Columns(\"B\").SpecialCells(2).\nFind\n([E5], , ,\nxlWhole\n)\n'B열에서 일치하는 이름을 찾아 변수에 넣음\nIf\nC Is Nothing\nThen\n'일치하는 데이터가 없을 경우\nMsgBox \"일치하는 데이터가 없습니다.\", 64, \"데이터 일치 오류\"\n'메시지출력\nExit Sub\n'매크로 종료\nElse\n'일치하는 데이터 있을 경우\nIf C.\nPrevious\n= \"+\"\nAnd\nC.Offset(1, -1) = \"+\" Then\n'왼쪽셀이 +, 왼쪽 아랫셀도 + 인 경우\nC.Previous.Resize(, 3).Select\n'C의 앞셀 한행만 선택\nElseIf C.Previous = \"+\" And C.Offset(1, -1) = \"-\" Then\n'왼쪽셀이 +, 왼쪽 아랫셀은 - 인 경우\nDo\n'다음을 실행\nSet rngBottom = C.Offset(r, -1)\n'C를 offset한 셀을 변수에 넣음\nr = r + 1\n'행을 1씩 늘려감\nLoop Until\nCells(C.Row + r, 1) = \"+\" Or Cells(C.Row + r, 1) = vbNullString\n'셀이 + 이거나 빈셀이 나올때까지 무한 반복\nRange(C.Previous, rngBottom).Resize(, 3).Select\n'C 앞셀에서 rngBottom까지 영역을 선택\nElseIf C.Previous = \"-\" Then\n'C 앞셀이 - 일 경우\nDo\n'다음을 실행\nr = r - 1\n'행을 1씩 줄여감\nSet rngTop = C.Offset(r, -1)\n'C을 offset한 셀을 변수에 넣음\nLoop Until\nCells(C.Row + r, 1) = \"+\"\n'셀이 + 일때까지 무한 반복\nDo\n'다음을 실행\nSet rngBottom = C.Offset(r, -1)\n'C를 offset한 셀을 변수에 넣음\nr = r + 1\n'행을 1씩 늘려감\nLoop Until\nCells(C.Row + r, 1) = \"+\" Or Cells(C.Row + r, 1) = vbNullString\n'셀이 + 이거나 빈셀이 나올때까지 무한 반복\nRange(rngTop, rngBottom).Resize(, 3).Select\n'rngTop에서 rngBottom까지의 영역을 선택\nEnd If\nEnd If\nEnd Sub", "context": "A열의 + 표시는 팀장, - 표시는 그 팀장 밑의 팀원을 의미함. E5셀에 있는 이름을 B열에서 검색하고 일치하는 데이터가 없을 경우 찾는 사람이 없다는 메시지를 출력하고, 일치하는 사람이 있을 경우 팀장을 포함한 전체 팀원을 선택하는 기능.\n(A열의 - 표시를 삭제 후 공백영역으로 만들어서 팀전체에 규칙을 주어 영역을 선택하고 영역 선택후 삭제한 - 표시를 다시 복원하는 것도 한 가지 방법이 될 것으로 생각된다.)\n매크로 실행 전                                                   매크로 실행 후 (\"라\"를 검색 시)\n매크로 실행 후 (\"사\"를 검색 시)                            매크로 실행 후 (\"자\"를 검색 시)\n일치하는 데이터가 없을 경우 나타나는 에러 메시지\nOption Explicit\nSub select_Group_Members()\nDim rngTop  As Range\n'각 그룹 제일 위(+)의 셀을 넣을 변수\n..."}
{"instruction": "Excel VBA code for: (889) 한글 및 한글 자음/모음 들어간 셀 구분하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Hangul()\nDim rngC As Range\n'각 셀을 넣을 변수\nFor Each rngC In Columns(1).SpecialCells(2)\n'A열 문자 있는 전체영역을 변수\nIf rngC\nLike \"*[가-힣]*\"\nOr rngC\nLike \"*[ㄱ-ㅎ]*\"\nOr rngC Like\n\"*[ㅏ-ㅣ]*\"\nThen\n'한글 또는 한글 자음/모음이 들어간 셀이면\nrngC.Next = \"O\"\n'셀 오른쪽에 O 표시\nElse\n'한글이 없다면\nrngC.Next = \"X\"\n'셀 오른쪽에 X 표시\nEnd If\nNext rngC\nEnd Sub", "context": "매크로 실행 전                                                  매크로 실행 후\nOption Explicit\nSub find_Hangul()\nDim rngC As Range\n'각 셀을 넣을 변수\nFor Each rngC In Columns(1).SpecialCells(2)\n'A열 문자 있는 전체영역을 변수\nIf rngC\nLike \"*[가-힣]*\"\nOr rngC\nLike \"*[ㄱ-ㅎ]*\"\nOr rngC Like\n\"*[ㅏ-ㅣ]*\"\nThen\n'한글 또는 한글 자음/모음이 들어간 셀이면\nrngC.Next = \"O\"\n'셀 오른쪽에 O 표시\nElse\n'한글이 없다면\nrngC.Next = \"X\"\n'셀 오른쪽에 X 표시\nEnd If\nNext rngC\nEnd Sub..."}
{"instruction": "Excel VBA code for: (891) 빈셀 있는 1열을 2열로 변환하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub into_2_Columns1()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'A열 마지막 행을 변수에 넣음\nFor i = lastRow To 2\nStep -3\n'마지막 행에서 행을 3씩 줄여감\nCells(i - 1, 2) = Cells(i, 1)\n'셀값을 오른쪽 윗셀에 복사\nCells(i, 1).ClearContents\n'셀값을 삭제\nNext i\nColumns(\"A\").\nSpecialCells(4).\nEntireRow.Delete\n'A열 빈셀의 전체행을 삭제\nEnd Sub", "context": "매크로 실행 전                                               매크로 실행 후\nOption Explicit\nSub into_2_Columns1()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'A열 마지막 행을 변수에 넣음\nFor i = lastRow To 2\nStep -3\n'마지막 행에서 행을 3씩 줄여감\nCells(i - 1, 2) = Cells(i, 1)\n'셀값을 오른쪽 윗셀에 복사\nCells(i, 1).ClearContents\n'셀값을 삭제\nNext i\nColumns(\"A\").\nSpecialCells(4).\nEntireRow.Delete\n'A열 빈셀의 전체행을 삭제\nEnd Sub..."}
{"instruction": "Excel VBA code for: (892) 빈셀 있는 1열을 2열로 변환하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub into_2_Columns2()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'A열 마지막 행을 변수에 넣음\nFor i = lastRow To 2\nStep -3\n'마지막 행에서 행을 3씩 줄여감\nCells(i - 1, 2) = Cells(i, 1)\n'셀값을 오른쪽 윗셀에 복사\nCells(i, 1).Resize(2).\nEntireRow.\nDelete\nNext i\n'현재셀과 아래 빈셀을 동시에 삭제\nEnd Sub", "context": "매크로 실행 전                                               매크로 실행 후\nOption Explicit\nSub into_2_Columns2()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'A열 마지막 행을 변수에 넣음\nFor i = lastRow To 2\nStep -3\n'마지막 행에서 행을 3씩 줄여감\nCells(i - 1, 2) = Cells(i, 1)\n'셀값을 오른쪽 윗셀에 복사\nCells(i, 1).Resize(2).\nEntireRow.\nDelete\nNext i\n'현재셀과 아래 빈셀을 동시에 삭제\nEnd Sub..."}
{"instruction": "Excel VBA code for: (893) 빈셀 있는 1열을 2열로 변환하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub into_2_Columns3()\nDim C As Range\n'각 \"단어\"가 위치한 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet C = Cells(Rows.Count, 1).End(3)(2)\n'마지막행 바로 아랫셀을 C에 넣음\nDo\n'다음을 실행\nSet C = C.\nEnd(3).End(3)\n'윗방향 종단셀 2회후 선택영역을 C에 넣음\nC.Next = C(2, 1)\n'셀 값을 오른쪽에 복사\nC(2, 1).ClearContents\n'아랫셀의 값을 삭제\nLoop Until\nC.Row = 1\n'C의 행이 1이 될때까지 무한 반복\nActiveSheet.UsedRange.\nSort\n[A1], 1\n'A열기준 오름차순 정렬\nEnd Sub", "context": "매크로 실행 전                                               매크로 실행 후\nOption Explicit\nSub into_2_Columns3()\nDim C As Range\n'각 \"단어\"가 위치한 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet C = Cells(Rows.Count, 1).End(3)(2)\n'마지막행 바로 아랫셀을 C에 넣음\nDo\n'다음을 실행\nSet C = C.\nEnd(3).End(3)\n'윗방향 종단셀 2회후 선택영역을 C에 넣음\nC.Next = C(2, 1)\n'셀 값을 오른쪽에 복사\nC(2, 1).ClearContents\n'아랫셀의 값을 삭제\nLoop Until\nC.Row = 1\n'C의 행이 1이 될때까지 무한 반복\nActiveSheet.UsedRange.\nSort\n[A1], 1\n'A열기준 오름차순 정렬\nEnd Sub..."}
{"instruction": "Excel VBA code for: (894) 빈셀 있는 1열을 2열로 변환하기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub into_2_Columns4()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'A열 마지막 행을 변수에 넣음\nFor i = lastRow To 2\nStep -3\n'마지막 행에서 행을 1씩 줄여감\nIf Cells(i, 1)(2, 1) = \"\" Then\n'각 셀 아래가 빈셀일 경우\nCells(i - 1, 2) = Cells(i, 1)\n'셀값을 오른쪽 윗셀에 복사\nCells(i, 1).\nClearContents\n'셀의 값을 삭제\nEnd If\nNext i\nActiveSheet.UsedRange.\nSort\n[A1], 1\n'A열기준 오름차순 정렬\nEnd Sub", "context": "매크로 실행 전                                               매크로 실행 후\nOption Explicit\nSub into_2_Columns4()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'A열 마지막 행을 변수에 넣음\nFor i = lastRow To 2\nStep -3\n'마지막 행에서 행을 1씩 줄여감\nIf Cells(i, 1)(2, 1) = \"\" Then\n'각 셀 아래가 빈셀일 경우\nCells(i - 1, 2) = Cells(i, 1)\n'셀값을 오른쪽 윗셀에 복사\nCells(i, 1).\nClearContents\n'셀의 값을 삭제\nEnd If\nNext i\nActiveSheet.UsedRange.\nSort\n[A1]..."}
{"instruction": "Excel VBA code for: (895) 빈셀 있는 1열을 2열로 변환하기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub into_2_Columns5()\nDim i As Long\n'반복구문에 사용할 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).Row\n'A열 마지막 행을 변수에 넣음\nDo\n'다음을 실행\ni = i + 1\n'행을 1씩 늘려감\nIf Cells(i, 1)(3, 1) = \"\" Then\n'각 셀 2행 아래가 빈셀일 경우\nCells(i, 2) = Cells(i + 1, 1)\n'셀값을 오른쪽 윗셀에 복사\nCells(i + 1, 1).ClearContents\n'셀의 값을 삭제\nEnd If\nLoop Until\nCells(i, 1).\nRow\n= lastRow\n'셀의 행이 마지막행이 될때까지 무한 반복\nActiveSheet.UsedRange.\nSort\n[A1], 1\n'A열기준 오름차순 정렬\nEnd Sub", "context": "매크로 실행 전                                               매크로 실행 후\nOption Explicit\nSub into_2_Columns5()\nDim i As Long\n'반복구문에 사용할 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).Row\n'A열 마지막 행을 변수에 넣음\nDo\n'다음을 실행\ni = i + 1\n'행을 1씩 늘려감\nIf Cells(i, 1)(3, 1) = \"\" Then\n'각 셀 2행 아래가 빈셀일 경우\nCells(i, 2) = Cells(i + 1, 1)\n'셀값을 오른쪽 윗셀에 복사\nCells(i + 1, 1).ClearContents\n'셀의 값을 삭제\nEnd If\nLoop Until\nCells(i, 1).\nRow\n= lastRow\n'셀의 행이 마지막행이..."}
{"instruction": "Excel VBA code for: (896) 빈셀 있는 1열을 2열로 변환하기 6 (엑셀 VBA 매크로)", "input": "", "output": "Sub into_2_Columns12()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim rngA As Range\n'각 (A)rea를 넣을 변수\nDim r As Long\n'행을 늘려갈 변수\nDim varTemp\n'배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Columns(\"A\").SpecialCells(2)\n'A열 전체 문자영역을 변수에 넣음\nFor Each rngA In rngAll.\nAreas\n'전체영역 빈셀을 순환\nvarTemp = rngA\n'각 area를 배열에 넣음\nr = r + 1\nCells(r, 2).Resize(, 2) =\nApplication\n.\nTranspose\n(varTemp)\nNext rngA\n'배열값을 행/열 변환하여 복사\nColumns(\"A\").Delete\n'기존 A열의 데이터 삭제\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                               매크로 실행 후\nOption Explicit\nSub into_2_Columns12()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim rngA As Range\n'각 (A)rea를 넣을 변수\nDim r As Long\n'행을 늘려갈 변수\nDim varTemp\n'배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Columns(\"A\").SpecialCells(2)\n'A열 전체 문자영역을 변수에 넣음\nFor Each rngA In rngAll.\nAreas\n'전체영역 빈셀을 순환\nvarTemp = rngA\n'각 area를 배열에 넣음\nr = r + 1\nCells(r, 2).Resize(, 2) =\nApplication\n.\nTranspose\n(varTemp)\nNext rngA\n'배열값을 행/열 변환..."}
{"instruction": "Excel VBA code for: (897) 빈셀 있는 1열을 2열로 변환하기 7 (엑셀 VBA 매크로)", "input": "", "output": "Sub into_2_Columns7()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim rngA As Range\n'각 (A)rea를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Columns(\"A\").SpecialCells(2)\n'A열 전체 문자영역을 변수에 넣음\nFor Each\nrngA In rngAll.\nAreas\n'전체영역 빈셀을 순환\nrngA.Next = rngA(2)\n'아랫셀을 오른쪽에 복사\nrngA(2).ClearContents\n'아랫셀 삭제\nNext\nrngA\nColumns(\"A\").\nSpecialCells(4)\n.EntireRow.Delete\n'A열 빈셀의 전체행을 삭제\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                               매크로 실행 후\nOption Explicit\nSub into_2_Columns7()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim rngA As Range\n'각 (A)rea를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Columns(\"A\").SpecialCells(2)\n'A열 전체 문자영역을 변수에 넣음\nFor Each\nrngA In rngAll.\nAreas\n'전체영역 빈셀을 순환\nrngA.Next = rngA(2)\n'아랫셀을 오른쪽에 복사\nrngA(2).ClearContents\n'아랫셀 삭제\nNext\nrngA\nColumns(\"A\").\nSpecialCells(4)\n.EntireRow.Delete\n'A열 빈셀의 전체행을 삭제\nSet rngAll = Nothing\n'개체변수 초기화(메모리 ..."}
{"instruction": "Excel VBA code for: (898) 빈셀 있는 1열을 2열로 변환하기 8 (엑셀 VBA 매크로)", "input": "", "output": "Sub into_2_Columns8()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim rngA As Range\n'각 (A)rea를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range([A1], Cells(Rows.Count, \"A\").End(3))\n'A열 데이터영역을 변수에 넣음\nrngAll.Offset(1).\nCopy\n[B1]\n'전체영역을 1행 offset후 B1셀에 복사\nActiveSheet.\nUsedRange\n.\nSpecialCells(4)\n.\nEntireRow.Delete\n'A:B열 빈셀의 전체행을 삭제\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                               매크로 실행 후\nOption Explicit\nSub into_2_Columns8()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim rngA As Range\n'각 (A)rea를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range([A1], Cells(Rows.Count, \"A\").End(3))\n'A열 데이터영역을 변수에 넣음\nrngAll.Offset(1).\nCopy\n[B1]\n'전체영역을 1행 offset후 B1셀에 복사\nActiveSheet.\nUsedRange\n.\nSpecialCells(4)\n.\nEntireRow.Delete\n'A:B열 빈셀의 전체행을 삭제\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub..."}
{"instruction": "Excel VBA code for: (899) 빈셀 있는 1열을 2열로 변환하기 9 (엑셀 VBA 매크로)", "input": "", "output": "Sub into_2_Columns9()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range([A1], Cells(Rows.Count, \"A\").End(3)(2))\n'A열 데이터영역을 변수에 넣음\nFor Each\nrngC In rngAll\n'전체영역 각셀을 순환\nIf rngC(2) = \"\" Then\n'아랫셀이 빈셀이면\nrngC.Offset(-1, 1) = rngC\n'윗셀 오른쪽에 각 셀을 복사\nrngC.ClearContents\n'각 셀을 삭제\nEnd If\nNext\nrngC\nActiveSheet.UsedRange.\nSort\n[A1], 1\n'A열기준 오름차순 정렬\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                               매크로 실행 후\nOption Explicit\nSub into_2_Columns9()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range([A1], Cells(Rows.Count, \"A\").End(3)(2))\n'A열 데이터영역을 변수에 넣음\nFor Each\nrngC In rngAll\n'전체영역 각셀을 순환\nIf rngC(2) = \"\" Then\n'아랫셀이 빈셀이면\nrngC.Offset(-1, 1) = rngC\n'윗셀 오른쪽에 각 셀을 복사\nrngC.ClearContents\n'각 셀을 삭제\nEnd If\nNext\nrngC\nActiveSheet.UsedRange.\nSort\n[A1], 1\n'A열기준 오름..."}
{"instruction": "Excel VBA code for: (901) 빈셀 있는 1열을 2열로 변환하기 11 (엑셀 VBA 매크로)", "input": "", "output": "Sub into_2_Columns11()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngT As Range\n'복사될 타겟(T)arget 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).Row\n'A열 마지막 행을 변수에 넣음\nFor i = 1 To lastRow Step 3\n'3행씩 늘려가며 반복\nSet\nrngT = Cells(Rows.Count, 2).\nEnd(3)(2)\n'복사될 위치를 변수에 넣음\nrngT = Cells(i, 1)\n'복사될 위치에 단어 복사\nrngT.\nNext\n= Cells(i + 1, 1)\n'복사될 위치 오른쪽에 뜻 복사\nNext i\nColumns(\"A\").\nDelete\n'기존 A열의 데이터 삭제\nRows(1).Delete\n'빈행인 1행 삭제\nEnd Sub", "context": "매크로 실행 전                                               매크로 실행 후\nOption Explicit\nSub into_2_Columns11()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngT As Range\n'복사될 타겟(T)arget 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).Row\n'A열 마지막 행을 변수에 넣음\nFor i = 1 To lastRow Step 3\n'3행씩 늘려가며 반복\nSet\nrngT = Cells(Rows.Count, 2).\nEnd(3)(2)\n'복사될 위치를 변수에 넣음\nrngT = Cells(i, 1)\n'복사될 위치에 단어 복사\nrngT.\nNext\n= Cells(i + 1, 1)\n'복사될 위치 오른쪽에 뜻 복사\n..."}
{"instruction": "Excel VBA code for: (902) 전체 시트에서 특정색을 가진 셀의 모든 행삭제 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Specific_Color()\nDim lngColor As Long\n'선택셀의 색값을 넣을 변수\nDim s As Integer\n'시트 개수만큼 반복할 변수\nDim rowsCnt As Long\n'(각 시트의) 행 개수 넣을 변수\nDim colsCnt As Integer\n'(각 시트의) 열 개수 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlngColor = ActiveCell.\nInterior.Color\n'현재셀의 컬러 값을 변수에 넣음\nIf lngColor = 16777215 Then\n'만약 선택셀이 바탕흰색이라면\nMsgBox\n\"색이 없는 셀을 선택하여 중단함\", 64, \"색 선택오류\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nFor s = 1 To Sheets.Count\n'전체 시트의 개수만큼 반복\nWith Sheets(s)\n'각 시트에서\nrowsCnt = .UsedRange.Rows.Count\n'사용영역의 행 개수를 변수에 넣음\ncolsCnt = .UsedRange.Columns.Count\n'사용영역의 열 개수를 변수에 넣음\nFor r = rowsCnt To 1 Step -1\n'마지막 행부터 위로 1씩 줄여감\nFor Each rngC In .UsedRange.Cells(r, 1).Resize(, colsCnt)\n'마지막 행부터 각 셀을 순환\nIf rngC.Interior.Color = lngColor Then\n'각 셀이 선택셀과 동일한 색이면\nrngC.\nEntireRow.Delete\n'각 셀의 전체행을 삭제\nExit For\n'For 구문 종료\nEnd If\nNext rngC\nNext r\nEnd With\nNext s\nEnd Sub", "context": "파일의 시트개수에 상관 없이 전체 시트에서 현재 선택된 셀과 동일한 색을 가진셀의 행을 모두 삭제하는 기능. 바탕 흰색을 선택 시 에러 메시지 출력.\n매크로 실행 전 Sheet1                                  매크로 실행 전 Sheet3\n매크로 실행 후 Sheet1                                 매크로 실행 후 Sheet3\n색이 없는 셀(바탕 흰색)을 선택 시 나타나는 오류 메시지\nOption Explicit\nSub delete_Specific_Color()\nDim lngColor As Long\n'선택셀의 색값을 넣을 변수\nDim s As Integer\n'시트 개수만큼 반복할 변수\nDim rowsCnt As Long\n'(각 시트의) 행 개수 넣을 변수\nDim colsCnt As Integer\n'(각 시트의) 열 개수 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'행 늘려갈 변수\nApp..."}
{"instruction": "Excel VBA code for: (904) 열려 있는 모든 시트에 동일한 내용 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub distribute_To_All_Open_Sheets()\nDim wnDw As\nWindow\n'창을 넣을 변수\nDim rngData As Range\n'복사할 영역을 넣을 변수\nDim wkSht As\nWorksheet\n'시트를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngData = Range(\"A2:A5\")\n'복사할 영역을 개체변수에 넣음\nFor Each wnDw In\nWindows\n'각 창을 순환\nIf wnDw.Visible = True Then\n'각 창이 숨겨져 있지 않다면\nwnDw.\nActivate\n'각 창을 활성화\nWith\nActiveWorkbook\nIf .Name <>\nThisWorkbook\n.Name Then\n'각 파일이 매크로 실행파일이 아니면\nFor Each wkSht In .\nWorksheets\n'활성화된 파일의 각 시트를 순환\nwkSht.Range(\"A2:A5\") = rngData.Value\n'복사할 영역의 값을 각 파일 각 시트에 복사\nNext wkSht\n'다음 시트를 선택\nEnd If\n'If 구문 종료\nEnd With\n'With 구문 종료\nEnd If\nNext wnDw\n'다음 창을 선택\nSet rngData = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1.\n열려 있는\n모든 파일의 모든 시트에 동일한 내용 복사하기\n2. 매크로를 실행하는 파일에는 복사하지 않음\n3. 개인용 매크로 통합파일(Personal.xlsb) 같이 숨겨져 있는 파일에는 복사하지 않음\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(904) 열려 있는 모든 시트에 동일한 내용 복사하기 (엑셀 VBA 매크로)\n재생\n764\n재생 (space/k)\n재생\n00:31\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:31\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n..."}
{"instruction": "Excel VBA code for: (905) 복수의 버튼에 그림 링크하여 클릭시 토글되도록 하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub picture_Hide_Show_Buttons()\nDim strName As String   '도형의 문자를 넣을 변수\nWith ActiveSheet.\nShapes\n(\nApplication.Caller\n)\n'매크로 실행한 도형\nstrName = .\nTextFrame2.TextRange.Text\n'도형문자를 변수에 넣음\nEnd With\nWith ActiveSheet.Shapes(strName)\n'현재시트 그림이 도형문자와 일치시\n.Visible = Not .Visible\n'그림 보이기 상태 반전\nEnd With\nEnd Sub", "context": "1. 버튼을 클릭 시 버튼에 연결된 그림이 숨기기/나타나기를 반복하도록 하는 기능.\n2. 모든 버튼은 동일한 VBA(매크로)를 공통으로 사용\n3. 버튼의 이름과 그림의 이름이 일치하도록 하면 됨.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(905) 복수의 버튼에 그림 링크하여 클릭시 토글되도록 하기 (엑셀 VBA 매크로)\n재생\n1,181\n재생 (space/k)\n재생\n01:02\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:02\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다...."}
{"instruction": "Excel VBA code for: (907) 5행씩 끊어서 행/열 변환하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub transpose_column()\nDim r As Long\n'행 1씩 늘려갈 변수\nDim i As Long\n'5행씩 건너뛸 변수\nDim lastRow As Long\n'마지막행 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, \"A\").End(3).Row\n'마지막행을 변수에 넣음\nFor i = 1 To lastRow\nStep 5\n'5씩 건너뛰며 마지막행까지 반복\nr = r + 1\n'행을 1씩 늘려감\nCells(r, 2).Resize(, 5) = Application.\nTranspose\n(Cells(i, 1).Resize(5))\nNext i\n'행/열 변환하여 복사\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(907) 5행씩 끊어서 행/열 변환하기 (엑셀 VBA 매크로)\n재생\n539\n재생 (space/k)\n재생\n00:14\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:14\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\nOption Explicit\nSub transpose_column()\nDim r As Long\n'행 1씩 늘려갈 변수\nDim i As Long\n'5행씩 건너뛸 변수\n..."}
{"instruction": "Excel VBA code for: (908) 수식에서 = 제거해 복사 후 값으로 되돌리기 (엑셀 VBA 매크로)", "input": "", "output": "Sub formula_Without_Equal()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim str As String\n'C열의 문자를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Columns(\"C\").\nSpecialCells(-4123)\n'C열 전체영역\n수식셀\n을 순환\nstr = rngC.\nFormula\n'각 셀의 앞 수식을 변수에 넣음\nrngC.Next = Right(str, Len(str) - 1)\n'D열에 = 제외한 문자를 넣음\nNext rngC\nEnd Sub\n\nSub evaulate_Formula()\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Columns(\"D\").\nSpecialCells(2)\n'D열 전체영역\n문자\n셀\n을 순환\nrngC.Next =\nEvaluate\n(rngC.Value)\n'E열에 D열의 계산값을 넣음\nNext rngC\nEnd Sub", "context": "1. A열과 B열에는 숫자가 입력되어 있고 C열에는 수식이 입력되어 있음.\n2. C열의 수식을 = 없이 D열에 입력\n3. D열의 = 없는 수식을 다시 값으로 되돌려 놓음\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(908) 수식에서 = 제거해 복사 후 값으로 되돌리기 (엑셀 VBA 매크로)\n재생\n995\n재생 (space/k)\n재생\n00:34\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:34\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 ..."}
{"instruction": "Excel VBA code for: (909) 선택영역 각 셀을 별도의 그림파일로 저장하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub save_Ranges_To_Pic1()\nDim strPath As String\n'파일 경로를 넣을 변수\nDim cht As ChartObject\n'차트개체를 넣을 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim cht As Chart\n'차트(ch)ar(t) 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중단\nstrPath =\nActiveWorkbook\n.\nPath\n& \"\\\"\n'이 엑셀파일이 저장된 폴더의 경로\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nrngC.\nCopyPicture\n'각셀을 그림으로 복사해서 clipboard에 넣음\nSet chtObj = ActiveSheet.ChartObjects.Add(0, 0, rngC.Width, rngC.Height)\n'새로운 차트개체를 각 셀크기로 생성\nchtObj.Chart.Paste\n'각셀을 복사해서 차트에 붙여 넣음\nSet cht = chtObj.Chart\n'차트개체를 변수에\nchtObj.Activate\n'차트개체 활성화\nWith cht\n'차트에서\n.ChartArea.Select\n'차트영역 선택\n.Paste\n'붙여넣기\n.Export strPath & ActiveWorkbook.Name & \" \" _\n& ActiveSheet.Name & \" \" & rngC.Address(0, 0) & \".gif\"\n'그림을 내보냄\nEnd With\nchtObj.Delete\n'삽입했던 차트개체를 삭제\nNext rngC\nSet chtObj = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet cht = Nothing\nEnd Sub", "context": "1. 선택영역 각 셀을 별도의 그림파일로 저장하기\n2. 파일이름은 \" 엑셀파일이름 + 시트이름 + 셀주소.gif \"로 저장\n3. 그림파일은 엑셀파일과 동일한 경로에 저장(아래 예제파일은 바탕화면에 저장하고 매크로 실행함)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(909) 선택영역 각 셀을 별도의 그림파일로 저장하기 (엑셀 VBA 매크로)\n재생\n2,379\n공유하기\n재생 (space/k)\n재생\n00:20\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:20\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질..."}
{"instruction": "Excel VBA code for: (911) 년도별로 더하고 년도별 이름 중복없이 나열하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub summarize_Per_Year2()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'컬렉션 반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Worksheets(2)\n.UsedRange.Offset(1).ClearContents\n'기존 데이터 삭제\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\nSet rngAll = .Offset(1, 2).Resize(.Rows.Count - 1, .Columns.Count - 2)\nEnd With\n'제목뺀 데이터 영역만 변수에 넣음\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nWith Worksheets(2).Cells(Rows.Count, 1).End(3)(2)\n'Sheet2 A열 종단셀 윗방향 셀위치\nIf\nLen(rngC) > 0\nThen\n'각 셀이 빈셀이 아니라면\n.Value =\nVal(Year\n(rngC))\n'년도를 값으로 A열에 복사\n.Next = 1\n'개수 1 입력\n.Offset(, 2) = Cells(rngC.Row, 2)\n'이름 복사\nEnd If\nEnd With\nNext rngC\n.UsedRange.\nRemoveDuplicates\nColumns:=\nArray\n(1, 2, 3), Header:=xlYes\n'중복제거\n.UsedRange.Offset(1).\nSort\n.[A2], 1\n'Sheet2 오름차순 정렬\nFor r = .Cells(Rows.Count, 1).End(3).Row To 2\nStep -1\n'마지막행부터 1씩 줄여가며 반복\nIf .Cells(r, 1) = .Cells(r - 1, 1) Then\n'위아래셀 값이 같으면\n.Cells(r - 1, 2) = .Cells(r - 1, 2) + 1\n'위셀 B열 값을 1씩 늘려감\n.Cells(r - 1, 3) = .Cells(r - 1, 3) & \" \" & .Cells(r, 3)\n'이름을 합쳐감\n.Cells(r, 1).Resize(, 3).ClearContents\n'아래셀의 데이터 삭제\nEnd If\nNext r\n.UsedRange.Offset(1).Sort .[A2], 1\n'Sheet2 오름차순 정렬\n.Columns.AutoFit\n'Sheet2의 열너비 자동맞춤\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. Sheet1의 각 년도를 중복없이 1개만 표시하고 동일년도 인원수 합계를 구합\n2. 각 년도별 이름(예, 5행의 2008년 2월은 \"무\"가 3번 반복)은 중복되지 않도록 1개씩만 나열\n매크로 실행 전 Sheet1\n매크로 실행 전 Sheet2                                     매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub summarize_Per_Year2()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'컬렉션 반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Worksheets(2)\n.UsedRange.Offset(1).ClearContents\n'기존 데이터 삭제\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\nSet rng..."}
{"instruction": "Excel VBA code for: (913) 문자에 대응하는 숫자만큼 건너뛰어 배치하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub offset_Consonant()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim colNo As Integer\n'열 위치 결정할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"N:R\").ClearContents\n'기존 데이터 삭제\nFor Each rngC In Range(\"C5\", Cells(Rows.Count, \"D\").End(3))\n'B:C열의 데이터영역 각셀을 순환\nIf\nLen(rngC) > 0\nThen\n'각 셀이 길이가 0보다 크면(빈셀이 아니면)\nIf rngC.Column = 3 Then\n'각 셀의 열이 C이면\ncolNo = 10\n'colNo 에 10을 넣음\nElse\n'열이 D일경우\ncolNo = 9\n'colNo에 9를 넣음\nEnd If\nSelect Case\nrngC\n'각 셀의 값을 선택\nCase \"ㄱ\": rngC.Offset(, colNo + 1) = rngC\n'ㄱ이면 N열에 넣음\nCase \"ㄴ\": rngC.Offset(, colNo + 2) = rngC\n'ㄴ이면 O열에 넣음\nCase \"ㄷ\": rngC.Offset(, colNo + 3) = rngC\n'ㄷ이면 P열에 넣음\nCase \"ㄹ\": rngC.Offset(, colNo + 4) = rngC\n'ㄹ이면 Q열에 넣음\nCase \"ㅁ\": rngC.Offset(, colNo + 5) = rngC\n'ㅁ이면 R열에 넣음\nEnd Select\nEnd If\nNext rngC\nEnd Sub", "context": "아주 교과서 적인 코드로 작성하여 보았다. 참고로 Select 구문은 다른 구문들에 비하여 속도가 약간 떨어져서 For .. Next, For Each .. Next 또는 If .. ElseIf, Else, ..End 구문들에 비해서 상대적으로 사용 빈도수가 낮다. 물론 데이터가 많지 않으면 별 상관 없다.\n( I:J 열의 숫자는 HLOOKUP을 이용하여 구함.)\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub offset_Consonant()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim colNo As Integer\n'열 위치 결정할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"N:R\").ClearContents\n'기존 데이터 삭제\nFor Each rngC In Range(\"C5\", Cells(Rows.Count, \"D\").End(3))\n'B:C열의 데이터영역 각셀을 순환\n..."}
{"instruction": "Excel VBA code for: (914) 문자에 대응하는 숫자만큼 건너뛰어 배치하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub offset_Consonant1()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim colNo As Integer\n'열 위치 결정할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"N:R\").ClearContents\n'기존 데이터 삭제\nFor Each rngC In Range(\"C5\", Cells(Rows.Count, \"D\").End(3))\n'B:C열의 데이터영역 각셀을 순환\nIf\nNot IsEmpty(rngC)\nThen\n'각 셀이 빈셀이 아니면\nIf rngC.Column = 3 Then\n'각 셀의 열이 C이면\ncolNo = 10\n'colNo 에 10을 넣음\nElse\n'열이 D일경우\ncolNo = 9\n'colNo에 9를 넣음\nEnd If\nrngC.\nOffset\n(, colNo + rngC.Offset(, 6).Value) = rngC\n'colNo + I:J 열에 있는 숫자만큼 건너뛰며 셀에 각 셀의 값 복사\nEnd If\nNext rngC\nEnd Sub", "context": "앞서는 Select 구문을 사용하였는데 아래에서는 간단히 Offset property를 사용하였다.\n( I:J 열의 숫자는 HLOOKUP을 이용하여 구함. )\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub offset_Consonant1()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim colNo As Integer\n'열 위치 결정할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"N:R\").ClearContents\n'기존 데이터 삭제\nFor Each rngC In Range(\"C5\", Cells(Rows.Count, \"D\").End(3))\n'B:C열의 데이터영역 각셀을 순환\nIf\nNot IsEmpty(rngC)\nThen\n'각 셀이 빈셀이 아니면\nIf rngC.Column = 3 Then\n'각 셀의 열이 C이면\ncolNo = 10\n'colNo 에 10을 넣음\nElse\n'열이 D일..."}
{"instruction": "Excel VBA code for: (915) 문자에 대응하는 숫자만큼 건너뛰어 배치하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub offset_Consonant2()\nDim C As Range\n'각 셀을 넣을 변수\nDim colNo As Integer\n'열 위치 결정할 변수\nDim varTemp\n'Switch 결과 값을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"N:R\").ClearContents\n'기존 데이터 삭제\nFor Each C In Range(\"C5\", Cells(Rows.Count, \"D\").End(3))\n'B:C열의 데이터영역 각셀을 순환\nWith C\nvarTemp =\nSwitch\n(C = \"ㄱ\", 1, C = \"ㄴ\", 2, C = \"ㄷ\", 3, C = \"ㄹ\", 4, C = \"ㅁ\", 5)\n'각 셀의 값에 따른 대응값을 변수에 넣음\n'즉, ㄱ이면 1, ㄴ이면 2 .... ㅁ이면 5를 변수에 넣음\nEnd With\nIf Not IsEmpty(C) Then\n'각 셀이 빈셀이 아니면\ncolNo =\nIIf\n(C.Column = 3, 10, 9)\n'셀의 행이 3이면 10, 아니면 9를 변수에 넣음\n'즉, 참이면 10, 거짓이면 9를 변수에 넣음\nC.\nOffset\n(, colNo + varTemp) = C\n'colNo + varTemp 값만큼 건너뛰며 셀에 각 셀의 값 복사\nEnd If\nNext C\nEnd Sub", "context": "Switch function과 Iif 구문을 이용하여 동일한 결과를 얻어보았다.\n( I:J 열의 숫자는 HLOOKUP을 이용하여 구함. )\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub offset_Consonant2()\nDim C As Range\n'각 셀을 넣을 변수\nDim colNo As Integer\n'열 위치 결정할 변수\nDim varTemp\n'Switch 결과 값을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"N:R\").ClearContents\n'기존 데이터 삭제\nFor Each C In Range(\"C5\", Cells(Rows.Count, \"D\").End(3))\n'B:C열의 데이터영역 각셀을 순환\nWith C\nvarTemp =\nSwitch\n(C = \"ㄱ\", 1, C = \"ㄴ\", 2, C = \"ㄷ\", 3, C = \"ㄹ\", 4, C = \"ㅁ\", 5)\n'각 셀의 값에 따른 대응값..."}
{"instruction": "Excel VBA code for: (916) 문자에 대응하는 숫자만큼 건너뛰어 배치하기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub offset_Consonant3()\nDim C As Range\n'각 셀을 넣을 변수\nDim colNo As Integer\n'열 위치 결정할 변수\nDim intNo As Integer\n'ㄱㄴㄷㄹㅁ에 대응하는 값을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"N:R\").ClearContents\n'기존 데이터 삭제\nFor Each C In Range(\"C5\", Cells(Rows.Count, \"D\").End(3))\n'B:C열의 데이터영역 각셀을 순환\nIf\nC <> vbNullString\nThen\n'각 셀이 빈셀이 아니면\nintNo =\nChoose\n(C.Offset(, 6).Value, 1, 2, 3, 4, 5)\n'각 셀의 값에 따른 대응값을 변수에 넣음\nSelect Case\nC.Column\n'C의 열 값이\nCase 3: colNo = 10\n'3이면 colNo에 10을 할당\nCase Else: colNo = 9\n'3이 아니면 colNo에 9를 할당\nEnd Select\nC.Offset(, colNo + intNo) = C\n'colNo + varTemp 값만큼 건너뛰며 셀에 각 셀의 값 복사\nEnd If\nNext C\nEnd Sub", "context": "Choose function을 이용하여 동일한 결과를 얻어보았다. 내가 했다면 어떤 방법으로 동일한 결과를 구하였을까 생각해보세요. 제가 구사한 4가지 방법이 아닌 (함수를 제외한) 다른 더 좋은 방법이 있으신분 있으시나요? 함수는 시트를 무겁게 하므로 VBA와 연동하여 사용하지 않는 한 개인적으로 선호하지 않습니다. 그래서 항상 함수는 최소한으로 사용하려고 노력하죠. ^^\n( I:J 열의 숫자는 HLOOKUP을 이용하여 구함. )\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub offset_Consonant3()\nDim C As Range\n'각 셀을 넣을 변수\nDim colNo As Integer\n'열 위치 결정할 변수\nDim intNo As Integer\n'ㄱㄴㄷㄹㅁ에 대응하는 값을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"N:R\").ClearContents\n'기존 데이터 삭제\n..."}
{"instruction": "Excel VBA code for: (917) 문자에 대응하는 숫자만큼 건너뛰어 배치하기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub offset_Consonant3()\nDim C As Range\n'각 셀을 넣을 변수\nDim colNo As Integer\n'열 위치 결정할 변수\nDim varTemp\n'ㄱㄴㄷㄹㅁ에 대응하는 값(1,2,3,4,5)을 넣을 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"N:R\").ClearContents\n'기존 데이터 삭제\nFor Each C In Range(\"C5\", Cells(Rows.Count, \"D\").End(3))\n'B:C열의 데이터영역 각셀을 순환\nIf C <> \"\" Then\n'각 셀이 빈셀이 아니면\nvarTemp =\nArray\n(1, 2, 3, 4, 5)\n'각 셀의 값에 따른 대응값을 배열변수에 넣음\nIf C.\nColumn\n= 3 Then colNo = 10\n'C의 열 값이 3이면 colNo에 10을 할당\nIf C.Column = 4 Then colNo = 9\n'C의 열 값이4이면 colNo에 9을 할당\nC.\nOffset\n(, colNo + varTemp(C.Offset(, 6)\n- 1\n)) = C\n'colNo + varTemp 값만큼 건너뛰며 각 셀의 값 복사\nEnd If\nNext C\nEnd Sub", "context": "배열(Array)을 이용하여 동일한 결과를 구해보았다. 앞에서 한 방법들과 크게 차이는 없다. 배열은 index가 0, 1, 2, 3 ... 으로 시작하므로 -1을 해주었다.\n( I:J 열의 숫자는 HLOOKUP을 이용하여 구함. )\nOption Explicit\nSub offset_Consonant3()\nDim C As Range\n'각 셀을 넣을 변수\nDim colNo As Integer\n'열 위치 결정할 변수\nDim varTemp\n'ㄱㄴㄷㄹㅁ에 대응하는 값(1,2,3,4,5)을 넣을 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"N:R\").ClearContents\n'기존 데이터 삭제\nFor Each C In Range(\"C5\", Cells(Rows.Count, \"D\").End(3))\n'B:C열의 데이터영역 각셀을 순환\nIf C <> \"\" Then\n'각 셀이 빈셀이 아니면\nvarTemp =\nArray\n(1, 2, ..."}
{"instruction": "Excel VBA code for: (919) 셀 숫자만큼 행삽입하고 이름뒤 번호붙이기 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Rows_As_Numbered_With_No()\nDim rngAll As Range\n'전체영역을 변수에\nDim varTemp\n'2차원 배열로 사용할 변수\nDim varR()\n'동적배열로 사용할 변수\nDim colsCnt As Integer\n'전체 열개수를 넣을 변수\nDim c As Long\n'배열의 행 개수만큼 반복할 변수\nDim i As Long\n'\"나이\"만큼 반복할 변수\nDim r As Long\n'배열의 행(1차원) 늘려갈 변수\nDim j As Integer\n'배열의 열(2차원) 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveSheet.UsedRange\n'현재시트 작업영역\nSet rngAll = .Offset(1).Resize(.Rows.Count - 1)\n'전체영역을 변수에\nEnd With\ncolsCnt = rngAll.Columns.Count\n'전체영역 열개수를 변수에 넣음\nvarTemp = rngAll\n'전체영역을 배열에 넣음\nrngAll.ClearContents\n'전체영역 기존 데이터 삭제\nFor c = 1 To\nUBound\n(varTemp, 1)\n'배열의 행(1차원) 개수만큼 반복\nFor i = 1 To varTemp(c, 2)\n'\"나이\" 숫자만큼 반복\nr = r + 1\n'배열 개수를 늘려감\nReDim Preserve\nvarR(1 To colsCnt, 1 To r)\n'배열크기 재 지정\nFor j = 1 To colsCnt\n'배열의 열(2차원) 개수만큼 반복\nIf j = 1 Then\n'1열이면\nk = k + 1\n'뒷 번호를 1씩 늘려감\nvarR(j, r) = varTemp(c, j) & \"-\" & k\n'배열값을 \"-번호\"와 함께 동적배열에 뿌림\nElse\n'1열이 아니면\nvarR(j, r) = varTemp(c, j)\n'배열값을 동적배열에 뿌림\nEnd If\nNext j\nNext i\nk = 0\n'재사용 위하여 초기화\nNext c\nCells(2, 1).Resize(r, colsCnt) = WorksheetFunction.\nTranspose\n(varR)\n'동적배열 값을 셀에 뿌림\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "(기존 \"나이\" 필드의 셀 숫자만큼 행삽입하던 코드에서 이름 뒤에 반복 횟수에 따라 순서대로 번호가 붙도록 일부 코드를 수정하였습니다.)\n매크로 실행 전                                                          매크로 실행 후 결과\nOption Explicit\nSub insert_Rows_As_Numbered_With_No()\nDim rngAll As Range\n'전체영역을 변수에\nDim varTemp\n'2차원 배열로 사용할 변수\nDim varR()\n'동적배열로 사용할 변수\nDim colsCnt As Integer\n'전체 열개수를 넣을 변수\nDim c As Long\n'배열의 행 개수만큼 반복할 변수\nDim i As Long\n'\"나이\"만큼 반복할 변수\nDim r As Long\n'배열의 행(1차원) 늘려갈 변수\nDim j As Integer\n'배열의 열(2차원) 개수만큼 반복할 변수\nApplication.ScreenUpdating = Fals..."}
{"instruction": "Excel VBA code for: (922) 상대 주소를 절대주소로 바꾸기 (엑셀 VBA 매크로)", "input": "", "output": "Public Sub from_Relative_To_Absolute()\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nFor Each rngC In Columns(\"B\").SpecialCells(-4123)\n'B열의 수식이 있는 각셀을 순환\nrngC.Formula = Application.\nConvertFormula\n(rngC.Formula, _\nfromreferencestyle\n:=1,\ntoabsolute\n:=1)\n'각 수식을 상대주소에서 절대주소로 변경\nNext rngC\nEnd Sub", "context": "B열의 각 셀은 다양한 상대주소를 가지고 있으며 여러 셀을 참조하고 있다. 이 상대주소를 한 번에 절대참조 주소로 바꾸는 기능. 물론 절대주소로 되어 있는 것을 상대주소로 바꾸는 것도 가능하다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(922) 상대 주소를 절대주소로 바꾸기 (엑셀 VBA 매크로)\n재생\n710\n재생 (space/k)\n재생\n00:20\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:20\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보..."}
{"instruction": "Excel VBA code for: (924) 1부터 숫자 만큼 복사하며 행채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_As_Numbered()\nDim i As Integer\n'반복구문에 사용할 변수\nDim intNo As Integer\n'입력할 숫자 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nIf Range(\"A2\") <> \"\" Then\n'A2셀에 문자가 입력되어 있을 경우\nRange(\"A2\", Cells(Rows.Count, 1).End(3)).ClearContents\n'기존 데이터 삭제\nEnd If\nIf\nTypeName\n(Range(\"A1\").Value) =\n\"Double\"\nThen\n'A1셀에 숫자가 입력되었을 경우\nintNo = Range(\"A1\").Value\n'A1셀의 값을 변수에 넣음\nIf intNo > 1430 Then\n'숫자가 1430보다 큰 경우\nMsgBox \"숫자가 너무 큽니다. 1430 보다 작은 숫자 입력\", 64, \"숫자입력 오류\"\nExit Sub\n'매크로 중단\nEnd If\nFor i = 1 To intNo\n'intNo 만큼 반복\nCells(Rows.Count, 1).End(3)(2).\nResize(i)\n= i\n'숫자 개수만큼 셀에 복사\nNext i\nElse\nMsgBox \"입력된 문자가 숫자가 아닙니다.\", 64, \"입력 오류\"\nEnd If\nEnd Sub", "context": "매크로 실행 전                                        매크로 실행 후 결과\n잘못된 숫자를 입력 시 출력되는 오류 메시지.\nOption Explicit\nSub fill_As_Numbered()\nDim i As Integer\n'반복구문에 사용할 변수\nDim intNo As Integer\n'입력할 숫자 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nIf Range(\"A2\") <> \"\" Then\n'A2셀에 문자가 입력되어 있을 경우\nRange(\"A2\", Cells(Rows.Count, 1).End(3)).ClearContents\n'기존 데이터 삭제\nEnd If\nIf\nTypeName\n(Range(\"A1\").Value) =\n\"Double\"\nThen\n'A1셀에 숫자가 입력되었을 경우\nintNo = Range(\"A1\").Value\n'A1셀의 값을 변수에 넣음\nIf intNo > 1430 Then\n'숫자가 143..."}
{"instruction": "Excel VBA code for: (925) 셀병합 영역별 중복없는 합계구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub consolidate_Subtotal()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'행 1씩 늘려가는 반복에 사용할 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim lngNo As Long\n'카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 3).End(3).Row\n'C열 마지막 행을 변수에 넣음\nr = 1\n'1행부터 시작\nFor r = 1 To lastRow\n'1부터 마지막 행까지 1씩 늘려가며 반복\nIf Len(Cells(r, 1)) > 0 Then\n'만약 A열이 빈셀이 아니라면\nlngNo = Cells(r, 1).\nMergeArea\n.Count\n'셀병합 개수를 변수에 넣음\nCells(r, 4).\nConsolidate\nSources:=Cells(r, 2).Resize(lngNo, 2).\nAddress(1, 1, xlR1C1)\n, _\nFunction:=\nxlSum\n, TopRow:=False, LeftColumn:=True\n'B열을 중복없이 통합하여 합계를 구하고 D열에 복사\nEnd If\nNext r\nColumns(\"B:C\").Delete\n'기존의 데이터 삭제\nColumns(\"B\").\nSpecialCells(4)\n.EntireRow.Delete\n'공백행을 삭제\n[A1].CurrentRegion.\nBorders.LineStyle = 1\n'데이터에 외곽선 테두리\nEnd Sub", "context": "이렇게 까지 해서 몽땅 알려드리는데 매크로를 배우지 못하신다면 .... 안되죠!!!!\n매크로 실행 전                                                       매크로 실행 후\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(925) 셀병합 영역별 중복없는 합계구하기 (엑셀 VBA 매크로)\n재생\n927\n재생 (space/k)\n재생\n00:36\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:36\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설..."}
{"instruction": "Excel VBA code for: (926) 색깔을 기준으로 정렬하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub color_Sort()\nDim rngC As Range\n'전체 영역의 각 셀을 넣을 변수\nDim lngCol As Long\n'색이 들어간 셀의 색 값을 넣을 변수\nDim X As New Collection\n'각 색깔을 넣을 collection\nDim i As Long\n'컬렉션의 반복에 사용될 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, 1).End(3))\n'제목 제외한 A열 각셀을 순환\nlngCol = rngC.Interior.\nColor\n'각 셀의 값을 변수에 넣음\nOn Error Resume Next\n'에러 발생해도 계속 진행\nX.\nAdd\nlngCol,\nCStr\n(lngCol)\n'컬렉션에 유일한 색만 넣음\nOn Error GoTo 0\n'에러검출 기능 복원\nNext rngC\nCells(1, 1).Resize(, 2).\nCopy\nSheets(2).Cells(1, 1)\n'제목을 Sheet2에 복사\nFor i = 1 To\nX.Count\n'컬렉션에 있는 색을\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, 1).End(3))\n'제목 제외한 A열 각셀을 순환\nIf rngC.Interior.Color = X(i) Then\n'각 셀이 컬렉션의 셀값과 일치하면\nrngC.Resize(, 2).Copy Sheets(2).Cells(Rows.Count, 1).\nEnd(3)(2)\nEnd If\n'각 행을 Sheet2에 종단셀 윗방향 위치에 복사\nNext rngC\nNext i\nEnd Sub", "context": "엑셀의 정렬옵션에 값, 셀의 색, 글자색 및 셀 아이콘을 기준으로 정렬할 수 있는 기능이 이미 있다. 물론 셀을 채운 색깔의 종류가 몇개 되지 않으면 레벨(계열)을 추가하여 정렬을 하면 되지만 색의 개수만큼 반복해야 한다. 아래의 기능은 셀의 색깔 개수에 제한없이 같은 색끼리 정렬한다. 코드를 일부 수정하면 색깔을 자신이 선호하는 순서로 변경할 수 있다.\n매크로 실행 전 Sheet1 (Sheet2는 비어있음)            매크로 실행 후 Sheet2의 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(926) 색깔을 기준으로 정렬하기 (엑셀 VBA 매크로)\n재생\n1,483\n재생 (space/k)\n재생\n01:06\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:06\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n자막\n설정\n사..."}
{"instruction": "Excel VBA code for: (928) 각 area의 개수를 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub count_Area()\nDim rngA As Range\n'각 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngA In Columns(\"A\").SpecialCells(2).\nAreas\n'A열의 각 문자 영역(area)를 순환\nWith rngA.Cells\n'각 영역의 셀 개수\nrngA.Cells(.\nCount\n+ 1) = .Count\n'각 영역의 셀 개수 + 1의 위치에 영역의 셀 개수를 입력\nEnd With\nNext rngA\nEnd Sub", "context": "매크로 실행 전 (개수가 입력될 셀을 미리 색으로 표시 함)     매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(928) 각 area의 개수를 추출하기 (엑셀 VBA 매크로)\n재생\n155\n재생 (space/k)\n재생\n00:28\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:28\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 설명 (순서대로 ) :\n각 값이 입력될 위치를 보여줌.\n매크로 창에..."}
{"instruction": "Excel VBA code for: (929) 행/열의 값 일치시 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Matching_Row_Column()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\nSet rngAll = .Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 1)\nEnd With\n'제목뺀 데이터 영역만 변수에 넣음\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nIf Cells(rngC.\nRow\n, 1) = Cells(1, rngC.\nColumn\n) Then\n'각 셀이 행/열 값이 일치 시\nrngC.ClearContents\n'셀 값을 삭제\nEnd If\nNext rngC\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "이런 코드는 이제 너무 쉽다. 너무 반복적이구... 행과 열의 A, B, C ... 가 일치하는 곳만 삭제하기\n매크로 실행 전                                                       매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(929) 행/열의 값 일치시 삭제하기 (엑셀 VBA 매크로)\n재생\n340\n재생 (space/k)\n재생\n00:41\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:41\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생..."}
{"instruction": "Excel VBA code for: (930) 특정시간(OnTime)에 반복작업하기 기본코드 (엑셀 VBA 매크로)", "input": "", "output": "Sub works_To_Do()\ntimeInterval = TimeValue(\"00:00:05\")\n'5초마다 실행\n'-----------------------------------------\n' 아래와 같이 작업할 내용을 여기에 넣으면 됨\n'-----------------------------------------\nWith Cells(2, 2)\n'B2셀의 값을 1씩 증가\n.Value = .Value + 1\n'카운터를 1씩 증가\nEnd With\nApplication.\nOnTime\nNow + timeInterval, \"works_To_Do\"\n'1 초마다 매크로 실행\nEnd Sub\n\nSub stop_OnTime()\nOn Error Resume Next\n' \"Stop Macro\" 버튼을 연속하여 두 번 눌러 에러 발생 시 이를 처리하기 위함\nApplication.OnTime Now + timeInterval, \"works_To_Do\", Schedule:=False\n'application_Ontime 의 실행을 중단\nEnd Sub", "context": "주식의 DDE(Dynamic Data Exchange) 또는 웹 쿼리(Web Query)와 같은 기능을 사용할 때 특정시간 마다 반복적으로 작업할 경우가 있다. 이미 공부해서 서너번 사용해 봤지만 가끔 찾기 귀찮아 기본코드에 넣어둠. 엑셀 도움말에 나온 코드로 여기저기에서 심심찮게 사용되는 코드이다. 좋은 코드를 잘 짜는 것도 좋지만 필요할 때 손쉽게 찾아 사용할 수 있도록 보관과 정리를 잘하는 것도 그 이상으로 중요하다.\nOption Explicit\nDim timeInterval\n'시간 간격을 넣을 변수\n​\nSub works_To_Do()\ntimeInterval = TimeValue(\"00:00:05\")\n'5초마다 실행\n'-----------------------------------------\n' 아래와 같이 작업할 내용을 여기에 넣으면 됨\n'-----------------------------------------\nWith Cells(2, 2)\n'B2셀의 값을 1씩 증가\n.Va..."}
{"instruction": "Excel VBA code for: (933) 각 sheet를 별도의 엑셀 파일로 저장하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub save_EachSheet_Into_SeparateFiles2()\nDim wkBk  As Workbook\n'각 파일을 넣을 변수\nDim wkSht As Worksheet\n'각 시트를 넣을 변수\nDim strName As String\n'기존파일 이름을 넣을 변수\nDim newName As String\n'파일경로 + 파일이름 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 일시 정지\nFor Each wkSht In Worksheets\n'각 sheet를 순화\nSet wkBk = Workbooks.\nAdd\n'새로운 빈 엑셀 파일을 열음\nWith ThisWorkbook\nstrName = Left(.Name, Len(.Name) - 5)\n'파일 확장자 제거후 파일이름만 추출\nnewName = .Path & \"\\\" & .Name & \" \" & wkSht.Name & \".xlsx\"\n'매크로 파일과 동일한 경로에 파일이름 + 시트이름으로 폴더에 저장\nEnd With\nIf\nLen(Dir(newName)) <> 0\nThen\n'파일 존재 유무 확인\nMsgBox \"파일이 이미 존재. 기존 파일 삭재후 재시행\", 64, \"동일 파일 존재\"\nwkBk.\nClose False\n'새로 열은 파일을 저장하지 않고 닫음\nExit Sub\nEnd If\nwkSht.\nCopy\nBefore:=wkBk.Sheets(1)\n'각 시트를 첫 시트 앞에 복사\nwkBk.\nSaveAs\nFilename:=newName\n'각 파일을 새로운 이름으로 저장\nwkBk.Close\n'저장한 파일을 닫음\nNext wkSht\nSet wkBk = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet wkSht = Nothing\nEnd Sub", "context": "각 시트를 매크로 파일과 동일한 폴더 경로에 각각의 시트 이름으로 구분하여 별도의 파일로 저장함. 매크로 버튼이 복사되는 것을 방지하기 위하여 버튼을 시트내에 넣지 않고 Alt + F8 을 클릭(또는 메뉴 => 보기 => (제일오른쪽) 매크로 버튼 클릭)하여 매크로 실행창에서 바로 매크로를 실행함.\n(파일 확장자가 엑셀 2007 이상인 경우를 기준으로 작성함. 엑셀 2003의 경우 일부코드 수정필요)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(933) 각 sheet를 별도의 엑셀 파일로 저장하기 2 (엑셀 VBA 매크로)\n재생\n1,906\n재생 (space/k)\n재생\n00:24\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:24\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생..."}
{"instruction": "Excel VBA code for: (934) 열려진 외곽선 테두리 닫기 (엑셀 VBA 매크로)", "input": "", "output": "Sub close_Open_Lines()\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim j As Long\n'반복구문에 사용할 변수\nDim cnt As Long\n'카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor i = 1 To 2\n'2회 반복\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nWith rngC\n'각 셀에서\nFor j = 7 To 10\n'(상하좌우) 4회 반복\nIf .\nBorders(j).\nLineStyle\n= 1\nThen\n'외곽선 테두리가 있으면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nEnd If\nNext j\nIf cnt > 2 Then\n'카운터가 2보다 클 경우\n.Borders.LineStyle = 1\n'각 셀에 전체 외곽선 테두리를 함\nEnd If\nIf .Borders(9).LineStyle = 1 And .Borders(10).LineStyle = 1\nOr\n_\n.Borders(7).LineStyle = 1 And .Borders(9).LineStyle = 1 Or _\n.Borders(8).LineStyle = 1 And .Borders(10).LineStyle = 1 Or _\n.Borders(7).LineStyle = 1 And .Borders(8).LineStyle = 1 Then\n'각 구석에 2개씩 빈 셀 영역\n.Borders.LineStyle = 1\n'전체 외곽선 테두리를 함\nEnd If\nEnd With\ncnt = 0\nNext rngC\nNext i\nEnd Sub", "context": "엑셀 작업을 하다보면 많은 테두리선을 그린다. 그런데 여기 저기 선을 그리고 지우고 셀을 복사 하다보면 윗그림과 같이 외곽선이 열려진 셀들이 생겨난다. 더우기 1행 또는 1열에서 선이 삭제되면 미리보기에도 잘 나오지 않아 인쇄하고 나서 발견하고 외곽선을 채우고 인쇄하였던 경험이 있다.\n참고로, 아래의 매크로는\n일부가 열린 셀에만 적용\n되며, 완전히 떨어져 있는 별도의 선이 그어진 셀에는 작동하지 않는다. 또한\n표준\n실선에 한정\n되며, 굵은선 또는 점선 등의 다른 외곽선에는 적용되지 않는다. 그러므로 내부는 실선, 외곽 테두리는 굵은선 등으로 만든 표 등에 적용하려면 아래의 코드를 수정하여야한다.\n매크로 실행 전(영역을 선택)                           매크로 실행 후 (일부가 열려진 셀들만 닫힘)\n매크로 실행 전 (여기 저기 열려진 선이 보인다.) 마우스로\n영역을 선택하고 매크로 실행\n한다.\n매크로 실행 후 결과\nOption Explicit\nSub close_Op..."}
{"instruction": "Excel VBA code for: (936) 부분합의 합계를 우측에 구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub sum_Of_Daily_Sales()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nCells(r, 1).Offset(, 2) =\nApplication\n.\nSum\n(Cells(r - i, 1).\nNext\n.Resize(i + 1))\n'중복품목별 합계 넣기\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until Cells(r, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\nEnd Sub", "context": "매크로 실행 전                                                  매크로 실행 후 결과\nOption Explicit\nSub sum_Of_Daily_Sales()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nCells(r, 1).Offset(, 2) =\nApplication\n.\nSum\n(Cells(r - i, 1).\nNext\n.Resize(i + 1))\n'중복품목별 합계 넣기\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Unti..."}
{"instruction": "Excel VBA code for: (938) 사용자폼에 랜덤으로 시트에 있는 그림 띄우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub load_Random_Picture()\nUserForm1.\nShow\nEnd Sub\n\nPrivate Sub CommandButton1_Click()\nUnload Me\n'사용자폼 닫기\nEnd Sub\n\nPrivate Sub UserForm_Initialize()\nDim intNo As Integer\n'랜덤한 번호를 넣을 변수\nDim shpC As Shape\n'각각의 사진을 넣을 변수\nDim rngShp As Range\n'각 사진의 왼쪽위가 속한 영역을 넣을 변수\nDim chtPic As Chart\n'차트를 넣을 변수\nDim picW As Long\n'그림크기 가로를 넣을 변수\nDim picH As Long\n'그림크기 세로를 넣을 변수\nintNo = WorksheetFunction.\nRandBetween\n(1, 4)\n'1 ~ 4 사이의 무작위 숫자를 추출\nFor Each shpC In Worksheets(\"Sheet1\").Shapes\n'시트내의 각 그림을 순환\nSet rngShp = shpC.\nTopLeftCell\n'각 그림의 왼쪽위영역을 변수에 넣음\nIf\nNot Intersect(Range(\"A\" & intNo), rngShp) Is Nothing\nThen\n'그림과 지정한 영역이 겹치면\nshpC.\nCopyPicture\n'그림을 복사\nExit For\n'For 구문 종료\nEnd If\nNext shpC\npicW = Image1.Width\n'그림의 가로크기를 변수에 넣음\npicH = Image1.Height\n'그림의 세로크기를 변수에 넣음\nSet chtPic = ActiveSheet.ChartObjects.Add(1, 1, picW, picH).Chart\n'차트 개체를 삽입\nWith chtPic\n'삽입된 차트에서\n.\nPaste\n'(복사한)그림 붙여넣기\n.\nExport\n\"Temp.jpg\"\n'그림파일을 내보내기\n.\nParent.Delete\n'차트개체 삭제\nEnd With\nSet Image1.Picture = LoadPicture(\"Temp.jpg\")\n'Image1 컨트롤에 그림 로딩\nKill\n\"Temp.jpg\"\n'임시로 사용한 그림 삭제\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(938) 사용자폼에 랜덤으로 시트에 있는 그림 띄우기 (엑셀 VBA 매크로)\n재생\n1,662\n재생 (space/k)\n재생\n00:23\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:23\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n'시트에 있는 매크로 버튼에 연결된 표준모듈에 입력된 코드\nSub load_Random_Picture()\nUserForm1.\nShow\nEnd Sub..."}
{"instruction": "Excel VBA code for: (939) 사용영역 이외의 행/열 숨기기 (엑셀 VBA 매크로)", "input": "", "output": "Sub hide_Unused_Area()\nDim colsCnt As Integer\n'사용영역 열 개수를 넣을 변수\nDim rowsCnt As Long\n'사용영역 행 개수를 넣을 변수\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\ncolsCnt = .Columns.Count\n'열 개수를 변수에 넣음\nrowsCnt = .Rows.Count\n'행 개수를 변수에 넣음\nEnd With\nRows(rowsCnt + 1 & \":\" & Rows.Count).\nEntireRow.Hidden = True\n'사용영역 이외의 행 숨기기\nRange(Cells(1, colsCnt + 1), Cells(1, Columns.Count)).EntireColumn.Hidden = True\n'사용영역 이외의 열 숨기기\nRange(\"A1\").Select\n'A1셀을 선택\nEnd Sub\n\nSub unhide_All()\nWith ActiveSheet.Cells\n'현재시트 전체셀에서\n.\nEntireRow.Hidden = False\n'전체행을 보이기\n.EntireColumn.Hidden = False\n'전체열을 보이기\nEnd With\nRange(\"A1\").Select\n'A1셀을 선택\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(939) 사용영역 이외의 행/열 숨기기 (엑셀 VBA 매크로)\n재생\n3,204\n재생 (space/k)\n재생\n00:17\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:17\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n버튼을 숨겨지는 영역에 놔두면 버튼마저 크기가 줄어 숨겨지므로 1행에 위치함.  버튼을 삭제하고 동영상처럼 메뉴 => 보기 => 매크로 실행을 하여도 된다. 페이..."}
{"instruction": "Excel VBA code for: (941) 부분합행 건너뛰며 순차적 번호채우기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub add_No_Skipping_Sum1()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'숫자를 1씩 증가할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, 1).End(3))\n'A열 전체영역을 변수에 넣음\nIf\nrngC = \"\"\nThen\n'만약 각 셀이 빈셀이라면\ni = i + 1\n'번호를 1씩 늘려감\nrngC = i\n'각 셀에 번호를 입력함\nEnd If\nNext rngC\nEnd Sub", "context": "매크로 실행 전                                                      매크로 실행 후\nOption Explicit\nSub add_No_Skipping_Sum1()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'숫자를 1씩 증가할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, 1).End(3))\n'A열 전체영역을 변수에 넣음\nIf\nrngC = \"\"\nThen\n'만약 각 셀이 빈셀이라면\ni = i + 1\n'번호를 1씩 늘려감\nrngC = i\n'각 셀에 번호를 입력함\nEnd If\nNext rngC\nEnd Sub..."}
{"instruction": "Excel VBA code for: (942) 부분합행 건너뛰며 순차적 번호채우기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub add_No_Skipping_Sum2()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'숫자를 1씩 증가할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, 1).End(3))\n'A열 전체영역을 변수에 넣음\nIf Not rngC.\nMergeCells\nThen\n'만약 각 셀이 셀병합셀이 아니라면\ni = i + 1\n'번호를 1씩 늘려감\nrngC = i\n'각 셀에 번호를 입력함\nEnd If\nNext rngC\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                                      매크로 실행 후\nOption Explicit\nSub add_No_Skipping_Sum2()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'숫자를 1씩 증가할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, 1).End(3))\n'A열 전체영역을 변수에 넣음\nIf Not rngC.\nMergeCells\nThen\n'만약 각 셀이 셀병합셀이 아니라면\ni = i + 1\n'번호를 1씩 늘려감\nrngC = i\n'각 셀에 번호를 입력함\nEnd If\nNext rngC\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub..."}
{"instruction": "Excel VBA code for: (943) 부분합행 건너뛰며 순차적 번호채우기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub add_No_Skipping_Sum3()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'숫자를 1씩 증가할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, 1).End(3))\n'A열 전체영역을 변수에 넣음\nIf Not rngC.\nMergeCells\nThen\n'만약 각 셀이 셀병합셀이 아니라면\ni = i + 1\n'번호를 1씩 늘려감\nrngC = i\n'각 셀에 번호를 입력함\nEnd If\nNext rngC\nEnd Sub", "context": "매크로 실행 전                                                      매크로 실행 후\nOption Explicit\nSub add_No_Skipping_Sum3()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'숫자를 1씩 증가할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, 1).End(3))\n'A열 전체영역을 변수에 넣음\nIf Not rngC.\nMergeCells\nThen\n'만약 각 셀이 셀병합셀이 아니라면\ni = i + 1\n'번호를 1씩 늘려감\nrngC = i\n'각 셀에 번호를 입력함\nEnd If\nNext rngC\nEnd Sub..."}
{"instruction": "Excel VBA code for: (944) 부분합행 건너뛰며 순차적 번호채우기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub add_No_Skipping_Sum4()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'셀을 1씩 늘려갈 변수\nDim i As Long\n'숫자를 1씩 증가할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nr = 2\n'2행부터 시작\nDo\n'다음을 실행\nIf Cells(r, 1) =\nvbNullString\nThen\n'각 셀이 빈세이라면\ni = i + 1\n'번호를 1씩 늘려감\nCells(r, 1) = i\n'각 셀에 번호를 입력함\nEnd If\nr = r + 1\n'각 행을 1씩 늘려감\nLoop Until\nCells(r, 1) = \"\"\nAnd\nCells(r, 2) = \"\"\n'A열과 B열이 빈셀일때 까지 무한 반복\nEnd Sub", "context": "매크로 실행 전                                                      매크로 실행 후\nOption Explicit\nSub add_No_Skipping_Sum4()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'셀을 1씩 늘려갈 변수\nDim i As Long\n'숫자를 1씩 증가할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nr = 2\n'2행부터 시작\nDo\n'다음을 실행\nIf Cells(r, 1) =\nvbNullString\nThen\n'각 셀이 빈세이라면\ni = i + 1\n'번호를 1씩 늘려감\nCells(r, 1) = i\n'각 셀에 번호를 입력함\nEnd If\nr = r + 1\n'각 행을 1씩 늘려감\nLoop Until\nCells(r, 1) = \"\"\nAnd\nCells(r, 2) = \"\"\n'A열과 B열이 빈셀일때 까지 무한 반복\nEnd Sub..."}
{"instruction": "Excel VBA code for: (945) 부분합행 건너뛰며 순차적 번호채우기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub add_No_Skipping_Sum5()\nDim rngA As Range\n'각 빈셀 area를 넣을 변수\nDim i As Long\n'숫자를 1씩 증가할 변수\nDim c As Long\n'각 area의 셀번호 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n'B열 전체영역을 변수에 넣음\nFor Each rngA In Columns(1).\nSpecialCells(4).Areas\n'A열 각\n빈셀 area\n를 순환\nFor c = 1 To rngA.\nCount\ni = i + 1\n'번호를 1씩 늘려감\nrngA.\nCells(c)\n= i\n'각 셀에 번호를 입력함\nNext c\nNext rngA\nEnd Sub", "context": "매크로 실행 전                                                      매크로 실행 후\nOption Explicit\nSub add_No_Skipping_Sum5()\nDim rngA As Range\n'각 빈셀 area를 넣을 변수\nDim i As Long\n'숫자를 1씩 증가할 변수\nDim c As Long\n'각 area의 셀번호 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n'B열 전체영역을 변수에 넣음\nFor Each rngA In Columns(1).\nSpecialCells(4).Areas\n'A열 각\n빈셀 area\n를 순환\nFor c = 1 To rngA.\nCount\ni = i + 1\n'번호를 1씩 늘려감\nrngA.\nCells(c)\n= i\n'각 셀에 번호를 입력함\nNext c\nNext rngA\nEnd Sub..."}
{"instruction": "Excel VBA code for: (947) 부분합행 건너뛰며 순차적 번호채우기 7 (엑셀 VBA 매크로)", "input": "", "output": "Sub add_No_Skipping_Sum7()\nDim rngAll As Range\n'A열 전체영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'숫자를 1씩 증가할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"A2\", Cells(Rows.Count, 1).End(3))\n'(제목제외한)전체영역을 변수에 넣음\nActiveSheet.UsedRange.\nAutoFilter\nField:=1, Criteria1:=\n\"=\"\n'A열 빈셀을 기준으로 필터링\nFor Each rngC In rngAll.\nSpecialCells(12)\n'A열 화면에 보이는 각 셀을 순환\ni = i + 1\n'번호를 1씩 늘려감\nrngC = i\n'각 셀에 번호를 입력함\nNext rngC\nActiveSheet.\nAutoFilter.Range.AutoFilter\n'필터 해제\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                                      매크로 실행 후\nOption Explicit\nSub add_No_Skipping_Sum7()\nDim rngAll As Range\n'A열 전체영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'숫자를 1씩 증가할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"A2\", Cells(Rows.Count, 1).End(3))\n'(제목제외한)전체영역을 변수에 넣음\nActiveSheet.UsedRange.\nAutoFilter\nField:=1, Criteria1:=\n\"=\"\n'A열 빈셀을 기준으로 필터링\nFor Each rngC In rngAll.\nSpecialCells(12)\n'A열 화면에 보이는 각 셀을 순환\ni = i + 1\n'번호를 1씩 늘려감\nrngC..."}
{"instruction": "Excel VBA code for: (948) 부분합행 건너뛰며 순차적 번호채우기 8 (엑셀 VBA 매크로)", "input": "", "output": "Sub add_No_Skipping_Sum8()\nDim rngAll As Range\n'A열 전체영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'숫자를 1씩 증가할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"A2\", Cells(Rows.Count, 1).End(3))\n'(제목제외한)전체영역을 변수에 넣음\nrngAll.\nColumnDifferences\n([A5]).Select\n'A5셀과 다른 셀만 선택\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\ni = i + 1\n'번호를 1씩 늘려감\nrngC = i\n'각 셀에 번호를 입력함\nNext rngC\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                                      매크로 실행 후\nOption Explicit\nSub add_No_Skipping_Sum8()\nDim rngAll As Range\n'A열 전체영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'숫자를 1씩 증가할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"A2\", Cells(Rows.Count, 1).End(3))\n'(제목제외한)전체영역을 변수에 넣음\nrngAll.\nColumnDifferences\n([A5]).Select\n'A5셀과 다른 셀만 선택\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\ni = i + 1\n'번호를 1씩 늘려감\nrngC = i\n'각 셀에 번호를 입력함\nNext rngC\nSet rngAll = N..."}
{"instruction": "Excel VBA code for: (949) 데이터와 x, v 값 재배치하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub relocate_XV()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngA As Range\n'중복되는 그룹별 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).UsedRange.ClearContents\n'Sheet2의 기존 데이터 삭제\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nSet rngA\n= Cells(r - i, 1).Resize(i + 1)\n'\"분류\"를 그룹별로 변수에 넣음\nWith Sheets(2)\n'Sheet2에서\nFor Each rngC In rngA\n'그룹별 영역의 각 셀을 순환\n.Cells(Rows.Count, 1).End(3)(2) = \"x(\"\n&\nrngC\n&\n\",\"\n&\nrngC.Next\n&\n\")\"\n'x로 시작되는 영역 복사\nNext rngC\n.Cells(Rows.Count, 2).End(3)(2).Resize(rngA.Count) = rngA.Offset(, 2).Value\n'값_x 복사\nFor Each rngC In rngA\n.Cells(Rows.Count, 1).End(3)(2) = \"v(\" & rngC & \",\" & rngC.Next & \")\"\n'v로 시작되는 영역 복사\nNext rngC\n.Cells(Rows.Count, 2).End(3)(2).Resize(rngA.Count) = rngA.Offset(, 3).Value\n'값_v 복사\nEnd With\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\nEnd Sub", "context": "매크로 실행 전 (Sheet2는 비어 있음)                                매크로 실행 후 결과\nOption Explicit\nSub relocate_XV()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngA As Range\n'중복되는 그룹별 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).UsedRange.ClearContents\n'Sheet2의 기존 데이터 삭제\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nSet rngA\n= Cells(r - i, 1).Resize(i + 1..."}
{"instruction": "Excel VBA code for: (950) 데이터 분배하여 재배치하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub relocate_And_Distribute()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp\n'B:C열의 각 셀의 문자 나누어 넣을 배열변수\nDim i As Long\n'반복구문에 사용할 변수\nDim j As Long\n'반복구문에 사용할 변수\nDim strU As String\n'각 행의 문자 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWorksheets(\"Sheet2\").UsedRange.\nClearContents\n'Sheet2의 기존 데이터 삭제\nColumns(\"F\").ClearContents\n'Sheet1 F열의 기존 데이터 삭제\nWith Worksheets(\"Sheet2\")\nFor Each rngC In Range(\"A1\").CurrentRegion\n'A1셀의 현재영역을 변수에 넣음\nSelect Case\nrngC.Column\n'각 셀의 열이\nCase\n1:\n'1인 경우\n.Cells(Rows.Count, 1).End(3)(2).Resize(4) = rngC\n'Sheet2의 A열 종단셀 윗방향 마지막 4행에 셀값 복사\nCase\n2:\n'2인 경우\nvarTemp\n=\nSplit\n(rngC, \",\")\n'셀 값을 나누에 배열에 넣음\nWith .Cells(Rows.Count, 2)\n'Sheet2의 B열 윗방향 종단셀\n.End(3)(2).Resize(2) = varTemp(0)\n'마지막행 2행에 배열의 첫째값 복사\n.End(3)(2).Resize(2) = varTemp(1)\n'마지막행 2행에 배열의 둘째값 복사\nEnd With\nCase\n3:\n'3인 경우\nvarTemp = Split(rngC, \",\")\n'셀 값을 나누에 배열에 넣음\nWith .Cells(Rows.Count, 3)\n'Sheet2의 C열 윗방향 종단셀\nFor i = 1 To 2\n'2회 반복\n.End(3)(2) = varTemp(0)\n'마지막행에 배열의 첫째값 복사\n.End(3)(2) = varTemp(1)\n'마지막행에 배열의 둘째값 복사\nNext i\nEnd With\nCase\n4:\n'4인 경우\n.Cells(Rows.Count, 4).End(3)(2).Resize(4) = rngC\n'Sheet2의 D열 종단셀 윗방향 마지막 4행에 셀값 복사\nEnd Select\nNext rngC\nFor i = 2 To .Cells(Rows.Count, 1).End(3).Row\n'2부터 Sheet2의 행 개수 만큼 반복\nFor j = 1 To 4\n'4회 반복\nIf strU = \"\" Then\n'strU가 비어 있을 경우\nstrU = .Cells(i, j)\n'strU에 첫 셀값을 넣고\nElse\n'strU가 비어 있지 않을 경우\nstrU = strU & .Cells(i, j)\n'각 셀의 셀값을 합쳐감\nEnd If\nNext j\nCells(Rows.Count, \"F\").End(3)(2) = strU\n'F열 윗방향 종단셀 바로 아래행에 strU 복사\nstrU = \"\"\n'재사용 위하여 초기화\nNext i\nEnd With\nColumns(\"F\").\nAutoFit\n'열너비 자동맞춤\nEnd Sub", "context": "(데이터를 Sheet2에 임시로 이동하여 순서대로 위치하고 이를 다시 가져오도록 함. 대중성이 떨어지는 내용이고 그리 마음에 드는 코드는 아니지만 어차피 작성한 것이므로 올려둠.)\n매크로 실행 전                                                       매크로 실행 후\nOption Explicit\nSub relocate_And_Distribute()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp\n'B:C열의 각 셀의 문자 나누어 넣을 배열변수\nDim i As Long\n'반복구문에 사용할 변수\nDim j As Long\n'반복구문에 사용할 변수\nDim strU As String\n'각 행의 문자 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWorksheets(\"Sheet2\").UsedRange.\nClearContents\n'Sheet2의 기존 데이터 삭제\nCol..."}
{"instruction": "Excel VBA code for: (951) var1 = Array(1, 2, 3) 의 뜻 (엑셀 VBA 매크로)", "input": "", "output": "Sub test()\nDim var1\nDim var2\nDim var3\nvar1 = Array(1, 2, 3)\nvar2 = Range(\"A1:C1\")\nvar3 = Range(\"A1:A3\")\nEnd Sub", "context": "오늘은 배열에 대해서 공부를 해본다. 배열을 자연스럽게 사용할 수 있다면 VBA의 중급수준에 접어들었다고 봐도 무방하다. 배열은 쉽지 않은 주제이며, 그래서 다루지 않으려고 했지만 배열을 사용하는 것이 속도나 효용성에서 정답인 경우가 흔하다. 깊은 내용은 다룰 수 없으므로 배열에 데이터가 저장되는 구조만 간단히 다루도록 한다.\nvar1\n: 위에 보는 바와 같이 var1은 variant형\n변수의 이름\n이다. 변수는 변수이름 규칙을 준수하면 어떤 이름도 사용가능하다. ( 예를들면, varTemp, arrayNo, 배열1  ... ). 한글로도 변수를 정의할 수 있다. Variant형은 Dim var1 As Variant 이라고 선언하지만 줄여서 Dim var1 라고 할 수 있다.\n초보 때 변수 선언 시 흔히 하는 실수중의 하나는 아래와 같은 것이다.\nDim i, j, k, l, m As Integer\n사용자는 위와 같이 i, j, k, l, m을 정수형(integer)으로 선언하려고 의..."}
{"instruction": "Excel VBA code for: (952) 그룹별 중복데이터 제일 윗행/아래행만 남기고 삭제하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Dupes_Leaving_Last()\nDim r As Long\n'행을 1씩 줄여가며 반복할 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'마지막 행을 변수에 넣음\nFor r = lastRow To 2\nStep -1\n'아래에서 위로 1행씩 줄여가며 2행까지 반복\nCells(r - 1, 1).Resize(2, 4).\nRemoveDuplicates\nArray\n(1, 2, 3, 4)\n'중복되는 A:D열의 데이터를 삭제\nNext r\nEnd Sub", "context": "매크로 실행 전                                                           매크로 실행 후 결과\nOption Explicit\nSub remove_Dupes_Leaving_Last()\nDim r As Long\n'행을 1씩 줄여가며 반복할 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'마지막 행을 변수에 넣음\nFor r = lastRow To 2\nStep -1\n'아래에서 위로 1행씩 줄여가며 2행까지 반복\nCells(r - 1, 1).Resize(2, 4).\nRemoveDuplicates\nArray\n(1, 2, 3, 4)\n'중복되는 A:D열의 데이터를 삭제\nNext r\nEnd Sub..."}
{"instruction": "Excel VBA code for: (953) 공백으로 문자 분리 후 나열하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub split_Each_Space()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp\n'각 셀을 공백으로 나누어 넣을 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"C\").ClearContents\n'기존 데이터 삭제\nFor Each rngC In Columns(\"A\").SpecialCells(2)\n'A열 각 문자셀을 순환\nvarTemp =\nSplit(WorksheetFunction.Trim\n(rngC), \" \")\n'각 셀의 공백제거 후 공백으로 분리하여 배열에 넣음\nCells(Rows.Count, 3).End(3)(2).Resize(\nUBound\n(varTemp) + 1) = _\nApplication.\nTranspose\n(varTemp)\n'C열 종단셀 윗방향 아래행에 배열을 복사\nNext rngC\nEnd Sub", "context": "각 셀의 중복되는 공백은 제거하고 각 공백을 기준으로 문자를 분리하여 나열하기\n매크로 실행 전                                               매크로 실행 후 결과\nOption Explicit\nSub split_Each_Space()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp\n'각 셀을 공백으로 나누어 넣을 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"C\").ClearContents\n'기존 데이터 삭제\nFor Each rngC In Columns(\"A\").SpecialCells(2)\n'A열 각 문자셀을 순환\nvarTemp =\nSplit(WorksheetFunction.Trim\n(rngC), \" \")\n'각 셀의 공백제거 후 공백으로 분리하여 배열에 넣음\nCells(Rows.Count, 3).End(3)(2).Resize(\nUBound\n(varTemp..."}
{"instruction": "Excel VBA code for: (954) 데이터베이스 테이블 형태로 변환 (엑셀 VBA 매크로)", "input": "", "output": "Sub relocate_Into_Database_Form()\nDim r As Long\n'행 1씩 늘려갈 변수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWorksheets(2).UsedRange.ClearContents\n'Sheet2의 기존 데이터 삭제\nr = 2\n'2행부터 시작\nDo\n'다음을 실행\nWith Worksheets(2)\n'Sheet2에서\n.Cells(1, 1).Resize(, 4) =\nArray\n(\"구분\", \"국가\", \"품목\", \"개수\")  '제목복사\n.Cells(Rows.Count, 1).End(3)(2).Resize(3, 2) = _\nCells(r, 1).Resize(, 2).Value\n'구분과 국가 복사\n.Cells(Rows.Count, 3).End(3)(2).Resize(3) = _\nApplication.\nTranspose\n(Range(\"C1:E1\"))\n'신발, 시계, 지갑 복사\nFor i = 1 To 3\n'1 ~ 3까지 반복\n.Cells(Rows.Count, 4).End(3)(2) = _\nCells(r, i + 2)\n'신발, 시계, 지갑 개수를 각 열에 복사\nNext i\nEnd With\nr = r + 1\n'행을 1씩 늘려감\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈행 나올때까지 무한 반복\nEnd Sub", "context": "매크로 실행 전 Sheet1 (Sheet2는 비어 있음)                           매크로 실행 후 결과\nOption Explicit\nSub relocate_Into_Database_Form()\nDim r As Long\n'행 1씩 늘려갈 변수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWorksheets(2).UsedRange.ClearContents\n'Sheet2의 기존 데이터 삭제\nr = 2\n'2행부터 시작\nDo\n'다음을 실행\nWith Worksheets(2)\n'Sheet2에서\n.Cells(1, 1).Resize(, 4) =\nArray\n(\"구분\", \"국가\", \"품목\", \"개수\")  '제목복사\n.Cells(Rows.Count, 1).End(3)(2).Resize(3, 2) = _\nCells(r, 1).Resize(, 2).Value\n'구분과 국가 복사\n.Cells(..."}
{"instruction": "Excel VBA code for: (955) 홀수/짝수 기준으로 자동필터 (엑셀 VBA 매크로)", "input": "", "output": "Sub filter_EveryOther()\nDim modNo As Integer\n'나머지 값을 0 또는 1로 설정할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열을 1씩 늘려갈 변수\nDim varTemp()\n'동적배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveSheet.\nShapes(Application.Caller)\n'매크로 실행한 도형의 문자\nIf\n.TextFrame2.TextRange.Text\n= \"Show All\" Then\n'버튼의 문자가 짝수면\n.TextFrame2.TextRange.Text = \"짝수\"\n'버튼의 문자를 홀수로\n.\nShapeStyle\n= 31\n'버튼 색깔을 자주색으로\nmodNo = 0\n'나머지 값을 0으로 설정\nElseIf .TextFrame2.TextRange.Text = \"짝수\" Then\n'버튼의 문자가 짝수면\n.TextFrame2.TextRange.Text = \"홀수\"\n'버튼의 문자를 Show All로\n.ShapeStyle = 32\n'버튼 색깔을 초록색으로\nmodNo = 1\n'나머지 값을 0로 설정\nElse\n'버튼문자가 홀수/짝수 아니면\n.TextFrame2.TextRange.Text = \"Show All\"\n'버튼 문자를 짝수로\n.ShapeStyle = 30\n'버튼의 색깔을 파랑색으로\nActiveSheet.UsedRange.AutoFilter\n'자동필터 해제\nExit Sub\n'매크로 종료\nEnd If\nEnd With\nFor i = 1 To\nWorksheetFunction.Max\n(Columns(\"A\"))\n'1 ~  A열의 최댓값까지 반복\nIf i\nMod\n2 = modNo Then\n'2로 나눈 나머지가 modNO이면\nr = r + 1\n'행을 1씩 늘려감\nReDim Preserve\nvarTemp(1 To r)\n'배열크기 1씩늘려 재지정\nvarTemp(r) =\nCStr\n(i)\n'배열에 값을 문자로 변환하여 입력\nEnd If\nNext i\nActiveSheet.UsedRange.\nAutoFilter\n1, varTemp, 7\n'현재시트 사용영역을 배열값으로 필터\nEnd Sub", "context": "버튼을 클릭할 때마다 A열의 짝수 => 홀수 => Show All의 순서대로 데이터를 자동필터\n버튼을 클릭 시 마다 버튼의 문자 및 색의 표시를 변경\n(아래 예제에서는 화면의 제한으로 단지 홀수/짝수로 구분을 하였지만 Mod 함수를 이용하여 배열내의 입력값을 조절하여 얼마든지 사용자가 원하는 숫자들만을 기준으로 자동필터를 할 수 있다.)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(955) 홀수/짝수 기준으로 자동필터 (엑셀 VBA 매크로)\n재생\n1,847\n재생 (space/k)\n재생\n00:18\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:18\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다...."}
{"instruction": "Excel VBA code for: (956) 메모의 폰트/모양 일괄 변경 (VBA 매크로 동영상)", "input": "", "output": "Sub customize_Comment_Size()\nDim cmt As\nComment\n'메모(comment)를 넣을 변수\nFor Each cmt In ActiveSheet.Comments\n'시트내의 모든 메모를 순환\nWith cmt.\nShape.TextFrame.Characters.Font\n'메모의 폰트\n.Name = \"Arial\"\n'Arial 폰트 적용\n.ColorIndex = 3\n'메모의 색깔 적용\n.Size = 12\n'메모의 크기\nEnd With\ncmt.Shape.\nAutoShapeType\n= 5\n'메모의 모양\nNext cmt\nEnd Sub", "context": "시트에 있는 전체 메모의 폰트/모양 등을 일괄 변경하는 기능. 한글로는 메모로 번역했지만 영어로는 Comment 임. (참고로, 메모의 기본 폰트는 엑셀에서 설정하는 것이 아니고 윈도우즈 설정을 변경하여야 된다. 즉, 디스플레이 고급 설정에서 도구설명의 폰트를 수정하여야 함. 하지만 이렇게 할 경우 엑셀의 메모 폰트뿐 아니라 전체 윈도우의 화면 관련 폰트 크기가 변경된다.)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(956) 메모의 폰트/모양 일괄 변경 (VBA 매크로 동영상)\n재생\n697\n재생 (space/k)\n재생\n00:54\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:54\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0..."}
{"instruction": "Excel VBA code for: (957) 환자명 셀병합하고 환자별 외곽테두리하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub merge_And_BorderAround()\nDim rngAll As Range\n'각 열의 빈셀을 넣을 변수\nDim rngA As Range\n'빈셀 영역의 (A)rea를 넣을 변수\nDim i As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Columns(\"A\").\nSpecialCells(4)\n'A 열의\n빈셀\n영역을 변수에 넣음\nFor Each rngA In rngAll.\nAreas\n'빈셀영역을 순환\nrngA(0, 1).Resize(rngA.Rows.Count + 1).\nMerge\n'각 빈셀영을 윗셀과 셀병합\nNext rngA\nFor i = 2 To Cells(Rows.Count, 2).End(3).Row\n'2행부터 마지막행까지 반복\nIf Cells(i, 1) <> \"\" Then\n'각 셀이 빈셀이 아니라면\nCells(i, 1).Resize(Cells(i, 1).\nMergeArea\n.Cells.Count, 5).BorderAround Weight:=xlThin\n'셀병합된 행마다 외곽테두리\nEnd If\nNext i\nColumns(\"A\").SpecialCells(2).Borders.LineStyle = 1\n'A열에 외곽 테두리\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "A열에 있는 환자명을 셀병합하고 각 환자명별 외곽 테두리를 생성한다.\n매크로 실행 전                                                        매크로 실행 후 결과\nOption Explicit\nSub merge_And_BorderAround()\nDim rngAll As Range\n'각 열의 빈셀을 넣을 변수\nDim rngA As Range\n'빈셀 영역의 (A)rea를 넣을 변수\nDim i As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Columns(\"A\").\nSpecialCells(4)\n'A 열의\n빈셀\n영역을 변수에 넣음\nFor Each rngA In rngAll.\nAreas\n'빈셀영역을 순환\nrngA(0, 1).Resize(rngA.Rows.Count + 1).\nMerge\n'각 빈셀영을 윗셀과 셀병합\nNext rngA\nFor i = 2 To ..."}
{"instruction": "Excel VBA code for: (958) 10으로 나눈 만큼 행 늘려 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub divide_Into_Eevery_Ten()\nDim rngAll As Range\n'제목뺀 데이터 영역 넣을 변수\nDim rngR As Range\n'각 행을 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수를 넣을 변수\nDim lngNo As Long\n'E열의 각 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\nSet rngAll = .Offset(1).Resize(.Rows.Count - 1)\n'제목제외한 영역을 변수에 넣음\nEnd With\ncolsCnt = rngAll.Columns.Count\n'전체 열 개수를 변수에 넣음\nWith Worksheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'Sheet2의 기존 데이터 삭제\nRange(\"A1:E1\").\nCopy\n.Range(\"A1\")\n'1행 제목 복사\nFor Each rngR In rngAll.\nRows\n'전체영역 각 행을 순환\nlngNo = rngR.Cells(colsCnt)\n'각 행의 마지막 셀값을 변수에 넣음\nWith .Cells(Rows.Count, 5)\n'E열의 개수에서\nIf lngNo > 10 Then\n'10보다 클 경우\n.End(3)(2, -3).Resize(, colsCnt) = rngR.Value\n'각 행을 복사\n.End(3).Resize(lngNo\n\\\n10) = 10\n'\"개수\"를 나눈 몫 만큼 10복사\nIf lngNo\nMod\n10 <> 0 Then\n'나머지가 0이 아니면\n.End(3)(2) = lngNo Mod 10\n'10으로 나눈 \"개수\"의 나머지 복사\nEnd If\nElse\n.End(3)(2, -3).Resize(, colsCnt) = rngR.Value\n'각 행을 복사\nEnd If\nEnd With\nNext rngR\n.Columns(\"B:D\").SpecialCells(4).\nFormulaR1C1\n= \"=R[-1]C\"\n'B:C열의 빈셀을 윗셀값 복사\n.Columns.\nAutoFit\n'Sheet2의 열너비 자동맞춤\n.Activate\n'Sheet2를 활성화\nActiveSheet.UsedRange.\nBorders.LineStyle = 1\n'Sheet2의 사용영역에 외곽선 적용\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 2) = Cells(r + 1, 2) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nCells(r - i, 2).Offset(, -1).Resize(i + 1, colsCnt).\nBorderAround\n, Weight:=\n4\n'각 이름별 굵은 테두리선 넣기\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 2) = vbNullString\n'B열에 빈셀 나올때까지 무한 반복\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. E열의 \"개수\"를 10으로 나눈 만큼 행을 늘려서 복사하기\n2. 전체영역에 테두리 적용하고 동일 \"사업장\"별로 굵은 테두리를 하여 구분\n매크로 실행 전 (Sheet2는 비어 있음)                               매크로 실행 후 결과\nOption Explicit\nSub divide_Into_Eevery_Ten()\nDim rngAll As Range\n'제목뺀 데이터 영역 넣을 변수\nDim rngR As Range\n'각 행을 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수를 넣을 변수\nDim lngNo As Long\n'E열의 각 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\nSet rngAll = .Of..."}
{"instruction": "Excel VBA code for: (963) Pass / Fail 찾기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Pass_Fail()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim rngR As Range\n'전체영역 각 열을 넣을 변수\nDim rngC As Range\n'각 열의 각 셀을 넣을 변수\nDim blnTF As\nBoolean\n'Pass/Fail 판명에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"D3:AR18\")\n'전체영역을 변수에 넣음\nRange(\"D2:AR2\").Font.\nBold = True\n'Pass/Fail 들어갈 영역 폰트 굵게\nFor Each rngR In rngAll.\nColumns\n'전체영역 각 열을 순환\nFor Each rngC In rngR.\nCells\n'각 열의 각 셀을 순환\nIf rngC < Cells(rngC.Row, 1)\nOr\n_\nrngC > Cells(rngC.Row, 2) Then\n'Min 보다 작거나 Max보다 크면\nblnTF =\nTrue\n'blnTF의 값에 참을 넣음\nrngC.\nFont.ColorIndex = 3\n'범위 벗어난 값은 빨간색 폰트로\nEnd If\nNext rngC\nIf blnTF = True Then\n'blnTF 값이 참이면\nrngR.Cells(1)(0, 1) = \"Fail\"\n'Fail 입력\nrngR.Cells(1)(0, 1).Font.ColorIndex = 3\n'셀의 폰트를 빨간색으로\nElse\nrngR.Cells(1)(0, 1) = \"Pass\"\n'Pass 입력\nrngR.Cells(1)(0, 1).Font.ColorIndex = 5\n'셀의 폰트를 파란색으로\nEnd If\nblnTF =\nFalse\n'blnTF 재사용 위하여 False로 초기화\nNext rngR\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "A:B열에 있는 Min / Max 값과 비교하여 Min 보다 작거나 Max보다 큰 값이 있는 경우 Fail, 아닐 경우에 Pass를 2행에 입력하는 기능.\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub find_Pass_Fail()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim rngR As Range\n'전체영역 각 열을 넣을 변수\nDim rngC As Range\n'각 열의 각 셀을 넣을 변수\nDim blnTF As\nBoolean\n'Pass/Fail 판명에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"D3:AR18\")\n'전체영역을 변수에 넣음\nRange(\"D2:AR2\").Font.\nBold = True\n'Pass/Fail 들어갈 영역 폰트 굵게\nFor Each rngR In rngAll.\nColumns\n'전체영역 각 열을 순환\nFor Each ..."}
{"instruction": "Excel VBA code for: (964) 각 이름의 기간별 합계 구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub filter_By_Month()\nDim dteStart As\nDate\n'시작일을 넣을 변수\nDim dteEnd As Date\n'종료일을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\ndteStart =\nDateSerial\n(Year([B1]), Month([B1]), 1)\n'시작월 1일부터\ndteEnd = DateSerial(Year([B2]), Month([B2]) + 1,\n0\n)\n'종료월 마지막일까지\nIf dteStart > dteEnd Then\n'종료일이 시작일보다 빠를 경우\nMsgBox \"종료일이 시작일보다 빠릅니다.\", 64, \"날짜입력 오류\"\nExit Sub\n'매크로 종료\nEnd If\nIf Range(\"A5\") <> \"\" Then\n'A2셀에 데이터 있다면, 즉 기존데이터 있으면\nRange(\"D5\", Cells(Rows.Count, \"A\").End(3)).ClearContents\n'기존데이터 삭제\nEnd If\nWith Worksheets(1).UsedRange\n'Shee1 즉 데이터시트 사용영역에서\n.\nAutoFilter\n1, \">=\" & dteStart,\nxlAnd\n, \"<=\" & dteEnd\n'시작일과 종료일을 기준으로 자동필터\nIf .Offset(1).SpecialCells(12).Cells(1) <> \"\" Then\n'필터링된 결과 데이터가 있을 경우\n.Offset(1, 1).SpecialCells(12).Copy Range(\"A5\")\n'필터된 데이터 Sheet2에 복사\nElse\n'조건에 일치하는 데이터 없을 경우\nMsgBox \"일치하는 데이터가 없습니다.\", 64, \"데이터 없음\"\n'메시지 출력\nGoTo ErrHandler\n'에러처리 구문으로 이동\nEnd If\nEnd With\nWith Range(\"C5\", Cells(Rows.Count, \"A\").End(3))\n'복사된 데이터 영역에서\n[D5].\nConsolidate\nSources:=.Address(1, 1, xlR1C1), Function _\n:=xlSum, LeftColumn:=True\n'데이터 통합\n.Delete xlToLeft\n'복사된 데이터 삭제\nEnd With\nRange(\"C5\", Cells(Rows.Count, \"A\").End(3)).\nSort\n[A5]\n'A열을 기준으로 오름차순 정렬\nRange(\"C5\", Cells(Rows.Count, \"C\").End(3)).Offset(, 1).\nFormulaR1C1\n_\n= \"=RC[-2]-RC[-1]\"\n'\"잔액\"의 계산식 입력\nErrHandler:\n'에러 발생시 실행할 행\nWorksheets(1).\nAutoFilter.Range.AutoFilter\n'Sheet1의 자동필터 해제\nEnd Sub", "context": "(시작 날짜의 1일)부터 (종료 날짜의 말일) 기간 내의 데이터를 가져온다.\n동일한 이름의 데이터를 통합하여 표시하여 준다.\n수입 - 지출 = 잔액\n시작/종료년도 버튼을 클릭하고 Run Macro 버튼을 클릭하거나, Run Macro버튼 왼쪽의 월(月)을 올리고 내리는 스피너 버튼을 클릭할 때마다 시작/종료일 기간내의 데이터를 가져온다.\n매크로 실행전 데이터가 저장된 Sheet1\n매크로 실행 전 Sheet2\n매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(964) 각 이름의 기간별 합계 구하기 (엑셀 VBA 매크로)\n재생\n1,334\n재생 (space/k)\n재생\n00:43\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:43\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n..."}
{"instruction": "Excel VBA code for: (966) z와 j자 사이의 문자만 추출하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub text_Between_zj()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim v As Variant\n'문자 z로 나눈 결과를 넣을 배열변수\nDim i As Byte\n'반복구문에 사용할 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nFor Each rngC In Sheet1.Range(\"B1:B7\")\n'B1:B7 각 셀을 순환\nv =\nSplit\n(rngC, \"z\")\n'각 셀을 z자를 구분자로 하여 배열에 쪼개어 넣음\nFor i = 1 To\nUBound\n(v)\n'1 에서 배열 개수만큼 반복\nr = r + 1\n'행을 1씩 늘려감\nSheet2.Cells(r, 1).Resize(, 2) =\nArray\n(rngC(1, 0), Split(v(i), \"j\")(0))\n'각 셀의 A열번호 와 각 배열값을 다시 j로 구분하여 index 0 즉 첫번째 값만 Sheet2에 뿌림\nNext\nNext\nEnd Sub", "context": "이번에는 거의 처음으로 다른 분의 코드를 올려봅니다. 마니또(npstart7)님의 코드입니다. 제가 알아보기 쉽도록 변수이름 하나만 바꾸었습니다. \"별로 어렵지 않은 코드를 왜 올렸나\"하고 생각할지 모르지만 군더더기 없이 정곡을 콕 찌른 코드네요. 중급자 분들은 제 블로그 오시는 것도 좋지만 시간 나시면 마니또님 블로그(\nhttp://cafe.naver.com/exceller\n)에 가셔서 공부하세요.^^\n아주 짧지만 음미할 것이 서 너개나 있는 코드입니다. 잘 봐두시기를 ... 특히 For 구문에서 LBound(v)To UBound(v) 하지 않고 1부터 시작하여 처음 z자 앞의 문자를 없애는 것과 split을 중첩하며 index 0을 응용한 것은 아주 탁월한 아이디어로 최상의 코드 선택이라 생각합니다.\n매크로 실행 전 (Sheet2는 비어 있음)                                              매크로 실행 후 결과\nOption Explicit\nSub..."}
{"instruction": "Excel VBA code for: (967) z와 j자 사이의 문자만 추출하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub text_Between_Two_Letters()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim strU As String\n'v, j 사이의 문자를 합칠변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim strLeft As String\n'시작문자 넣을 변수\nDim strRight As String\n'마지막 문자 넣을 변수\nstrLeft = \"\nz\n\"\n'시작문자를 변수에\nstrRight = \"\nj\n\"\n'마지막 문자를 변수에\nFor Each rngC In Sheet1.Range(\"B1:B7\")\n'B1:B7 각 셀을 순환\nIf\nInStr\n(1, rngC, strLeft, vbTextCompare) > 0 And _\nInStr(1, rngC, strRight, vbTextCompare) Then\n'시작문자와 마지막문자가 포함되었다면(대소문자구분 안함)\nIf InStr(1, rngC, strLeft) < InStr(1, rngC, strRight) Then\nFor i = 1 To Len(rngC)\n'각 셀의 문자 길이만큼 반복\nIf\nMid\n(rngC, i, 1) = strLeft Then\n'만약 시작문자와\n일치하면\nDo\n'다음을 실행\ni = i + 1\n'각 셀의 문자위치를 1씩 늘려감\nstrU = strU & Mid(rngC, i, 1)\n'문자를 합쳐감\nLoop Until\nMid(rngC, i + 1, 1) = strRight\n'마지막 문자 나올때까지 무한 반복\nr = r + 1\n'행을 1씩 늘려감\nWorksheets(2).Cells(r, 1).Resize(, 2) =\nArray\n(rngC(1, 0), strU)\n'숫자와 v, j 사이의 문자를 배열에 넣어 Sheet2에 뿌림\nstrU = \"\"\n'재사용 위하여 strU 초기화\nEnd If\nNext i\nEnd If\nEnd If\nNext rngC\nSheet2.Activate\n'결과 확인위해 Sheet2 활성화\nEnd Sub", "context": "(두 개의 서로 다른 문자 사이에 있는 문자만 추출에 사용할수 있는 코드이므로 \"기본코드\"에 저장함.)\n앞서는 split의 중첩으로 결과를 구하였고 이번에는 Do .. Loop 구문을 활용하여 동일한 결과를 구함.\n당연히 코드에서 z와 j를 자신이 원하는 문자로 바꾸면 된다.\n매크로 실행 전 (Sheet2는 비어 있음)                                              매크로 실행 후 결과\nOption Explicit\nSub text_Between_Two_Letters()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim strU As String\n'v, j 사이의 문자를 합칠변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim strLeft As String\n'시작문자 넣을 변수\nDim strRight As String\n'마지막 문자 넣을 변수\nstrLeft = \"\nz\n\"\n'시..."}
{"instruction": "Excel VBA code for: (969) 이름사용과 인덱스(index)의 속도비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub using_Index()                                 Sub using_Name()\nDim i As Long                                       Dim i As Long\nApplication.ScreenUpdating = False        Application.ScreenUpdating = False\nFor i = 1 To 1000                                   For i = 1 To 1000\nWorksheets(\n2\n).Select                          Worksheets\n(\"This is the sheet name2\")\nSelect\nWorksheets(\n1\n).Select                          Worksheets\n(\"This is the sheet name1\")\nSelect\nNext i                                                  Next i\nEnd Sub", "context": "Selection.SpecialCells(\nxlCellTypeConstants\n).Select\nWorksheets(\n\"This is the sheet name1\"\n).Select\nRange(\"A1\").End(\nxlUp\n)(2).Select\n저처럼 궁금한 것을 못참는 성격이면, 왜 VBA(매크로)좀 하는 사람들이 위와 같은 코드 대신에 아래와 같이 자꾸 약자를 써서 초보들을 골탕먹이려고 하는지 이해 안간다고 하는 생각하는 분들이 있을 수 있습니다.\nSelection.SpecialCells(\n2\n).Select\nWorksheets(\n1\n).Select\nRange(\"A1\").End(\n3\n)(2).Select\n물론 고수들이 좀 잘난체 하려고 하는 것도 일부 있지만 실제로는 윗 코드 보다는 index를 사용하는 아래코드가 더 속도가 빠릅니다. 아래와 같이 약 15 ~ 20% 정도 속도 차이가 납니다.\nindex를 사용한 코드                             이름을 사용한 코..."}
{"instruction": "Excel VBA code for: (970) 실내화와 운동화의 각 합계 구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub sum_Shoes_Sales()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim c As Integer\n'B, C 열을 반복해 넣을 변수\nDim i As Long\n'각 셀의 문자 개수만큼 반복할 변수\nDim strU As String\n'각 셀의 숫자와 + 기호를 합쳐갈 변수\nDim lngSum As Long\n'전체 합을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"B:C\").Delete\n'B:C열 기존 데이터 삭제\nColumns(\"A\").SpecialCells(2).Copy [B1]\n'A열을 문자를 B열에 복사\nColumns(\"B\").SpecialCells(2).\nTextToColumns\n[B1], _\nOther:=True, OtherChar:=\"/\"\n'복사한 B열을 문자 나누기\nColumns(\"B:C\").AutoFit\n'B:C열 열너비 자동맞춤\nFor Each rngC In Columns(\"B\").SpecialCells(2)\n'B열의 각 셀을 순환\nIf InStr(1, rngC, \"운동화\", 0) > 0 Then\n'각 셀에 \"운동화\"가 있으면\nrngC.Next = rngC\n'C열에 B열을 복사\nrngC = vbNullString\n'각 셀값을 삭제\nEnd If\nNext rngC\nFor c = 2 To 3\n'2, 3열을 반복\nFor Each rngC In Columns(c).SpecialCells(2)\n'각 열의 문자셀을 반복\nFor i = 1 To Len(rngC)\n'각 셀의 문자 개수만큼 반복\nIf\nMid\n(rngC, i, 1)\nLike \"[0-9]\"\nThen\n'각 문자가 숫자이면\nstrU = strU & Mid(rngC, i, 1)\n'숫자를 합쳐감\nEnd If\nNext i\nIf strU = \"\" Then\n'(각 셀에 숫자가 있어) strU에 숫자 있으면\nlngSum = lngSum + 1\n'1을 더함\nElse\n'각 셀에 숫자가 있으면\nlngSum = lngSum +\nEvaluate\n(strU)\n'각 숫자를 lngSum에 합쳐감\nEnd If\nstrU = vbNullString\n'(다음 셀에서)재사용 위하여 초기화\nNext rngC\nWith Cells(Rows.Count, c)\n'B, C열 에서\n.End(3)(2) = \"합 : \" & lngSum\n'총 합계를 \"합 :\" 문자와 입력\n.End(3).Interior.ColorIndex = 4\n'총 합계셀을 초록색으로 채움\nEnd With\nlngSum = 0\n'재사용 위하여 lngSum 초기화\nNext c\nEnd Sub", "context": "매크로 실행 전                                  매크로 실행 후 결과\nOption Explicit\nSub sum_Shoes_Sales()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim c As Integer\n'B, C 열을 반복해 넣을 변수\nDim i As Long\n'각 셀의 문자 개수만큼 반복할 변수\nDim strU As String\n'각 셀의 숫자와 + 기호를 합쳐갈 변수\nDim lngSum As Long\n'전체 합을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"B:C\").Delete\n'B:C열 기존 데이터 삭제\nColumns(\"A\").SpecialCells(2).Copy [B1]\n'A열을 문자를 B열에 복사\nColumns(\"B\").SpecialCells(2).\nTextToColumns\n[B1], _\nOther:=True, OtherChar:=\"/\"\n'복사한 B열을 ..."}
{"instruction": "Excel VBA code for: (972) With 사용안한 코드와 사용한 코드의 속도비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub without_With()                                                  Sub with_With()\nDim r As Long                                                        Dim r As Long\nApplication.ScreenUpdating = False                          Application.ScreenUpdating = False\nFor r = 1 To 100000\nWith\nWorksheets(\"Sheet1\").Range(\"A1\")\nWorksheets(\"Sheet1\").Range(\"A1\").Select            For r = 1 To 100000\nWorksheets(\"Sheet1\").Range(\"A2\").Select               .Select\nNext r                                                                      .Next.Select\nNext r                                                                       Next r\nEnd With\nEnd Sub\n\nSub with_With()\nDim r As Long\nApplication.ScreenUpdating = False\nFor r = 1 To 100000\nWith\nWorksheets(\"Sheet1\").Range(\"A1\")\n.Select\n.Next.Select\nEnd With\nNext r\nEnd Sub", "context": "아래의 코드들은 Sheet1의 A1셀과 A2셀을 100,000회 번갈아 가면서 선택하는 코드이다. 왼쪽 코드는 With 구문을 사용하지 않아 25초 정도 소요되지만, With 구문을 사용하여 코드를 줄인 오른쪽의 경우 15초가 소요된다. 아래의 예제와 같이 중복되는 코드가 있을 경우 이를 개별적으로 모두 표기하면 코드의 속도가 떨어지므로, 가능하면 중복되는 부분은 With 구문을 사용하여 간결하게 하여주면 가독성도 올라가고 속도도 더 빨라진다.\nWith를 사용하지 않은 코드                       With를 사용하여 코드를 줄인 코드\n소요시간 :\n25초\n15초\nSub without_With()                                                  Sub with_With()\nDim r As Long                                                        Dim r As Long\nApplica..."}
{"instruction": "Excel VBA code for: (973) 선택적으로 페이지 인쇄하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub print_Selected_Pages()\nDim rngC As Range\n'B3셀 아래 각 셀을 넣을변수\nDim lngPage As Long\n'전체 페이지를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Worksheets(Range(\"B1\"))\n'B1셀과 일치하는 시트\nlngPage = (.\nHPageBreaks\n.\nCount\n+ 1) * (.\nVPageBreaks\n.Count + 1)\n'전체 페이지를 추출\nFor Each rngC In Range(\"B3\", Cells(Rows.Count, \"B\").End(3))\n'B3셀 아래의 각 셀을 순환\nIf rngC <= lngPage Then\n'각 셀이 전체 페이지보다 작다면\nIf\nNot IsEmpty(rngC)\nThen\n'각 셀이 비어 있지 않다면\n.PrintOut from:=varTemp(r), To:=varTemp(r),\npreview:=True\n'인쇄미리보기\n'실제 인쇄하려면 .PrintOut from:=varTemp(r), To:=varTemp(r)로 수정\nEnd If\nEnd If\nNext rngC\nEnd With\nEnd Sub", "context": "항상 그렇듯 제 블로그에 올리는 것은 하나의 예제이며 이의 공부를 통하여 본인의 응용능력을 기르고 궁극적으로 자신에게 맞는 코드를 본인이 직접 만들어 사용하거나, 적어도 아래의 코드를 수정하여 본인의 목적에 맞게 사용하셔야 합니다. 가금 제게 너무 많은 것을 요구하는 분이 계신데 .. 제가 모든 분의 상황을 100% 고려하여 코드를 작성하는 것은 불가능하죠. ^^\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(973) 선택적으로 페이지 인쇄하기 (엑셀 VBA 매크로)\n재생\n1,263\n재생 (space/k)\n재생\n00:47\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:47\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니..."}
{"instruction": "Excel VBA code for: (974) 폴더내 모든 파일의 특정시트만 통합하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_All_Sheets_In_Folder4()\nDim wkBk As Workbook\n'각 파일을 넣을 변수\nDim wkSht As Worksheet\n'각 시트를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim colsCnt As Integer\n'데이터시트 전체 열 개수 넣을 변수\nDim rowsCnt As Long\n'데이터시트 전체 행 개수 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim varTemp\n'각 항목을 넣을 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf\n.SelectedItems.Count = 0\nThen\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nThisWorkbook.ActiveSheet.UsedRange.Offset(1).ClearContents\n'Main 시트의 기존 데이터 삭제\nfileName =\nDir\n(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nSet wkBk = Workbooks.\nOpen\n(strPath & \"\\\" & fileName)\n'파일을 열고 변수에 넣음\nFor Each wkSht In wkBk.Worksheets\n'열린파일 각 시트를 순환\nWith wkSht\nIf .Name = \"\ndata\n\" Then\n'시트이름이 \"data\"이면\nWith ActiveSheet.UsedRange\n'활성화된 시트의 사용영역에서\ncolsCnt = .Columns.Count\n'열 개수를 변수에 넣음\nrowsCnt = .Rows.Count\n'전체 행 개수를 변수에 넣음\nEnd With\nThisWorkbook.ActiveSheet.Cells(Rows.Count, 1).End(3)(2).Resize(rowsCnt, colsCnt) = _\n.UsedRange.Offset(1).Value\n'각 시트 값을 Main 시트에 뿌림\nEnd If\nEnd With\nNext wkSht\nwkBk.\nClose\n'열려진 파일을 닫음\nfileName =\nDir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nColumns.AutoFit\n'열너비 자동맞춤\nEnd Sub", "context": "특정 폴더내에 여러 엑셀 데이터 파일이 존재하고, 파일내에 복수의 시트가 존재할 때, 자신이 원하는 이름을 가진 특정 시트(아래 예제에서는 \"data\"시트)의 데이터만 Main시트에 통합하는 기능. 그러므로 본인의 시트이름이 data가 아닐 경우 아래 코드에서 data라고된 시트명을 본인의 통합하고자 하는 시트명으로 바꾸면 됨. 열 개수는 제한을 받지 않음.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(974) 폴더내 모든 파일의 특정시트만 통합하기 1 (엑셀 VBA 매크로)\n재생\n1,638\n재생 (space/k)\n재생\n00:48\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:48\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0..."}
{"instruction": "Excel VBA code for: (975) 이름정의 추가 기본코드 (엑셀 VBA 매크로)", "input": "", "output": "Sub add_Names()\nRange(\"A1:A10\").\nName\n= \"ColumnA\"\n'이름정의 추가\nRange(\"ColumnA\").Select\nNames.\nAdd\nName:=\"ColumnB\",\nRefersTo\n:=Range(\"B1:B10\")\nRange(\"ColumnB\").Select\n'영역을 이용 이름 추가\nNames.Add Name:=\"ColumnC\", RefersTo:=\"=$C$1:$C$10\"\nRange(\"ColumnC\").Select\nNames.Add Name:=\"ColumnD\", RefersTo:=\"=\" & Range(\"D1:D10\").\nAddress\nRange(\"ColumnD\").Select\n'주소를 이용 이름추가\nNames.Add Name:=\"NameR1C1_1\",\nRefersToR1C1\n:=\"=RC5:R10C5\"\nRange(\"NameR1C1_1\").Select\n'R1C1주소 이용한 이름추가\nDim strAddr As String\nstrAddr = Range(\"F1:G10\").\nAddress(, , xlR1C1)\nNames.Add Name:=\"NameR1C1_2\", RefersToR1C1:=\"=\" & strAddr\nRange(\"NameR1C1_2\").Select\nRange(\"G1:G10\").Name = \"Sheet1!Data\"\n'시트의 위치 지정하여 이름 추가\nRange(\"Data\").Select\nNames(\"Data\").Name = \"ChangedName\"\n'기존의 이름정의 다른 이름으로 바꾸기\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(975) 이름정의 추가 기본코드 (엑셀 VBA 매크로)\n재생\n1,269\n재생 (space/k)\n재생\n00:42\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:42\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n이름정의 추가하는 다양한 방법을 미리 아래와 같이 정리해둔다. 매크로창에서 F8 키를 이용하여 단계별 실행 시 선택된 영역을 표시하기 위해 행마다 영역을 선택하는 코드를..."}
{"instruction": "Excel VBA code for: (977) 폴더내 모든 그림파일 행열로 삽입 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Pictures_Column_Row_1()\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nConst\n열시작 As Integer =\n2\n'첫 그림이 들어갈 열의 위치 넣을 변수\nConst colSkip As Integer =\n2\n'(열방향)그림 사이 건너뛸 열의 개수\nConst 열개수 As Integer =\n3\n'그림의 전체 열개수 넣을 변수\nDim 행시작 As Long\n'첫 그림이 들어갈 행의 위치 넣을 변수\nConst rowSkip As Long =\n2\n'(행방향) 그림 사이 건너뛸 행의 개수\nDim cnt As Integer\n'열의 개수 변경에 사용할 카운터 넣을 변수\nDim cntC As Integer\n'열방향 위치 넣을 변수\nDim C As Range\n'각 그림들어갈 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n행시작 =\n2\n'첫 그림이 들어갈 행의 위치\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf\n.SelectedItems.Count = 0\nThen\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nActiveSheet.\nPictures.Delete\n'기존 사진들 삭제\nfileName =\nDir\n(strPath)\n'(폴더내)각 그림파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nActiveSheet.\nPictures.Insert\n(strPath & fileName).Select\n'각 그림파일 삽입\nWith Selection\n'선택된 그림파일\n.Name = \"Temp#\"\n'(임시로) 이름을 \"Temp\"로 지정\n.ShapeRange.\nLockAspectRatio\n= msoFalse\n'그림의 가로/세로크기 고정 해제\nSet C = Cells(행시작, 열시작 + cntC)\n'그림이 들어갈 셀을 변수에 넣음\nIf C.\nMergeCells\nThen\n'만약 셀병합 셀이면\nSet C = C.\nMergeArea\n'셀병합 셀을 C에 넣음\nEnd If\n​\n.Height = C.Height - 4\n'그림의 가로크기 지정\n.Width = C.Width - 4\n'그림의 세로크기 지정\n.Copy\n'그림을 복사\nActiveSheet.\nPasteSpecial\nFormat:=\"Picture (JPEG)\",\nLink:=False\n'그림 링크깨고 붙여넣기\nActiveSheet.Pictures(\"Temp#\").Delete\n'원본 그림파일 삭제\nEnd With\nWith Selection\n'(복사되어)선택된 그림파일\n.Left = C.Left + 2\n'그림의 왼쪽위치 지정\n.Top = C.Top + 2\n'그림의 윗쪽위치 지정\nEnd With\ncnt = cnt + 1\n'카운트를 1씩 늘려감\ncntC = cntC + colSkip + 1\n'그림의 열방향 위치 늘려감\nIf cnt = 열개수 Then\n'카운터가 열개수에 도달하면\ncnt = 0\n'(재사용 위하여)카운터 초기화\ncntC = 0\n'(재사용 위하여)열위치 초기화\n행시작 = 행시작 + rowSkip + 1\n'행 위치 늘려감\nEnd If\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nApplication.\nCommandBars\n.\nExecuteMso\n\"PicturesCompress\"\n'사진 압축창 출력\nMsgBox \"매크로가 종료 되었습니다.\"\n'매크로 종료창 출력\nEnd Sub", "context": "매크로 실행 시 폴더선택 창이 나타나며, 그림파일 저장된 폴더 선택 시 모든 그림을 가져옴\n그림을 셀의 크기에 맞추어 가져오므로 그림 크기를 키우려면 셀의 크기를 키우면 됨\n그림은 아래 각 그림 옆에 번호 매겨진 순서대로 가져옴\n그림은 링크를 깨고 복사해 삽입하므로 엑셀 파일내에\n영구삽입\n됨\n그림 크기는 각 셀의 크기에 맞추어 넣으므로 확대 시 해상도가 떨어짐. 해상도 높여 저장하려면 셀크기 키우거나 코드 일부수정 필요.\n본인이 저장하고자 하는 위치에 따라 주황색으로 표시된 숫자를 조정하면 됨\n1열로 그림을 넣으려면\nConst 열개수 As Integer =\n1\n이라고 아래코드 수정하면 됨\n1행으로 그림을 넣으려면\nConst 열개수 As Integer =\n10000\n(또는 폴더내 그림파일의 개수) 이라고 아래코드 수정하면 됨\n동영상에는 나타나지 않지만\n셀병합 셀에도 적용\n되도록 코드를 동영상 작업 이후에 수정함.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nau..."}
{"instruction": "Excel VBA code for: (979) 폴더내 그림파일과 일치 시 사진(그림) 영구삽입 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Pictures_Matching_Name()\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim C As Range\n'검색에 일치한 셀을 넣을 변수\nDim strName As String\n'파일 확장자 제외한 이름을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf\n.SelectedItems.Count = 0\nThen\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nActiveSheet.Pictures.Delete\n'기존 사진들 삭제\nfileName =\nDir\n(strPath)\n'(폴더내)각 그림파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nstrName =\nSplit\n(fileName, \".\")\n(0)\n'파일 확장자 제거한 이름 추출\nSet C = ActiveSheet.UsedRange.\nFind\n(strName, , ,\nxlWhole\n)\n'그림파일과 일치하는 셀을 찾음\nIf Not C Is Nothing Then\n'그림파일과 동일한 이름이 셀에 존재하면\nActiveSheet.\nPictures.Insert\n(strPath & fileName).Select\n'각 그림파일 삽입\nSet C = C.Next.\nMergeArea\n'셀병합 셀을 C에 넣음\nWith Selection\n'선택된 그림파일\n.Name = \"Temp\"\n'복사된 사진의 이름을 변경\n.ShapeRange.LockAspectRatio = msoFalse\n'그림의 가로/세로비율 고정 해제\n.Height = C.Height - 4\n'그림의 가로크기 지정\n.Width = C.Width - 4\n'그림의 세로크기 지정\n.Copy\n'그림을 복사\nActiveSheet.PasteSpecial\nLink:=False\n'그림 링크깨고 붙여넣기\nActiveSheet.Pictures(\"Temp\").Delete\n'원본 그림파일 삭제\nEnd With\nWith Selection\n'(복사되어)선택된 그림파일\n.Left = C.Left + 2\n'그림의 왼쪽위치 지정\n.Top = C.Top + 2\n'그림의 윗쪽위치 지정\nEnd With\nEnd If\nfileName =\nDir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nEnd Sub", "context": "폴더내 그림파일과 이름이 일치하는 셀의 오른편 위치에 그림을\n링크아닌 영구\n삽입\n하는 기능.\n매크로 실행 전\n매크로 실행 후 그립이 삽입된 결과\n사진 삽입 속도를 올리려면 Set C = ActiveSheet.UsedRange.Find(strName, , , xlWhole) 라고 되어 있는 코드를 Set C = ActiveSheet.\"본인시트이름영역\".Find(strName, , , xlWhole) 이라고 하면 된다. 즉, 그림파일 이름이 A열에 있을 경우 Set C = ActiveSheet.Columns(\"A\").SpecialCells(2).Find(strName, , , xlWhole) 라고 하면 된다. 아래코드는 속도는 늦지만 모든 사람에게 적용되도록 하기 위해 ActiveSheet.UsedRange 즉, 현재시트 전체셀을 검색하도록 하였다.\n동영상에는 나타나지 않지만\n셀병합 셀에도 적용\n되도록 코드를 동영상 작업 이후에 수정함. ActiveSheet.Pictures.Delete..."}
{"instruction": "Excel VBA code for: (980) Application.Dialogs(xlDialogOpen).Show 의 뜻 (엑셀 VBA 매크로)", "input": "", "output": "MsgBox Application.Dialogs.Count 를 즉석창에서 실행 시 본인의 전체 Dialogs 개수가 출력됨.", "context": "Application\n.Dialogs(xlDialogOpen).Show : VBA는 Visual Basic for Applications 의 약자이며, 여기에서 Applications는 MS사의 Word, Excel, PowerPoint, Access, Outlook 등의 프로그램을 뜻한다. 그러므로, 엑셀 VBA에서의 application 은 엑셀 object model의 최상위인\n엑셀 프로그램 자체\n를 나타낸다\nApplication.\nDialogs\n(xlDialogOpen).Show : 영어에서 di 가 들어가면 둘(2) 이라는 뜻이며 log가 들어가면 말, 언어란 뜻이다. 그러므로 Dialog는 둘이 하는 말 즉 대화라는 뜻이며\n엑셀에서는 대화창을 의미\n한다. 프로그래밍 초기에는 사용자가 컴퓨터에 일방적으로 명령을 내렸고 컴퓨터는 이에 따랐다. 하지만 최근 소프트웨어들은 프로그래밍의 발전과 함께 사용자가 명령을 내리면 소프트웨어가 답변을 하는 인터액티브한 양방향 대화형식이 대부..."}
{"instruction": "Excel VBA code for: (981) 3회 미만 중복데이터 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Less_Than_Three()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 5) = Cells(r + 1, 5) Then\n'E열 각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nIf i <= 2 Then\n'중복 개수가 3개 미만이면\nCells(r - i, 1).Resize(i + 1).EntireRow.\nClearContents\n'전체행의 데이터 삭제\nEnd If\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 2) =\nvbNullString\n'B열에 빈셀 나올때까지 무한 반복\nActiveSheet.UsedRange.Offset(1).\nSort\nRange(\"E2\"), 1\n'카드번호 기준 오름차순 정렬\nEnd Sub", "context": "E열의 카드번호가 3회 미만 중복 시 이를 삭제하는 기능. 즉, 3회 이상 중복되는 데이터만 남겨둠.\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub delete_Less_Than_Three()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 5) = Cells(r + 1, 5) Then\n'E열 각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nIf i <= 2 Then\n'중복 개수가 3개 미만이면\nCells(r - i, 1).Resize(i + 1).EntireRow.\nClearContents\n'전체행의 데이터 삭제\nEnd If\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = ..."}
{"instruction": "Excel VBA code for: (982) 폴더내 일별 데이터파일 통합하여 월합계 구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub consolidate_Daily_Data()\nDim wkBk As\nWorkbook\n'통합파일을 넣을 변수\nDim wkBkData As Workbook\n'각 일별 데이터 파일 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet wkBk = ActiveWorkbook\n'통합파일을 변수에 넣음\nApplication.ScreenUpdating = False\n화면 업데이트 (일시) 정지\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf\n.SelectedItems.Count = 0\nThen\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName = Dir(strPath)\n'(폴더내)각 일별 데이터 파일을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nSet wkBkData =\nWorkbooks.Open\n(strPath & \"\\\" & fileName)\n'폴더내 각 파일을 열기\nWith wkBk.Worksheets(2)\n'통합파일 \"Temp\"시트에서\n.Range(.[A8], .[D13]) = Range(\"D3\", \"G8\").Value\n'일별 데이터를 복사\nActiveWorkbook.\nClose False\n'일별 데이터 파일 저장하지 않고 닫음\n[D3].\nConsolidate\nSources:=\nArray\n(.Range(.[A1], .[D6]).\nAddress\n(1, 1, xlR1C1, 1), _\n.Range(.[A8], .[D13]).Address(1, 1, xlR1C1, 1)), Function:=\nxlSum\n'통합기능을 이용하여 일별데이터 합계를 구함\nEnd With\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nEnd Sub\n\nSub delete_Data()\nRange(\"D3:G8\").ClearContents\n'기존 데이터 삭제\nWorksheets(2).UsedRange.Offset(7).ClearContents\n'기존 데이터 삭제\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(982) 폴더내 일별 데이터파일 통합하여 월합계 구하기 (엑셀 VBA 매크로)\n재생\n1,208\n공유하기\n재생 (space/k)\n재생\n00:43\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:43\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n통합할 파일을 보여준다.\n일자별 데이터가 저장된 폴더내의 파일 3개를 보여준다.\n모든 일별데이터 파일을 열어서 ..."}
{"instruction": "Excel VBA code for: (983) .Copy 와 .Value의 복사 속도비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub with_Copy()                                       Sub with_Value()\nDim r As Long                                           Dim r As Long\nApplication.ScreenUpdating = False             Application.ScreenUpdating = False\nFor r = 1 To 10000                                      For r = 1 To 10000\nCells(r, 1).\nCopy\nCells(r, 3)                             Cells(r, 3) = Cells(r, 1)\n.Value\nNext r                                                       Next r\nEnd Sub", "context": "﻿\nVBA(매크로)에서 셀의 내용을 복사할 때 셀의 서식/수식 및 값을 모두 복사하는 .Copy와 단지 값만을 복사하는 .Value의 두 가지 방법이 있다.\n.Copy는\n속도가 느리지만 모든 셀의 서식이 함께 복사되며, .Value는 결과 값만을 복사하므로 속도가 빠르지만 셀의 서식이 복사되지 않는다.\n그러므로, 데이터 복사를 할 때 필요에 따라 사용자가 어떤 방식을 사용할지 선택을 해야한다.\n.Copy를 이용한\n셀\n의 복사                       .Value를 이용한\n값\n의 복사\n.Copy를 사용한 코드                             .Value를 사용한 코드\n소요시간 :\n90초\n0.7초\nSub with_Copy()                                       Sub with_Value()\nDim r As Long                                           Dim r As Long\nAppli..."}
{"instruction": "Excel VBA code for: (985) 조건부서식으로 중복(또는 유일한) 값을 표시하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Dupes_FormatConditions()\nDim rngAll As Range\n'전체 사용영역을 넣을 변수\nDim uniVal As\nUniqueValues\n'유일한 값 조건을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet uniVal = Selection.\nFormatConditions.AddUniqueValues\n'전체영역 조건부서식 유일한 값 조건을 변수에 넣음\nuniVal.DupeUnique =\nxlDuplicate\n'유일한 값 중복여부를 중복값으로 설정\nuniVal.Interior.Color = vbRed\n'중복되는 값을 가진 셀의 조건부서식을 적색으로 채움\nEnd Sub\n\nSub delete_Dupe_Color()\nSelection.\nFormatConditions.Delete\n'기존 조건부서식 삭제\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(985) 조건부서식으로 중복(또는 유일한) 값을 표시하기 (엑셀 VBA 매크로)\n재생\n1,346\n공유하기\n재생 (space/k)\n재생\n00:35\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:35\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n영역을 선택하고 매크로 실행.\n중복된\n값이 적색으로 표시\n됨.\n영역을 바꿔가면서 동일한 작업을 수행.\n매크로 ..."}
{"instruction": "Excel VBA code for: (986) 행높이 열너비 일치시키기 (엑셀 VBA 매크로)", "input": "", "output": "Sub match_RowHeight_ColumnWidth()\nDim wkBk1 As Workbook\n'매크로 실행전 활성화된 파일 넣을 변수\nDim rngC As Range\n'사용영역 1열의 각 셀을 넣을 변수\nDim r As Long\n'배열값을 1씩 늘려갈 변수\nDim varTemp()\n'각 행의 높이를 넣을 동적 배열변수\nDim rngSel As Range\n'입력창에서 선택한 영역을 넣을 변수\nDim fileName As String\n'복사될 타겟 파일의 파일이름을 넣을 변수\nDim shtName As String\n'복사될 타겟 파일의 시트이름을 넣을 변수\nDim strAddr As String\n'복사될 타겟 파일의 선택된셀 주소를 넣을 변수\nSet wkBk1 = ActiveWorkbook\n'활성화된 셀을 변수에 넣음\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\nFor Each rngC In .Resize(, 1)\n'1열의 각셀을 순환\nr = r + 1\n'행을 1씩 늘려감\nReDim Preserve\nvarTemp(1 To r)\n'배열크기 재지정\nvarTemp(r) = rngC.RowHeight\n'각 셀의 행 높이를 배열에 넣음\nNext rngC\nOn Error Resume Next\n'에러 발생해도 다음코드 진행\nSet rngSel =\nApplication.InputBox\n(\"복사될 시트 선택\", \"시트선택\",\nType:=8\n)\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nfileName = rngSel.\nParent.Parent.Name\n'선택된 셀이 속한 파일이름을 변수에 넣음\nshtName = rngSel.\nParent.Name\n'선택된 셀이 속한 시트이름을 변수에 넣음\nstrAddr = .Cells(1).\nAddress\n'첫 번째 셀의 주소를 변수에 넣음\n.Resize(1).Copy\n'첫 행을 복사\nEnd With\nWorkbooks(fileName).Activate\n'복사될 타겟 파일 활성화\nWorksheets(shtName).Activate\n'복사될 타겟 시트 활성화\nRange(strAddr).Activate\n'복사될 시트 활성화\nActiveSheet.\nPasteSpecial\nxlPasteColumnWidths\n'열 너비를 복사\nr = 0\n'재사용 위하여 0으로 초기화\nFor Each rngC In Range(strAddr).Resize(\nUBound\n(varTemp))\n'복사될 시트의 1열 각셀을 순환\nr = r + 1\n'배열값을 1씩 늘려감\nrngC.\nRowHeight\n= varTemp(r)\n'각 셀의 행 높이를 배열에 있는 값으로 바꿈\nNext rngC\nApplication.CutCopyMode = False\n'복사모드 해제 (클립보드 비우기)\nSet wkBk1 = Nothing\n'개체변수들 초기화 (메모리 비우기)\nSet rngSel = Nothing\nEnd Sub", "context": "많은 엑셀 작업을 하다 보면 서로 같은 행높이, 열너비를 유지해야 하는 시트들이 있지만 작업중 여러가지 이유로 행높이/열너비가 일부 변동된다. 이럴 때 이를 일치시켜주는 기능. 당연히 동일한 양식을 가지고 있지만 행높이/열너비만 다른 시트에서 아래의 매크로를 사용하여야 한다. 양식이 서로 다를 경우 셀병합이 되어 있지 않으면 상관 없지만 셀병합이 되어 있는 경우 에러가 발생할 수 있다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(986) 행높이 열너비 일치시키기 (엑셀 VBA 매크로)\n재생\n3,157\n재생 (space/k)\n재생\n00:28\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:28\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1...."}
{"instruction": "Excel VBA code for: (987) Union method의 For구문 단일사용 및 중첩사용의 속도비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub single_For()                                              Sub nesting_For()\nDim tmr As Single                                             Dim tmr As Single\nDim rngU As Range                                          Dim rngU As Range\nDim i As Long\nApplication.ScreenUpdating = False                   Application.ScreenUpdating = False\nFor\ni =\n1 To 100\nFor\nr =\n1 To 10000 Step 2\nFor\nr =\n(i - 1) * 100 + 1 To 100 * i Step 2\nIf rngU Is Nothing Then                                          If rngU Is Nothing Then\nSet rngU = Cells(r, 1)                                             Set rngU = Cells(r, 1)\nElse                                                                    Else\nSet rngU =\nUnion\n(rngU, Cells(r, 1))                          Set rngU =\nUnion\n(rngU, Cells(r, 1))\nEnd If                                                                  End If\nNext r\nNext r\nrngU.RowHeight = 30                                           rngU.RowHeight = 30\nSet rngU = Nothing\nNext i\nEnd Sub", "context": "아래의 두 매크로는 1행씩 건너 뛰며 반복하여 10,000행까지 행의 높이를 30으로 설정하는 기능이다.\nUnion\nmethod를 사용할 때 2,000 ~ 3,000행 까지는 속도가 빠르지만 만행을 넘어가면 너무 버벅대서 한 동안 Union method를 사용하지 않았다. 그런데 아래와 같이 For 구문을 중첩하여 사용하니 이문제가 해결되었다. 왼쪽 코드는 For 구문을 1회 사용하여 10,000행의 행높이를 한 번에 설정하며, 오른쪽 코드는 For구문의 중첩사용으로 100행씩 나누어 100번 작업한다. 왼쪽은 한 번에 많은 메모리를 필요로 하여 시간이 오래 걸리지만 오른쪽은 100번에 나누어 하므로 상대적으로 왼쪽 코드에 비하여 적은 메모리를 사용하므로 속도가 훨씬 빠르다.\n이와 같이 동일한 결과여도 어떤 코드로 어떻게 접근하느냐에 따라서 엄청난 시간차이가 발생한다. 필요 시 가능하면 모든 영역을 한 번에 작업하지 않고 본인의 메모리와 컴퓨터 성능에 따라서 분할 하여 작업하는 것도..."}
{"instruction": "Excel VBA code for: (988) 행을 필터하여 선택적으로 보이기 (엑셀 VBA 매크로)", "input": "", "output": "Sub show_Preferred_Rows()\nDim input_Value As String\n'입력값을 넣을 변수\nDim msg As String\n'메시지 넣을 문자 변수\nConst\nintMin As Integer = 1\n'최솟값을 넣을 변수\nConst intMax As Integer = 100\n'최댓값을 넣을 변수\nDim i As Long\n'행 반복에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nDo\n'다음을 실행\ninput_Value =\nInputBox\n(intMin & \" 과 \" & intMax & \" 사이의 숫자를 입력.\")\n'입력창 값을 변수에 넣음\nIf input_Value = \"\" Then Exit Sub\n'입력값 없으면 매크로 중단\nIf\nIsNumeric\n(input_Value) Then\n'입력값이 숫자이면\nIf input_Value >= intMin And input_Value <= intMax Then\n'입력값이 최솟값보다 크거나 같고, 최댓값보다 작거나 같으면\nExit Do\n'Do 구문 탈출\nEnd If\nEnd If\nmsg = \"번호입력 오류.\" & vbCr\n& vbCr\n'메시지창 내용 + 줄바꿈 2번\nmsg = msg & intMin & \" 과 \" & intMax & \" 사이의 숫자를 입력.\"\n'메시지창 내용\nMsgBox msg, 64, \"입력오류\"\n'메시지창 출력\nLoop\n'무한 반복\nFor i = 1 To Cells(Rows.Count, 2).End(3).Row\n'1에서 마지막 B열 행까지 반복\nIf Cells(i, 1).Row\nMod\ninput_Value = 1 Then\n'만약 입력값으로 나눈 나머지가 1이면\nCells(i, 1).\nEntireRow.Hidden\n=\nFalse\n'전체행을 보여주기\nElse\n'나머지가 1이 아닐경우\nCells(i, 1).EntireRow.Hidden = True\n'전체행을 숨기기\nEnd If\nNext i\nEnd Sub\n\nSub show_All_Rows()\nCells.EntireRow\n.Hidden = False\n'전체 시트의 행 숨기기 취소\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(988) 행을 필터하여 선택적으로 보이기 (엑셀 VBA 매크로)\n재생\n1,416\n재생 (space/k)\n재생\n00:34\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:34\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n전체 데이터를 보여준다.\n매크로 실행하면 입력창이 나타남.\n잘못된 숫자를 입력시 나타나는 메시지 창\n입력범위(1~100)를 벗어나면 나..."}
{"instruction": "Excel VBA code for: (989) 빠진 제목 채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub complete_9_Items()\nDim rngA As Range\n'각 area를 넣을 변수\nDim r As Long\n'반복구문에 사용할 변수\nDim rngT As Range\n'복사될 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'사용영역의 데이터를 삭제\nFor Each rngA In Columns(\"A\").SpecialCells(2).\nAreas\n'A열 각 area를 순환\nIf rngA.Count = 9 Then\n'각 area가 9개의 셀이면\n.Cells(Rows.Count, \"A\").\nEnd(3)(3).\nResize(9, 2) _\n= rngA.Resize(, 2).Value\n'각 area를 Sheet2에 복사\nElse\n'각 area에 빠진 행이 있다면\nSet rngT = Sheets(2).Cells(Rows.Count, \"A\").End(3)(3)\n'Sheet2의 복사될 위치를 변수에 넣음\nFor r = 1 To rngA.Count\n'각 area의 셀 개수만큼 반복\nWith rngA.Cells(r).Resize(, 2)\n'각 area의 각 셀 + 우측셀\nSelect Case\nrngA.Cells(r)\n'각 area의 각 셀값\nCase \"가\": rngT.Resize(, 2) = .Value\nCase \"나\": rngT.Offset(1).Resize(, 2) = .Value\nCase \"다\": rngT.Offset(2).Resize(, 2) = .Value\nCase \"라\": rngT.Offset(3).Resize(, 2) = .Value\nCase \"마\": rngT.Offset(4).Resize(, 2) = .Value\nCase \"바\": rngT.Offset(5).Resize(, 2) = .Value\nCase \"사\": rngT.Offset(6).Resize(, 2) = .Value\nCase \"아\": rngT.Offset(7).Resize(, 2) = .Value\nCase \"자\": rngT.Offset(8).Resize(, 2) = .Value\nEnd Select\nEnd With\nNext r\nrngT.Resize(9) = Application.\nTranspose\n(\nArray\n(\"가\", \"나\", \"다\", \"라\", _\n\"마\", \"바\", \"사\", \"아\", \"자\"))\n'각 area 제목 복사\nEnd If\nNext rngA\n.Rows(\"1:2\").Delete\n'Sheet2의 빈행 삭제\nEnd With\nSet rngT = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(989) 빠진 제목 채우기 (엑셀 VBA 매크로)\n재생\n273\n재생 (space/k)\n재생\n00:30\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:30\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n가나다라마바사아자 제목이 모두 있는 area를 보여준다.\n\"나다\"가 빠지고 \"가라마바사아자\"만 있는 area\n\"아자\"가 빠지고 \"가나다라마바사\"만 있는 ..."}
{"instruction": "Excel VBA code for: (990) 행삽입 삭제 기본 코드 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub fastest_Rows_Delete()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim intNo As Long\n'100번씩 몇 번 반복할지를 결정할 변수\nDim r As Long\n'각 행을 넣을 변수\nDim i As Long\n'100회 반복할 변수\nDim rngU As Range\n'(조건에 만족하는) 영역을 합쳐갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트(일시)정지\nlastRow = Cells(Rows.Count, \"A\").End(3).Row\n'마지막 행을 변수에 넣음\nintNo = lastRow \\ 100 + 1\n'전체행을 100으로 나눈 몫 + 1 을 i에넣음\nFor i = intNo To 1 Step -1\n'100부터 1씩 줄여가며 반복\nFor r = i * 100 To (i - 1) * 100 + 1 Step -1\n'100행씩 행을 1씩 줄여가며 반복\nIf Cells(r, \"A\") <> 1 Then\n'만약 셀값이 비어 있으면\nIf rngU Is Nothing Then\n'(영역을 합칠) rngU가 비어 있다면\nSet rngU = Cells(r, \"A\")\n'rngU에 첫 값을 넣고\nElse\n'(첫 값을 넣어서)rngU가 비어 있지 않다면\nSet rngU = Union(rngU, Cells(r, \"A\"))\n'조건을 만족하는 영역을 계속 합쳐간다\nEnd If\nEnd If\nNext r\nIf Not rngU Is Nothing Then\n'rngU가 비어 있지 않다면\nrngU.EntireRow.Delete\n'rngU영역의 전체행을 삭제\nEnd If\nSet rngU = Nothing\n'(재사용 위하여) rngU 초기화\nNext i\nEnd Sub", "context": "많은 행삽입 삭제를 해야할 경우 배열에 넣었다 셀에 다시 뿌리지 못하는 경우 전체행과 열을 실제 삭제/삽입해야 하므로 시간이 너무 오래 걸렸는데 아래의 코드로 이를 해결할 수 있다. 다음에 사용하기 위하여 기본코드에 정리해 놓음.\n아래의 코드는 10,000행의 데이터에서 A열에 빈셀이 있는\n행을 실제로\n삭제\n(결과적으로 5,000행 삭제)하며\n2.2초 정도 소요\n. 100,000행의 경우 1분 25초 정도 소요. 책에서마저 가장 빠르다는 방법인 \"고급필터로 보이는 셀 선택후 삭제하는 코드\"도 아래 코드보다 2배 이상 느리다. 배열에 넣지 못하고 전체행 또는 열을 삭제해야만 할 경우 사용할 애용할 예정. 아래 예제에서는 행삭제의 예제만 올렸지만 행삽입도 마찬가지임.\nfastest_Rows_Delete 매크로 실행 전                매크로 실행 후 결과\nOption Explicit\nSub fastest_Rows_Delete()\nDim lastRow As Long\n'마지막 행..."}
{"instruction": "Excel VBA code for: (991) 폴더내 모든 텍스트파일 별도시트로 통합하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_All_TextFiles_In_Folder()\nDim wkBk As Workbook\n'매크로 실행하는 파일 넣을 변수\nDim wkBk2 As Workbook\n'폴더내 각 파일을 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim s As Integer\n' 각 시트를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor s = Sheets.Count To 2 Step -1\n'Data시트 제외한 전체시트 순환\nApplication.DisplayAlerts\n= False\n'화면 경고기능 중지\nSheets(s).Delete\n'각 시트 삭제\nApplication.DisplayAlerts = True\n'화면 경고기능 복원\nNext s\nSet wkBk = ActiveWorkbook\n'현재 활성화된 파일을 변수에 넣음\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf\n.SelectedItems.Count = 0\nThen\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName =\nDir\n(strPath)\n'(폴더내)각 파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nSet wkBk2 = Workbooks.Open(strPath & fileName)\n'각 파일을 열고 변수에 넣음\nActiveSheet.\nCopy\nafter\n:=wkBk.Sheets(Sheets.Count)\n'시트를 wkBk파일 제일뒤에 복사\nwkBk2.Close False\n'각 열은 파일을 저장하지 않고 닫음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nCall\nsorting_Sheets\n'시트를 오름차순 정렬하는 코드 호출\nEnd Sub\n\nSub sorting_Sheets()\nDim i As Integer\n'반복구문에 사용할 변수\nDim j As Integer\n'반복구문에 사용할 변수\nDim intCnt As Integer\n'전체 시트의 개수를 넣을 변수\nintCnt = Sheets.Count\n'전체 sheets 개수를 변수 intCnt에 넣음\nFor i = 1 To intCnt\n'전체 시트 개수만큼 반복\nFor j = i To intCnt\n'i 부터 전체 시트 개수만큼 반복\nIf\nUCase\n(Sheets(j).Name) < UCase(Sheets(i).Name) Then\n'두 sheet의 이름을 대문자로 변경후 비교하여\nSheets(j).Move Before:=Sheets(i)\n'정렬 우선순위가 있는 sheet를 앞으로 이동하고 이를 반복\nEnd If\nNext j\nNext i\nWith Sheets(\"Main\")\n'Main 시트에서\n.Move Before:=Sheets(1)\n'Main 시트를 제일 앞으로 가져옴\n.Activate\n'Main 시트를 활성화\nEnd With\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(991) 폴더내 모든 텍스트파일 별도시트로 통합하기 (엑셀 VBA 매크로)\n재생\n946\n재생 (space/k)\n재생\n00:25\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:25\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 설명 (순서대로) :\n특정 폴더내에 예제로 만든 3개의\n텍스트\n파일\n들이 있음\n(매크로 실행후\nMain 시트를 제외한 모든 시트 삭제\n하므로\n주..."}
{"instruction": "Excel VBA code for: (992) 셀값으로 양식시트 이름 바꾸며 엑셀2003(.xls)으로 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub create_FileCopy_Per_Name()\nDim rngSel As Range\n'입력창에서 선택한 영역을 넣을 변수\nDim rngC As Range\nOn Error Resume Next\n'에러 발생해도 다음코드 진행\nSet rngSel = Application.\nInputBox\n(\"양식시트를 선택하시오.\", \"시트선택\", Type:=8)\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'A열 각 학교이름 셀을 순환\nWith Workbooks(rngSel.\nParent.Parent.Name\n)\n'입력창에서 선택한 파일\nWith .Sheets(1)\n'1번 시트에서\n.Range(\"B2\") = rngC\n'B2셀에 학교명을 넣음\n.Range(\"B5\") = \"2100년 7월 7일 09시\"\n'B5셀에 일시를 넣음\n.Range(\"B6\") = rngC.Next\n'B6셀에 주소를 넣음\n.Columns(\"B\").\nAutoFit\n'B열 열너비 자동맞춤\nEnd With\nApplication.DisplayAlerts = False\n'화면 경고 중지\n.\nSaveAs\nThisWorkbook\n.Path\n& \"\\\" & rngC & \".xls\",\nFileFormat:=xlExcel8\n'각 파일을 2003형식(xls)으로 복사\nApplication.DisplayAlerts = True\n'화면 경고 복원\nEnd With\nNext rngC\nSet rngSel = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(992) 셀값으로 양식시트 이름 바꾸며 엑셀2003(.xls)으로 복사하기 (엑셀 VBA 매크로)\n재생\n1,149\n재생 (space/k)\n재생\n00:35\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:35\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n폴더내에 매크로 파일과 양식파일이 있음\n두 파일을 열기\n파일 편집 및 매크로 실행이 가능하도록 설정\n..."}
{"instruction": "Excel VBA code for: (993) 각 과목에 O 표시된 셀데이터만 Sheet2에 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub filtered_Copy()\nDim c As Integer\n'선택셀의 열 위치 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngAll As Range\n'선택셀의 전체 열을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nc = ActiveCell.\nColumn\n'선택셀의 열을 변수에 넣음\nSet rngAll = Range(Cells(2, c), Cells(Rows.Count, c).End(3))\n'선택셀의 전체열을 변수에 넣음\nWith Worksheets(2)\n'Sheet2에서\n.Range(\"A1\") = Cells(1, c)\n'A1셀에 선택과목 입력\nRange(\"A1\").Resize(, 9).Copy .Range(\"A2\")\n'Sheet2에 제목 복사\n.UsedRange.Offset(2).\nClearContents\n'Sheet2의 기존 데이터 삭제\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nIf\nNot IsEmpty\n(rngC) Then\n'각 셀이 빈셀이 아니라면\n.Cells(Rows.Count, \"A\").End(3)(2).Resize(, 5) = _\nCells(rngC.Row, 1).Resize(, 5).Value\n'Sheet2의 종단셀 윗방향 바로아래에 O표시 행의 5열을 복사\nEnd If\nNext rngC\n.Columns.\nAutoFit\n'Sheet2의 열너비 자동맞춤\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "각 과목에 O 표시된 데이터만 Sheet2로 옮기는 기능.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(993) 각 과목에 O 표시된 셀데이터만 Sheet2에 복사하기 (엑셀 VBA 매크로)\n재생\n1,146\n재생 (space/k)\n재생\n00:28\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:28\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n데이터가 옮겨질 Sheet2는 비어 있는 상태\nShe..."}
{"instruction": "Excel VBA code for: (995) 각 중복 그룹별 최소값 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Smallest_In_Group()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngA As Range\n'각 중복영역을 넣을 변수\nDim sngMin As Single\n'각 그룹의 최소값을 넣을 변수\nDim C As Range\n'최소값이 있는 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 1\n'1행 부터 시작\nDo\n'다음을 실행\nIf Cells(r, 2) = Cells(r + 1, 2) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nIf i <> 0 Then\nSet rngA = Cells(r - i, 1).Resize(i + 1)\n'각 중복영역을 변수에 넣음\nsngMin =\nWorksheetFunction.Small\n(rngA, 1)\n'각 중복영역의 최소값을 변수에 넣음\nSet C = rngA.\nFind\n(sngMin, , ,\nxlWhole\n)\n'최소값이 있는 셀을 찾아 변수에 넣음\nC.Resize(, 2).ClearContents\n'최소값의 행을 삭제\nEnd If\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\nSet rngA = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(995) 각 중복 그룹별 최소값 삭제하기 (엑셀 VBA 매크로)\n재생\n199\n재생 (space/k)\n재생\n00:27\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:27\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n(삭제될 각 그룹별 최소값이 있는 셀은 알아보기 쉽도록 색으로 표시함)\n각 중복 그룹별 영역을 확인\n매크로 실행 후 각 중복 그룹별 최소값..."}
{"instruction": "Excel VBA code for: (998) 파일을 열지 않고 폴더속 모든파일의 특정셀위치 합계내기 (엑셀 VBA 매크로)", "input": "", "output": "Sub get_From_Closed_Files()\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim strAddr As String\n'각 파일의 데이터 주소 넣을 변수\nDim varTemp()\n'각 시트의 값을 넣을 동적 배열변수\nDim r As Long\n'배열크기 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf\n.SelectedItems.Count = 0\nThen\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName = Dir(strPath & \"*.xls*\")            '\n(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nstrAddr = \"'\" & strPath & \"[\" & fileName & \"]\" & \"Sheet1\" & \"'!\" & _\nRange(\"B2\").\nAddress(, , xlR1C1)\n'지정 폴더내 각 파일의 셀주소를 변수에 넣음\nr = r + 1\n'배열크기 1씩 늘려감\nReDim Preserve varTemp(1 To r)\n'배열크기 재지정\nvarTemp(r) =\nExecuteExcel4Macro\n(strAddr)\n'배열에 각 파일의 Sheet1 B2 셀값을 넣음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nRange(\"A2\") =\nApplication.Sum\n(varTemp)\n'배열의 합계를 A2셀에 뿌림\nEnd Sub", "context": "예전 엑셀 4의 매크로 기능 중에 파일을 열지 않고도 데이터를 가져올 수 있는 ExecuteExcel4Macro method가 있다. 이를 이용하면 파일을 열지 않고 각 폴더에 있는 모든 파일의 특정 셀위치에 있는 값을 구할수 있다. 폴더에 3개의 파일이 있고, \"나이\"가 Sheet1의 B2셀에 있다. 이의 합을 구해본다.\ndata 폴더내에 3개의 파일이 들어 있음\n2003.xls 파일                            Book1.xlsx 파일                         Book2.xlsx 파일\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(998) 파일을 열지 않고 폴더속 모든파일의 특정셀위치 합계내기 (엑셀 VBA 매크로)\n재생\n1,391\n재생 (space/k)\n재생\n00:19\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:19\n실시간\n설정\n전체 화면 (f)\n해상도\n270..."}
{"instruction": "Excel VBA code for: (999) 폴더속 모든파일, 모든시트의 데이터를 현 파일로 시트 추가하며 통합 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_All_Sheets_In_Folder5()\nDim wkBk As Workbook\n'각 파일을 넣을 변수\nDim wkSht As Worksheet\n'각 시트를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim colsCnt As Integer\n'데이터시트 전체 열 개수 넣을 변수\nDim rowsCnt As Long\n'데이터시트 전체 행 개수 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf\n.SelectedItems.Count = 0\nThen\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName =\nDir\n(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nSet wkBk = Workbooks.\nOpen\n(strPath & \"\\\" & fileName) '파일을 열고 변수에 넣음\nFor Each wkSht In wkBk.Worksheets\n'열린파일 각 시트를 순환\nWith wkSht.UsedRange\n'각 시트의 사용영역에서\ncolsCnt = .Columns.Count\n'전체 열 개수를 변수에 넣음\nrowsCnt = .Rows.Count\n'전체 행 개수를 변수에 넣음\nEnd With\nWith ThisWorkbook\n'매크로 실행파일\nWith .ActiveSheet\n'활성화된 시트에서\nIf .Cells(Rows.Count, 1).End(3).Row + rowsCnt > 1000000 Then\n'입력된 데이터와 입력될 데이터 행의 합이 1000000을 넘으면\n.Range(\"A1\").Resize(, colsCnt).\nCopy\n'제목 복사\nWith ThisWorkbook.Sheets\n'매크로 실행파일 시트에서\n.\nAdd\nafter:=Sheets(.Count)\n'새로운 시트를 제일 마지막에 추가\nEnd With\nThisWorkbook.ActiveSheet.\nPaste\n'제목 붙여넣기\nEnd If\nEnd With\n.ActiveSheet.Cells(Rows.Count, 1).End(3)(2).Resize(rowsCnt, colsCnt) = _\nwkSht.UsedRange.Offset(1).Value\n'매크로 실행파일 활성화된 시트에서 종단셀 윗방향 아래셀에 각 시트 값을 뿌림\nEnd With\nNext wkSht\nwkBk.\nClose\nFalse\n'열려진 각 파일을 저장없이 닫음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nEnd Sub", "context": "폴더속 모든 파일내의 모든 시트의 데이터를 통합파일에 합치는 기능으로, 1,048,576행을 넘어갈 경우 계속하여 새로운 시트를 추가하며 데이터를 통합하는 기능.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(999) 폴더속 모든파일, 모든시트의 데이터를 현 파일로 시트 추가하며 통합 (엑셀 VBA 매크로)\n재생\n1,828\n공유하기\n재생 (space/k)\n재생\n01:05\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:05\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서..."}
{"instruction": "Excel VBA code for: (1000) 태그 날짜 1씩 늘려가기 (엑셀 VBA 매크로)", "input": "", "output": "Sub increase_Tag_Day()\nDim input_Value As String\n'입력값을 넣을 변수\nDim msg As String\n'메시지 넣을 문자 변수\nConst intMin As Integer = 1\n'최솟값을 넣을 변수\nConst intMax As Integer = 365\n'최댓값을 넣을 변수\nDim r As Integer\n'8행씩 반복해 증가할 변수\nDim i As Integer\n'행을 1씩 늘려갈 변수\nDim dteS As\nDate\n'기준일을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"A\").ClearContents\n'A열의 기존 데이터 삭제\nDo\n'다음을 실행\ninput_Value = InputBox(intMin & \" 과 \" & intMax & \" 사이의 숫자를 입력.\")\n'입력창 값을 변수에 넣음\nIf input_Value = \"\" Then Exit Sub\n'입력값 없으면 매크로 중단\nIf IsNumeric(input_Value) Then\n'입력값이 숫자이면\nIf input_Value >= intMin And input_Value <= intMax Then\nExit Do\n'입력값이 최솟값보다 크거나 같고, 최댓값보다 작거나 같으면 Do 구문 탈출\nEnd If\nEnd If\nmsg = \"숫자입력 오류.\" & vbCr & vbCr\n'메시지창 내용 + 줄바꿈 2번\nmsg = msg & intMin & \" 과 \" & intMax & \" 사이의 숫자를 입력.\"\n'메시지창 내용\nMsgBox msg, 64, \"입력오류\"\n'오류 메시지 출력\nLoop\n'무한 반복\ndteS = \"2012-02-29\"\n'기준일을 넣을 변수\nFor r = 1 To input_Value\n* 8 Step 8\n'8회 x 입력숫자 만큼 반복\ni = i + 1\n'행을 1씩 늘려감\nCells((r - 1) + 1, 1) = \"<day time=\"\"t\" &\nFormat\n(dteS + i, \"yyyymmdd\") & \"\"\">\"\n'날짜를 1씩 늘려감\nCells((r - 1) + 2, 1) = \"<header>\"\n'<header> 복사\nCells((r - 1) + 4, 1) = \"</header>\"\n'</header> 복사\nCells((r - 1) + 5, 1) = \"<body>\"\n'<body> 복사\nCells((r - 1) + 7, 1) = \"</body>\"\n'</body> 복사\nCells((r - 1) + 8, 1) = \"</day>\"\n'</day> 복사\nNext r\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1000) 태그 날짜 1씩 늘려가기 (엑셀 VBA 매크로)\n재생\n631\n재생 (space/k)\n재생\n00:25\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:25\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n매크로 버튼 클릭하여 입력창이 나타남.\n문자를 입력하거나 지정 범위 이외의 숫자를 입력 시 오류 메시지창 출력\n지정범위내 값을 입력 시 태그의 ..."}
{"instruction": "Excel VBA code for: (1003) 부서별 파일 및 이름별 시트만들기 (엑셀 VBA 매크로)", "input": "", "output": "Sub create_WkBk_WkShts()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim strName As String\n'파일이름 넣을 변수\nDim rngA As Range\n'B열의 중복 영역을 넣을 변수\nDim wkBk As Workbook\n'각 파일을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim intCnt As Integer\n'처음 엑셀 열었을 때 생성되는 시트개수 넣을 변수\nDim j As Integer\n'처음 생성되는 시트의 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n' 화면 업데이트 (일시) 정지\nr = 1\n'1행 부터 시작\nDo\nIf Cells(r, 2) = Cells(r + 1, 2) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nstrName = Cells(r, 2).Value\n'B열의 이름을 변수에 넣음\nSet rngA = Cells(r - i, 1).Resize(i + 1)\n'B열의 중복영역을 변수에 넣음\nSet wkBk =\nWorkbooks.\nAdd\n'새로운 파일을 생성\nWith wkBk\nintCnt = .Sheets.Count\n'시트에 기본으로 생성되는 시트개수를 변수에 넣음\nFor Each rngC In rngA\n'B열 중복영역의 각 셀을 순환\n.\nSheets.Add after:=\nSheets(.Sheets.Count)\n'새로운 시트를 제일 뒤에 추가\nActiveSheet.Name = rngC\n'시트의 이름을 A열 이름으로 변경\nActiveSheet.Range(\"A1\") = rngC\n'각 시트의 A1셀에 A열의 이름을 넣음\nNext rngC\nApplication.\nDisplayAlerts = False\n'화면 경고기능 정지\nFor j = 1 To intCnt\n'처음 생성되는 시트 개수만큼 반복\n.Sheets(1).Delete\n'빈 시트 삭제\nNext j\nApplication.DisplayAlerts = True\n'화면 경고기능 복원\n.Sheets(1).Activate\n'1번 시트를 활성화\n.SaveAs ThisWorkbook.\nPath\n& \"\\\" & strName & \".xlsx\"\n'부서이름으로 각 파일 저장\n.Close\n'각 파일 닫기\nEnd With\ni = 0\n'재사용 위하여 초기화\nstrName = vbNullString\n'strName 재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\nSet rngA = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet wkBk = Nothing\nEnd Sub", "context": "B열에 있는 각 부서별로 파일을 생성하고, 각 파일마다 A열에 있는 이름의 시트를 생성하며, 각 시트 A1셀에는 A열의 해당 이름이 입력되도록 함. (즉 총무부 파일내에 김씨, 이씨, 박씨 시트, ..... 기획팀 파일내에 김씨, 박씨 시트,..... 영업지원부 파일내에 .....)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n재생\n2,055\n재생 (space/k)\n재생\n00:34\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:34\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다..."}
{"instruction": "Excel VBA code for: (1004) 랜덤 단어 조합 (엑셀 VBA 매크로)", "input": "", "output": "Sub mix_And_Join_Words_Randomly()\nDim i As Long\n'반복구문에 사용할 변수\nDim lngCnt As Long\n'전체 반복 횟수를 넣을 변수\nDim intLen As Integer\n'전체 문자 길이를 넣을 변수\nDim lngNo As Long\n'무작위 숫자를 넣을 변수\nDim X As New\nCollection\n'컬렉션 개체로 사용할 변수\nDim r As Long\n'배열 1씩 늘려갈 변수\nDim varTemp()\n'동적배열로 사용할 변수\nDim j As Long\n'B열 행을 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"B\").ClearContents\n'B열의 기존 데이터 삭제\nlngCnt =\n10\n'문자 합치기 반복할 횟수\nFor i = 1 To lngCnt\n'1부터 반복횟수까지 1씩 늘려가며 반복\nDo\n'다음을 실행\nlngNo = WorksheetFunction.\nRandBetween\n(1, Cells(Rows.Count, \"A\").End(3).Row)\n'1과 전체행의 개수 사이의 무작위 숫자를 변수에 넣음\nOn Error Resume Next\n'에러 발생해도 (중단 없이) 다음 코드 진행\nX\n.Add\nEmpty, Cells(lngNo, 1)\n'컬렉션에 지정된 셀값을 넣음\nIf\nErr <> 0\nThen\n'중복된 값을 컬렉션에 넣어 에러 발생 시\nErr.Clear\n'에러를 제거\nElse\n'중복되지 않은 값일 경우\nintLen = intLen + Len(Cells(lngNo, 1)) + 1\n'전체 문자길이 + 1(공백)의 값을 변수에\nIf intLen > 30 Then Exit Do\n'문자 길이가 30보다 크면 Do 구문 종료\nr = r + 1\n'배열을 1씩 늘려감\nReDim Preserve varTemp(1 To r)\n'기존 값을 유지하며 배열크기 재지정\nvarTemp(r) = (Cells(lngNo, 1))\n'배열에 각 셀값을 넣음\nEnd If\nOn Error GoTo 0\n'에러 검출기능 복원\nLoop\n'무한 반복\nj = j + 1\n'B열 행을 1씩 늘려감\nCells(j, 2) =\nJoin\n(varTemp, \" \")\n'배열의 값을 공백과 함께 합쳐 B열에 뿌림\nSet X = Nothing\n'재사용 위하여 컬렉션 초기화\nr = 0\n'재사용 위하여 배열 크기값 초기화\nintLen = 0\n'재사용 위하여 전체 문자길이 초기화\nErase\nvarTemp\n'재사용 위하여 동적배열 초기화\nNext i\nColumns(\"B\").AutoFit\n'B열 열너비 자동맞춤\nEnd Sub", "context": "1. A열의 단어를 중복 없이 무작위로 선택하여 공백과 함께 합친다.\n2. 문자의 전체 길이는 30을 넘지 않아야 한다.\n(전체 생성할 합친 단어(행) 개수는 lngCnt = 10 를 조절하면 된다.)\n매크로 실행 전                                     매크로 실행 후 결과\nOption Explicit\nSub mix_And_Join_Words_Randomly()\nDim i As Long\n'반복구문에 사용할 변수\nDim lngCnt As Long\n'전체 반복 횟수를 넣을 변수\nDim intLen As Integer\n'전체 문자 길이를 넣을 변수\nDim lngNo As Long\n'무작위 숫자를 넣을 변수\nDim X As New\nCollection\n'컬렉션 개체로 사용할 변수\nDim r As Long\n'배열 1씩 늘려갈 변수\nDim varTemp()\n'동적배열로 사용할 변수\nDim j As Long\n'B열 행을 1씩 늘려갈 변수\nApplication.Scree..."}
{"instruction": "Excel VBA code for: (1005) 시트이동 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Sheet()\nDim input_Value As String\n'입력값을 넣을 변수\nDim msg As String\n'메시지 넣을 문자 변수\nConst intMin As Integer = 1\n'최솟값을 넣을 변수\nDim intMax As Integer\n'최댓값을 넣을 변수\nDim s As Integer\n'전체 시트 개수만큼 반복할 변수\nDim wkSht As Worksheet\n'각 시트를 넣을 변수\nDim intCnt As Integer\n'카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nintMax =\nSheets.Count\n'전체 시트의 개수를 변수에 넣음\nDo\n'다음을 실행\ninput_Value =\nInputBox\n(intMin & \" 과 \" & intMax & \" 사이의 숫자를 입력.\")\n'입력창 값을 변수에 넣음\nIf input_Value = \"\" Then\n'아무것도 입력하지 않았다면\nMsgBox\n\"입력하지 않거나 취소하셨습니다.\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nIf\nIsNumeric\n(input_Value) Then\n'입력값이 숫자이면\nIf input_Value >= intMin And input_Value <= intMax Then\n'입력값이 최솟값보다 크거나 같고, 최댓값보다 작거나 같으면\nWorksheets(\nVal\n(input_Value)).Activate\n'입력값의 시트를 활성황\nExit Do\n'Do 구문 종료\nEnd If\nElse\n'입력값이 문자라면\nOn Error Resume Next\n'에러 발생해도 (중단없이) 다음코드 진행\nFor s = 1 To intMax\n'1부터 전체 시트개수만큼 반복\nintCnt = intCnt + 1\n'카운터를 1씩 늘려감\nSet wkSht = Worksheets(input_Value)\n'입력값을 각 시트이름에 넣음\nIf\nErr <> 0\nThen\n'(일치하는 이름 없어)에러 발생 시\nErr.Clear\n'에러 제거\nElse\n'(일치하는 이름 있어) 에러 발생하지 않으면\nwkSht.Activate\n'입력값과 일치하는 시트 활성화\nExit Do\n'Do 구문 종료\nEnd If\nIf intCnt = intMax Then\n'만일 일치하는 이름이 없으면\nMsgBox \"일치하는 파일명이 없습니다.\", 64, \"파일명 불일치\"\nEnd If\nNext s\nOn Error GoTo 0\n'에러 검출기능 복원\nEnd If\nmsg = \"파일명 또는 파일번호를 다시 입력하시오.\" & vbCr & vbCr\n'메시지창 내용 + 줄바꿈 2번\nmsg = msg & \"번호는 \" & intMin & \" 과 \" & intMax & \" 사이의 숫자를 입력.\"\n'메시지창 내용\nMsgBox msg\n'메시지창 출력\nLoop\n'무한 반복\nEnd Sub", "context": "시트가 몇 십개까지면 모를까 불가피하게 몇 백개가 되면 시트의 이동도 보통일이 아니다. 물론 시트이동 화살표에 오른쪽 마우스 클릭하여 이동할 수 있지만 시트가 많으면 이것 또한 불편하다.\n아래의 매크로(첨부파일 find_Sheet.xlsm)는\n시트의 번호\n(제일 왼쪽 시트가1, 그다음이 2, ....) 또는\n시트의 이름\n을 입력 시 그 시트를 활성화 하여주는 기능이다. 또 다른 첨부파일(find_Sheet2.xlsm) 파일은 인덱스로 찾지 않고\n파일명으로만\n찾는 기능이다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1005) 시트이동 (엑셀 VBA 매크로)\n재생\n2,566\n공유하기\n재생 (space/k)\n재생\n00:50\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:50\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n자막\n설정..."}
{"instruction": "Excel VBA code for: (1006) alt + Enter 친 첫 행만 폰트 굵게 색표시 (엑셀 VBA 매크로)", "input": "", "output": "Sub emphasize_The_First_Line()\nDim rngC As Range\n'각셀을 넣을 변수\nDim intNo As Integer\n'alt + Enter 위치를 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Columns(1).SpecialCells(2)\n'A열 각 셀을 순환\nIf\nInStr\n(1, rngC,\nChr(10)\n, 0) Then\n'각 셀에 alt + Enter 줄바꿈 있으면\nintNo = InStr(1, rngC, Chr(10), 0)\n'alt + Enter 위치를 변수에 넣음\nFor i = 1 To intNo - 1\n'첫 alt + Enter위치 개수만큼 반복\nWith rngC.\nCharacters\n(i, 1).Font\n'각 문자의 폰트를\n.Bold = True\n'굵게\n.Color = vbBlue\n'색을 파란색으로\nEnd With\nNext i\nEnd If\nNext rngC\nEnd Sub", "context": "매크로 실행 전                                             매크로 실행 후 결과\nOption Explicit\nSub emphasize_The_First_Line()\nDim rngC As Range\n'각셀을 넣을 변수\nDim intNo As Integer\n'alt + Enter 위치를 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Columns(1).SpecialCells(2)\n'A열 각 셀을 순환\nIf\nInStr\n(1, rngC,\nChr(10)\n, 0) Then\n'각 셀에 alt + Enter 줄바꿈 있으면\nintNo = InStr(1, rngC, Chr(10), 0)\n'alt + Enter 위치를 변수에 넣음\nFor i = 1 To intNo - 1\n'첫 alt + Enter위치 개수만큼 반복\nWith rn..."}
{"instruction": "Excel VBA code for: (1007) 텍스트파일 10행씩 합계내기 (엑셀 VBA 매크로)", "input": "", "output": "Sub import_Each10_And_Sum()\nDim strInput As String\n'각 행을 읽어서 저장할 변수\nDim strName As String\n'읽어들일 파일이름 넣을 변수\nDim i As Integer\n'10회 반복구문에 사용할 변수\nDim r As Long\n'행번호 늘려갈 변수\nDim dblU As Double\n'합친 값을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSheets(1).UsedRange.Clear\n'기존 데이터 삭제\nstrName = Application.\nGetOpenFilename\n(\"텍스트파일,*.txt;*.csv;*.prn\", _\nTitle:=\"텍스트파일\")\n'파일을 열어서 파일명을 변수에 넣음\nIf strName = \"False\" Then\n'취소(Cancel) 선택 시\nMsgBox \"취소(Cancel)하여 중단합니다.\", 64, \"파일선택 오류\"\n'오류메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nOpen\nstrName For\nInput As #1\n'선택한 파일 열기\nDo Until\nEOF\n(1)\n'파일의 마지막 행까지 실행\nFor i = 1 To 10\n'10회 반복\nLine\nInput #1, strInput\n'각 행을 읽어서 strInput에 저장\ndblU = dblU +\nVal\n(strInput)\n'각 행을 숫자로 변환하여 합쳐간다\nNext i\nr = r + 1\n'행을 1씩 늘려감\nCells(r, 1) = dblU\n'10개씩 합친 값을 셀에 뿌림\ndblU = 0\n'재사용 위하여 초기화\nLoop\n'무한 반복\nClose\n#1\n'파일 닫기\nWith Cells(Rows.Count, 1)\n'A열 종단셀 윗방향\n.End(3)(2) =\nApplication.Sum\n(Columns(\"A:A\"))\n'바로 아래셀에 A열 합계를 넣음\n.End(3).Interior.Color = vbYellow\n'합계 셀의 색을 노란색으로\nEnd With\nEnd Sub", "context": "텍스트 파일을 10행씩 합하여 불러오며, 제일 마지막 행에는 전체의 합계를 넣음\n(매크로 실행 후 파일 선택창이 나타나면 텍스트 파일을 선택)\n텍스트 파일(1 ~ 100)     매크로 실행 전                                     매크로 실행 후 결과\nOption Explicit\nSub import_Each10_And_Sum()\nDim strInput As String\n'각 행을 읽어서 저장할 변수\nDim strName As String\n'읽어들일 파일이름 넣을 변수\nDim i As Integer\n'10회 반복구문에 사용할 변수\nDim r As Long\n'행번호 늘려갈 변수\nDim dblU As Double\n'합친 값을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSheets(1).UsedRange.Clear\n'기존 데이터 삭제\nstrName = Application.\nGetOpenFilename\n..."}
{"instruction": "Excel VBA code for: (1008) 백업파일 저장하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub SaveWorkbookBackup()\nDim wkBk As Workbook\n'파일을 넣을 변수\nDim strBackUp As String\n'파일이름 넣을 변수\nDim i As Integer\n'점(.) 찾기 위한 반복구문에 사용할 변수\nDim blnYN As\nBoolean\n'저장여부 넣을 변수\nWith Application\n'애플리케이션 즉 엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nIf\nTypeName\n(ActiveWorkbook) = \"Nothing\" Then Exit Sub\n'(개인용 매크로 통합파일에 매크로 저장되어) 열린파일 없으면 종료\nSet wkBk = ActiveWorkbook\n'화면에 활성화된 파일을 변수에 넣음\nIf wkBk.\nPath = \"\"\nThen\n'저장되지 않은 파일이면\n.Dialogs\n(\nxlDialogSaveAs\n).Show\n'다른이름으로 저장하는 창 출력\nElse\n'저장된 파일이면\nstrBackUp = wkBk.\nFullName\n'파일의 전체경로 포함한 이름을 변수에 넣음\nDo While InStr(i + 1, strBackUp, \".\") > 0\n'(마지막 점(.) 찾을때까지 실행\ni = InStr(i + 1, strBackUp, \".\")\n'점(.) 위치를 변수에 넣음\nLoop\nIf i > 0 Then strBackUp = Left(strBackUp, i - 1)\n'(파일이름에 점(.) 존재하면, 확장자를 뺀 이름을 변수에 넣음\nstrBackUp = strBackUp & \".bak\"\n'새로운 .bak 확장자와 파일이름 합침\nblnYN = False                              '\n(저장여부) 참/거짓 값을 거짓으로\nOn Error GoTo\nerrHandler\n'(여러 이유로 저장안되어)에러 발생시 에러핸들링 코드로 이동\n.\nStatusBar\n= \"파일 저장중...\"\n'상태표시에 \"파일저장중...\"출력\nwkBk.Save\n'파일 저장\n.StatusBar = \"백업파일 저장중...\"\n'상태표시에 저장중 출력\nwkBk.\nSaveCopyAs\nstrBackUp\n'백업파일을 저장\nblnYN = True\n'(저장여부) 참/거짓을 참으로\nEnd If\nerrHandler:\n'에러 처리구문\n.StatusBar = False\n'상태표시 하지 않음\nEnd With\nIf blnYN = False Then\n'(저장여부) 거짓일 경우\nMsgBox \"백업파일 저장되지 않음!\", 48, ThisWorkbook.Name\n'메시지 출력\nElse\n'정상적으로 저장되었을 경우\nMsgBox \"정상적으로 파일 저장되고 백업 저장됨\"\n'저장완료 메시지 출력\nEnd If\nSet wkBk = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "지난 번부터 백업파일 저장하는 코드를 하나 만들어 봐야겠다고 생각하고 있었는데 인터넷에 쓸만한 코드가 있어 이를 일부 수정해서 올립니다. 아래에서는 그냥 파일에 매크로를 넣어서 실행했지만, 이런 파일은 \"개인용 매크로 통합문서\"에 넣어서 단축키를 할당하여 사용해야 한다. 그래야지만 사용하기 편하고 파일에 매크로가 포함되지 않고 에러도 적게 난다.\n아래에서 InStr function구문은 InStrRev를 사용하는 것이 더 간단하지만 원본코드를 살려둠.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1008) 백업파일 저장하기 (엑셀 VBA 매크로)\n재생\n946\n재생 (space/k)\n재생\n00:34\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:34\n실시간\n설정\n전체 화면 (f)\n해상도\n480p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n480p\n자막\n설정\n사용 안함\n자막 설정\n글..."}
{"instruction": "Excel VBA code for: (1010) 3그룹으로 된 데이터 돌아가며 복사 (엑셀 VBA 매크로)", "input": "", "output": "Sub alternating_Data_Trans()\nDim c As Integer\n'열 늘려갈 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Worksheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nFor c = 1 To ActiveSheet.UsedRange.\nColumns.Count\n'1부터 열 개수만큼 반복\nFor r = 1 To Cells(\nRows.Count\n, 1).End(3).Row\nStep 5\n'1부터 마지막행까지 5씩 증가하며 반복\nWorksheets(2).Cells(1, Columns.Count).\nEnd(1)(1, 2).\nResize(4) = _\nCells(r, c).Resize(4).Value\n'Sheet2에 종단셀 왼쪽방향 오른쪽에 데이터 복사\nNext r\nNext c\n.Columns(1).Delete\n'공백인 열 삭제\nRange(\"A1\").Copy\n'A1셀 복사\n.Range(.Cells(1, 1), .Cells(1, Columns.Count).End(1)).\nPasteSpecial\n_\nPaste:=\nxlPasteFormats\n'Sheet2 1행에 서식 복사\nApplication.CutCopyMode = False\n'복사모드 해제\n.Activate\n'Sheet2 활성화\nEnd With\nEnd Sub", "context": "이런 데이터 이동을 할 때 한 가지 참고할 것은, 등호(=)를 사용하여 데이터를 복사하는 것이다. 물론 .Copy를 이용하면 끝부분의 PasteSpecial을 사용하지 않아도 되지만 속도가 느리다. 그러므로 등호(=)를 이용하여 빠르게 데이터를 가져온 후 제목행에 서식만 복사를 함.\n매크로 실행 전 (Sheet2는 비어 있음)        매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub alternating_Data_Trans()\nDim c As Integer\n'열 늘려갈 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Worksheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nFor c = 1 To ActiveSheet.UsedRange.\nColumns.Count\n'1부터 열 개수만큼 반복\nFor r = 1 To Cells(..."}
{"instruction": "Excel VBA code for: (1011) 두 줄로 입력된 데이터 정렬하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_Merged_Cells4()\nDim r As Long\n'전체 열개수 만큼 반복할 변수\nDim c As Long\n'전체 열개수 만큼 반복할 변수\nDim rowsCnt As Long\n'마지막 행을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nrowsCnt = Cells(Rows.Count, 1).End(3).\nRow\n'전체영역의 마지막 행을 넣을 변수\nFor c = 1 To rowsCnt / 2\n'전체열 개수 / 2 만큼 반복\nFor r = 5 To rowsCnt - 1 Step 2\n'전체행 개수 - 1 만큼 반복\nIf Cells(r, 2) > Cells(r + 2, 2) Then\n'위 값이 아래 값보다 크면\nCells(r, 2).Offset(, 6).Resize(2, 6) = Cells(r, 2).Resize(2, 6).Value\n'위 데이터 오른쪽으로\nCells(r, 2).Resize(2, 6) = Cells(r + 2, 2).Resize(2, 6).Value\n'아래 데이터 윗쪽으로\nCells(r + 2, 2).Resize(2, 6) = Cells(r, 2).Offset(, 6).Resize(2, 6).Value\n'오른쪽 데이터 아래로\nEnd If\nNext r\nNext c\nColumns(\"H:M\").\nDelete\n'임시로 사용한 열 삭제\nEnd Sub", "context": "각 사람마다 두 줄로 입력된 데이터를 B열의 \"성명\"을 기준으로 (소위 버블 소트(bubble sort)를 이용하여) 오름차순으로 정렬하는 기능.\n매크로 실행 전\n매크로 실행 후 결과 (B열을 기준으로 오름차순으로 정렬됨)\nOption Explicit\nSub sort_Merged_Cells4()\nDim r As Long\n'전체 열개수 만큼 반복할 변수\nDim c As Long\n'전체 열개수 만큼 반복할 변수\nDim rowsCnt As Long\n'마지막 행을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nrowsCnt = Cells(Rows.Count, 1).End(3).\nRow\n'전체영역의 마지막 행을 넣을 변수\nFor c = 1 To rowsCnt / 2\n'전체열 개수 / 2 만큼 반복\nFor r = 5 To rowsCnt - 1 Step 2\n'전체행 개수 - 1 만큼 반복\nIf Cells(r, 2) > Cells(r + 2,..."}
{"instruction": "Excel VBA code for: (1013) 배열사용한 코드와 데이터 삭제후 정렬한 코드의 속도비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub no_EntireRow_Delete1()\nDim lastRow As Long\n'마지막 행을 넣을 문자\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'배열 크기 늘려갈 변수\nDim varTemp()\n'배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 2).End(3).Row\n'마지막 행을 변수에 넣음\nReDim\nvarTemp(1 To lastRow, 1 To 2)\n'배열크기 재지정\nFor Each rngC In Range(\"B2\", Cells(lastRow, 2))\n'\"나이\" 열의 각셀을 순환\nIf rngC <= 5 Then\n'\"나이\"열 각 셀이 5보다 작거나 같으면\nr = r + 1\n'배열 크기 1씩 늘려감\nvarTemp(r, 1) = rngC.Previous\n'배열에 \"이름\"을 넣음\nvarTemp(r, 2) = rngC\n'배열에 \"나이\"를 넣음\nEnd If\nNext rngC\nActiveSheet.UsedRange.Offset(1).ClearContents\n'기존데이터 삭제\nRange(\"A2\").Resize(\nUBound\n(varTemp, 1), 2) = varTemp\n'배열값을 셀에 뿌림\nEnd Sub\n\nSub no_EntireRow_Delete2()\nDim lastRow As Long\n'마지막 행을 넣을 문자\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).Row\n'마지막 행을 변수에 넣음\nColumns(\"A\").Insert\n'(정렬 기준으로 사용할) 임시열 삽입\nRange(\"A1\", Cells(lastRow, 1)) =\nEvaluate\n(\"row(1:\" & lastRow & \")\")\n'1행에서 마지막 행까지 행번호 입력\nFor Each rngC In Range(\"C2\", Cells(lastRow, 3))\n'\"나이\" 열의 각셀을 순환\nIf rngC > 5 Then rngC.Offset(, -2).Resize(, 3).ClearContents\nNext rngC\n'나이가 5보다 많을 경우 행 삭제\nActiveSheet.UsedRange.\nSort\n[A1], 1\n'A열을 기준으로 오름차순 정렬\nColumns(\"A\").Delete\n'(정렬 기준으로 사용한) 임시열 삭제\nEnd Sub", "context": "EntireRow.Delete(EntireRow.Insert) 또는\nEntireRow.Delete shift:=xlUp(EntireRow.Insert Shift:=xlDown) 를 사용하는 코드는 죽었다 깨어도 속도를 낼 수 없다. 몇 천행의 데이터는 사용해도 좋지만 2 ~ 3만 행을 넘어가면 가급적 사용을 피해야 하고, 십만행이 넘어가면 사용하지 않아야 한다.\n여러 가지 시도를 좋아하는 본능(?)으로 인하여 많은 행을 빠르게 삭제할 수 있는 방법을 찾기 위해 다양한 코드를 시험해 보았지만 결론은 똑같다. EntireRow.Delete 또는 EntireRow.Delete shift:=xlUp 코드는 절대로 속도를 낼 수 없다. 예외 없이 항상\n배열이 가장 빠르다.\n배열보다는 상대적으로 느리지만, 배열을 사용할 수 없을 때, 데이터만을 삭제하고 정렬하는 것이 그나마 빠른 편이다. 정렬의 기준으로 사용하기 위해 임시열을 삽입하고 Evaluate method를 사용하여 순번을 입력한 다음..."}
{"instruction": "Excel VBA code for: (1014) 전체 워크북을 .pdf파일로 인쇄 시 복수의 .pdf 파일이 생성되는 문제해결 (엑셀 VBA 매크로)", "input": "", "output": "Sub same_Print_Setup()\nDim wkSht As Worksheet\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each wkSht In ActiveWorkbook.Sheets\nApplication.PrintCommunication = False\nWith\nwkSht\n.PageSetup\n.PrintTitleRows = \"\"\n.PrintTitleColumns = \"\"\nEnd With\nApplication.PrintCommunication = True\nwkSht\n.PageSetup.PrintArea = \"\"\nApplication.PrintCommunication = False\nWith\nwkSht\n.PageSetup\n.LeftHeader = \"\"\n.CenterHeader = \"\"\n.RightHeader = \"\"\n.LeftFooter = \"\"\n.CenterFooter = \"\"\n.RightFooter = \"\"\n.LeftMargin = Application.InchesToPoints(0.708661417322835)\n.RightMargin = Application.InchesToPoints(0.708661417322835)\n.TopMargin = Application.InchesToPoints(0.748031496062992)\n.BottomMargin = Application.InchesToPoints(0.748031496062992)\n.HeaderMargin = Application.InchesToPoints(0.31496062992126)\n.FooterMargin = Application.InchesToPoints(0.31496062992126)\n.PrintHeadings = False\n.PrintGridlines = False\n.PrintComments = xlPrintNoComments\n.PrintQuality = 1200\n.CenterHorizontally = False\n.CenterVertically = False\n.Orientation = xlPortrait\n.Draft = False\n.PaperSize = xlPaperA4\n.FirstPageNumber = xlAutomatic\n.Order = xlDownThenOver\n.BlackAndWhite = False\n.Zoom = 100\n.PrintErrors = xlPrintErrorsDisplayed\n.OddAndEvenPagesHeaderFooter = False\n.DifferentFirstPageHeaderFooter = False\n.ScaleWithDocHeaderFooter = True\n.AlignMarginsHeaderFooter = True\n.EvenPage.LeftHeader.Text = \"\"\n.EvenPage.CenterHeader.Text = \"\"\n.EvenPage.RightHeader.Text = \"\"\n.EvenPage.LeftFooter.Text = \"\"\n.EvenPage.CenterFooter.Text = \"\"\n.EvenPage.RightFooter.Text = \"\"\n.FirstPage.LeftHeader.Text = \"\"\n.FirstPage.CenterHeader.Text = \"\"\n.FirstPage.RightHeader.Text = \"\"\n.FirstPage.LeftFooter.Text = \"\"\n.FirstPage.CenterFooter.Text = \"\"\n.FirstPage.RightFooter.Text = \"\"\nEnd With\nApplication.PrintCommunication = True\nNext wkSht\nEnd Sub", "context": ".pdf 파일이 대세를 이룬지 오래되었으며, 많은 사람들이 .pdf 파일을 생성하고 주고 받는다. 그런데 어떤 때에는 전체 시트가 한 개의 .pdf 파일로 잘 인쇄 되었다가, 어떤 때에는 각 시트가 별도의 파일로 인쇄되어 사용자를 당황하게 하며 지식인에서도 유사한 질문을 많이 보았다.\n아래 동영상에서 보는 바와 같이, 프린터 설정을 전혀 손대지 않고 인쇄시 전체 워크북을 인쇄하면 한 개의 .pdf 파일이 생성되지만, 프린터 설정을 바꾼 Sheet1 시트는 별개의 파일로 인쇄된다. 그러므로, 다중 시트를 한 개의 .pdf파일로 만들고자 한다면 인쇄설정을 통일하면 된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1014) 전체 워크북을 .pdf파일로 인쇄 시 복수의 .pdf 파일이 생성되는 문제해결 (엑셀 VBA 매크로)\n재생\n1,933\n재생 (space/k)\n재생\n01:15\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n..."}
{"instruction": "Excel VBA code for: (1018) 두 번째 선택한 영역크기로 그림(사진) 삽입 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Picture_To_Area2()\nDim area1 As Range\n'선택영역 첫 번째 area 넣을 변수\nDim area2 As Range\n'선택영역 두 번째 area 넣을 변수\nDim blnTF As\nBoolean\n'일치하는 그림 유/무 판단할 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim strName As String\n'파일 확장자 제외한 이름을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Selection\n'선택영역에서\nIf .\nAreas\n.\nCount\n<> 2 Then\n'선택영역의 area가 2개가 아닐 경우\nMsgBox \"2개의 영역만 허용됩니다.\", 64, \"영역선택 오류\"\nExit Sub\n'매크로 종료\nEnd If\nSet area1 = .Areas(1)\n'첫 번째 영역을 변수에 넣음\nSet area2 = .Areas(2)\n'두 번째 영역을 변수에 넣음\nEnd With\nIf area1.Cells(1) = \"\" Then\n'선택영역 첫 번째 area에 값이 없으면\nMsgBox \"첫 번째 area에 값이 없습니다.\", 64, \"첫 area 값 오류\"\nExit Sub\n'매크로 종료\nElseIf Not\nIntersect\n(area1, area2) Is Nothing Then\nMsgBox \"두 area에 겹친영역이 있습니다.\", 64, \"영역 중복오류\"\nExit Sub\n'매크로 종료\nEnd If\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf\n.SelectedItems.Count = 0\nThen\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName =\nDir\n(strPath)\n'(폴더내)각 그림파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nstrName =\nSplit\n(fileName, \".\")\n(0)\n'파일 확장자 제거한 이름 추출\nIf strName = area1.Cells(1) Then\n'파일 이름이 첫번째 area와 일치 시\nActiveSheet.\nPictures.Insert\n(strPath & fileName).Select\n'일치한 그림파일 삽입\nblnTF = True\n'blnTF 값에 참 값을 넣음\nWith Selection\n'선택된 그림파일\n.Name = \"Temp\"\n'(임시로) 이름을 \"Temp\"로 지정\n.ShapeRange.\nLockAspectRatio\n=\nmsoFalse\n'그림의 가로/세로크기 고정 해제\n.Height = area2.Height - 4\n'그림의 가로크기 지정\n.Width = area2.Width - 4\n'그림의 세로크기 지정\n.Copy\n'그림을 복사\nActiveSheet.\nPasteSpecial\nFormat:=\"Picture (JPEG)\",\nLink:=False\n'링크깨고 붙여넣기\nActiveSheet.Pictures(\"Temp\").Delete\n'원본 그림파일 삭제\nEnd With\nWith Selection\n'(복사되어)선택된 그림파일\n.Left = area2.Left + 2\n'그림의 왼쪽위치 지정\n.Top = area2.Top + 2\n'그림의 윗쪽위치 지정\nEnd With\nExit Do\n'Do 구문 종료\nEnd If\nfileName =\nDir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nIf blnTF = False Then\n'blnTF 값이 거짓일 경우\nMsgBox \"폴더내에 일치하는 그림이 없습니다.\", 64, \"일치파일 없음\"\nEnd If\nEnd Sub", "context": "셀의 입력값과 폴더내 그림파일의 이름이 일치 시 두 번째 선택영역에 그림을 삽입하는 기능.\nctrl\n+ 마우스\n를 이용하여 두 개의 영역(area)만을 선택해야 하며, 첫 번째 area의 이름과 폴더내의 그림파일 이름이 일치 시 두 번째 영역의 위치에 그림을 삽입\n그림은 삽입 후 링크를 깨고 복사하여\n영구삽입\n되도록 함.\n(두 번째 선택영역은 셀병합 영역이어도 상관 없음)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1018) 두 번째 선택한 영역크기로 그림(사진) 삽입 (엑셀 VBA 매크로)\n재생\n2,007\n공유하기\n재생 (space/k)\n재생\n01:08\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:08\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0..."}
{"instruction": "Excel VBA code for: (1019) 그림 삽입하고 동그라미로 표시하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Pictures_And_Circle()\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim obj As\nObject\n'각 개체(object)를 넣을 변수\nDim C As Range\n'검색에 일치한 셀을 넣을 변수\nDim strName As String\n'파일 확장자 제외한 이름을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf\n.SelectedItems.Count = 0\nThen\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nFor Each obj In ActiveSheet.\nShapes\n'현재시트 각 개체를 순환\nIf obj.Name <> \"Run Macro\" Then\n'도형이 \"Run Macro\"가 아니면\nobj.Delete\n'도형 삭제\nEnd If\nNext obj\nfileName = Dir(strPath)\n'(폴더내)각 그림파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nstrName =\nSplit\n(fileName, \".\")\n(0)\n'파일 확장자 제거한 이름 추출\nSet C = ActiveSheet.UsedRange.\nFind\n(strName, , , xlWhole)\n'그림파일과 일치하는 셀을 찾음\nIf\nNot C Is Nothing\nThen\n'그림파일과 동일한 이름이 셀에 존재하면\nActiveSheet.\nPictures.Insert\n(strPath & fileName).Select\n'각 그림파일 삽입\nWith Selection\n'선택된 그림파일\n.Name = \"Temp\"\n'(임시로) 이름을 \"Temp\"로 지정\n.ShapeRange.\nLockAspectRatio\n= msoFalse\n'그림의 가로/세로크기 고정 해제\n.Height = C.Offset(, 2).Height - 4\n'그림의 가로크기 지정\n.Width = C.Offset(, 2).Width - 4\n'그림의 세로크기 지정\n.Copy\n'그림을 복사\nEnd With\nWith ActiveSheet\n.\nPasteSpecial\nFormat:=\"Picture (JPEG)\",\nLink:=False\n'그림 링크깨고 붙여넣기\n.Pictures(\"Temp\").Delete\n'원본 그림파일 삭제\nEnd With\nWith Selection\n'(복사되어)선택된 그림파일\n.Left = C.Offset(, 2).Left + 2\n'그림의 왼쪽위치 지정\n.Top = C.Offset(, 2).Top + 2\n'그림의 윗쪽위치 지정\nEnd With\nWith C.Offset(, 2)\n'이름 일치한셀 오른쪽 두 번째 셀\nActiveSheet.Shapes.\nAddShape\n(9, 1, 1, .Width / 2, .Height / 2).Select\n'동그라미를 셀의 1/2 크기로 삽입\nWith Selection.ShapeRange\n'선택된 도형에서\n.Line.\nForeColor.RGB\n= RGB(255, 0, 0)\n'외곽선을 빨간색으로\n.\nFill.Visible\n= msoFalse\n'색 채우기를 제거하여 투명하게\nEnd With\nSelect Case\nC.Next\n'이름 일치한 셀의 오른쪽 셀이\nCase \"좌상\":\n'\"좌상\"일 경우\nSelection.Left = .Left\n'동그라미의 왼쪽위치\nSelection.Top = .Top\n'동그라미의 윗쪽 위치\nCase \"좌하\":\n'\"좌하\"일 경우\nSelection.Left = .Left\n'동그라미의 왼쪽위치\nSelection.Top = .Top + .Height / 2\n'동그라미의 윗쪽 위치\nCase \"우상\":\n'\"우상\"일 경우\nSelection.Left = .Left + .Width / 2\n'동그라미의 왼쪽위치\nSelection.Top = .Top\n'동그라미의 윗쪽 위치\nCase \"우하\":\n'\"우하\"일 경우\nSelection.Left = .Left + .Width / 2\n'동그라미의 왼쪽위치\nSelection.Top = .Top + .Height / 2\n'동그라미의 윗쪽 위치\nEnd Select\nEnd With\nEnd If\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nSet C = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "폴더내 그림파일과 각 셀의 그림이름이 일치할 경우 그림을 삽입하고, 각 셀의 오른편에 입력된 동그라미의 위치(좌상, 좌하, 우상, 우하)에 따라 그림 위에 빨간 동그라미를 그려넣는 기능\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1019) 그림 삽입하고 동그라미로 표시하기 (엑셀 VBA 매크로)\n재생\n1,812\n재생 (space/k)\n재생\n00:31\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:31\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보..."}
{"instruction": "Excel VBA code for: (1022) 제목을 번갈아가며 데이터 반복 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub alternating_Data_Trans()\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim rngT As Range\n'각 셀 복사할 타겟(T)arget 셀위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(\"Sheet2\")\n'Sheet2시트에서\n.UsedRange.\nClear\n'Sheet2의 기존 데이터 삭제\nFor Each rngC In Columns(\"C\").SpecialCells(2)\n'C열 각 셀을 순환\nSet rngT = .Cells(1, Columns.Count).\nEnd(1)(1, 2)\n'복사지점을 변수에 넣음\nIf rngT.\nColumn\n> 16380 Then\n'복사될 지점이 전체열개수 벗어나면\nMsgBox \"전체 열개수를 벗어나 중단합니다.\"\nElse\nrngT.Resize(, 4) = rngC\n'알파벳 복사\nrngT(2, 1).Resize(3, 4) = Range(\"D3:G5\").Value\n'D3:G5 값을 복사\nrngT.Resize(4, 4).\nBorderAround\n1,\nxlMedium\n'각 그룹별 외곽테두리 그리기\nEnd If\nNext rngC\n.Columns(1).Delete\n'빈 열 삭제\n.Columns.AutoFit\n'열너비 자동맞춤\nEnd With\nSet rngT = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. C열 데이터의 행 개수는 가변적.\n2. C열 각 셀을 제목행으로 하여 D3:G5를 번갈아 가면서 복사\n매크로 실행 전 (Sheet2는 비어있는 상태)     매크로 실행 후 결과\nOption Explicit\nSub alternating_Data_Trans()\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim rngT As Range\n'각 셀 복사할 타겟(T)arget 셀위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(\"Sheet2\")\n'Sheet2시트에서\n.UsedRange.\nClear\n'Sheet2의 기존 데이터 삭제\nFor Each rngC In Columns(\"C\").SpecialCells(2)\n'C열 각 셀을 순환\nSet rngT = .Cells(1, Columns.Count).\nEnd(1)(1, 2)\n'복사지점을 변수에 넣음\nIf rngT.\nColumn\n> 16380..."}
{"instruction": "Excel VBA code for: (1023) 사이숫자 연속으로 채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_Text_Inbetween()\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim varS As Variant\n'각 셀을 공백으로 분리(S)plit해 넣을 배열변수\nDim i As Long\n'반복구문에 사용될 변수\nDim j As Long\n'분리된 문자 개수만큼 반복할 변수\nDim strL As String\n'각 문자(L)etter를 넣을 변수\nDim strU As String\n'합쳐진(U)nion 문자를 넣을 변수\nDim k As Long\n'분리된 문자 개수만큼 반복할 변수\nDim strEach As String\n'각(Each) 숫자를 넣을 변수\nDim strNo As String\n'합쳐진 숫자(No)를 넣을 변수\nDim r As Long\n'숫자 1씩 늘려갈 변수\nDim m As Long\n'연속으로 숫자만 나올경우 앞의 문자 찾을 변수\nDim loopGuard As Long\n'루프 방지용 변수\nDim cntCancel As Long\n'문자 찾아 앞으로 이동하는 만큼 보정할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.Offset(, 1).ClearContents\n'기존 데이터 삭제\nColumns(\"A:A\").Copy [B1]\n'A열을 B열에 복사\nFor Each rngC In Columns(2).SpecialCells(2)\n'A열 각 셀을 순환\nrngC =\nReplace\n(\nReplace\n(\nReplace\n(rngC, \"-\", \" \"), \"~\", \" \"), \",\", \" \")\n'각 셀의 하이픈(-), 틸드(~), 콤마(,)를 공백으로 바꿈\nvarS =\nSplit\n(rngC, \" \")\n'각 셀을 공백으로 나눠 배열에 넣음\nFor i =\nLBound\n(varS) To\nUBound\n(varS)\n'배열 개수만큼 반복\nIf Left(varS(i), 1)\nLike\n\"[a-zA-Z]\n\" Then\n'첫 글자가 알파벳으로 시작하면\nCells(rngC.Row, Columns.Count).\nEnd(1)(1, 2)\n= varS(i)\n'각 분리된 문자를 셀에 뿌림\nElse\n'첫 글자가 알파벳이 아니라면\nm = i - 1\n'm에 i-1을 넣음\nDo\n'다음을 실행\nIf Left(varS(m), 1) Like \"[a-zA-Z]\" Then\nFor j = 1 To Len(varS(m))\n'바로 앞에 배열에 들은 문자 숫자만큼 반복\nstrL = Mid(varS(m), j, 1)\n'각 문자를 변수에 넣음\nIf strL Like \"[a-zA-Z]\" Then\n'각 문자가 알파벳 이라면\nstrU = strU & strL\n'각 문자를 합쳐감\nEnd If\nNext j\nFor k = 1 To Len(varS(m))\n'바로 앞에 배열에 들은 문자 숫자만큼 반복\nstrEach = Mid(varS(m), k, 1)\n'각 숫자를 변수에 넣음\nIf strEach\nLike \"[0-9]\"\nThen\n'각 문자가 숫자라면\nstrNo = strNo & strEach\n'각 숫자를 합쳐감\nEnd If\nNext k\nExit Do\n'Do 구문 종료\nElse\nm = m - 1\n'값을 1씩 빼나감\ncntCancel = cntCancel + 1\n'보정값을 1씩 늘려감\nEnd If\nloopGuard = loopGuard + 1\n'루프 방지용 카운터\nIf loopGuard = 1000 Then\n'오류로 인하여 1000번 반복되면\nMsgBox \"오류가 있어 종료합니다.\", 64, \"오류\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nLoop\n'무한 반복\nDo\n'다음을 실행\nIf\nVal\n(strNo) + cntCancel = varS(i) Then\n'strNo 가 배열값과 일치시\nExit Do\n'Do 구문 종료\nElse\n'strNo가 배열 값과 일치하지 않으면\nIf cntCancel = 0 Then\n'보정할 값이 0일 경우\nstrNo = Val(strNo) + 1\n'strNo 를 1씩 늘려감\nCells(rngC.Row, Columns.Count).End(1)(1, 2) = strU & strNo\n'합쳐진 문자와 숫자를 셀에 뿌림\nElse\n'보정값이 0이 아닐 경우\nstrNo = strNo + cntCancel\n'strNo에 보정값을 더함\ncntCancel = 0\n'보정값을 제거\nEnd If\nEnd If\nloopGuard = loopGuard + 1\n'루프 방지용 카운터\nIf loopGuard = 2000 Then\n'오류로 인하여 2000번 반복되면\nMsgBox \"오류가 있어 종료합니다.\", 64, \"오류\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nLoop\n'무한 반복\nstrU = \"\"\n'재사용 위하여 초기화\nstrNo = \"\"\n'재사용 위하여 초기화\nloopGuard = 0\n'재사용 위하여 초기화\nm = 0\n'재사용 위하여 초기화\ncntCancel = 0\n'재사용 위하여 초기화\nEnd If\nNext i\nNext rngC\nColumns(2).Delete\n'임시로 사용한 B열 삭제\nColumns.\nAutoFit\n'열너비 자동 맞춤\nEnd Sub", "context": "하이픈(-) 또는 틸드(~)가 앞에 없는 경우에는 그대로 값을 입력한다.\n하이픈(-) 또는 틸드(~)가 앞에 있는 숫자의 경우 앞에 있는 문자를 사용하여 연속으로 숫자를 채워야 한다.\n바로 앞에 문자가 없을 경우 그 앞, 그 앞에도 없을 경우 그 앞 ...의 문자를 사용하여 연속으로 숫자를 채워야 한다.\n(간단해 보일지 모르지만 지식인의 질문에 답변이 달리지 않을 정도로 상당히 까다로운 질문이었다.\nloopGuard\n라는 카운터를 사용한 이유는 아래와 같은 내용의 경우 생각지 못한 변수가 많아서 루프에 걸릴 확률이 높으므로 이의 예방을 위해서 일정 횟수 이상 반복을 하게 되면 Do 구문을 종료하도록 하는 기능으로 데이터에 불확실성이 높을 때에는 나름 유용한 테크닉이다.)\n매크로 실행 전                      매크로 실행 후 결과\nOption Explicit\nSub fill_Text_Inbetween()\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\n..."}
{"instruction": "Excel VBA code for: (1025) 1열로 저장된 텍스트파일 5열로 불러오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub import_Text_Five_Columns()\nDim strName As String\n' 읽어들일 파일이름 넣을 변수\nDim strInput As String\n' 각 행을 읽어서 저장할 변수\nDim r As Long\n' 행번호 늘려갈 변수\nDim c As Integer\n' 열번호 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nstrName = Application.\nGetOpenFilename\n(\"텍스트파일,*.txt\", _\nTitle:=\"텍스트파일\")\n'파일을 열어서 파일명을 변수에 넣음\nIf strName = \"False\" Then\n'취소(Cancel) 선택 시\nMsgBox \"취소(Cancel)하여 중단합니다.\", 64, \"파일선택 오류\"\n'오류메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nOpen\nstrName For\nInput As #1\n'선택한 파일 열기\nr = 1\n'1행 부터 시작\nDo Until\nEOF(1)\n' 파일의 마지막 행까지 실행\nLine Input\n#1, strInput\n'각 행을 읽어서 strInput에 저장\nc = c + 1\n'열 방향 1씩 늘려감\nIf c\nMod\n6 = 0 Then\n'c를 6으로 나눈 나머지가 0이면\nr = r + 1\n'행을 1씩 늘려감\nc = 1\n'재사용 위하여 열위치 초기화\nEnd If\nCells(r, c) = strInput\n'불러온 값을 셀에 뿌림\nLoop\n'무한 반복\nClose\n#1\n'파일 닫기\nColumns.AutoFit\n'열너비 자동맞춤\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1025) 1열로 저장된 텍스트파일 5열로 불러오기 (엑셀 VBA 매크로)\n재생\n1,257\n재생 (space/k)\n재생\n00:22\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:22\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n텍스트 파일을 연다. 1 ~ 50까지의 숫자가 1열로 저장된 파일.\n매크로 파일을 열고 매크로 실행 후 텍스트 파일을 선택...."}
{"instruction": "Excel VBA code for: (1026) 월별 품목별 합계내기 (엑셀 VBA 매크로)", "input": "", "output": "Sub monthly_Statistics()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim s As Integer\n'각 시트를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"A1\").CurrentRegion\n'전체 데이터를 변수에 넣음\nWorksheets.\nFillAcrossSheets\nRange(rngAll.Resize(1).Address).Cells\n'각 시트에 제목을 복사\nRange(\"J1:K1\") = \"일자\"\n'임시로 \"일자\"삽입\nFor s = 2 To 13\n'Data시트 제외한 전체시트 순환\nWith Sheets(s)\n'각 시트에서\n.UsedRange.Offset(1).ClearContents\n'제목을 제외한 기존 데이터 삭제\nRange(\"J2\") = \">=\" &\nDateSerial\n(Range(\"H2\"), s - 1, 1)\n'각 월의 첫 일자를 J2셀에\nIf s <> 13 Then\n'13번째(\"12월\")시트 아닐 경우\nRange(\"K2\") = \"<\" & DateSerial(Range(\"H2\"), s, 1)\n'각 월의 다음달을 K2셀에 입력\nElse\n'13번째(\"12월\")시트일 경우\nRange(\"K2\") = \"<\" & DateSerial(Range(\"H2\") + 1, 1, 1)\nEnd If\n'다음년도 1월 1일을 K2셀에 넣음\nSheets(\"Temp\").UsedRange.ClearContents\n'Temp 시트의 임시데이터 삭제\nrngAll.\nAdvancedFilter\nxlFilterCopy, Range(\"J1:K2\"), _\nSheets(\"Temp\").Range(\"A1:F1\"), False\n'각 월의 데이터를 임시 데이터에 고급필터로 복사\n.[A2].\nConsolidate\n_\nSources:=Sheets(\"Temp\").UsedRange.Offset(1).Address(1, 1, xlR1C1, 1), _\nFunction:=xlSum, LeftColumn:=True\n'중복없이 통합하여 합계구함\n.UsedRange.\nSort\n.[A1], Header:=xlYes\n'A열 기준으로 오름차순 정렬\n.Columns(\"E\").Delete\n'날짜열 삭제\n.Columns.AutoFit\n'열너비 자동맞춤\nEnd With\nNext s\nRange(\"J1:K2\").ClearContents\n'임시로 입력한 값들 삭제\nSet rngAll = Nothing\n'개체변수 초기화\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1026) 월별 품목별 합계내기 (엑셀 VBA 매크로)\n재생\n4,722\n재생 (space/k)\n재생\n00:52\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:52\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n2011년, 2012년 데이터가 들어 있음.\n미리 생성한 각 월별 시트는 비어 있음\n년도를 선택 시 매크로 실행. 2011년 선택 시 2011년..."}
{"instruction": "Excel VBA code for: (1027) 연속되는 숫자 또는 영문자로 구분하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub split_English_No()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'반복구문에 사용될 변수\nDim varTemp\n'문자를 나누어 넣을 배열로 사용할 변수\nDim strU As String\n'문자를 공백과 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.Offset(, 1).ClearContents\n'기존 데이터 삭제\nColumns(\"A:A\").Copy [B1]\n'A열을 B열에 복사\nColumns(\"B\").\nReplace\n\" \", \"\"\n'B열의 모든 공백 제거\nFor Each rngC In Columns(2).SpecialCells(2)\n'B열의 각 셀을 순환\nFor i = 1 To Len(rngC)\n'각 셀의 문자 숫자만큼 반복\nIf (\nMid\n(rngC, i, 1)\nLike \"[0-9]\"\nAnd\n_\nMid(rngC, i + 1, 1)\nLike \"[a-zA-Z]\"\n)\nOr\n_\n(Mid(rngC, i, 1) Like \"[a-zA-Z]\"\nAnd\n_\nMid(rngC, i + 1, 1) Like \"[0-9]\") Then\n'숫자와문자, 또는 문자와숫자가 연달아나오면\nIf strU = \"\" Then\n'strU가 비어 있을 경우\nstrU = Mid(rngC, i, 1) & \" \"\n'문자를 공백과 합친다\nElse\n'strU가 비어 있지 않을 경우\nstrU = strU & Mid(rngC, i, 1) & \" \"\n'strU + 새로운문자 + 공백\nEnd If\nElse\n'숫자와문자, 문자와 숫자가 붙어 있지 않으면\nIf strU = \"\" Then\n'strU가 비어 있을 경우\nstrU = Mid(rngC, i, 1)\n'문자를 합쳐감\nElse\n'strU가 비어 있지 않을 경우\nstrU = strU & Mid(rngC, i, 1)\n'strU + 새로운 문자\nEnd If\nEnd If\n'앞에 공백을 넣음\nNext i\nvarTemp =\nSplit\n(strU, \" \")\n'공백으로 구분하여 배열에 넣음\nstrU = \"\"\n'재사용 위하여 초기화\nCells(rngC.Row, Columns.Count).End(1)(1, 2).Resize(,\nUBound\n(varTemp) + 1) _\n= varTemp\n'배열의 값을 셀에 뿌림\nNext rngC\nColumns.AutoFit\n'열너비 자동맞춤\nColumns(\"B\").Delete\n'임시로 복사한 B열 삭제\nEnd Sub", "context": "1. 숫자와 숫자, 영어와 영어 사이에는 공백(space)이 있으면 안됨.\n2. 숫자와 영어를 분리하여 각 셀에 넣는다.\n뭔가 더 간단하고 좋은 방법이 있을 것 같은데 ... 아래와 같은 방법뿐이 생각이 나지 않네요.\n매크로 실행 전                        매크로 실행 후 결과\nOption Explicit\nSub split_English_No()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'반복구문에 사용될 변수\nDim varTemp\n'문자를 나누어 넣을 배열로 사용할 변수\nDim strU As String\n'문자를 공백과 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.Offset(, 1).ClearContents\n'기존 데이터 삭제\nColumns(\"A:A\").Copy [B1]\n'A열을 B열에 복사\nColumns(\"B\").\nRepl..."}
{"instruction": "Excel VBA code for: (1028) 규칙적인 빈행 빠르게 삽입하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Blank_Rows()\nDim lastRow As Long\n'마지막 행 - 1 을 넣을 변수\nDim lngNo As Long\n'삽입할 행의 개수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, \"A\").End(3).\nRow - 1\n'마지막 행 -1 을 변수에 넣음\nlngNo = 1\n'삽입할 행의 개수를 변수에 넣음\nColumns(\"A\").Insert\n'A열에 열을 삽입\nFor i = 1 To lngNo + 1\n'lngNo + 1 회만큼 반복\nCells(Rows.Count, \"A\").End(3)(2).Resize(lastRow) = _\nApplication\n.\nEvaluate\n(\"row(1:\" & lastRow & \")\")\n'행 개수의 만큼 연속숫자 입력\nNext i\nActiveSheet.UsedRange.\nSort\n[A1], 1, Header:=True\n'현재시트 사용영역을 오름차순 정렬\nColumns(\"A\").Delete\n'임시로 사용한 열 삭제\nEnd Sub", "context": "매크로 실행 전                                  lngNo =\n1\n로 실행한 결과          lngNo =\n2\n으로 실행한 결과\n(윗 그림과 같이 lngNo에 입력한 값 만큼 빈행이 생성됨)\n빈행 삽입에도 여러가지 방법이 있지만 아래의 방법으로 해보니 정말 빠르다. 첨부 파일에는 파일 크기를 작게 하기 위해 1,000행만 들어가 있지만\n25,000\n행을 넣고 1행씩 빈행을 넣어 전체행이 50,000행이 되었을 때 제 컴퓨터로\n0.20초가 소요\n됩니다. 참고로, 실제로 행마다 빈행을 삽입하는 것이 아니라 정렬로 인하여 빈행이 생성되는 것임.\nOption Explicit\nSub insert_Blank_Rows()\nDim lastRow As Long\n'마지막 행 - 1 을 넣을 변수\nDim lngNo As Long\n'삽입할 행의 개수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데..."}
{"instruction": "Excel VBA code for: (1029) 규칙적인 빈행 빠르게 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub deletet_Blank_Rows()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim lngNo As Integer\n'삽입할 행의 개수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'번호를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, \"A\").End(3).\nRow\n'마지막 행을 변수에 넣음\nlngNo = 1\n'삭제할 행의 개수를 변수에 넣음\nColumns(\"A\").Insert\n'A열에 열을 삽입\nFor i = 2 To lastRow\nStep lngNo + 1\n'마지막행까지 lngNo + 1 만큼 건너 뛰며 반복\nr = r + 1\n'번호를 1씩 늘려감\nCells(i, 1) = r\n'A열에 정렬 기준으로 사용할 번호를 뿌려줌\nNext i\nActiveSheet.UsedRange.\nSort\n[A1], 1, Header:=True\n'현재시트 사용영역을 오름차순 정렬\nColumns(\"A\").Delete\n'임시로 사용한 열 삭제\nEnd Sub", "context": "매크로 실행 전                                                         lngNo =\n1\n로 매크로 실행한 결과\n매크로 실행 전                                                         lngNo =\n2\n로 매크로 실행한 결과\n(윗 그림과 같이 lngNo에 입력한 값 만큼 규칙적으로 빈행이 삭제됨)\n빈행 삭제에도 여러가지 방법이 있지만 아래의 방법으로 해보니 정말 빠르다. 첨부 파일에는 파일 크기를 작게 하기 위해 2,000행만 들어가 있지만\n50,000\n행을 넣고 1행씩 삭제하여 전체행이 25,000행이 되도록 하였을 때 제 컴퓨터로\n0.67초가 소요\n됩니다. 참고로, 실제로 빈행이 삭제되는 것이 아니라 정렬로 인하여 아래로 밀려 내려가는 것임.\nOption Explicit\nSub deletet_Blank_Rows()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim lngNo..."}
{"instruction": "Excel VBA code for: (1030) 셀안의 숫자 만큼 행삽입 후 복사하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Rows_As_Numbered()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim rngAll As Range\n'\"전화\"열 제목 제외한 C열 전체영역 넣을 변수\nDim lngSum As Long\n'숫자의 합계를 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'번호를 1씩 늘려갈 변수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, \"A\").End(3).Row - 1\n'마지막행 - 1 을 변수에 넣음\nSet rngAll = Range(\"C2\", Cells(Rows.Count, \"C\").End(3))\n'전체영역을 변수에 넣음\nlngSum =\nApplication.Sum\n(rngAll)\n'숫자의 합계를 변수에 넣음\nReDim\nvarTemp(1 To lngSum, 1 To 1)\n'배열크기 재지정\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nr = r + 1\n'숫자를 1씩 늘려감\nIf rngC = 1 Then\n'각 셀값이 1이라면\nvarTemp(r, 1) = r\n'배열에 r 값을 넣음\nElse\n'각 셀값이 1이 아니라면\nvarTemp(r, 1) = r\n'배열에 r 값을 넣음\nFor i = 1 To rngC - 1\n'각 셀값 -1 만큼 반복\nlastRow = lastRow + 1\n'마지막 행의 위치 1씩 늘려감\nvarTemp(lastRow, 1) = r\n'배열에 r 값을 넣음\nNext i\nEnd If\nNext rngC\nColumns(\"A\").Insert\n'A열에 임시열을 삽입\nCells(2, 1).Resize(lngSum, 1) = varTemp\n'배열내의 값을 셀에 뿌림\nActiveSheet.UsedRange.\nSort\n[A1], 1, Header:=True\n'현재시트 사용영역을 오름차순 정렬\nColumns(\"A\").Delete\n'임시로 사용한 열 삭제\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "각 행의 데이터가 C열에 적힌 셀의 숫자 만큼의 행을 가지도록 빈행을 삽입하는 기능. 첨부파일에는 1,000행의 데이터가 있으며, 20,000행의 데이터로 매크로 실행하여 전체행이 50,000 행으로 늘어나는데 약\n0.6초 정도 소요\n. 물론 단순히 배열에 넣어 셀에 뿌려도 되지만 새로운 방법 찾기를 좋아하는 내 취미에는 맞는 코드. 속도는 빠르지만, 사용방법 자체가 복잡하여 많은 분들이 사용하기는 어려울듯.\n매크로 실행 전                                                          매크로 실행 후 결과 파일\nOption Explicit\nSub insert_Rows_As_Numbered()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim rngAll As Range\n'\"전화\"열 제목 제외한 C열 전체영역 넣을 변수\nDim lngSum As Long\n'숫자의 합계를 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\n..."}
{"instruction": "Excel VBA code for: (1032) 증권 hts 가격상승 검출기능 (엑셀 VBA 매크로)", "input": "", "output": "Sub application_OnTime()\nStatic\nlngFixed As Long\n'기준이될 값을 넣을 변수\nStatic cnt As Integer\n'카운터로 사용할 변수\nsetTime =\nNow + TimeValue\n(\"00:00:01\")\n'현재시간 + 1초를 변수에 넣음\nApplication.OnTime\nsetTime, \"application_OnTime\"\n'설정시간이 되면 application_OnTime 실행\nIf Range(\"A1\") > lngFixed Then\n'A1셀 값이 lngFixed 보다 클 경우\nIf lngFixed = 0 Then\n'만일 (처음 시작하여) lngFixed 값이 0일 경우\nlngFixed = Range(\"A1\")\n'A1셀값을 lngFixed에 넣음\nElse\nIf Range(\"A1\") >= lngFixed + 3 Then\n'A1셀 값이 lngFixed + 3과 같을 경우\nRange(\"C1\") = \"v\"\n'C1셀에 \"v\" 값을 입력\nlngFixed = Range(\"A1\")\n'A1셀값을 lngFixed에 넣음\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nRange(\"B1\") = cnt\n'B1셀에 카운터 입력\nIf cnt = 5 Then\n'카운터가 5회에 도달하면\ncnt = 0\n'카운터를 0으로초기화\nlngFixed = 0\n'lngFixed 값을 0으로 초기화\nMsgBox \"5회 값이 증가하였으므로 종료합니다.\"\n'메시지 출력\nCall\nstop_OnTime\n'stop_OnTime 매크로 호출\nExit Sub\n'매크로 종료\nEnd If\nEnd If\nEnd If\nElse\n'A1셀 값이 lngFixed보다 작거나 같을 경우\nlngFixed = Range(\"A1\")\n'A1셀값을 lngFixed에 넣음\nEnd If\nEnd Sub\n\nSub stop_OnTime()\nOn Error\nResume Next\n'에러 발생해도 다음코드 진행\nApplication.OnTime setTime, \"application_OnTime\", ,\nFalse\n'설정한 시간에 application_OnTime 실행을 중단\nEnd Sub", "context": "질문자의 요청내용 : 증권 hts프로그램에서 엑셀하고 연동해서 주문넣는걸 만들기 위해 아래와 같은 기능이 필요함.\nA1셀에는 DDE를 통하여 계속하여 값이 변동되는 상황.\n현재숫자보다 +3이되면 c1셀에 v를 표시(C1셀의 v는 입력 시 자동으로 삭제되게 해놓은 상태)\nv 입력시 B1셀에 v표시한 개수를 입력\n현재 숫자가 10이면 13이 되었을때 v를 입력해주고 다시 13이 16이 되면 v를 입력.\n16에서 5까지 빠졌을 때는 가만있다가 5에서 8이되면 다시 v를 입력.\nv를 5회 입력하면 매크로 종료\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1032) 증권 hts 가격상승 검출기능 (엑셀 VBA 매크로)\n재생\n1,220\n재생 (space/k)\n재생\n00:34\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:34\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)..."}
{"instruction": "Excel VBA code for: (1033) Evaluate method와 동적배열의 속도비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub evaluate_Array()                                                    Sub for_Array()\nDim lngNo As Long                                                       Dim lngNo As Long\nDim varTemp                                                                Dim varTemp()\nDim i As Long                                                              Dim i As Long\nApplication.ScreenUpdating = False                                Application.ScreenUpdating = False\nlngNo = 1000000                                                            lngNo = 1000000\nvarTemp =\nApplication.Evaluate\n(\"row(1:\" & lngNo & \")\")\nReDim\nvarTemp(1 To lngNo, 1 To 1)\nEnd Sub", "context": "아래의 두 코드는 배열에 1 ~ 1,000,000 까지의 숫자를 넣는 코드로서, 하나는 Evaluate method를 사용하였고 다른 하나는 For 구문과 동적배열을 사용하였다. 두 코드의 속도차이는 대략 2배 정도가 난다. 동적배열이 참 빠르긴 빠르다. 아무래도 evaluate이라는 조건이 들어가므로 아무 조건이 없는 For구문과 동적배열을 사용한 코드보다 속도가 떨어지는게 당연한 것 같다.\n반복횟수                 Evaluate method를 사용한 코드          For 구문과 동적배열을 사용한 코드\n1,000,000회\n0.16초\n0.08초\nSub evaluate_Array()                                                    Sub for_Array()\nDim lngNo As Long                                                       Dim lngNo As Long\nDi..."}
{"instruction": "Excel VBA code for: (1034) 중복없는 숫자와 알파벳을 50개씩 나열 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub random_Numbers_Alphabet()\nConst\nintL As Integer = 62\n'숫자(10) + 소문자(26) + 대문자(26)\nDim intNo As Integer\n'각 셀당 문자의 개수\nDim rowsCnt As Long\n'생성할 행의 개수\nDim vA()\n'숫자와 알파벳을 넣을 배열변수\nDim vL\n'숫자와 알파벳을 복사해 넣을 배열변수\nDim strU As String\n'합쳐진 문자를 넣을 변수\nDim i As Integer\n'생성할 셀의 개수를 넣을 변수\nDim j As Integer\n'intNo 만큼 반복할 변수\nDim k As Integer\n'무작위 숫자를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.ClearContents\n'기존 데이터 삭제\nRandomize\n'초기화\nintNo =\n50\n'각 셀당 문자의 개수\nrowsCnt =\n10000\n'전체행의 개수\nIf intNo > 62 Or rowsCnt > 1048576 Then\n'셀의 문자가 62보다 크거나 행이 1048576을 넘어서면\nMsgBox \"숫자가 범위를 벗어남. 문자62, 1048576행 이하로 설정\"\nExit Sub\n'매크로 종료\nEnd If\nReDim\nvL(1 To intL)\n'배열크기 재지정\nFor i = 1 To 62\nIf i >= 1 And i <= 10 Then vA(i) =\nChr\n(48 + i - 1)\n'배열에 숫자입력\nIf i >= 11 And i <= 36 Then vA(i) = Chr(65 + i - 11)\n'배열에 대문자입력\nIf i >= 37 And i <= 62 Then vA(i) = Chr(97 + i - 37)\n'배열에 소문자입력\nNext i\nFor i = 1 To rowsCnt\n'전체 행의 개수만큼 반복\nvL = vA\n'배열을 복사해 넣음\nFor j = intNo To 1 Step -1\n'intNo 만큼 반복\nk = Int(\nRnd\n* j) + 1\n'무작위 숫자 추출\nstrU = strU & vL(k)\n'추출한 문자를 합쳐감\nvL(k) = vL(j)\n'추출한 값에 제일 높은 값을 넣음\nNext j\nCells(i, 1) = strU\n'합친 값을 셀에 뿌림\nstrU = \"\"\n'재사용 위하여 초기화\nNext i\nColumns(1).AutoFit\n'열너비 자동 맞춤\nEnd Sub", "context": "숫자와 알파벳 대소문자를 중복없이 나열하는 기능으로, 아래의 intNo 와 rowsCnt 의 숫자를 조절하면 각 셀에 입력되는 문자의 숫자와 생성할 전체행의 개수를 조절할 수 있다.\n(참고로 제 컴퓨터에서 10,000 행을 넣고 돌렸을 때 0.7초 정도 소요.)\n매크로 실행 전\n매크로 실행 후 결과 파일\nOption Explicit\nSub random_Numbers_Alphabet()\nConst\nintL As Integer = 62\n'숫자(10) + 소문자(26) + 대문자(26)\nDim intNo As Integer\n'각 셀당 문자의 개수\nDim rowsCnt As Long\n'생성할 행의 개수\nDim vA()\n'숫자와 알파벳을 넣을 배열변수\nDim vL\n'숫자와 알파벳을 복사해 넣을 배열변수\nDim strU As String\n'합쳐진 문자를 넣을 변수\nDim i As Integer\n'생성할 셀의 개수를 넣을 변수\nDim j As Integer\n'intNo 만큼 반복할 변수\nDim ..."}
{"instruction": "Excel VBA code for: (1036) 슬래시(/)로 분리하고 복사하여 채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub split_As_Per_Slash()\nDim r As Long\n'각 행을 넣을 변수\nDim C As Range\n'각 셀을 넣을 변수\nDim intNo As Integer\n'슬래시(/) 위치를 넣을 변수\nDim strH As String\n'앞쪽(H)ead 쪽 문자\nDim strT As String\n'뒷쪽(T)ail 쪽 문자\nDim varTemp\n'슬래시(/)로 문자를 나누어 넣을 배열변수\nDim rngC As Range\n'복사할 셀의 각셀을 넣을 변수\nDim j As Integer\n'배열 요소의 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor r = Cells(Rows.Count, 1).End(3).\nRow\nTo 2 Step -1\n'마지막행에서 2행까지\nSet C = Cells(r, 1)\n'각 셀을 C에 넣음\nIf InStr(1, C, \"/\") Then\n'각 셀에 슬래시가 포함되어 있다면\nintNo =\nInStr\n(1, C, \"/\")\n'슬래시의 위치를 변수에 넣음\nstrH = Left(C, intNo - 2)\n'앞쪽 문자를 추출해 변수에 넣음\nstrT = Right(C, Len(C) - intNo + 2)\n'뒷쪽 문자를 추출해 변수에 넣음\nvarTemp =\nSplit\n(strT, \"/\")\n'뒷쪽 문자를 슬래시로 나누어 배열에 넣음\nC.Offset(1).Resize(UBound(varTemp)).\nEntireRow.Insert\n'아래행 복사\nFor Each rngC In C.Resize(UBound(varTemp) + 1)\n'복사한 각 셀을 순환\nrngC = strH & varTemp(j)\n'각 셀에 앞쪽 문자 + 슬래시로 나눈 문자\nj = j + 1\n'배열위치 1씩 늘려감\nNext rngC\nC.Offset(, 1).Resize(UBound(varTemp) + 1, 3).\nFillDown\n'각 영역을 아래로 복사\nj = 0\n'재사용 위하여 초기화\nEnd If\nNext r\nSet C = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                                       매크로 실행 후 결과\nOption Explicit\nSub split_As_Per_Slash()\nDim r As Long\n'각 행을 넣을 변수\nDim C As Range\n'각 셀을 넣을 변수\nDim intNo As Integer\n'슬래시(/) 위치를 넣을 변수\nDim strH As String\n'앞쪽(H)ead 쪽 문자\nDim strT As String\n'뒷쪽(T)ail 쪽 문자\nDim varTemp\n'슬래시(/)로 문자를 나누어 넣을 배열변수\nDim rngC As Range\n'복사할 셀의 각셀을 넣을 변수\nDim j As Integer\n'배열 요소의 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor r = Cells(Rows.Count, 1).End(3).\nRow\nTo 2 Step -1\n'마지막행에서 2..."}
{"instruction": "Excel VBA code for: (1037) 급여명세서 메일머지로 인쇄하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub print_Of_Payment_Statement()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngIn As Range\n'급여항목 행을 넣을 변수\nDim rngOut As Range\n'공제항목 행을 넣을 변수\nDim rngEach As Range\n'급여/공제 항목의 각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(1)\n'시트 1에서\nFor Each rngC In .Range(.[C2], .Cells(Rows.Count, 3).End(3))\n'C열 각 셀을 순환\nRange(\"D13:D14\").\nClearContents\n'기존 데이터 삭제\nRange(\"A16:D27\").ClearContents\n'기존 데이터 삭제\nSet rngIn = rngC.Offset(, 1).Resize(, 11)\n'급여항목 영역을 변수에 넣음\nSet rngOut = rngC.Offset(, 13).Resize(, 7)\n'공제항목 영역을 변수에 넣음\nRange(\"D13\") = rngC.\nPrevious\n'수령자 입력\nRange(\"D14\") = rngC\n'직급 입력\nFor Each rngEach In rngIn\n'급여항목 각 셀을 순환\nIf\nNot IsEmpty\n(rngEach) Then\n'각 셀값이 비어 있지 않다면\nRange(\"A28\").End(3)(2) = .Cells(1, rngEach.\nColumn\n)\n'급여항목을 셀에 입력\nRange(\"B28\").End(3)(2) = rngEach\n'급여금액을 셀에 입력\nEnd If\nNext rngEach\nFor Each rngEach In rngOut\n'공제항목 각 셀을 순환\nIf Not IsEmpty(rngEach) Then\n'각 셀값이 비어있지 않다면\nRange(\"C28\").End(3)(2) = .Cells(1, rngEach.Colu mn)\n'공제항목을 셀에 입력\nRange(\"D28\").End(3)(2) = rngEach\n'공제내역을 셀에 입력\nEnd If\nNext rngEach\nActiveSheet.\nPrintPreview\n'각 시트 인쇄 미리보기\n'Activesheet.\nPrintOut\n'각 시트를 출력(인쇄 시 윗행 삭제후 이행을 사용)\nNext rngC\nEnd With\nSet rngIn = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngOut = Nothing\nEnd Sub", "context": "(많이 문의하는 내용중의 하나이다. 소위 메일머지(mail merge) 기능으로 동일한 양식에 일부 내용만 바꿔가면서 인쇄를 하는 기능이다.  현실세계가 아니므로 회장/사장님의 월급을 깎고 아래 사람들이 월급을 더 가져가는 이상향(?)을 실천하였다. 경리 월급이 제일 많다. ㅎㅎ)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1037) 급여명세서 메일머지로 인쇄하기 (엑셀 VBA 매크로)\n재생\n4,896\n재생 (space/k)\n재생\n00:47\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:47\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움..."}
{"instruction": "Excel VBA code for: (1038) 특정 구간의 값만 원하는 위치로 이동하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub shift_Certain_Data_Span()\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim cnt As Long\n'(무한루프 방지용)카운터를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"A:D\").\nNumberFormatLocal\n= \"0.00\"\n'A:D열 서식을 소수점 두자리까지\nDo\nr = r + 1\n'(A열의) 행을 1씩 늘려감\nIf Cells(r, 1) = 1 Then\n'만일 (A열)셀값이 1이면\nDo\n'다음을 실행\nIf Cells(r, 1) = 0.7 Then\n'만일 A열 셀값이 0.7이면\nCells(r, 1).Offset(, 1) = Cells(r, 1)\n'B열에 값을 넣음\nExit Sub\n'매크로 종료\nElse\n'만일 A열 셀값이 0.7이 아니라면\nCells(r, 1).Offset(, 1) = Cells(r, 1)\n'B열에 값을 넣음\nEnd If\nr = r + 1\n'(A열의) 행을 1씩 늘려감\ncnt = cnt + 1\n'(무한루프 방지용)카운터를 1씩 늘려감\nIf cnt > 100000 Then Exit Sub\n'(일치하는 값 없어)100,000을 넘어가면 매크로 종료\nLoop\nEnd If\nIf cnt > 100000 Then Exit Sub\n'(일치하는 값 없어)100,000을 넘어가면 매크로 종료\nLoop\nEnd Sub", "context": "특정 구간의 값만 원하는 위치로 이동하는 기능으로, 아래의 예제에서는 A1셀부터 아래로 내려가다가 처음으로 값이 1.00 인 셀부터 값이 0.70 인 셀까지의 구간을 오른쪽으로 1칸 이동하는 기능.\n1. 어느 구간의 데이터가 이동할지 알아보기 쉽도록 두 데이터의 영역을 미리 색으로 표시해 놓음.\n2. 일치하는 값이 없어 무한 루프에 걸려 100,000회를 넘어가면 매크로를 중단하도록 함\n매크로 실행 전                                             매크로 실행 후 결과\nOption Explicit\nSub shift_Certain_Data_Span()\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim cnt As Long\n'(무한루프 방지용)카운터를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"A:D\").\nNumberFormatLocal\n= \"0.00\"\n'A:D열 서식을 소..."}
{"instruction": "Excel VBA code for: (1039) 셀안의 숫자 만큼 행삽입 후 복사하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Rows_As_Numbered2()\nDim rngAll As Range\n'F 데이터 영역 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수를 넣을 변수\nDim lngSum As Long\n'숫자의 합계를 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'번호를 1씩 늘려갈 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim c As Long\n'열 개수만큼 반복할 개수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"F3\", Cells(Rows.Count, \"F\").End(3))\n'전체영역을 변수에 넣음\ncolsCnt = ActiveSheet.\nUsedRange\n.Columns.Count\n'전체 열의 개수를 변수에 넣음\nlngSum =\nApplication.Sum\n(rngAll)\n'숫자의 합계를 변수에 넣음\nReDim\nvarTemp(1 To lngSum, 1 To colsCnt)\n'배열크기 재지정\nFor Each\nrngC In rngAll\n'전체영역 각 셀을 순환\nFor\ni = 1 To rngC\n'각 셀값 만큼 반복\nr = r + 1\n'숫자를 1씩 늘려감\nFor\nc = 1 To colsCnt\n'전체 열 개수만큼 반복\nvarTemp(r, c) = rngC.Offset(, -(colsCnt) + c)\n'배열에 r 값을 넣음\nNext\nc\nNext\ni\nNext\nrngC\nActiveSheet.UsedRange.Offset(2).\nClear\n'기존 데이터 삭제\nCells(3, 1).Resize(lngSum, colsCnt) = varTemp\n'배열의 값을 셀에 뿌림\nRange(\"A4\").CurrentRegion.\nBorders.LineStyle\n= 1\n'데이터에 외곽 테두리\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "각 행의 데이터가 F열에 적힌 셀의 숫자 만큼의 행을 가지도록 빈행을 삽입한 뒤 삽입한 행에 데이터를 복사하여 넣는 기능. 이런 코드는 너무 많이 해서 약간은 지겨운 감도 없지 않지만 역시 이러류의 작업에는 \"초보님들의 강력한 적(敵) → 배열\"만큼 빠르고 적합한 코드는 없다.\n매크로 실행 전                                                            매크로 실행 후 결과\nOption Explicit\nSub insert_Rows_As_Numbered2()\nDim rngAll As Range\n'F 데이터 영역 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수를 넣을 변수\nDim lngSum As Long\n'숫자의 합계를 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'번호를 1씩 늘려갈 변수\nDim i As Long\n'반복구문에 사용..."}
{"instruction": "Excel VBA code for: (1040) 그룹별 중복데이터 제일 윗행/아래행만 남기고 삭제하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub multiple_Columns_Comparison1()\nDim a\n'윗행을 넣을 배열변수\nDim b\n'아래행을 넣을 배열변수\nDim colsCnt As Integer\n'전체 열개수 넣을 변수\nDim i As Long\n'열 개수만큼 반복할 변수\nDim cnt As Long\n'(일치한 열의 개수를 셀)카운터로 사용할 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열개수를 변수에 넣음\nr = 2\n'2행부터 시작\nDo\n'다음을 실행\na = Range(Cells(r, 1), Cells(r, colsCnt))\n'윗행을 배열에 넣음\nb = Range(Cells(r + 1, 1), Cells(r + 1, colsCnt))\n'아래행을 배열에 넣음\nFor i = 1 To colsCnt\n'1부터 열 개수만큼 반복\nIf a(1, i) <> b(1, i) Then\n'배열내 각 값을 비교해 서로 다르면\ncnt = 0\n'카운터를 초기화\n'                Cells(r, colsCnt + 1) = r\n'제일 오른쪽열에 행번을 넣음\nExit For\n'For 구문 종료\nElse\n'배열내 각 값을 비교해 서로 같으면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nIf cnt = colsCnt Then\n'만약 카운터가 열개수와 같다면\nRange(Cells(r, 1), Cells(r, colsCnt)).ClearContents\n'중복데이터 윗행 삭제\ncnt = 0\n'카운터 초기화\nEnd If\nEnd If\nNext i\nr = r + 1\n'행을 1씩 늘려감\nLoop Until Cells(r, 1) = \"\"\n'A열에 빈셀이 나올때까지 무한 반복\n'    ActiveSheet.UsedRange.Sort Cells(2, colsCnt + 1), 1, Header:=True\n'오른차순으로 정렬\n'    Columns(colsCnt + 1).Delete\n'임시로 행번\n넣을 마지막열 삭제\nEnd Sub\n\nSub multiple_Columns_Comparison2()\nDim a\n'윗행을 넣을 배열변수\nDim b\n'아래행을 넣을 배열변수\nDim colsCnt As Integer\n'전체 열개수 넣을 변수\nDim i As Long\n'열 개수만큼 반복할 변수\nDim cnt As Long\n'(일치한 열의 개수를 셀)카운터로 사용할 변수\nDim r As Long\n'행을 1씩 줄여갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열개수를 변수에 넣음\nr = Cells(Rows.Count, \"A\").End(3).Row\n'마지막 행을 변수에 넣음\nDo\n'다음을 실행\na = Range(Cells(r - 1, 1), Cells(r - 1, colsCnt))\n'윗행을 배열에 넣음\nb = Range(Cells(r, 1), Cells(r, colsCnt))\n'아래행을 배열에 넣음\nFor i = 1 To colsCnt\n'1부터 열 개수만큼 반복\nIf a(1, i) <> b(1, i) Then\n'배열내 각 값을 비교해 서로 다르면\ncnt = 0\n'카운터를 초기화\n'                Cells(r, colsCnt + 1) = r\n'제일\n오른쪽열에 행번을 넣음\nExit For\n'For 구문 종료\nElse\n'배열내 각 값을 비교해 서로 같으면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nIf cnt = colsCnt Then\n'만약 카운터가 열개수와 같다면\nRange(Cells(r, 1), Cells(r, colsCnt)).ClearContents\n'중복데이터 아래행 삭제\ncnt = 0\n'카운터 초기화\nEnd If\nEnd If\nNext i\nr = r - 1\n'행을 1씩 줄여감\nLoop Until Cells(r, 1).Row = 1\n'A1셀에 도달할 때까지 무한반복\n'    ActiveSheet.\nUsedRange\n.\nSort\nCells(2, colsCnt + 1), 1, Header:=True\n'오름차순으로 정렬\n'\nColumns(colsCnt + 1).\nDelete\n'임시로\n행번 넣을 마지막열 삭제\nEnd Sub", "context": "엑셀의 중복제거(Remove Duplicates)는 아래와 같은 경우 이름이 \"나\"인 행을 모두 삭제하고 제일 윗행(3행)만 남겨 놓는다. 아래의 코드들은 중간 중간 중복된 데이터의 제일 윗(오래된)행만 남기거나, 가장 마지막(최근)행만 남겨두는 기능. 최고 속도는 나지 않지만 기존 정렬을 유지하면서 행을 삭제하므로 특별한 경우 유용할 수 있겠다.\n(아래 노란색으로 표시한 주석처리된 행의 주석을 제거할 경우 (빈행이 아래로 밀려 내려가서) 빈 행이 모두 삭제된다.)\n매크로 실행 전 (색칠해진 곳이 삭제될 데이터)                   매크로 실행 후 결과\n'중복 데이터 중 제일 아래\n행만 남겨두는 코드\nOption Explicit\nSub multiple_Columns_Comparison1()\nDim a\n'윗행을 넣을 배열변수\nDim b\n'아래행을 넣을 배열변수\nDim colsCnt As Integer\n'전체 열개수 넣을 변수\nDim i As Long\n'열 개수만큼 반복할 ..."}
{"instruction": "Excel VBA code for: (1041) 그룹별 중복데이터 제일 윗행/아래행만 남기고 삭제하기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Dupes_Leaving_Last2()\nDim r As Long\n'행을 1씩 줄여가며 반복할 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'마지막 행을 변수에 넣음\nr = 1\n'1행부터 시작\nDo\n'다음을 실행\nCells(r, 1).Resize(2, 4).\nRemoveDuplicates\nArray(1, 2, 3, 4)\n'중복되는 A:D열의 데이터를 삭제\nIf Cells(r + 1, 1) = \"\" Then\n'위 아래행이 중복되어 아래행 삭제시\nCells(r + 1, 1).Resize(, 4) = Cells(r, 1).Resize(, 4).Value\n'윗행을 아래행에 복사\nCells(r, 1).Resize(, 4).ClearContents\n'윗행을 삭제\nEnd If\nr = r + 1\n'행을 1씩 늘려감\nLoop Until\nCells(r, 1).Row = lastRow\n'마지막 행에 도달할 때까지 무한 반복\nEnd Sub", "context": "아래의 코드는 약간 비효율적이지만 \"아 이런 방식으로도 가능하구나\" 정도로 참고하시면 될듯. 5만행에 5초 정도 소요되므로 아주 늦는 편은 아니다.\n매크로 실행 전 (색칠해진 곳이 삭제될 데이터)                   매크로 실행 후 결과\nOption Explicit\nSub remove_Dupes_Leaving_Last2()\nDim r As Long\n'행을 1씩 줄여가며 반복할 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'마지막 행을 변수에 넣음\nr = 1\n'1행부터 시작\nDo\n'다음을 실행\nCells(r, 1).Resize(2, 4).\nRemoveDuplicates\nArray(1, 2, 3, 4)\n'중복되는 A:D열의 데이터를 삭제\nIf Cells(r + 1, 1) = \"\" Then..."}
{"instruction": "Excel VBA code for: (1042) 데이터 재배치하고 합계구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub trans_And_SubTotal()\nDim rngC As Range\n'A열 각 셀을 넣을 변수\nDim rngEach As Range\n'각 행의 각 셀을 넣을 변수\nDim c As Integer\n'열 또는 행번호 늘려가며 반복할 변수\nDim rngT As Range\n'Sheet2 각 행에 데이터 이동될 위치를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n.\nCells.Delete\nShift:=xlUp\n'Sheet2의 기존 데이터 삭제\n.Range(\"A1\").Resize(, 3) =\nArray\n(\"선택\", \"규격\", \"단가\")\n'Sheet2에 제목 입력\nEnd With\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, \"A\").End(\n3)) 'A열 각 셀을 순환\nFor c = 1 To 6\n'6회 반복\nIf\nNot IsEmpty\n(rngC.\nOffset\n(, c)) Then\n'각 셀의 오른쪽으로 offset한 값이 비어있지 않으면\nWith Sheets(2)\n'Sheet2에서\nSet rngT = .Cells(Rows.Count, \"A\").End(3)(2)\n'A열 종단셀 윗방향 바로 아래셀을 변수에 넣음\nrngT = rngC\n'\"선택\"을 복사\nrngT.Offset(, 1) = Cells(1, rngC.Offset(, c).Column)\n'\"규격\"을 복사\nrngT.Offset(, 2) = rngC.Offset(, c)                             '\n\"단가\"를 복사\nEnd With\nEnd If\nNext c\nNext rngC\nSheets(2).Activate\n'Sheet2를 활성화\nActiveSheet.UsedRange.\nSubtotal\n1,\nxlSum\n, 3\n'부분합 실행\nFor c = Cells(Rows.Count, \"A\").End(3).Row To 2\nStep -1\n'A열 제일 아래행에서 3행까지\nIf Cells(c, 1) = Cells(c - 1, 1) Then\n'A열 아래행이 윗행과 같으면\nCells(c, 1).ClearContents\n'아래행 셀값을 삭제\nElseIf Right(Cells(c, 1), 5) = \"Total\" Then\n'오른쪽 5자가 Total로 끝나면\nCells(c, 1).Copy Cells(c, 2)\n'B열에 A열 셀값을 복사\nCells(c, 1).ClearContents\n'A열 셀값을 삭제\nEnd If\nNext c\nSheets(2).\nCells.ClearOutline\n'부분합 삭제\nColumns.AutoFit\n'열너비 자동 맞춤\nSet rngT = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "(제가 영문 버전이라 Total로 나오지만, 확인은 안해봤지만, 한글 버전에서는 \"합계\"라고 나올것 같다. 그럴 경우 아래 코드를    ElseIf Right(Cells(c, 1), 2) = \"합계\" Then   이라고 바꿔야 함.)\n매크로 실행 전 (Sheet2는 비어 있는 상태)                      매크로 실행 후 결과\nOption Explicit\nSub trans_And_SubTotal()\nDim rngC As Range\n'A열 각 셀을 넣을 변수\nDim rngEach As Range\n'각 행의 각 셀을 넣을 변수\nDim c As Integer\n'열 또는 행번호 늘려가며 반복할 변수\nDim rngT As Range\n'Sheet2 각 행에 데이터 이동될 위치를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n.\nCells.Delete\nShift:=xlUp\n'Sheet2의 기존 데이터..."}
{"instruction": "Excel VBA code for: (1044) 텍스트 파일에서 특정값이 들어 있는 행만 가져오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub import_Line_Including_Specific_Text()\nDim strFind As String\n'찾으려는 문자를 넣을 변수\nDim varFiles As Variant\n'선택한 파일을 넣을 배열 변수\nDim r As Long\n'텍스트파일 행의 위치 1씩 늘려갈 변수\nDim i As Long\n'파일 개수만큼 반복할 변수\nDim intNo As Integer\n' \"\\\" 위치 찾아 넣을 변수\nDim strName As String\n'파일 이름을 넣을 변수\nDim strInput As String\n'각 행의 문자를 넣을 변수\nDim j As Integer\n'열 개수만큼 반복할 변수\nDim y As Long\n'텍스트파일의 행위치 넣을 변수\nDim blnTF As\nBoolean\n'일치하는 값이 하나라도 있는지 판단할 변수\nDim varTemp As Variant\n'각 행의 문자를 구분자로 나누어 넣을 배열 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nActiveSheet.UsedRange.Offset(1).ClearContents\n'제목 제외한 기존 데이터 삭제\nCells.\nFormatConditions.Delete\n'기존 조건부서식 삭제\nstrFind = \"\n31\n\"\n'찾으려고 하는 문자\nvarFiles = Application.\nGetOpenFilename\n(\"텍스트파일, *.txt; *.csv; *.prn\", , _\n\"텍스트파일을 선택\", MultiSelect:=True)\n'텍스트 파일을 (복수로) 선택\nIf TypeName(varFiles) = \"Boolean\" Then Exit Sub\n'취소 선택 시 매크로 종료\nr = 1\n'r에 1을 넣음\nFor i = 1 To UBound(varFiles)\n'선택한 파일 개수만큼 반복\nOpen varFiles(i) For\nInput As #1\n'각 파일을 열기\nintNo =\nInStrRev\n(varFiles(i), \"\\\")\n' \\위치를 찾아서 변수에 넣음\nstrName = Right(varFiles(i), Len(varFiles(i)) - intNo)\n'파일 이름만 추출해 변수에 넣음\nDo While Not EOF(1)\n'파일의 마지막 행이 될때까지 반복\ny = y + 1\n'텍스트 파일의 행위치 넣을 변수\nLine Input\n#1, strInput\n'각 행의 문자를 strInput에 넣음\nIf\nInStr\n(1, strInput, strFind) Then\n'각 행이 찾으려는 문자를 포함한 경우\nvarTemp =\nSplit\n(strInput, \",\")\n'각 행의 문자를 콤마(,)로 나누어 배열에 넣음\nFor j = LBound(varTemp) To UBound(varTemp)\n'배열 개수만큼 반복\nIf varTemp(j) = strFind Then\n'배열내 값이 strFind와 일치 시\nblnTF = True\n'blnTrue 값을 참으로\nr = r + 1\n'행을 1씩 늘려감\nCells(r, 1).Resize(, UBound(varTemp) + 1) = varTemp '배열값을 셀에 뿌림\nCells(r, UBound(varTemp) + 2) = strName\n'텍스트 파일의 파일 이름을 입력\nCells(r, UBound(varTemp) + 3) = y\n'텍스트 파일의 행을 입력\nExit For\n'For 구문 종료\nEnd If\nNext j\nEnd If\nLoop\ny = 0\n'재사용 위하여 초기화\nClose #1\n'열린 파일을 닫음\nNext i\nIf blnTF = True Then\n'값이 1개라도 있을 경우(일치값 없어 에러나는것 방지)\nWith Columns(\"A:E\").SpecialCells(2)\n'A:E 열 문자에서\nFor Each rngC In .Cells\n'각 셀을 순환\nWith rngC\n'각 셀에서\n.Value = .Value\n'문자로 입력된 값을 숫자로 바꾸어 입력\nEnd With\nNext rngC\n.\nFormatConditions\n.Add Type:=xlCellValue, Operator:=xlEqual, _\nFormula1:=\"=\" & strFind\n'strFind를 포함한 문자에 조건부 서식을 적용\n.FormatConditions(1).Interior.\nColorIndex = 6\n'조건 일치한 셀을 노란색으로 채움\nEnd With\nElse\n'일치하는 값을 없을 경우\nMsgBox \"일치하는 값이 없습니다.\"\n'메시지 출력\nEnd If\nColumns.AutoFit\n'열너비 자동 맞춤\nEnd Sub", "context": "아래의 예제는 .csv(Comma Delimited) 파일 즉, 데이터와 데이터가 콤마(,)로 구분된 파일에서 특정 값이 들어간 행만 가져오는 기능이다. 요즘 텍스트파일 관련 공부를 하고 있어서 연습해본 내용. 만일 공백(space)이나 탭(tab)으로 구분된 텍스트 파일이라면 아래 코드에서 Split을 사용하는 행의 구분자(delimiter)를 적절히 수정해야 한다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1044) 텍스트 파일에서 특정값이 들어 있는 행만 가져오기 (엑셀 VBA 매크로)\n재생\n3,549\n재생 (space/k)\n재생\n00:30\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:30\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기..."}
{"instruction": "Excel VBA code for: (1045) 폴더내 텍스트 파일 특정행만 불러오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub import_Specific_Rows_Only()\nConst\nlngFrom As Long =\n11\n'텍스트 파일 불러올 시작행을 넣을 변수\nConst\nlngTo As Long =\n20\n'텍스트 파일 불러올 마지막행을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim objFSO As Object\n'파일시스템 개체를 넣을 변수\nDim objFile As Object\n'파일을 넣을 변수\nDim r As Long\n'행을 늘려갈 변수\nDim varTemp As Variant\n'각 행을 콤마(,)로 나누어 넣을 배열변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.ClearContents\n'기존 데이터 삭제\nSet objFSO =\nCreateObject(\"Scripting.FileSystemObject\")\n'파일시스템 개체를 생성\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName = Dir(strPath & \"*.csv\")\n'(폴더내)각 csv파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, csv파일이 존재하면\nSet objFile = objFSO.\nOpenTextFile\n(fileName:=strPath & fileName, _\nIOMode:=1, Create:=False, Format:=-2)\n'csv 파일을 열어서 변수에 넣음\nFor r = 1 To lngTo\n'1 ~ 20행까지 반복\nIf Not objFile.\nAtEndOfStream\nThen\n'만일 파일의 제일 마지막행이 아니라면\nIf r < lngFrom Then\n'행이 11보다 작으면\nobjFile.\nSkipLine\n'행을 건너뜀\nElse\n'11 ~ 20 행이라면\nvarTemp =\nSplit\n(objFile.\nReadLine\n, \",\")\n'행을 읽어들이고 문자를 콤마로 나누어 배열에 넣음\nCells(Rows.Count, 1).End(3)(2).Resize(, UBound(varTemp) + 1) = varTemp\nEnd If\n'배열로 읽어드린 값을 셀에 뿌림\nEnd If\nNext r\nobjFile.Close\n'파일을 닫음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nFor Each rngC In ActiveSheet.UsedRange '\n(읽어들인 숫자가 문자이므로)문자를 숫자로 변환\nWith rngC\n'각 셀에서\n.Value = .Value\n'(문자값을 숫자로) 각 셀을 복사\nEnd With\nNext rngC\nSet objFSO = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet objFile = Nothing\nEnd Sub", "context": "폴더내에 있는 텍스트 파일의 특정행만을 불러오는 기능. csv가 아닌 경우 fileName = Dir(strPath & \"*.csv\")에서 \"*.csv\"를 \"*.txt\" 또는 \"*.prn\" 등으로 수정하고,  varTemp = Split(objFile.ReadLine, \",\")에서 텍스트 파일의  \",\" 를 \" \" 또는 vbTab 등으로 수정하면 된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1045) 폴더내 텍스트 파일 특정행만 불러오기 (엑셀 VBA 매크로)\n재생\n2,447\n재생 (space/k)\n재생\n00:31\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:31\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합..."}
{"instruction": "Excel VBA code for: (1046) 특정 개수씩 문자 합치기 (엑셀 VBA 매크로)", "input": "", "output": "Sub join_With_Comma()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim colsCnt As Integer\n'각 행을 합칠 개수 넣을 변수\nDim rowsCnt As Long\n'문자를 합친 뒤 생성될 행의 개수넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim i As Long\n'전체행 / 열개수 + 1만큼 반복할 변수\nDim j As Integer\n'합칠 행의 개수만큼 반복할 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim strU As String\n'문자를 합쳐갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'마지막 행을 변수에 넣음\ncolsCnt =\n5\n'합칠 행의 개수\nrowsCnt =\nInt\n(lastRow / colsCnt) + 1\n'문자 합친 뒤 생성될 행의 개수\nReDim\nvarTemp(1 To lastRow, 1 To 1)\n'배열크기 재지정\nFor i = 1 To rowsCnt\n'1 ~ 전체행을 colsCnt로 나눈 개수만큼 반복\nFor j = 1 To colsCnt\n'1 ~ colsCnt 만큼 반복\nr = r + 1\n'행을 1씩 늘려감\nIf strU = \"\" Then\n'strU가 비어 있으면\nstrU = Cells(r, 1)\n'셀값만 넣고\nElse\n'strU가 비어 있지 않다면\nstrU = strU & \",\" & Cells(r, 1)\n'strU + 콤마(,) + 셀값을 넣음\nEnd If\nNext j\nvarTemp(i, 1) = strU\n'합친 문자를 배열에 넣음\nstrU = vbNullString\n'재사용 위하여 초기화\nNext i\nCells(1, 2).Resize(rowsCnt) = varTemp\n'배열내 값을 셀에 입력\nColumns(\"B\").AutoFit\n'B열 열너비 자동맞춤\nEnd Sub", "context": "매크로 실행 전                              colsCnt =\n5\n으로 매크로 실행하였을 때의 결과\ncolsCnt =\n3\n으로 매크로 실행하였을 때의 결과\nOption Explicit\nSub join_With_Comma()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim colsCnt As Integer\n'각 행을 합칠 개수 넣을 변수\nDim rowsCnt As Long\n'문자를 합친 뒤 생성될 행의 개수넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim i As Long\n'전체행 / 열개수 + 1만큼 반복할 변수\nDim j As Integer\n'합칠 행의 개수만큼 반복할 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim strU As String\n'문자를 합쳐갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, 1)...."}
{"instruction": "Excel VBA code for: (1047) 문자열 유지하면서 데이터 통합 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub improved_Data_Consolidate()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim v As Long\n'배열 위치 1씩 늘려갈 변수\nDim varTemp\n'배열로 사용할 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'중복개수 구할 변수\nDim j As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = ActiveSheet.UsedRange\n'전체데이터 영역을 변수에 넣음\nrowsCnt = rngAll.\nRows.Count\n'전체 행개수를 변수에 넣음\ncolsCnt = rngAll.\nColumns.Count\n'전체 열개수를 변수에 넣음\nr = 2\n'2행부터 시작\nReDim\nvarTemp(1 To rowsCnt, 1 To colsCnt)\n'배열크기 재지정\nDo\n'다음을 실행\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'위아래 셀값이 같다면\ni = i + 1\n'중복개수를 1씩 늘려감\nElse\nv = v + 1\n'배열 위치 1씩 늘려감\nFor j = 1 To 2\n'문자 있는 열(A:B열)을 반복\nvarTemp(v, j) = Cells(r, j)\n'배열에 문자를 넣음\nNext j\nFor j = 3 To colsCnt\n'숫자 있는 열(C:D)열을 반복\nvarTemp(v, j) =\nWorksheetFunction\n.\nSum\n(Cells(r, j).Offset(-i).Resize(i + 1))\nNext j\n'배열에 중복된 값을 합쳐감\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until Cells(r, 1) = \"\"\n'A열에 빈셀이 나올때까지 무한 반복\nWith Sheets(2)\n'Sheet2 에서\nRows(1).SpecialCells(2).\nCopy\n.Cells(1, 1)\n'제목복사\n.Cells(2, 1).Resize(\nUBound\n(varTemp, 1), colsCnt) = varTemp\n'배열 값을 셀에 뿌림\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\n'메시지 출력\nEnd Sub", "context": "상당히 맘에드는 코드이다. 기존의 문자를 유지하면서 데이터통합(Consolidate)을 할 수 있다. 제대로 하려면 SQL 집계함수의 사용이 정답이겠지만 동영상에서 보는 바와 같이 왠만한 것은 엑셀로 충분히 할 수 있다. 행삭제를 전혀 하지 않으므로 상당히 빠른편이며 내 컴퓨터로\n50,000행에 1.25초 정도가 소요\n된다. Transpose를 사용하면 65536개의 행으로 제한되므로 약간은 비효율적이지만 동적배열이 아닌 전체 행 개수만한 2차원 정적배열에 넣어 행의 제한을 없앴다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1047) 문자열 유지하면서 데이터 통합 1 (엑셀 VBA 매크로)\n재생\n1,926\n공유하기\n재생 (space/k)\n재생\n00:33\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:33\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 ..."}
{"instruction": "Excel VBA code for: (1049) 열을 기준으로 데이터 재배치 (엑셀 VBA 매크로)", "input": "", "output": "Sub reLocate_ColumnWise()\nDim varTemp()\n'정적배열로 사용할 변수\nDim i As Long\n'전체 열 개수만큼 반복할 변수\nDim rngC As Range\n'(빈 셀이 아닌)각 셀을 넣을 변수\nDim r As Long\n'배열크기 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith ActiveSheet.UsedRange\n'현재 사용영역에서\nReDim varTemp(1 To\nWorksheetFunction.CountA\n(.\nCells\n), 1 To 1)\n'배열크기를 값이 들어간 전체셀 개수로 크기 재지정\nFor i = 1 To .Columns.Count\n'1~ 전체 열 개수만큼 반복\nFor Each rngC In .Columns(i).Cells\n'각 열의 각 셀을 순환\nIf\nNot IsEmpty\n(rngC) Then\n'각 셀이 빈셀이 아니라면\nr = r + 1\n'배열크기 1씩 늘려감\nvarTemp(r, 1) = rngC\n'배열에 셀값을 넣음\nEnd If\nNext rngC\nNext i\nSheets.Add after:=Sheets(ActiveSheet.\nIndex\n)\n'현재시트 바로 뒤에 시트 추가\nEnd With\nCells(1, 1).Resize(\nUBound\n(varTemp, 1)) = varTemp\n'배열값을 셀에 뿌림\nEnd Sub", "context": "이와 유사한 코드는 벌써 수십번 한 것 같다. 전형적으로 아래와 같은 방식을 사용한다.\n1) 데이터영역을 행 또는 열 방향으로 선택\n2) For Each ... Next 구문을 사용하여 각 셀을 순환\n3) 동적/정적 배열크기를 1씩 늘려가며 각 셀을 배열에 넣음\n4) Resize(Ubound(배열)) 방식을 이용하여 배열내 값을 셀에 뿌림\n매크로 실행 전                                                       매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub reLocate_ColumnWise()\nDim varTemp()\n'정적배열로 사용할 변수\nDim i As Long\n'전체 열 개수만큼 반복할 변수\nDim rngC As Range\n'(빈 셀이 아닌)각 셀을 넣을 변수\nDim r As Long\n'배열크기 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWit..."}
{"instruction": "Excel VBA code for: (1050) 하위 폴더까지 모두 순환하는 기본코드 (엑셀 VBA 매크로)", "input": "", "output": "Sub loop_Through_All_Folders()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n'----------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'----------------------------------------------\nChDir ThisWorkbook.Path\n'매크로 실행파일과 동일한 경로 기준\nWith Application.FileDialog(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'--------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'--------------------------------\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nWith ActiveSheet\n'활성화된 시트에서\n.UsedRange.Clear\n'기존 데이터 삭제\n.Range(\"A1:F1\") = Array(\"Path\", \"Name\", \"File Size\", \"FolderSize\", \"subFolders\", \"File\")\nEnd W\n﻿\nith\n'필드제목 입력\neachFolder strPath\n'eachFolder 코드를 호출\nColumns.AutoFit\n'열너비 자동맞춤\nEnd Sub\n\nPrivate Function eachFolder(mainFolder As String)\nDim fSO As Scripting.FileSystemObject\n'FileSystemObject를 넣을 변수\nDim fldName As Scripting.Folder\n'상위폴더 전체경로(마지막이 \"\\\")를 넣을 변수\nDim subFolder As Scripting.Folder\n'하위폴더 넣을 변수\nDim rngT As Range\n'복사될 위치 넣을 변수\nDim wkBk As Workbook\n'각 파일을 넣을 변수\nDim wkSht As Worksheet\n'각 시트를 넣을 변수\nDim fileName As Object\n'각 파일의 이름(확장자포함)을 넣을 변수\nSet fSO = New Scripting.FileSystemObject\n'새로운 파일시스템개체를 변수에\nSet fldName = fSO.GetFolder(mainFolder)\n'선택한 폴더의 이름을 변수에 넣음\nFor Each fileName In fldName.Files\n'폴더내 각 파일을 순환\nIf InStr(fileName, \".\nxlsx\n\") Then\n'파일이 엑셀 파일이면\nSet rngT = Cells(Rows.Count, \"A\").End(3)(2)\n'복사될 지점을 변수에 넣음\nWith fldName\n'각 폴더에서\nrngT = .Path\n'파일 경로를 입력\nrngT(1, 2) = fileName.Name\n'파일이름을 입력\nrngT(1, 3) = fileName.Size\n'파일크기를 입력\nrngT(1, 4) = .Size\n'폴더크기를 입력\nrngT(1, 5) = .SubFolders.Count\n'하위폴더 개수를 입력\nrngT(1, 6) = .Files.Count\n'각 폴더내 파일개수 입력\nEnd With\nSet wkBk = Workbooks.Open(fileName)\n'파일을 열고 변수에 넣음\nFor Each wkSht In wkBk.Worksheets\n'열린파일 각 시트를 순환\n'자신이 하고 싶은 작업을 입력\nNext wkSht\nwkBk.Close False\n'열려진 파일을 닫음\nEnd If\nNext fileName\nFor Each subFolder In fldName.SubFolders\n'각 폴더의 하위폴더를 순환\neachFolder subFolder.Path\n'각 폴더경로로 eachFolder함수호출\nNext subFolder\nSet fSO = Nothing\nSet fldName = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngT = Nothing\nSet wkBk = Nothing\nEnd Function\n\nPrivate Function eachFolder(mainFolder As String)\nDim fSO As Scripting.FileSystemObject\n'FileSystemObject를 넣을 변수\nDim fldName As Scripting.Folder\n'상위폴더 전체경로(마지막이 \"\\\")를 넣을 변수\nDim subFolder As Scripting.Folder\n'하위폴더 넣을 변수\nDim rngT As Range\n'복사될 위치 넣을 변수\nDim wkBk As Workbook\n'각 파일을 넣을 변수\nDim wkSht As Worksheet\n'각 시트를 넣을 변수\nDim fileName As Object\n'각 파일의 이름(확장자포함)을 넣을 변수\nSet fSO = New Scripting.FileSystemObject\n'새로운 파일시스템개체를 변수에\nSet fldName = fSO.GetFolder(mainFolder)\n'선택한 폴더의 이름을 변수에 넣음\nFor Each fileName In fldName.Files\n'폴더내 각 파일을 순환\nSet rngT = Cells(Rows.Count, \"A\").End(3)(2)\n'복사될 지점을 변수에 넣음\nWith fldName\n'각 폴더에서\nrngT = .Path\n'파일 경로를 입력\nrngT(1, 2) = fileName.Name\n'파일이름을 입력\nrngT(1, 3) = fileName.Size\n'파일크기를 입력\nrngT(1, 4) = .Size\n'폴더크기를 입력\nrngT(1, 5) = .SubFolders.Count\n'하위폴더 개수를 입력\nrngT(1, 6) = .Files.Count\n'각 폴더내 파일개수 입력\nEnd With\nNext fileName\nFor Each subFolder In fldName.SubFolders\n'각 폴더의 하위폴더를 순환\neachFolder subFolder.Path\n'각 폴더경로로 eachFolder함수호출\nNext subFolder\nSet fSO = Nothing\nSet fldName = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngT = Nothing\nSet wkBk = Nothing\nEnd Function", "context": "메인폴더 및 하위 폴더를 포함한 작업을 위해 미리 코드를 작성해 보았음. 현재는 모든 엑셀(*.xls*) 파일만을 불러오도록 되어 있음. 텍스트 파일과 같은 다른 종류의 파일 불러올 경우 아래의 fileName = Dir(strFolder & \"\\\" &\n\"*.xls*\"\n) 에서 확장자를 수정해야함.\n매크로 실행 전 엑셀창에서 Alt + F11 클릭하고 매크로 창으로 들어간 뒤 윗 그림과 같이\nMicrosoft Scripting Runtime\n을 미리 활성화 하여야 함.\nOption Explicit\nSub loop_Through_All_Folders()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n'----------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'-------------------..."}
{"instruction": "Excel VBA code for: (1052) 중복없이 오름차순으로 정렬하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Dupes_And_Sort()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp As Variant\n'중복제거한 숫자를 넣을 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"B\").ClearContents\n'기존 B열의 데이터 삭제\nSheets(2).UsedRange.ClearContents\n'기존 데이터 삭제\nFor Each rngC In Columns(\"A\").SpecialCells(2)\n'A열의 각 셀을 순환\nWith Sheets(2)\n'Sheet2에서\nvarTemp =\nSplit\n(rngC, \",\")\n'배열에 각 셀을 콤마로 나누어 넣음\n.Cells(1, 1).Resize(UBound(varTemp) + 1) = _\nApplication.\nTranspose\n(varTemp)\n'배열값을 Sheet2에 뿌림\nWith .UsedRange\n'사용 영역에서\n.\nRemoveDuplicates\n1, Header:=xlNo\n'중복제거\n.SpecialCells(2).\nSort\n.Cells(1, 1), 1\n'오름차순으로 정렬\nEnd With\nReDim\nvarTemp(1 To .Columns(1).SpecialCells(2).Count)\n'배열크기 재지정\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nvarTemp(r) = .Cells(r, 1)\n'배열에 각 셀값을 넣음\nLoop Until\n.Cells(r + 1, 1) = \"\"\n'A열에 빈셀이 나올때까지 무한반복\nEnd With\nr = 0\n'재사용 위하여 초기화\nrngC.Next =\nJoin\n(varTemp, \",\")\n'각 셀의 오른쪽에 배열값을 콤마로 합쳐 넣음\nNext rngC\nColumns(\"B\").AutoFit\n'B열 열너비 자동맞춤\nEnd Sub", "context": "매크로 실행 전                                                         매크로 실행 후 결과\nOption Explicit\nSub remove_Dupes_And_Sort()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp As Variant\n'중복제거한 숫자를 넣을 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"B\").ClearContents\n'기존 B열의 데이터 삭제\nSheets(2).UsedRange.ClearContents\n'기존 데이터 삭제\nFor Each rngC In Columns(\"A\").SpecialCells(2)\n'A열의 각 셀을 순환\nWith Sheets(2)\n'Sheet2에서\nvarTemp =\nSplit\n(rngC, \",\")\n'배열에 각 셀을 콤마로 나누어 넣음\n.Cells(1, ..."}
{"instruction": "Excel VBA code for: (1053) 중복없는 숫자만 오름차순 정렬하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Dupes_And_Sort2()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp As Variant\n'중복제거한 숫자를 넣을 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim rngAll As Range\n'Sheet2 전체 사용영역 넣을 변수\nDim rngEach As Range\n'Sheet2 각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"B\").ClearContents\n'기존 B열의 데이터 삭제\nFor Each rngC In Columns(\"A\").SpecialCells(2)\n'A열의 각 셀을 순환\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nvarTemp =\nSplit\n(rngC, \",\")\n'배열에 각 셀을 콤마로 나누어 넣음\n.Cells(1, 1).Resize(UBound(varTemp) + 1) = _\nApplication.\nTranspose\n(varTemp)\n'배열값을 Sheet2에 뿌림\nSet rngAll = .UsedRange.SpecialCells(2)\n'Sheet2 사용영역 문자셀을 변수에 넣음\nFor Each rngEach In rngAll\n'Sheet2 사용영역 각셀을 순환\nrngEach.Next =\nWorksheetFunction\n.\nCountIf\n(rngAll, rngEach)\n'각 셀의 오른쪽에 중복개수 입력\nNext rngEach\n.UsedRange.\nSort\n.Cells(1, 2), 1\n'Sheet2 사용영역 B열기준 오름차순으로 정렬\nIf .Cells(1, 2) = 1 Then\n'B1셀이 1이라면\nOn Error\nResume Next\n'에러 발생해도 다음코드 진행\n.Columns(\"B\").SpecialCells(2).\nColumnDifferences\n([B1]).EntireRow.ClearContents\n'B열에서 B1셀과 다른셀의 전체행을 삭제\nIf\nErr <> 0\nThen\n'(B열이 모두 1이어서 중복 없어)에러 발생 시\nErr.Clear\n'에러를 제거\nEnd If\nOn Error GoTo 0\n'에러 검출기능 복원\n.UsedRange.Sort .Cells(1, 1), 1\n'Sheet2 A열 오름차순으로 정렬\nReDim varTemp(1 To .Columns(1).SpecialCells(2).Count)\n'배열크기 재지정\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nvarTemp(r) = .Cells(r, 1)\n'배열에 각 셀값을 넣음\nLoop Until\n.Cells(r + 1, 1) = \"\"\n'A열에 빈셀이 나올때까지 무한반복\nr = 0\n'재사용 위하여 초기화\nrngC.Next =\nJoin\n(varTemp, \",\")\n'각 셀의 오른쪽에 배열값을 콤마로 합쳐 넣음\nEnd If\nEnd With\nNext rngC\nColumns(\"B\").AutoFit\n'B열 열너비 자동맞춤\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                                         매크로 실행 후 결과\nOption Explicit\nSub remove_Dupes_And_Sort2()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp As Variant\n'중복제거한 숫자를 넣을 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim rngAll As Range\n'Sheet2 전체 사용영역 넣을 변수\nDim rngEach As Range\n'Sheet2 각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"B\").ClearContents\n'기존 B열의 데이터 삭제\nFor Each rngC In Columns(\"A\").SpecialCells(2)\n'A열의 각 셀을 순환\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearConte..."}
{"instruction": "Excel VBA code for: (1054) 시트(탭)에 각 월의 일자 생성하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub list_Up_Dates()\nDim dteS As\nDate\n'시작(S)tart 일을 넣을 변수\nDim dteF As Date\n'종료(F)inish 일을 넣을 변수\nDim s As Integer\n'각 시트를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor s = Sheets.Count To 2\nStep -1\n'시트의 개수에서 1씩 줄여감\nApplication.\nDisplayAlerts = False\n'화면경고 중지\nSheets(s).Delete\n'(임시로 생성한) 시트 삭제\nApplication.DisplayAlerts = True\n'화면 경고 복원\nNext s\ndteS =\nDateSerial\n(Cells(1, 1), Cells(1, 2), 1)  '\n시작일\ndteF = DateSerial(Cells(1, 1), Cells(1, 2) + 1, 1)\n'종료일\nActiveSheet.UsedRange.Copy\n'활성화된 시트 사용영역 복사\nDo\n'다음을 실행\nSheets.Add after:=Sheets(Sheets.Count)\n'시트를 마지막 시트뒤에 추가\nActiveSheet.Name =\nFormat\n(dteS, \"d\" & \"일\")\n'시트이름을 일자로 바꿈\nActiveSheet.Paste\n'각 시트에 복사한 내용 붙여넣기\ndteS = dteS + 1\n'날짜를 1씩 늘려감\nLoop Until\ndteF = dteS\n'시작일이 종료일이 될때까지 무한반복\nApplication.CutCopyMode = False\n'붙여넣기/복사 모드 해제\nSheets(1).Activate\n'Main 시트를 활성화\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1054) 시트(탭)에 각 월의 일자 생성하기 (엑셀 VBA 매크로)\n재생\n1,082\n재생 (space/k)\n재생\n00:27\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:27\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\nOption Explicit\nSub list_Up_Dates()\nDim dteS As\nDate\n'시작(S)tart 일을 넣을 변수\nDim dteF As D..."}
{"instruction": "Excel VBA code for: (1055) 행열 변환하여 데이터 재배치하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_With_Transpose()\nDim colsCnt As Integer\n'전체 사용영역의 열 개수 넣을 변수\nDim varT As\nVariant\n'각 제목(T)itle 넣을 변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim varR As Variant\n'각 행(R)ow 넣을 변수\nDim rngT As Range\n'복사될 타겟(T)arget 지점을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nvarT = Range(\"B1\", Cells(1, Columns.Count).End(1))\n'제목행을 배열에 넣음\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'현재시트 사용영역 열개수를 변수에 넣음\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'제목뺀 A열 각 셀을 순환\nvarR = Range(rngC.Next, rngC.\nNext.End(2)\n)\n'각 행의 데이터를 변수에 넣음\nSet rngT = .Cells(Rows.Count, \"A\").End(3)(2)\n'Sheet2의 복사될 지점을 변수에 넣음\nrngT.Resize(colsCnt - 1) = rngC\n'이름 복사\nWith Application\nrngT.Next.Resize(colsCnt - 1) = .\nTranspose\n(varT)\n'제목을 복사\nrngT.Offset(, 2).Resize(colsCnt - 1) = .Transpose(varR)\n'각 행의 데이터를 복사\nEnd With\nNext rngC\n.Rows(1).Delete\n'빈행 삭제\nEnd With\nSet rngT = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "행과 열이 늘어나도 아래의 규칙을 가지고 데이터를 재배치한다.\n매크로 실행 전 (Sheet2는 비어 있는 상태)                        매크로 실행 후 결과\nOption Explicit\nSub copy_With_Transpose()\nDim colsCnt As Integer\n'전체 사용영역의 열 개수 넣을 변수\nDim varT As\nVariant\n'각 제목(T)itle 넣을 변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim varR As Variant\n'각 행(R)ow 넣을 변수\nDim rngT As Range\n'복사될 타겟(T)arget 지점을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nvarT = Range(\"B1\", Cells(1, Columns.Count).End(1))\n'제목행을 배열에 넣음\ncolsCnt = ActiveSheet.UsedRange.Columns.Count..."}
{"instruction": "Excel VBA code for: (1056) 셀안의 숫자 만큼 행삽입 후 복사하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Rows_As_Numbered3()\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim varTemp()\n'데이터 넣을 배열 변수\nDim c As Integer\n'열 반복에 사용할 변수\nDim y As Long\n'행을 늘려갈 변수\nDim r As Integer\n'배열내 행 늘려갈 변수\nDim i As Integer\n'4회 반복에 사용할 변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\ncolsCnt = ActiveSheet.UsedRange.Columns.Count + 1\n'열 개수 + 1을 변수에 넣음\nReDim\nvarTemp(1 To Application.\nSum\n(Columns(colsCnt - 1)), 1 To colsCnt)\n'배열크기 재지정\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\n.Columns(colsCnt).\nNumberFormat\n= \"@\"\n'D열 서식을 텍스트로\nFor Each\nrngC\nIn\nRange(Cells(1, colsCnt - 1), _\nCells(Rows.Count, colsCnt - 1).End(3))\n'C열 각 셀을 순환\ny = y + 1\n'행을 1씩 늘려감\nFor c = 1 To rngC\n'각 셀의 숫자만큼 반복\nr = r + 1\n'배열내의 행 1씩 늘려감\nFor i = 1 To colsCnt\n'4회 반복\nIf i <> colsCnt Then\n'i가 4가 아니면\nvarTemp(r, i) = Cells(y, i)\n'각 행의 값을 배열에 입력\nElse\n'i가 4일 경우\nvarTemp(r, i) = c & \"/\" & rngC\n'슬래시와 함께 값을 입력\nEnd If\nNext i\nNext c\nNext\nrngC\n.Cells(1, 1).Resize(\nUBound\n(varTemp, 1), UBound(varTemp, 2)) = varTemp\n'배열내 값을 셀에 뿌림\n.Columns.AutoFit\n'열너비 자동맞춤\nEnd With\nEnd Sub", "context": "1. C열의 번호 숫자대로 행을 늘려서 복사\n2. D열에 C열의 숫자를 분수로 표기\n3. 중간에 품목명이 늘어나도, 즉 열 개수 늘어나도, 이를 반영하여 분수로 표기되도록 함.\n단 개수는 제일 마지막 열에 있어야 함.\n매크로 실행 전 (Sheet2는 비어 있음)                     매크로 실행 후 결과\nOption Explicit\nSub insert_Rows_As_Numbered3()\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim varTemp()\n'데이터 넣을 배열 변수\nDim c As Integer\n'열 반복에 사용할 변수\nDim y As Long\n'행을 늘려갈 변수\nDim r As Integer\n'배열내 행 늘려갈 변수\nDim i As Integer\n'4회 반복에 사용할 변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nc..."}
{"instruction": "Excel VBA code for: (1057) 추가된 데이터 각 파일에 업데이트 하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Matching_Date_And_Update()\nDim strPath As String\n'매크로 실행파일의 경로를 넣을 변수\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim colsCnt As Integer\n'전체영역의 열 개수를 넣을 변수\nDim rowsCnt As Long\n'전체영역의 행 개수를 넣을 변수\nDim rngA2 As Range\n'A2셀을 넣을 변수\nDim strName As String\n'파일 이름을 넣을 변수\nDim wkBk As Workbook\n'파일을 넣을 변수\nDim C As Range\n'검색하여 찾은 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nstrPath = ThisWorkbook.\nPath\n& \"\\\"\n'매크로 실행파일의 경로를 변수에 넣음\nstrName = Range(\"A1\") & \".xlsx\"\n'A1셀 + .xlsx 를 변수에 넣음\nIf\nLen\n(\nDir\n(strPath & strName))\n<> 0\nThen\n'만약 파일이 존재한다면\nSet wkBk = Workbooks.Open(strPath & strName)\n'파일을 열고 변수에 넣음\nSet rngA2 = Range(\"A2\")\n'A2셀을 변수에 넣음\nWindows\n(2).Activate\n'매크로 실행 파일을 활성화\nSet C = Columns(\"A\").\nFind\n(rngA2, , , xlWhole)\n'A2셀과 일치하는 값을 찾아 변수에 넣음\nIf Not C Is Nothing Then\n'만일 일치하는 데이터가 있으면\nIf C.Row <> 4 Then\n'일치한 날짜가 4행 아니면(업데이트할 데이터 있으면)\nC.Offset(-C.Row + 4).Resize(C.Row - 4, 4).\nEntireRow\n.\nCopy\n'일치날짜 윗 데이터 복사\nWindows(2).Activate\n'열은 파일을 활성화\nRows(\"2:2\").\nInsert\nShift:=xlDown\n'복사한 데이터를 붙여넣기\nApplication.CutCopyMode = False\n'자르기/붙여넣기 모드를 해제\nwkBk.Save\n'파일을 저장\nEnd If\nEnd If\nwkBk.Close\n'파일을 닫음\nElse\n'파일이 존재하지 않을 경우\nSet rngAll = [A3].CurrentRegion\n'A3과 연결된 현재영역을 변수에 넣음\ncolsCnt = rngAll.Columns.Count\n'현재영역의 열 개수를 변수에 넣음\nrowsCnt = rngAll.Rows.Count\n'현재영역의 행 개수를 변수에 넣음\nSet wkBk = Workbooks.Add\n'새로운 파일을 추가하고 변수에 넣음\nCells(1, 1).Resize(rowsCnt, colsCnt) = rngAll.Value\n'현재영역을 복사\nwkBk.\nSaveAs\nFilename:=strPath & strName\n'새로운 이름으로 파일 저장\nwkBk.\nClose\n'파일을 닫음\nEnd If\nSet wkBk = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngA2 = Nothing\nSet C = Nothing\nSet rngAll = Nothing\nEnd Sub", "context": "이 기능을 요청하신 분이 2000 개의 파일이 있으며 A1셀에 For Each ...Next 구문을 이용하여 파일이름을 바꾸며 아래의 코드를 실행하려고 함.\nA1셀과 일치하는 파일이 없을 경우 매크로 실행파일의 데이터를 새로운 파일에 복사하고 A1셀을 파일 이름으로 저장.\nA1셀과 일치하는 파일이 있을 경우, 파일을 열어 A2셀과 일치하는 날짜를 매크로 실행파일의 A열에서 찾아 윗줄에 있는 데이터들을 새로 열은 파일에 업데이트(추가).\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1057) 추가된 데이터 각 파일에 업데이트 하기 (엑셀 VBA 매크로)\n재생\n1,007\n재생 (space/k)\n재생\n00:36\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:36\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막..."}
{"instruction": "Excel VBA code for: (1058) 엑셀파일을 .pdf로 인쇄하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub print_As_PDF()\nDim strPath As String\n'파일 경로를 넣을 변수\nDim strName As String\n'파일 이름을 넣을 변수\nDim fName As String\n'파일경로 포함한 파일이름 넣을 변수\nDim hpBreaks As Long\n'가로 페이지 나누기 개수 넣을 변수\nDim vpBreaks As Integer\n'세로 페이지 나누기 개수 넣을 변수\nDim totalPages As Long\n'전체 페이지 개수를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveSheet\nhpBreaks = .\nHPageBreaks\n.Count + 1\n'가로 페이지 나누기 개수를 변수에 넣음\nvpBreaks = .\nVPageBreaks\n.Count\n'세로 페이지 나누기 개수를 변수에 넣음\ntotalPages = hpBreaks * vpBreaks\n'전체 페이지 개수를 변수에 넣음\nstrPath = ActiveWorkbook.Path & \"\\\"\n'파일의 경로를 변수에 넣음\nstrName =\nSplit\n(ActiveWorkbook.Name, \".\")\n(0)\n'파일 이름을 변수에 넣음\nfName = strPath & strName & \"_\" & .Name & \".pdf\"\n'파일경로 포함한 파일이름 넣을 변수\nIf Len(Dir(fName)) <> 0 Then\n'이미 파일이 존재한다면\nIf MsgBox(\"동일한 파일이 존재합니다. 덮어쓸까요?\", _\nvbYesNo + 64, \"파일이름 중복\") = vbNo Then\n'덮어쓰기 여부 메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nEnd If\nOn Error Resume Next\n.ExportAsFixedFormat Type:=\nxlTypePDF\n, Filename:=fName, _\nQuality:=xlQualityStandard, IncludeDocProperties:=True, _\nIgnorePrintAreas:=True,\nFrom:\n=\n1\n,\nto:\n=\ntotalPages\n, OpenAfterPublish:=False\n'파일을 .pdf 파일로 출력\nEnd With\nEnd Sub", "context": "프린터 종류에서 .pdf 인쇄 드라이버를 선택하지 않고 엑셀내의 인쇄 옵션을 사용하여 활성화된 시트를 .pdf 파일로 출력하는 기능. 두 가지의 인쇄 방식에 약간의 차이가 있음을 알게됨.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1058) 엑셀파일을 .pdf로 인쇄하기 (엑셀 VBA 매크로)\n재생\n3,976\n재생 (space/k)\n재생\n00:36\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:36\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세..."}
{"instruction": "Excel VBA code for: (1059) 폴더내 모든 텍스트파일 통합하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub append_Text_Files()\nDim strAll As String\n'통합파일을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strInput As String\n'각 행을 읽어서 저장할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.ClearContents\n'기존 데이터 삭제\nstrAll = Application.\nGetOpenFilename\n(\"Text Files (*.txt),*.txt\", , _\n\"텍스트파일을 선택\", MultiSelect:=False)\n'텍스트 파일을 선택\nIf strAll = \"False\" Then Exit Sub\n'취소 선택 시 매크로 종료\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf\n.SelectedItems.Count = 0\nThen\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName = Dir(strPath & \"*.txt*\")\n'(폴더내)각 텍스트파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nOn Error\nGoTo errHandler\n'에러 발생시 errHandler로 이동\nOpen strAll For\nAppend\nAs #1\n'통합 파일에 추가(append)하기위해 파일 열기\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 텍스트파일이 존재하면\nOpen strPath & fileName For Input As #2\n'각 파일을 열기\nDo While\nNot EOF(2)\n'파일의 마지막 행이 아니면 무한 반복\nLine Input\n#2, strInput\n'각 파일의 각 행을 읽음\nPrint #1\n, strInput\n'각 파일의 각 행을 출력(통합파일에 추가)\nLoop\n'무한 반복\nClose #2\n'파일 닫기\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\ncloseAll:\n'모든파일 닫기\nClose #1\n'통합파일 닫기\nWith ActiveSheet.\nQueryTables.Add\n(Connection:= _\n\"TEXT;\" & strAll, Destination:=Range(\"$A$1\"))\n'통합파일을 열기\n.\nTextFileCommaDelimiter\n= True\n'콤마로 구분된 텍스트파일\n.Refresh BackgroundQuery:=False\n'쿼리 배경 refresh 안함\nEnd With\nExit Sub\n'매크로 종료\nerrHandler:\n'에러 처리구문\nMsgBox \"Error # \" & Err & \": \" & Error(Err)\n'발생한 에러 메시지 창에 출력\nResume\ncloseAll\n'closeAll을 재실행\nEnd Sub", "context": "여러 텍스트 파일이 있을 경우 이를 통합하기 위하여 각 파일을 엑셀에 불러들여 통합할 수도 있지만 아래는 텍스트의 Append를 이용하여 텍스트 파일들을 통합하는 기능.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1059) 폴더내 모든 텍스트파일 통합하기 (엑셀 VBA 매크로)\n재생\n2,308\n재생 (space/k)\n재생\n00:40\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:40\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기..."}
{"instruction": "Excel VBA code for: (1061) 3열로 공백을 채워서 인쇄하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub change_Into_3_Columns()\nConst\nrowsCnt As Integer =\n42\n'반복하여 복사될 행 개수 넣을 변수\nConst colsCnt As Integer =\n4\n'반복하여 복사될 열 개수 넣을 변수\nDim lastRow As Long\n'마지막행 넣을 변수\nDim r As Long\n'행을 늘려갈 변수\nDim c As Integer\n'열을 늘려갈 변수\nDim y As Long\n'Sheet2에서 행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, \"A\").End(3)\n'마지막 행을 변수에 넣음\ny = 2\n'(Sheet2) 2행 부터 시작\nWith Sheets(2)\n'Sheet2에서\n.Range(\"D:D, H:H\").\nColumnWidth\n= 1.5\n'D, H열 열너비 1.5로 설정\n.Range(\"A:C, E:F, I:K\").ColumnWidth = 7.5\n'A:C, E:F, I:K 열너비 7.5로\n.PageSetup.\nPrintTitleRows\n= \"$1:$1\"\n'1행을 각 페이지 제목으로 반복사용\n.UsedRange.Clear\n'기존 데이터 삭제\nFor c = 1 To colsCnt\n* 3 Step colsCnt\n'colsCnt * 3 회 만큼 반복\nRange(\"A1:C1\").Copy .Cells(1, c)\n'제목 복사\nNext c\nFor r = 1 To lastRow Step rowsCnt\n'마지막을 행까지 rowsCnt행씩 건너뛰며 반복\nFor c = 1 To colsCnt * 3 Step colsCnt\n'열개수 * 3 까지 3씩 건너 뛰며 반복\n.Cells(Rows.Count, c).End(3)(2).Resize(rowsCnt, colsCnt) = _\nCells(y, 1).Resize(rowsCnt, colsCnt).Value\n'rowsCnt행씩 건너 뛰면서 데이터 복사\ny = y + rowsCnt\n'행을 rowsCnt씩 늘려감\nNext c\n.\nHPageBreaks\n.Add Before:=.Cells(Rows.Count, \"A\").End(3)(2)\n'가로 페이지 구분선 추가\nNext r\nEnd With\nEnd Sub", "context": "엑셀 자료가 1~3열에만 입력되어 이를 인쇄 시 여백이 많이 남아 인쇄용지가 낭비되므로 3열로 데이터를 변환하여 용지를 꽉 채워 인쇄하는 기능.\n매크로 실행 전 (Sheet2는 비어 있는 상태)\n매크로 실행 후 Sheet2에 옮겨진 데이터\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1061) 3열로 공백을 채워서 인쇄하기 (엑셀 VBA 매크로)\n재생\n529\n재생 (space/k)\n재생\n00:32\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:32\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이..."}
{"instruction": "Excel VBA code for: (1062) 2행씩 짝을 유지하며 정렬하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_As_Pair()\nDim varTemp()\n'데이터 넣을 배열 변수\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim r As Long\n'행 늘려갈 변수\nDim c As Integer\n'열 늘려갈 변수\nDim y As Long\n'배열크기 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.\nCopy\nSheets(2).Cells(1, 1)\n'Sheet1 사용영역 Sheet2에 복사\nSheets(2).Activate\n'Sheet2 활성화\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\ncolsCnt = .Columns.Count\n'열개수를 변수에\nrowsCnt = Cells(Rows.Count, 1).End(3).\nRow\n'마지막 행을 변수에 넣음\n.Offset(1).Sort [B2], 1\n'제목뺀 영역 B2셀기준 오름차순 정렬\nEnd With\nReDim\nvarTemp(1 To rowsCnt, 1 To colsCnt)\n'배열크기 재지정\nFor r = 2 To Cells(Rows.Count, \"A\").End(3).Row\n'행을 2부터 1씩 늘려가며 반복\nIf Cells(r, 2) = Cells(r + 1, 2) Then\n'만일 B열 위아래 셀값이 같으면\ny = y + 2\n'배열위치 2씩 늘려감\nFor c = 1 To colsCnt\n'열을 1부터 열개수까지 반복\nvarTemp(y, c) = Cells(r, c)\n'셀에 있는 값을 넣고\nNext c\nElse\n'위아래 셀값이 다를 경우\ny = y + 1\n'배열위치 1씩 늘려감\nFor c = 1 To colsCnt\n'열을 1부터 열개수까지 반복\nvarTemp(y, c) = Cells(r, c)\n'셀에 있는 값을 넣고\nNext c\nEnd If\nNext r\nActiveSheet.UsedRange.Offset(1).ClearContents\n'제목을 제외한 기존 데이터 삭제\nCells(2, 1).Resize(rowsCnt, colsCnt) = varTemp\n'배열값을 셀에 뿌림\nRange(\"A2\").\nEntireRow.Delete\nshift:=xlUp\n'빈행 삭제\nColumns.AutoFit\n'열너비 자동 맞춤\nEnd Sub", "context": "공백을 유지하면서 B열을 기준으로 오름차순으로 같은 이름끼리 2행씩 짝으로 정렬하는 기능\n매크로 실행 전 (Sheet2는 비어 있음)                     매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub sort_As_Pair()\nDim varTemp()\n'데이터 넣을 배열 변수\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim r As Long\n'행 늘려갈 변수\nDim c As Integer\n'열 늘려갈 변수\nDim y As Long\n'배열크기 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.\nCopy\nSheets(2).Cells(1, 1)\n'Sheet1 사용영역 Sheet2에 복사\nSheets(2).Activate\n'Sheet2 활성화\nWith ActiveShe..."}
{"instruction": "Excel VBA code for: (1063) 2행씩 짝을 유지하며 정렬하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_As_Pair2()\nDim rngC As Range\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Cells(1, 1)\n'Sheet1 사용영역 Sheet2에 복사\n.Activate\n'Sheet2 활성화\nEnd With\nActiveSheet.UsedRange.Offset(1).\nSort\n[B2], 1\n'제목뺀 영역 B2셀기준 오름차순 정렬\nFor Each\nrngC\nIn\nRange(\"B2\", Cells(Rows.Count, \"B\").End(3))\n'B열 각셀을 순환\nWith rngC(1, 0).Resize(, 3)\nIf rngC = rngC(2, 1) Then\n'위아래 셀값이 같다면\nCells(Rows.Count, \"A\").\nEnd(3)(3)\n.Resize(, 3) = .Value\n'1칸 띄고 복사\nElse\n'위아래 셀값이 다르면\nCells(Rows.Count, \"A\").\nEnd(3)(2)\n.Resize(, 3) = .Value\n'빈칸 없이 연달아 복사\nEnd If\nEnd With\nNext\nrngC\nRange(\"A1\").CurrentRegion.Offset(1).\nEntireRow.Delete\nshift:=xlUp\n'제목을 제외한 기존 데이터 삭제\nColumns.AutoFit\n'열너비 자동 맞춤\nEnd Sub", "context": "공백을 유지하면서 B열을 기준으로 오름차순으로 같은 이름끼리 2행씩 짝으로 정렬하는 기능\n매크로 실행 전 (Sheet2는 비어 있음)                     매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub sort_As_Pair2()\nDim rngC As Range\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Cells(1, 1)\n'Sheet1 사용영역 Sheet2에 복사\n.Activate\n'Sheet2 활성화\nEnd With\nActiveSheet.UsedRange.Offset(1).\nSort\n[B2], 1\n'제목뺀 영역 B2셀기준 오름차순 정렬\nFor Each\nrngC\nIn\nRange(\"B2\", Cells(Rows.Count, \"B\").End..."}
{"instruction": "Excel VBA code for: (1064) 2행씩 짝을 유지하며 정렬하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_As_Pair3()\nDim r As Long\n'행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Cells(1, 1)\n'Sheet1 사용영역 Sheet2에 복사\n.Activate\n'Sheet2 활성화\nEnd With\nActiveSheet.UsedRange.Offset(1).\nSort\n[B2], 1\n'제목뺀 영역 B2셀기준 오름차순 정렬\nr = 2\n'2행부터 시작\nDo\nCells(Rows.Count, \"A\").\nEnd(3)(3)\n.Resize(2, 3) = _\nCells(r, 1).Resize(2, 3).Value\n'2행씩 1칸 띠고 복사\nr = r + 2\n'행을 2칸씩 늘려감\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈 셀이 나올때까지 반복\nRange(\"A1\").CurrentRegion.Offset(1).\nEntireRow.Delete\nshift:=xlUp\n'제목을 제외한 기존 데이터 삭제\nColumns.AutoFit\n'열너비 자동 맞춤\nEnd Sub", "context": "공백을 유지하면서 B열을 기준으로 오름차순으로 같은 이름끼리 2행씩 짝으로 정렬하는 기능\n매크로 실행 전 (Sheet2는 비어 있음)                     매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub sort_As_Pair3()\nDim r As Long\n'행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Cells(1, 1)\n'Sheet1 사용영역 Sheet2에 복사\n.Activate\n'Sheet2 활성화\nEnd With\nActiveSheet.UsedRange.Offset(1).\nSort\n[B2], 1\n'제목뺀 영역 B2셀기준 오름차순 정렬\nr = 2\n'2행부터 시작\nDo\nCells(Rows.Count, \"A\").\nEnd(3)..."}
{"instruction": "Excel VBA code for: (1066) URL의 그림을 파일로 컴퓨터에 저장하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub save_Web_Pictures_To_File()\nDim strPath As String\n'파일 경로를 넣을 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim picName As String\n'그림의 이름 넣을 변수\nDim fileName As String\n'파일이름 넣을 변수\nDim cht As\nChartObject\n'차트개체를 넣을 변수\nDim lngW As Long\n'그림의 가로크기 넣을 변수\nDim lngH As Long\n'그림의 세로크기 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중단\nstrPath = ActiveWorkbook.Path & \"\\\"\n'화면에 띄워진 파일의 경로\nFor Each\nrngC\nIn\nRange(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'지정영역 각 셀을 순환\nApplication.\nWait\n(Now + TimeValue(\"0:00:01\"))\n'1초에 1번씩 각 URL 접속\nOn Error Resume Next\n'에러 발생해도 다음코드 진행\nActiveSheet.\nPictures.Insert\n(rngC.Value).Select\n'그림파일을 삽입함\nIf\nErr = 0\nThen\n'(그림이 존재하여) 에러가 발생하지 않으면\nWith Selection\n'선택한것\npicName = .Name\n'그림의 이름을 변수에 넣음\nlngW = .Width\n'그림의 가로 크기를 변수에 넣음\nlngH = .Height\n'그림의 세로 크기를 변수에 넣음\n.\nCopyPicture\n'각셀을 그림으로 복사해서 clipboard에 넣음\nEnd With\nfileName = Right(rngC, Len(rngC) - InStrRev(rngC, \"/\"))\n'파일이름을 추출\nSet cht = ActiveSheet.\nChartObjects.Add\n(0, 0, lngW, lngH)\n'새로운 차트개체를 그림크기로 생성\ncht.Chart.Paste\n'차트에 그림을 붙여 넣음\nDo\n'다음을 실행\nIf Len(Dir(strPath & fileName)) <> 0 Then\n'동일한 파일이름이 이미 폴더에 존재하면\nfileName = Split(fileName, \".\")(0) & \"R\" & \".jpg\"\n'파일이름에 R을 덧붙임\nElse\n'동일한 파일이 없으면\ncht.\nChart.Export\nstrPath & fileName\n'차트개체를 그림파일로 내보냄\ncht.Delete\n'임시로 삽입했던 차트개체를 삭제\nActiveSheet.\nShapes\n(picName).Delete\n'불러온 그림 삭제\nExit Do\n'Do 구문 종료\nEnd If\nLoop\nElse\n'(주소 틀리거나 링크 잘못되어) 그림이 없으면\nOn Error GoTo 0\n'에러 검출기능 복원\nEnd If\nNext\nrngC\nSet cht = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전 (왼쪽은 폴더에 있는 매크로 삽입된 엑셀파일, 오른쪽은 이 파일을 열은것)\n매크로 실행 후 URL에 있는 그림들을 가져와 폴더에 저장한 결과\nOption Explicit\nSub save_Web_Pictures_To_File()\nDim strPath As String\n'파일 경로를 넣을 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim picName As String\n'그림의 이름 넣을 변수\nDim fileName As String\n'파일이름 넣을 변수\nDim cht As\nChartObject\n'차트개체를 넣을 변수\nDim lngW As Long\n'그림의 가로크기 넣을 변수\nDim lngH As Long\n'그림의 세로크기 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중단\nstrPath = ActiveWorkbook.Path & \"\\\"\n'화면에 띄워진 파일의 경로\nFor Each\nrngC\nIn\n..."}
{"instruction": "Excel VBA code for: (1068) 학과별로 재배치하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub rearrange_As_Per_Dept()\nDim rngAll As Range\n'전체 데이터영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp()\n'모든 학과를 넣을 동적배열 변수\nDim r As Long\n'배열 크기 늘려갈 변수\nDim rngDept As Range\n'모든 학과를 넣을 변수\nDim C As Range\n'검색하여 일치한 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중단\nWith ActiveSheet.UsedRange\n'활성화된 시트 사용영역에서\nSet rngAll = .Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 1)\nEnd With\n'제목을 제외한 전체영역을 변수에 넣음\nFor Each rngC In rngAll\n'전체 데이터 영역의 각 셀을 순환\nr = r + 1\n'배열 크기 1씩 늘려감\nReDim Preserve\nvarTemp(1 To r)\n'배열크기 재지정\nvarTemp(r) = rngC\n'배열에 각 셀의 값을 넣음\nNext rngC\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\n.Cells(1, 1).Resize(UBound(varTemp)) = _\nApplication.\nTranspose\n(varTemp)\n'배열값을 셀에 뿌림\nWith .Columns(1).SpecialCells(2)\n'1열 문자에서\n.\nRemoveDuplicates\n1, Header:=xlNo\n'중복제거\n.\nSort\n.Cells(1, 1), 1\n'오름차순 정렬\n.Copy\n'학과를 복사\n.Cells(1, 2).\nPasteSpecial\nTranspose:=True\n'행열 변환하여 붙여넣기\n.ClearContents\n'(임시로 사용한)1열 문자삭제\nEnd With\n.Range(\"A2:A3\") = Application.Transpose(\nArray\n(\"개설학교數\", \"학교\"))\nSet rngDept = .Rows(1).SpecialCells(2)\n'1행의 문자열을 변수에 넣음\nFor Each rngC In rngDept\n'각 학과의 각 셀을 순환\nrngC(2, 1) =\nWorksheetFunction.CountIf\n(rngAll, rngC)\nNext rngC\n'각 학과의 아래셀에 학교개수 입력\nFor Each rngC In rngAll\n'전체영역을 순환\nSet C = rngDept.\nFind\n(rngC, , , xlWhole)\n'각 학과를 검색후 일치하는 셀을 변수에 넣음\n.Cells(Rows.Count, C.Column).End(3)(2) = Cells(1, rngC.Column)\nNext rngC\n'종단셀 윗방향 아래셀에 각 학과를 입력\nFor r = 2 To .UsedRange.Columns.Count\n'2 ~ 사용영역 열 개수만큼 반복\nWith .Range(.Cells(3, r), .Cells(Rows.Count, r).End(3))\n'각 열 3행부터 마지막행까지\n.RemoveDuplicates 1, xlNo\n'중복제거\n.Sort Sheets(2).Cells(3, r), 1\n'오름차순 정렬\nEnd With\nNext r\n.Columns.AutoFit\n'열너비 자동맞춤\n.UsedRange.\nBorders.LineStyle = 1\n'외곽 테두리 넣기\n.Activate\n'활성화\nEnd With\nSet rngAll = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngDept = Nothing\nSet C = Nothing\nEnd Sub", "context": "1. 전체학교의 개설학과 수를 추출\n2. 각 학과별 학교를 중복없이 추출하여 재배치\n3. 각 학과 및 학교는 오름차순 정렬\n매크로 실행 전 (Sheet2는 비어 있는 상태)\n매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub rearrange_As_Per_Dept()\nDim rngAll As Range\n'전체 데이터영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp()\n'모든 학과를 넣을 동적배열 변수\nDim r As Long\n'배열 크기 늘려갈 변수\nDim rngDept As Range\n'모든 학과를 넣을 변수\nDim C As Range\n'검색하여 일치한 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중단\nWith ActiveSheet.UsedRange\n'활성화된 시트 사용영역에서\nSet rngAll = .Offset(1, 1).Resize(.Rows.Count - ..."}
{"instruction": "Excel VBA code for: (1071) Left 와 Left$ 의 속도비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub left_Without_Dollar()                        Sub left_With_Dollar()\nDim r As Long                                      Dim r As Long\nDim strIn As String                                Dim strIn As String\nDim strOut As String                              Dim strOut As String\nApplication.ScreenUpdating = False        Application.ScreenUpdating = False\nstrIn = \"Sample text.\"                             strIn = \"Sample text.\"\nFor r = 1 To 10000000                             For r = 1 To 10000000\nstrOut =\nLeft\n(strIn, 10)                            strOut =\nLeft\n$\n(strIn, 10)\nNext r                                                  Next r\nEnd Sub", "context": "아래의 두 코드는 \"Sample text.\" 라는 텍스트에서 왼쪽의 10개 문자를 추출하는 동일한 기능을 한다. 하나는 Left 함수를 사용하고, 다른 하나는 Left$ 함수를 사용하였다.\n﻿\n반복횟수\nLeft\n사용한 코드\nLeft$\n사용한 코드\n10,000,000회\n2.9초\n2.1\n초\nSub left_Without_Dollar()                        Sub left_With_Dollar()\nDim r As Long                                      Dim r As Long\nDim strIn As String                                Dim strIn As String\nDim strOut As String                              Dim strOut As String\nApplication.ScreenUpdating = False        Application.Screen..."}
{"instruction": "Excel VBA code for: (1072) Resize와 Range의 속도비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub resize_Range()                              Sub range_Range()\nDim r As Long                                      Dim r As Long\nApplication.ScreenUpdating = False        Application.ScreenUpdating = False\nFor r = 1 To 100000                                For r = 1 To 100000\nCells(r, 1).Resize(, 10)\n= 1\nRange(Cells(r, 1), Cells(r, 10))\n= 1\nNext r                                                  Next r\nEnd Sub", "context": "아래의 두 코드는 A1:J100000 영역을 1로 채우는 동일한 기능을 한다. 하나는 Resize 속성을 사용하고 다른 하나는 Range 속성을 사용한다.\n﻿\n반복횟수\nResize\n사용한 코드\nRange\n사용한 코드\n100,000회\n6.6초\n6.2\n초\nSub resize_Range()                              Sub range_Range()\nDim r As Long                                      Dim r As Long\nApplication.ScreenUpdating = False        Application.ScreenUpdating = False\nFor r = 1 To 100000                                For r = 1 To 100000\nCells(r, 1).Resize(, 10)\n= 1\nRange(Cells(r, 1), Cells(r, 10))\n= 1\nNext r        ..."}
{"instruction": "Excel VBA code for: (1073) 연속되는 O 의 개수 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub max_Iiterated_O()\nDim c As Integer\n'열을 1씩 늘려갈 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim cnt As Long\n'카운터로 사용될 변수\nDim lngO As Long\n'연속되는 O 의 개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중단\nFor c = 1 To ActiveSheet.UsedRange.\nColumns.Count\n'현재시트 사용영역 열 개수를 변수에 넣음\nlngO = 0\n'lngO 에 0을 넣음\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nIf Cells(r, c) = \"O\"\nAnd\nCells(r + 1, c) = \"O\" Then\n'위아래가 \"O\"일 경우\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nIf cnt > lngO Then\n'만일 카운터가 lngO 보다 클경우\nlngO = cnt\n'lngO에 카운터 값을 넣음\nEnd If\nElse\n'카운터가 lngO보다 크지 않을 경우\ncnt = 0\n'카운터 값을 초기화\nEnd If\nLoop Until\nCells(r, c) = \"\"\n'빈행이 나올때까지 무한 반복\nIf lngO <> 0 Then\n'lngO가 0이 아니라면\nCells(r, c) = lngO + 1\n'셀에 연속된 O의 개수 입력\nEnd If\ncnt = 0\n'재사용 위하여 카운터 초기화\nr = 0\n'다음열 작업을 위하여 행 초기화\nNext c\nEnd Sub", "context": "각 열에서 연속되는 O의 개수중 가장 큰 수를 추출하는 기능\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub max_Iiterated_O()\nDim c As Integer\n'열을 1씩 늘려갈 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim cnt As Long\n'카운터로 사용될 변수\nDim lngO As Long\n'연속되는 O 의 개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중단\nFor c = 1 To ActiveSheet.UsedRange.\nColumns.Count\n'현재시트 사용영역 열 개수를 변수에 넣음\nlngO = 0\n'lngO 에 0을 넣음\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nIf Cells(r, c) = \"O\"\nAnd\nCells(r + 1, c) = \"O\" Then\n'위아래가 \"O\"일 경우\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nIf cnt > l..."}
{"instruction": "Excel VBA code for: (1074) 평균차이 계산(내삽법)하여 채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Average_And_Fill()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'0의 중복(i)teration 개수 구할 변수\nDim c As Integer\n'전체 열(c)olumn 개수 넣을 변수\nDim rngA As Range\n'각 0이 있는 영역(A)rea를 넣을 변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim sngDiff As Single\n'평균차이 값을 계산해 넣을 변수\nDim sngU As Single\n'평균차이 값을 적산(積算)해갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor\nc = 1 To ActiveSheet.UsedRange.Columns.Count\n'전체 열 개수만큼 반복\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 증가\nIf Cells(r, c) = 0 Then\n'각 셀값이 0일 경우\nIf Cells(r, c) = Cells(r + 1, c) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nSet rngA = Cells(r - i, c).Resize(i + 1)\n'각 0 영역을 변수에 넣음\nsngDiff =\n(Cells(r + 1, c) - Cells(r - rngA.Count, c)) / (rngA.Count + 1)\n'평균차이 값을 계산하여 변수에 넣음\nFor Each\nrngC In rngA\n'각 0 area의 각 셀을 순환\nsngU = sngU + sngDiff\n'평균차이 값을 적산(積算)해감\nrngC = Cells(r - rngA.Count, c) + sngU\n'각 셀에 값을 입력\nNext\nrngC\ni = 0\n'재사용 위하여 초기화\nsngDiff = 0\n'재사용 위하여 초기화\nsngU = 0\n'재사용 위하여 초기화\nEnd If\nEnd If\nLoop Until\nCells(r + 1, c) = \"\"\n'각 열에 빈셀 나올때까지 무한 반복\ni = 0\n'재사용 위하여 초기화\nr = 0\n'재사용 위하여 초기화\nSet rngA = Nothing\n'개체변수 초기화(메모리 비우기)\nNext\nc\nEnd Sub", "context": "1. 셀 값이 0일 경우 위 아래 0이 아닌 값의 평균값 차이를 계산하여 값을 채워가는 기능.\n2. 0 이 있는 셀의 위치는 구분의 편리를 위하여 색으로 표시함.\n매크로 실행 전                                                       매크로 실행 후 결과\nOption Explicit\nSub find_Average_And_Fill()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'0의 중복(i)teration 개수 구할 변수\nDim c As Integer\n'전체 열(c)olumn 개수 넣을 변수\nDim rngA As Range\n'각 0이 있는 영역(A)rea를 넣을 변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim sngDiff As Single\n'평균차이 값을 계산해 넣을 변수\nDim sngU As Single\n'평균차이 값을 적산(積算)해갈 변수\nApplication.ScreenU..."}
{"instruction": "Excel VBA code for: (1075) 특정 숫자부터 중복없이 무작위로 채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_From_Certain_No_Randomly()\nDim minNo As String\n'입력값을 넣을 변수\nDim msg As String\n'메시지 넣을 문자 변수\nDim maxNo As Long\n'선택셀 개수를 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nmaxNo = Selection.Count\n'선택영역 셀 개수를 변수에 넣음\nDo\n'다음을 실행\nminNo = InputBox(\"1과 \" & maxNo & \" 사이의 숫자를 입력.\")\n'입력창 값을 변수에 넣음\nIf minNo = \"\" Then Exit Sub\n'입력값 없으면 매크로 중단\nIf\nIsNumeric\n(minNo) Then\n'입력값이 숫자이면\nIf minNo >= 1 And minNo <= maxNo Then\n'1보다 크거나 같고, maxNo보다 작거나 같으면\nExit Do\n'Do 구문 종료\nEnd If\nEnd If\nmsg = \"번호입력 오류.\" &\nvbCr\n& vbCr '메시지창 내용 + 줄바꿈 2번\nmsg = msg & \"1과 \" & maxNo & \" 사이의 숫자를 입력.\"\n'메시지 내용\nMsgBox msg, 64, \"입력오류\"\n'메시지 출력\nLoop\n'무한 반복\nReDim\nvarTemp(1 To maxNo)\n'배열크기 재지정\nFor i = minNo To maxNo + minNo - 1\n'선택영역 셀 개수만큼 반복\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = i\n'각 숫자를 배열에 넣음\nNext i\nFor i = maxNo To 1 Step -1\n'최댓값 부터 1씩 줄여가며 반복\nr =\nInt(Rnd()\n* i) + 1\n'무작위 값을 추출\nSelection.\nCells\n(i) = varTemp(r)\n'선택영역에 랜덤값을 채워감\nvarTemp(r) = varTemp(i)\n'배열 윗값을 추출된 위치에 채움\nNext i\nEnd Sub", "context": "중복 없이 특정 숫자부터 1씩 숫자를 늘려가며 선택영역에 무작위로 숫자를 채우는 기능\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1075) 특정 숫자부터 중복없이 무작위로 채우기 (엑셀 VBA 매크로)\n재생\n1,071\n공유하기\n재생 (space/k)\n재생\n00:35\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:35\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n영역을 먼저 선택하고 매크로 실..."}
{"instruction": "Excel VBA code for: (1076) 선택영역을 랜덤(random)하게 뒤섞기 8 (엑셀 VBA 매크로)", "input": "", "output": "Sub random_Reshuffle3()\nDim maxNo As Long\n'선택영역 셀 개수 넣을 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nRandomize\n'랜덤값 발생기 초기화\n'(계속 새로운 랜덤 기준값 생성)\nWith Selection\n'선택영역에서\nmaxNo = .Count\n'셀 개수를 변수에 넣음\nReDim\nvarTemp(1 To maxNo)\n'배열크기 재지정\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = rngC\n'각 셀을 배열에 넣음\nNext rngC\nFor i = maxNo To 1 Step -1\n'최댓값 부터 1씩 줄여가며 반복\nr =\nInt\n(\nRnd\n() * i) + 1\n'무작위 값을 추출\n.Cells(i) = varTemp(r)\n'랜덤값을 채워감\nvarTemp(r) = varTemp(i)\n'배열 윗값을 추출된 위치에 채움\nNext i\nEnd With\nEnd Sub", "context": "선택영역을 무작위로 섞어주는 기능. 지금까지 해왔던 어떤 코드보다도 속도도 빠르고, 빈 셀이 있어도 상관없으며, 여러개의 구역(area)를 선택하여도 된다. 여러 개의 구역(area)를 섞는데는 가장 빠른 코드중의 하나가 아닐까 생각한다.\n매크로 실행 전                                                        매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1076) 선택영역을 랜덤(random)하게 뒤섞기 8 (엑셀 VBA 매크로)\n재생\n531\n공유하기\n재생 (space/k)\n재생\n00:09\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:09\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x ..."}
{"instruction": "Excel VBA code for: (1077) 중복없이 랜덤하게 행 선택하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub random_Selection()\nDim maxNo As Long\n'선택셀 개수를 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nDim j As Long\n'E열 행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nRandomize\n'초기화\nmaxNo = Cells(Rows.Count, 1).End(3).\nRow\n'1열 마지막 행을 변수에 넣음\nReDim\nvarTemp(1 To maxNo)\n'배열크기 재지정\nFor i = 1 To maxNo\n'선택영역 셀 개수만큼 반복\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = i\n'각 숫자를 배열에 넣음\nNext i\nFor i = maxNo - 1 To 1 Step -1\n'최대값 -1 부터 1씩 줄여가며 반복\nr =\nInt(Rnd()\n* i) + 1\n'무작위 값을 추출\nIf j = 5 Then Exit Sub\n'j가 5이면 매크로 종료\nj = j + 1\n'E열 행을 1씩 늘려감\nCells(j, 5).Resize(, 3) = Cells(varTemp(r), 1).Resize(, 3).Value\n'추출한 값을 셀에 뿌림\nvarTemp(r) = varTemp(i + 1)\n'배열 윗값을 추출된 위치에 채움\nNext i\nEnd Sub", "context": "1. 10개의 행중에 무작위로 5개의 행을 선택하여 오른편에 나열하는 기능\n2. 행은 중복되면 안됨\n(물론 아래처럼 단지 10개의 행이면 아무 비슷한 기능을 하는 코드를 사용해도 되지만 데이터가 많아서 행이 늘어나면 인터넷에 있는 코드들은 상당히 속도가 떨어졌음. 아래의 코드는 직접 실행해보시면 아시겠지만 상당히 속도가 빠름.)\n매크로 실행 전                                                                   매크로 실행 후 결과\nOption Explicit\nSub random_Selection()\nDim maxNo As Long\n'선택셀 개수를 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nDim j As Long\n'E열 행을 늘려갈 변수\nApplication.ScreenUpdating = False..."}
{"instruction": "Excel VBA code for: (1078) 중복 없는 랜덤한 전화번호 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Random_Phone_Numbers()\nDim minNo As Long\n'시작 값을 넣을 변수\nDim maxNo As Long\n'마지막 값을 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nDim j As Long\n'행을 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(1).ClearContents\n'기존 데이터 삭제\nminNo =\n1000\n'시작값을 변수에 넣음\nmaxNo =\n9999\n'마지막 값을 변수에 넣음\nReDim\nvarTemp(1 To maxNo - minNo + 1)\n'배열크기 재지정\nFor i = minNo To maxNo\n'1000에서 9999까지 반복\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = i\n'각 숫자를 배열에 넣음\nNext i\nFor i = maxNo - minNo - 1 To 1 Step -1\n'9999 - 1000 -1 부터 1씩 줄여가며 반복\nr =\nInt(Rnd()\n* (maxNo - minNo)) + 1\n'무작위 값을 추출\nIf j = 100 Then\nExit Sub\n'j가 100 이면 매크로 종료\nj = j + 1\n'행을 1씩 늘려감\nCells(j, 1) = \"02-\" & varTemp(r + 1) & \"-\" & varTemp(r)\n'전화번호를 셀에 입력\nvarTemp(r) = varTemp(i + 1)\n'배열 윗값을 추출된 위치에 채움\nNext i\nEnd Sub", "context": "1. 아래의 코드는 중복 없는 8개의 전화번호 뒷자리를 무작위로 100개 추출하는 기능.\n2. 전화번호는 최대 9999 - 1000 = 8,999 개의 숫자까지 가능\n3. 전화번호의 앞자리 숫자나 또는 생성되는 전화번호의 개수는 아래 코드에서 숫자를 조절하면 된다.\n매크로 실행 전                                                매크로 실행 후 결과\nOption Explicit\nSub extract_Random_Phone_Numbers()\nDim minNo As Long\n'시작 값을 넣을 변수\nDim maxNo As Long\n'마지막 값을 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nDim j As Long\n'행을 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시..."}
{"instruction": "Excel VBA code for: (1079) 정해진 분포로 랜덤한 숫자들 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub random_As_User_Distributed()\nDim minNo As String\n'시작 값을 넣을 변수\nDim maxNo As Long\n'마지막 값을 넣을 변수\nDim varNo As Long\n'배열크기 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim c As Long\n'단계(step)별 반복 횟수 넣을 변수\nDim y As Long\n'Choose함수 또는 행을 1씩 늘려갈 변수\nDim rptNo As Integer\n'각 단계별 숫자의 반복횟수 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(1).ClearContents\n'기존 데이터 삭제\nminNo =\n2\n'시작값을 변수에 넣음\nmaxNo =\n12\n'마지막 값을 변수에 넣음\nvarNo =\n100\n'배열크기 넣을 변수\nFor i = 1 To maxNo / minNo\n'1에서 maxNo / minNo 개수까지 반복\nCells(i, 4) = i * minNo\n'D열에 각 단계별 숫자 입력\nNext i\nReDim\nvarTemp(1 To varNo)\n'배열크기 재지정\nFor c = minNo To maxNo Step maxNo /\n6\n'minNo에서 maxNo까지 단계별로 늘려가며 반복\ny = y + 1\n'y 값을 1씩 늘려감\nrptNo =\nChoose\n(y,\n10, 20, 20, 30, 15, 5\n)\n'각 선택된 값을 변수 rptNo에 넣음\nFor i = 1 To rptNo\n'1에서 rptNo까지 반복\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = c\n'각 숫자를 배열에 넣음\nNext i\nNext c\ny = 0\n'재사용 위하여 초기화\nFor i = varNo To 1 Step -1\n'varNo 에서 1까지 1씩 줄여가며 반복\nr =\nInt(Rnd()\n* i) + 1\n'무작위 값을 추출\ny = y + 1\n'행을 1씩 늘려감\nCells(y, 1) = varTemp(r)\n'추출한 값을 셀에 입력\nvarTemp(r) = varTemp(i)\n'배열 윗값을 추출된 위치에 채움\nNext i\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1079) 정해진 분포로 랜덤한 숫자들 추출하기 (엑셀 VBA 매크로)\n재생\n870\n재생 (space/k)\n재생\n01:03\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:03\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n2부터 12까지 2씩 올라가도록 설정됨.\n매크로 실행 시 2, 4, 6, 8, 10, 12의 숫자가 A열에 각각 10, 20, 20..."}
{"instruction": "Excel VBA code for: (1080) 복수의 행 선택후 특정행의 선택 해제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub unselect_Row()\nDim rngSel As Range\n'마우스 선택영역을 넣을 변수\nDim rngA As Range\n'마우스 선택영역의 A열을 넣을 변수\nDim rngC As Range\n'전체행 선택한 영역의 A열 각 셀을 넣을 변수\nDim rngU As Range\n'영역을 합쳐갈 변수\nWith Selection\n'선택영역에서\nIf .Columns.Count <> Columns.Count Then\n'전체행이 선택되지 않았으면\nMsgBox \"전체행이 선택되지 않아 종료합니다.\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nIf .Areas.Count > 1 Then\n'선택영역이 1개가 아니면\nMsgBox \"영역이 1개가 아닙니다.\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nIf .Rows.Count = 1 Then\n'1개의 행만을 선택하였을 경우\nMsgBox \"1개의 행만 선택하셨습니다.\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nOn\nError\nResume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel =\nApplication.InputBox\n(\"마우스로 영역을 설정하시오!\",\nType:=8\n)\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nIf rngSel.\nAreas\n.Count > 1 Then\n'두 개 이상의 영역을 선택 시\nMsgBox \"2개 이상의 영역을 선택함\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nOn Error GoTo 0\n'에러검출기능 복원\nSet rngA = rngSel.Offset(, -rngSel.Cells(1).Column + 1).Resize(, 1)\n'마우스 선택영역의 A열을 변수에 넣음\nFor Each rngC In .Resize(, 1)\n'선택영역의 A열 각 셀을 순환\nIf\nIntersect\n(rngC, rngA) Is Nothing Then\n'각 셀과 rngA와 교차영역이 없으면\nIf rngU Is Nothing Then\n'rngU가 비어 있으면\nSet rngU =\nRows\n(rngC.Row)\n'첫 행을 넣고\nElse\n'rngU가 비어 있지 않다면\nSet rngU =\nUnion\n(rngU, rngC.EntireRow)\n'합집합 영역을 적산(積算)하여감\nEnd If\nEnd If\nNext rngC\nEnd With\nIf Not rngU Is Nothing Then\n'rngU가 비어 있지 않다면\nrngU.Select\n'rngU를 선택\nEnd If\nSet rngSel = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngA = Nothing\nSet rngU = Nothing\nEnd Sub", "context": "복수의 행을 선택하였다가 필요에 의하여 특정 행(들)의 선택을 해제하는 기능.\n전체행을 선택하지 않으면 에러메시지 출력\n1개의 행만을 선택 시 (unselect할 행이 없으므로) 에러메시지 출력\n복수의 영역(area)을 선택하면 에러메시지 출력(이를 가능하게 코딩하려면 상당히 복잡해짐)\n행선택이 정상적으로 취소되어 선택영역이 2개로 나누어진 뒤 계속하여 매크로 실행하면 영역이 2개이므로 에러메시지 출력. 즉, 항상 1개의 영역(area)에만 매크로가 정상 작동\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1080) 복수의 행 선택후 특정행의 선택 해제하기 (엑셀 VBA 매크로)\n재생\n735\n재생 (space/k)\n재생\n00:39\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:39\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자..."}
{"instruction": "Excel VBA code for: (1081) 랜덤한 숫자로 특정 평균만들기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Average_Randomly()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nRange(\"A2\", Cells(Rows.Count, \"G\").\nEnd(3)(1, -1)\n).ClearContents\n'기존 데이터 삭제\nr = 1\n'1에 1을 넣음\nFor Each\nrngC\nIn\nRange(\"G2\", Cells(Rows.Count, \"G\").End(3))\n'G열 각 셀을 순환\nreCal:\nr = r + 1\n'행을 1씩 늘려감\nFor i = 1 To 4\n'1부터 4까지 반복\nCells(r, i) =\nWorksheetFunction\n.\nRandBetween\n(1, rngC * 2)\n'셀에 랜덤값을 넣음\nNext i\nCells(r, i) = rngC * 5 -\nApplication\n.\nSum\n(Range(Cells(r, 1), Cells(r, 4)))\n'평균 * 5 - A:D열의 합을 E열에 넣음\nIf Cells(r, i) < 1 Then\n'E열의 값이 음수일 경우\nr = r - 1\n'행을 1 빼어줌\nGoTo\nreCal\n'reCal로 돌아가서 재 실행\nEnd If\nNext\nrngC\nEnd Sub", "context": "랜덤한 A:E열의 값을 이용하여 평균값이 G열이 되도록 함.\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub find_Average_Randomly()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nRange(\"A2\", Cells(Rows.Count, \"G\").\nEnd(3)(1, -1)\n).ClearContents\n'기존 데이터 삭제\nr = 1\n'1에 1을 넣음\nFor Each\nrngC\nIn\nRange(\"G2\", Cells(Rows.Count, \"G\").End(3))\n'G열 각 셀을 순환\nreCal:\nr = r + 1\n'행을 1씩 늘려감\nFor i = 1 To 4\n'1부터 4까지 반복\nCells(r, i) =\nWorksheetFunction\n.\nRandBet..."}
{"instruction": "Excel VBA code for: (1082) 랜덤한 값으로 숫자 늘려가기 (엑셀 VBA 매크로)", "input": "", "output": "Sub random_Within_No()\nDim minNo As Long\n'시작 값을 넣을 변수\nDim maxNo As Long\n'마지막 값을 넣을 변수\nDim intDiff As Integer\n'랜덤하게 올려갈 숫자 넣을 변수\nDim r As Long\n'행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nminNo =\n50\n'시작값을 변수에 넣음\nmaxNo =\n1000\n'마지막 값을 변수에 넣음\nintDiff =\n5\n'랜덤하게 올려갈 숫자\nColumns(1).ClearContents\n'기존 데이터 삭제\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nIf r = 1 Then\n'첫 행이라면\nCells(r, 1) = minNo\n'minNo 값을 입력\nElse\n'첫행이 아니면\nCells(r, 1) = Cells(r - 1, 1) +\nWorksheetFunction.RandBetween\n(1, intDiff)\n'윗행 + 랜덤값을 입력\nEnd If\nLoop Until\nCells(r, 1) > maxNo\n'셀의 값이 maxNo보다 클 때까지 무한반복\nEnd Sub", "context": "특정 숫자부터 시작하여 특정 숫자까지\n매크로 실행 전                                            매크로 실행 후 결과\nOption Explicit\nSub random_Within_No()\nDim minNo As Long\n'시작 값을 넣을 변수\nDim maxNo As Long\n'마지막 값을 넣을 변수\nDim intDiff As Integer\n'랜덤하게 올려갈 숫자 넣을 변수\nDim r As Long\n'행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nminNo =\n50\n'시작값을 변수에 넣음\nmaxNo =\n1000\n'마지막 값을 변수에 넣음\nintDiff =\n5\n'랜덤하게 올려갈 숫자\nColumns(1).ClearContents\n'기존 데이터 삭제\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nIf r = 1 Then\n'첫 행이라면\nCells(r, 1) = minNo\n'minNo 값..."}
{"instruction": "Excel VBA code for: (1083) 지정 문자의 숫자만큼 무작위로 배치하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub deployment_Schedule()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim strABCD As String\n'4회 반복하며 문자를 결정할 변수\nDim rngAll As Range\n'각 행의 B:AE열까지 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nRange(\"B2:AE10\").ClearContents\n'기존 데이터 삭제\nr = 1\n'1에 1을 넣음\nFor Each rngC In Range(\"AF2\", Cells(Rows.Count, \"AF\").End(3))\n'AF열 각 셀을 순환\nr = r + 1\n'행을 1씩 늘려감\nFor i = 1 To 4\n'1부터 4까지 반복\nstrABCD =\nChoose\n(i, \"A\", \"B\", \"C\", \"D\")\n'각 선택된 값을 변수에 넣음\nCells(r, rngC.Column).\nEnd(1)(1, 2)\n.Resize(, rngC.Offset(, i - 1)) = strABCD\n'각 셀의 종단셀 왼쪽방향 오른쪽셀에 각 문자입력\nNext i\nSet rngAll = Range(Cells(r, 2), Cells(r, 31))\n'각 행의 B:AE열까지 변수에 넣음\nCall\nrandom_Reshuffle3(rngAll)\n'각 영역을 무작위로 섞는 코드호출\nNext rngC\nEnd Sub\n\nSub random_Reshuffle3(rngAll As Range)\nDim maxNo As Long\n'선택영역 셀 개수 넣을 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith rngAll\n'선택영역에서\nmaxNo = .Count\n'셀 개수를 변수에 넣음\nReDim\nvarTemp(1 To maxNo)\n'배열크기 재지정\nFor Each rngC In rngAll\n'선택영역 각 셀을 순환\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = rngC\n'각 셀을 배열에 넣음\nNext rngC\nFor i = maxNo To 1 Step -1\n'최댓값부터 1씩 줄여가며 반복\nr =\nInt(Rnd()\n* i) + 1\n'무작위 값을 추출\n.Cells(i) = varTemp(r)\n'랜덤값을 채워감\nvarTemp(r) = varTemp(i)\n'배열 윗값을 추출된 위치에 채움\nNext i\nEnd With\nEnd Sub", "context": "AF:AI 열에 있는 숫자만큼 A, B, C, D를 무작위로 각 행에 배치하는 기능. 우선은 각 문자를 각 행에 개수대로 배치한 뒤 문자를 섞어주는 코드를 호출하여 각 행을 뒤 섞음. B12:AE15 영역은 CountIf 함수를 넣어서 각 문자의 개수를 표시하여 준다.\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub deployment_Schedule()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim strABCD As String\n'4회 반복하며 문자를 결정할 변수\nDim rngAll As Range\n'각 행의 B:AE열까지 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nRange(\"B2:AE10\").ClearContents\n'기존 데이터 삭제\nr = 1\n'1에 1을 넣음\nFor Ea..."}
{"instruction": "Excel VBA code for: (1084) 무작위로 행/열 변환하여 붙여넣기 (엑셀 VBA 매크로)", "input": "", "output": "Sub random_Transpose()\nDim rngSel As Range\n'입력창에서 선택한 셀을 넣을 변수\nDim rowsCnt As Long\n'선택영역 행 개수 넣을 변수\nDim colsCnt As Integer\n'선택영역 열 개수 넣을 변수\nDim maxNo As Long\n'선택영역 셀 개수 넣을 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel =\nApplication.InputBox\n(\"마우스로 영역을 설정하시오!\", Type:=8)\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Selection\n'선택영역에서\nrowsCnt = .Rows.Count\n'행 개수를 변수에 넣음\ncolsCnt = Selection.Columns.Count\n'열 개수를 변수에 넣음\nmaxNo = .Count\n'선택영역 셀 개수를 변수에 넣음\nEnd With\nReDim\nvarTemp(1 To maxNo)\n'배열크기 재지정\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = rngC\n'각 셀을 배열에 넣음\nNext rngC\nFor i = maxNo To 1 Step -1\n'최대값 부터 1씩 줄여가며 반복\nr =\nInt(Rnd()\n* i) + 1\n'무작위 값을 추출\nrngSel.Resize(colsCnt, rowsCnt).Cells(i) = varTemp(r)\n'선택영역에 랜덤값을 채워감\nvarTemp(r) = varTemp(i)\n'배열 윗값을 추출된 위치에 채움\nNext i\nEnd Sub", "context": "엑셀의 기본 기능중에 행/열을 변환하여 붙여넣는 기능은 이미 있다. 아래의 코드는 선택영역을 무작위로 행/열 변환하여 붙여넣는 기능이다. 먼저 영역을 선택하고 매크로 실행 후 영역선택 창이 나타나면 복사될 위치를 선택하면 된다. 물론 중복 없이 복사된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1084) 무작위로 행/열 변환하여 붙여넣기 (엑셀 VBA 매크로)\n재생\n1,098\n재생 (space/k)\n재생\n00:19\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:19\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보..."}
{"instruction": "Excel VBA code for: (1089) 동일한 데이터끼리 통합하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub improved_Data_Consolidate2()\nDim lastRow As Long\n'마지막 행을 넣을변수\nDim colsCnt As Integer\n'각 행을 합칠 개수 넣을 변수\nDim y As Long\n'행을 1씩 늘려갈 변수\nDim varTemp()\n'배열로 사용할 변수\nDim r As Long\n'배열위치 1씩 늘려갈 변수\nDim j As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Copy\n'현재시트 사용영역 복사\nSheets.Add\nafter:=Sheets(ActiveSheet.\nIndex\n)\n'현재시트 바로 뒤에 시트 추가\nWith ActiveSheet\n.Paste\n'붙여넣기\nApplication.\nCutCopyMode = False\n'클립보드 비우기\n.UsedRange.\nSort\nkey1:=[A2], order1:=1, key2:=[B2], order2:=1\n'A열과 B열 오름차순 정렬\nlastRow = Cells(Rows.Count, 1).End(3).Row\n'마지막 행을 변수에 넣음\ncolsCnt = .UsedRange.Columns.Count\n'전체 열개수를 변수에 넣음\nEnd With\ny = 1\n'1행부터 시작\nReDim\nvarTemp(1 To lastRow, 1 To colsCnt)\n'배열크기 재지정\nDo\n'다음을 실행\ny = y + 1\n'행을 1씩 늘려감\nIf Cells(y, 1) = Cells(y - 1, 1) And _\nCells(y, 2) = Cells(y - 1, 2) Then\n'A열의 위아래 셀값이 같다면\nFor j = 3 To colsCnt\n'3 ~ colsCnt 만큼 반복\nvarTemp(r, j) = varTemp(r, j) & \", \" & Cells(y, j)\n'기존 배열값에 새로운 행 값을 더함\nNext j\nElse\n'A열의 위아래 셀값이 다르면\nr = r + 1\n'배열위치 1씩 늘려감\nFor j = 1 To colsCnt\n'1 ~ colsCnt 만큼 반복\nvarTemp(r, j) = Cells(y, j)\n'새로운 행 값을 배열에 추가함\nNext j\nEnd If\nLoop Until\nCells(y + 1, 1) = \"\"\n'A열에 빈셀이 나올때까지 무한 반복\nActiveSheet.UsedRange.Offset(1).\nClearContents\n'임시 데이터 삭제\nCells(2, 1).Resize(\nUBound\n(varTemp, 1), colsCnt) = varTemp\n'배열 값을 셀에 뿌림\nColumns.AutoFit\n'열너비 자동맞춤\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub improved_Data_Consolidate2()\nDim lastRow As Long\n'마지막 행을 넣을변수\nDim colsCnt As Integer\n'각 행을 합칠 개수 넣을 변수\nDim y As Long\n'행을 1씩 늘려갈 변수\nDim varTemp()\n'배열로 사용할 변수\nDim r As Long\n'배열위치 1씩 늘려갈 변수\nDim j As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Copy\n'현재시트 사용영역 복사\nSheets.Add\nafter:=Sheets(ActiveSheet.\nIndex\n)\n'현재시트 바로 뒤에 시트 추가\nWith ActiveSheet\n.Paste\n'붙여넣기\nApplication.\nCutCopyMode = False\n'클립보드 비우기\n.UsedRange..."}
{"instruction": "Excel VBA code for: (1090) 영역의 반복 복사와 배열의 반복복사 속도비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub using_Range() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n5.52\n초\nDim r As Long\nApplication.ScreenUpdating = False\nFor r = 1 To 100000\nRange(Cells(r, 1), Cells(r, 10)) =\nRange(\"A1:J1\").Value\nNext r\nEnd Sub\n\nSub using_Array1() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3.80\n초\nDim\nvarR\nDim r As Long\nApplication.ScreenUpdating = False\nvarR = Range(\"A1:J1\")\nFor r = 1 To 100000\nRange(Cells(r, 1), Cells(r, 10)) =\nvarR\nNext r\nEnd Sub\n\nSub nexting_For() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n21.20\n초\nDim r As Long\nDim c As Long\nApplication.ScreenUpdating = False\nFor\nr = 1 To 100000\nFor\nc = 1 To 10\nCells(r, c) = c\nNext\nc\nNext\nr\nEnd Sub", "context": "아래의 코드들은 아래 그림처럼 A1:J100,000 영역의 각 행을 1~10으로 채우는 기능이다. 물론 FillDown 을 사용하거나 한 번에 복사(이 경우 1초도 안걸린다.)할 수 있지만 여기에서는 반복속도를 비교하는 목적이므로 이를 제외하고 각 행 또는 셀을 복사해 넣는 것을 기준으로 한다.\n소요시간\nSub using_Range() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n5.52\n초\nDim r As Long\nApplication.ScreenUpdating = False\nFor r = 1 To 100000\nRange(Cells(r, 1), Cells(r, 10)) =\nRange(\"A1:J1\").Value\nNext r\nEnd Sub\n(윗 코드에서 무언가 이상한 점은 없는가? A1:J100,000 영역을 행을 1씩 늘려가며\nA1:J1 영역을 복사하므로 별 이상이 없..."}
{"instruction": "Excel VBA code for: (1092) 두 가지 조건을 만족하는 행을 추출하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub filter_Two_Fruits2()\nDim rngR As Range\n'전체영역 각 행(R)ow 을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.Columns(1).\nNumberFormatLocal\n= \"mm\"\"월\"\" dd\"\"일\"\";@\"\n'1열 서식을 월일로 설정\n.UsedRange.Offset(1).ClearContents\n'기존 데이터 삭제\nRows(1).\nSpecialCells(2)\n.Copy .Cells(1, 1)\n'제목을 시트2에 복사\nFor Each\nrngR\nIn\nActiveSheet.UsedRange.Rows\n'현재시트 사용영역 각 행을 순환\nWith\nWorksheetFunction\n'엑셀 워크시트함수\nIf .\nCountIf\n(rngR, \"사과\") > 0 And _\n.CountIf(rngR, \"바나나\") > 0 Then\n'사과와 바나나가 각 행에 있으면\nSheets(2).Cells(Rows.Count, \"A\").End(3)(2).Resize(, 5) = rngR.Value\n'각 행을 Sheet2에 복사\nEnd If\nEnd With\nNext\nrngR\n.Columns.AutoFit\n'열너비 자동 맞춤\n.\nActivate\n'활성화\nEnd With\nEnd Sub", "context": "각 행에 사과와 바나나가 들어간 행만 Sheet2로 옮기는 기능.\n매크로 실행 전 (Sheet2는 비어 있는 상태)                 매크로 실행 후 결과\nOption Explicit\nSub filter_Two_Fruits2()\nDim rngR As Range\n'전체영역 각 행(R)ow 을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.Columns(1).\nNumberFormatLocal\n= \"mm\"\"월\"\" dd\"\"일\"\";@\"\n'1열 서식을 월일로 설정\n.UsedRange.Offset(1).ClearContents\n'기존 데이터 삭제\nRows(1).\nSpecialCells(2)\n.Copy .Cells(1, 1)\n'제목을 시트2에 복사\nFor Each\nrngR\nIn\nActiveSheet.UsedRange.Rows\n'현재시트 사용영역 각 행을 순환\nWith\nWorksheet..."}
{"instruction": "Excel VBA code for: (1095) 그룹별 중복데이터 제일 윗행/아래행만 남기고 삭제하기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Dupes_Leaving_Last3()\nDim lastRow As Long\n'마지막 행을 넣을변수\nDim colsCnt As Integer\n'전체 열의 개수 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim y As Long\n'행을 1씩 늘려갈 변수\nDim varTemp\n'배열로 사용할 변수\nDim r As Long\n'배열위치 1씩 늘려갈 변수\nDim j As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'마지막 행을 변수에 넣음\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열개수를 변수에 넣음\ny = 1\n'1행부터 시작\nReDim\nvarTemp(1 To lastRow - 1, 1 To colsCnt)\n'2차원 배열의 크기 재지정\nDo\n'다음을 실행\ny = y + 1\n'행을 1씩 늘려감\nFor i = 1 To colsCnt\n'열 개수만큼 반복\nIf Cells(y, i) <> Cells(y\n+\n1, i) Then\n'A열의 위아래 셀값이 다르다면\nr = r + 1\n'배열위치 1씩 늘려감\nFor j = 1 To colsCnt\n'열 개수만큼 반복\nvarTemp(r, j) = Cells(y, j)\n'배열에 데이터를 넣음\nNext j\nExit\nFor\n'For 구문 종료\nEnd If\nNext i\nIf i = colsCnt + 1 Then\n'i가 열개수 + 1 즉 위 아래 모두 일치시\nr = r + 1\n'배열위치 1씩 늘려감\nFor j = 1 To colsCnt\n'열 개수만큼 반복\nvarTemp(r, j) =\nEmpty\n'배열에 빈 데이터를 넣음\nNext j\nEnd If\nLoop Until\nCells(y + 1, 1) = \"\"\n'A열에 빈셀이 나올때까지 무한 반복\nSheets.\nAdd\nafter:=Sheets(ActiveSheet.Index)\n'현재시트 바로 뒤에 시트 추가\nSheets(ActiveSheet.Index - 1).Rows(1).SpecialCells(2).\nCopy\nCells(1, 1)\n'제목복사\nCells(2, 1).Resize(\nUBound\n(varTemp, 1), colsCnt) = varTemp\n'배열 값을 셀에 뿌림\nColumns.AutoFit\n'열너비 자동맞춤\nEnd Sub\n\nSub remove_Dupes_Leaving_Last4()\nDim lastRow As Long\n'마지막 행을 넣을변수\nDim colsCnt As Integer\n'전체 열의 개수 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim y As Long\n'행을 1씩 늘려갈 변수\nDim varTemp\n'배열로 사용할 변수\nDim r As Long\n'배열위치 1씩 늘려갈 변수\nDim j As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, 1).End(3).Row\n'마지막 행을 변수에 넣음\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열개수를 변수에 넣음\ny = 1\n'1행부터 시작\nReDim varTemp(1 To lastRow - 1, 1 To colsCnt)\n'2차원 배열의 크기 재지정\nDo\n'다음을 실행\ny = y + 1\n'행을 1씩 늘려감\nFor i = 1 To colsCnt\n'열 개수만큼 반복\nIf Cells(y, i) <> Cells(y\n-\n1, i) Then\n'A열의 위아래 셀값이 다르다면\nr = r + 1\n'배열위치 1씩 늘려감\nFor j = 1 To colsCnt\n'열 개수만큼 반복\nvarTemp(r, j) = Cells(y, j)\n'배열에 데이터를 넣음\nNext j\nExit For\n'For 구문 종료\nEnd If\nNext i\nIf i = colsCnt + 1 Then\n'i가 열개수 + 1 즉 위 아래 모두 일치시\nr = r + 1\n'배열위치 1씩 늘려감\nFor j = 1 To colsCnt\n'열 개수만큼 반복\nvarTemp(r, j) = Empty\n'배열에 빈 데이터를 넣음\nNext j\nEnd If\nLoop Until Cells(y + 1, 1) = \"\"\n'A열에 빈셀이 나올때까지 무한 반복\nSheets.Add after:=Sheets(ActiveSheet.Index)\n'현재시트 바로 뒤에 시트 추가\nSheets(ActiveSheet.Index - 1).Rows(1).SpecialCells(2).Copy Cells(1, 1)\n'제목복사\nCells(2, 1).Resize(UBound(varTemp, 1), colsCnt) = varTemp\n'배열 값을 셀에 뿌림\nColumns.AutoFit\n'열너비 자동맞춤\nEnd Sub", "context": "그룹별 중복되는 데이터가 있을 때 정렬을 하지 않고 중복행의 제일 윗행만 남기거나, 반대로 중복행의 제일 아래행만 남기는 것은 제목에서 보듯이 이미 4번이나 해보았다. 하지만 두 가지를 한 번에 할 수 있는 공용코드를 찾기 어려웠는데 아래의 코드는 부호 하나만 바꾸는 것으로 이것이 가능하다.\n아래의 코드는\n중복 데이터의 제일\n아래\n데이터만\n남기는 기능\n. (참고로 내 컴퓨터로 50,000 행에 약 1.7초 정도 소요)\n매크로 실행 전 (색칠해진 곳이 삭제될 데이터)             매크로 실행 후 결과\nOption Explicit\nSub remove_Dupes_Leaving_Last3()\nDim lastRow As Long\n'마지막 행을 넣을변수\nDim colsCnt As Integer\n'전체 열의 개수 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim y As Long\n'행을 1씩 늘려갈 변수\nDim varTemp\n'배열로 사용할 변수\nDim r As Lon..."}
{"instruction": "Excel VBA code for: (1096) 그룹별 중복데이터 제일 윗행/아래행만 남기고 삭제하기 6 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Dupes_Leaving_Last5()\nDim colsCnt As Integer\n'전체 열의 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim j As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Worksheets(2)\n'Sheet2에서\n.UsedRange.Offset(1).\nClearContents\n'Sheet2 기존 데이터 삭제\nRows(1).SpecialCells(2).Copy .Cells(1, 1)\n'제목복사\ncolsCnt = ActiveSheet.UsedRange.\nColumns.Count\n'전체 열개수를 변수에 넣음\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nFor j = 1 To colsCnt\n'전체 열개수 만큼 반복\nIf Cells(r, j) <> Cells(r\n+\n1, j) Then\n'각 셀이 바로 아래 셀과 다르면\n.Cells(r, j).Resize(, colsCnt) = _\nCells(r, j).Resize(, colsCnt).Value\n'각 행의 값을 Sheet2에 복사\nExit\nFor\n'For 구문 종료\nEnd If\nNext j\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\n.Columns.\nAutoFit\n'열너비 자동맞춤\n.\nActivate\n'Sheet2 활성화\nEnd With\nEnd Sub\n\nSub remove_Dupes_Leaving_Last6()\nDim colsCnt As Integer\n'전체 열의 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim j As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Worksheets(2)\n'Sheet2에서\n.UsedRange.Offset(1).ClearContents\n'Sheet2 기존 데이터 삭제\nRows(1).SpecialCells(2).Copy .Cells(1, 1)\n'제목복사\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열개수를 변수에 넣음\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nFor j = 1 To colsCnt\n'전체 열개수 만큼 반복\nIf Cells(r, j) <> Cells(r\n-\n1, j) Then\n'각 셀이 바로 아래 셀과 다르면\n.Cells(r, j).Resize(, colsCnt) = _\nCells(r, j).Resize(, colsCnt).Value\n'각 행의 값을 Sheet2에 복사\nExit For\n'For 구문 종료\nEnd If\nNext j\nr = r + 1\n'행을 1씩 증가\nLoop Until Cells(r, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\n.Columns.AutoFit\n'열너비 자동맞춤\n.Activate\n'Sheet2 활성화\nEnd With\nEnd Sub", "context": "아래의 코드는 그룹별\n중복 데이터의 제일\n아래\n데이터만\n남기는 기능\n.\n매크로 실행 전 (색칠해진 곳이 삭제될 데이터)             매크로 실행 후 Sheet2의 결과\n(Sheet2는 현재 비어 있는 상태)\nOption Explicit\nSub remove_Dupes_Leaving_Last5()\nDim colsCnt As Integer\n'전체 열의 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim j As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Worksheets(2)\n'Sheet2에서\n.UsedRange.Offset(1).\nClearContents\n'Sheet2 기존 데이터 삭제\nRows(1).SpecialCells(2).Copy .Cells(1, 1)\n'제목복사\ncolsCnt = Activ..."}
{"instruction": "Excel VBA code for: (1097) 통합시트의 데이터를 월별로 분리하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub create_Monthly_Sheet1()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim colsCnt As Integer\n'전체 열개수 넣을 변수\nDim s As Long\n'반복 구문에 사용할 변수\nWith Application\n.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor s = Sheets.Count To 2 Step -1\n'Data시트 제외한 전체시트 순환\n.\nDisplayAlerts = False\n'화면 경고기능 중지\nSheets(s).Delete\n'각 시트 삭제\n.DisplayAlerts = True\n'화면 경고기능 복원\nNext s\nEnd With\nSet rngAll = ActiveSheet.UsedRange\n'전체 영역을 변수에 넣음\ncolsCnt = rngAll.Columns.Count\n'전체 사용영역의 열 개수를 변수에 넣음\nFor s = 1 To 12\n'12회 반복\nSheets.\nAdd After:=\nSheets(Sheets.Count)\n'새로운 시트 생성\nActiveSheet.\nName\n= s & \"월\"\n'시트의 이름 변경\nNext s\nSheets(1).Activate\n'Data 시트 활성화\nCells(1, colsCnt + 1).Resize(, 2) = \"\n일자\n\"\n'고급필터 조건이될 \"일자\" 입력\nFor s = 1 To 12                                    '12회 반복\nCells(2, colsCnt + 1) = \">=\" &\nDateSerial\n(\n2012\n, s, 1)\n'시작일을 입력\nCells(2, colsCnt + 2) = \"<\" & DateSerial(\n2012\n, s + 1, 1)\n'종료일을 입력\nrngAll.\nAdvancedFilter\nAction:=2, CriteriaRange:=Cells(1, colsCnt + 1).Resize(2, 2), _\nCopyToRange:=Sheets(s + 1).Cells(1, 1), Unique:=0\n'각 월별 데이터 시트에 복사\nSheets(s + 1).Columns.AutoFit\n'각 시트의 열너비 자동 맞춤\nNext s\nCells(1, colsCnt + 1).Resize(, 2).\nEntireColumn.Delete\n'임시로 사용한 열 삭제\nSet rngAll = Nothing\n'개체변수 초기화 (메모리 비우기)\nEnd Sub", "context": "통합 시트에 있는 데이터를 월별로 분리하는 기능.\n\"\n일자\n\" 열이 어느 열에 있어도 상관 없다.\n단, 본인의 통합파일에 \"날짜\" (또는 다른 이름일 경우)라고 필드 제목이 되어 있을 경우 아래의 코드에서 이에 맞추어 필드제목만 \"일자\"로 수정 해주면 된다. 만일 통합 시트에 여러 해의 데이터가 있고, 2011년 데이터만 추출하고 싶을 경우, 아래의 코드에서 년도를 2011로만 바꿔주면 된다.\n아래의 코드는 전체 필드를 모두 복사한다. 만일, \"일자\"와 \"입고\" 또는 \"일자\"와 \"출고\" 필드만을 각 시트에 월별로 분류하고자 할 때에는 코드를 약간만 수정하면 된다. 필요한 분들은 덧글을 다시거나 이메일 보내시면 알려드립니다. ^^\n매크로 실행 전 Data 시트(통합시트로서 모든 날짜의 데이터가 들어 있음)\n매크로 실행 후 결과 (각 월별로 시트가 분리됨)\n매크로 실행 후 결과 12월\nOption Explicit\nSub create_Monthly_Sheet1()\nDim rngAll As..."}
{"instruction": "Excel VBA code for: (1098) 각 반복되는 이름을 건너 뛰며 색칠하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub paint_Every_Other_Group()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim blnYN As Boolean\n'각 그룹을 건너 뛰며 반전할 변수\nDim cnt As Long\n'카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Offset(1).\nInterior.Color\n=\nxlNone\n'기존 색채우기 삭제\nColumns(\"A\").Insert\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nIf Cells(r, 2) = Cells(r + 1, 2) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nWith Cells(r - i, 1).Resize(i + 1)\n'그룹별 영역에서\n.\nMerge\n'셀병합\n.Value = cnt\n'각 그룹에 순번입력\nEnd With\nblnYN =\nNot\nblnYN\n'blnYN의 값을 반전\nIf blnYN =\nTrue\nThen\n'blnYN의 값이 참이라면\nCells(r - i, 2).Resize(i + 1, 4).Interior.Color = 15523812\n'옅은 보라색으로 채움\nEnd If\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 2) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\n[A1].CurrentRegion.\nBorders.LineStyle = 1\n'외곽에 테두리\nColumns.AutoFit\n'열너비 자동맞춤\nEnd Sub", "context": "1. 각 중복되는 이름 그룹을 건너 뛰며 색칠\n2. 같은 중복이름 그룹은 셀병합을 하고 순번을 매김\n매크로 실행 전                                                   매크로 실행 후 결과\nOption Explicit\nSub paint_Every_Other_Group()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim blnYN As Boolean\n'각 그룹을 건너 뛰며 반전할 변수\nDim cnt As Long\n'카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Offset(1).\nInterior.Color\n=\nxlNone\n'기존 색채우기 삭제\nColumns(\"A\").Insert\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nIf Cells(r, 2) = Cells(r + 1..."}
{"instruction": "Excel VBA code for: (1099) 5행씩 행열 변환하여 옮기기 (엑셀 VBA 매크로)", "input": "", "output": "Sub transpose_Every_Five_Lines()\nDim r As Long\n'5행씩 늘려갈 변수\nDim y As Long\n'Sheet2 1행씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 일시 정지\nWith Worksheets(2)\n'sheet2에서\n.UsedRange.\nClearContents\n'Shee2의 기존 데이터 삭제\nr = 1\nDo\ny = y + 1\n.Cells(y, 1).Resize(, 5) = _\nApplication.\nTranspose\n(Cells(r, 1).Resize(5).Value)\n'5행씩 행열 변환하여 복사\nr = r + 5\n'행을 5행씩 늘려감\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈행 나올때까지 무한 반복\n.Columns.AutoFit\n'열너비 자동맞춤\n.\nActivate\n'(Sheet2 확인 위해) 활성화\nEnd With\nEnd Sub", "context": "매크로 실행 전                                                 매크로 실행 후 결과\nOption Explicit\nSub transpose_Every_Five_Lines()\nDim r As Long\n'5행씩 늘려갈 변수\nDim y As Long\n'Sheet2 1행씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 일시 정지\nWith Worksheets(2)\n'sheet2에서\n.UsedRange.\nClearContents\n'Shee2의 기존 데이터 삭제\nr = 1\nDo\ny = y + 1\n.Cells(y, 1).Resize(, 5) = _\nApplication.\nTranspose\n(Cells(r, 1).Resize(5).Value)\n'5행씩 행열 변환하여 복사\nr = r + 5\n'행을 5행씩 늘려감\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈행 나올때까지 무한 반복\n.Columns.Auto..."}
{"instruction": "Excel VBA code for: (1100) 무작위로 로또번호 추출하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Lotto_Numbers()\nDim y As Long\n'행 늘려갈 변수\nConst\nmaxNo As Long =\n1000\n'생성할 행 개수를 변수에 넣음\nDim x As Integer\n'열 늘려갈 변수\nDim r As Integer\n'랜덤값 추출에 사용할 변수\nDim vR(\n1 To maxNo\n,\n1 To 6\n) As Integer\n'무작위로 섞은 값을 넣을 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nRandomize\n'초기화\nFor y = 1 To 45\n'1 ~ 45 까지 반복\nCells(1, y) = y\n'A1:AS1 영역을 1~45로 채움\nNext y\nCells(1, 1).Resize(maxNo, 45).\nFillDown\n'maxNo 행까지 아래로 복사\nFor\ny = 1 To maxNo\n'행방향 1 ~ maxNo회 반복\nFor\nx = 1 To 6\n'열방향 6회 반복\nDo\n'다음을 실행\nr =\nInt(Rnd\n* 45) + 1\n'무작위 값을 추출\nIf Cells(y, r) <> \"\" Then\n'빈셀이 아니라면\nvR(y, x) = Cells(y, r)\n'셀값을 배열에 넣음\nCells(y, r) = \"\"\n'사용한 셀의 값 삭제\nExit Do\n'Do 구문 종료\nEnd If\nLoop\nNext\nx\nNext\ny\nActiveSheet.UsedRange.ClearContents\n'현재시트 사용영역 삭제\nRange(Cells(1, 1), Cells(maxNo, 6)) = vR\n'배열 값을 셀에 뿌림\nEnd Sub", "context": "매크로 실행 전                                                      매크로 실행 후 결과\nOption Explicit\nSub extract_Lotto_Numbers()\nDim y As Long\n'행 늘려갈 변수\nConst\nmaxNo As Long =\n1000\n'생성할 행 개수를 변수에 넣음\nDim x As Integer\n'열 늘려갈 변수\nDim r As Integer\n'랜덤값 추출에 사용할 변수\nDim vR(\n1 To maxNo\n,\n1 To 6\n) As Integer\n'무작위로 섞은 값을 넣을 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nRandomize\n'초기화\nFor y = 1 To 45\n'1 ~ 45 까지 반복\nCells(1, y) = y\n'A1:AS1 영역을 1~45로 채움\nNext y\nCells(1, 1).Resize(maxNo, 45).\nFillDown\n'maxNo 행까지 아..."}
{"instruction": "Excel VBA code for: (1101) 무작위로 로또번호 추출하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Lotto_Numbers1()\nDim r As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'Sheet2에서\nColumns(\"A:F\").ClearContents\n'A:F열 기존 데이터 삭제\n.Cells(1, 1).Resize(45) =\n[row(1:45)]\n'A1:A45 까지 1 ~ 45까지 입력\n.Cells(1, 2).Resize(45).\nFormula\n= \"=\nRAND\n()\"\n'B1:B45까지 랜덤함수 입력\nFor r = 1 To\n1000\n'1000회 반복\n.UsedRange.\nSort\n.[B1], 1\n'B1셀을 기준셀로 오름차순 정렬\nCells(r, 1).Resize(, 6) = _\nApplication.\nTranspose\n(.Cells(1, 1).Resize(6).Value)\n'A1:A6 값을 행열 변환하여 복사\nNext r\nEnd With\nEnd Sub", "context": "매크로 실행 전                                                      매크로 실행 후 결과\nOption Explicit\nSub extract_Lotto_Numbers1()\nDim r As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'Sheet2에서\nColumns(\"A:F\").ClearContents\n'A:F열 기존 데이터 삭제\n.Cells(1, 1).Resize(45) =\n[row(1:45)]\n'A1:A45 까지 1 ~ 45까지 입력\n.Cells(1, 2).Resize(45).\nFormula\n= \"=\nRAND\n()\"\n'B1:B45까지 랜덤함수 입력\nFor r = 1 To\n1000\n'1000회 반복\n.UsedRange.\nSort\n.[B1], 1\n'B1셀을 기준셀로 오름차순 정렬\nCells(r, 1).Resize(, 6) = _\nAppli..."}
{"instruction": "Excel VBA code for: (1102) 무작위로 로또번호 추출하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Lotto_Numbers2()\nDim r As Long\n'행 위치 늘려갈 변수\nDim c As Integer\n'열 위치 늘려갈 변수\nDim intNo As Integer\n'추출한 무작위 값을 넣을 변수\nDim wkF As\nWorksheetFunction\n'엑셀 시트함수를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet wkF = WorksheetFunction\n'엑셀 시트함수를 변수에 넣음\nFor\nr = 1 To\n1000\n'1 ~ 1000 까지 반복\nFor\nc = 1 To 6\n'1 ~ 6까지 반복\nDo\n'다음을 실행\nintNo = wkF.\nRandBetween\n(1, 45)\n'1과 45 사이의 무작위 숫자를 변수에 넣음\nIf wkF.\nCountIf\n(Cells(r, 1).Resize(, 5), intNo) = 0 Then\n'만일 같은 숫자가 없으면\nCells(r, c) = intNo\n'셀에 추출한 숫자를 넣음\nExit Do\n'Do 구문 종료\nEnd If\nLoop\nNext\nc\nNext\nr\nEnd Sub", "context": "매크로 실행 전                                                      매크로 실행 후 결과\nOption Explicit\nSub extract_Lotto_Numbers2()\nDim r As Long\n'행 위치 늘려갈 변수\nDim c As Integer\n'열 위치 늘려갈 변수\nDim intNo As Integer\n'추출한 무작위 값을 넣을 변수\nDim wkF As\nWorksheetFunction\n'엑셀 시트함수를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet wkF = WorksheetFunction\n'엑셀 시트함수를 변수에 넣음\nFor\nr = 1 To\n1000\n'1 ~ 1000 까지 반복\nFor\nc = 1 To 6\n'1 ~ 6까지 반복\nDo\n'다음을 실행\nintNo = wkF.\nRandBetween\n(1, 45)\n'1과 45 사이의 무작위 숫자를 변수에 넣음\nIf wkF.\nCount..."}
{"instruction": "Excel VBA code for: (1103) 무작위로 로또번호 추출하기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Lotto_Numbers3()\nDim minNo As Long\n'시작 값을 넣을 변수\nDim maxNo As Long\n'마지막 값을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nDim X As New Collection\n'컬렉션으로 사용할 변수\nDim j As Long\n'행을 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"A:F\").ClearContents\n'A:F열 기존 데이터 삭제\nminNo = 1\n'시작값을 변수에 넣음\nmaxNo = 45\n'마지막 값을 변수에 넣음\nFor j = 1 To\n1000\n'1 ~ 1000 행까지 반복\nOn Error\nResume Next\n'에러 발생해도 (중단없이)다음코드 진행\nDo\n'다음을 실행\nr = Int(Rnd * (maxNo - minNo)) + 1\n'무작위 값을 추출\nX.Add r,\nCStr\n(r)\n'컬렉션에 중복 없는 값을 넣음\nIf X.Count > 6 Then Exit Do\n'컬렉션에 6개의 데이터 입력시 Do 구문 종료\nLoop\n'무한 반복\nOn Error\nGoTo 0\n'에러 검출기능 복원\nFor i = 1 To 6\n'6회 반복\nCells(j, i) = X(i)\n'컬렉션의 값을 셀에 뿌림\nNext i\nSet X = Nothing\n'컬렉션 초기화\nNext j\nEnd Sub", "context": "매크로 실행 전                                                      매크로 실행 후 결과\nOption Explicit\nSub extract_Lotto_Numbers3()\nDim minNo As Long\n'시작 값을 넣을 변수\nDim maxNo As Long\n'마지막 값을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nDim X As New Collection\n'컬렉션으로 사용할 변수\nDim j As Long\n'행을 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"A:F\").ClearContents\n'A:F열 기존 데이터 삭제\nminNo = 1\n'시작값을 변수에 넣음\nmaxNo = 45\n'마지막 값을 변수에 넣음\nFor j = 1 To\n1000\n'1 ~ 1000 행까지 반복\nOn E..."}
{"instruction": "Excel VBA code for: (1104) 무작위로 로또번호 추출하기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Lotto_Numbers4()\nDim y As Long\n'행 늘려갈 변수\nConst\nmaxNo As Long =\n1000\n'생성할 행 개수를 변수에 넣음\nDim x As Integer\n'열 늘려갈 변수\nDim varTemp(\n1 To maxNo\n,\n1 To 45\n) As Integer\n'1 ~ 45를 넣을 배열변수\nDim r As Integer\n'랜덤값 추출에 사용할 변수\nDim vR(1 To maxNo, 1 To 6) As Integer\n'무작위로 섞은 값을 넣을 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nRandomize\n'초기화\nFor\ny = 1 To maxNo\n'행방향 1 ~ maxNo회 반복\nFor\nx = 1 To 45\n'열방향 6회 반복\nvarTemp(y, x) = x\n'배열에 반복하여 1 ~ 45의 숫자를 넣음\nNext\nx\nNext\ny\nFor y = 1 To maxNo\n'행방향 1 ~ maxNo회 반복\nFor x = 1 To 6\n'열방향 6회 반복\nDo\n'다음을 실행\nr =\nInt(Rnd\n* 45) + 1\n'무작위 값을 추출\nIf\nNot IsEmpty\n(varTemp(y, r)) Then\n'배열이 비어 있지 않다면\nvR(y, x) = varTemp(y, r)\n'셀값을 배열에 넣음\nvarTemp(y, r) =\nEmpty\n'배열내 사용한 값 삭제\nExit Do\n'Do 구문 종료\nEnd If\nLoop\nNext x\nNext y\nRange(Cells(1, 1), Cells(maxNo, 6)) = vR\n'배열 값을 셀에 뿌림\nEnd Sub", "context": "매크로 실행 전                                                       매크로 실행 후 결과\nOption Explicit\nSub extract_Lotto_Numbers4()\nDim y As Long\n'행 늘려갈 변수\nConst\nmaxNo As Long =\n1000\n'생성할 행 개수를 변수에 넣음\nDim x As Integer\n'열 늘려갈 변수\nDim varTemp(\n1 To maxNo\n,\n1 To 45\n) As Integer\n'1 ~ 45를 넣을 배열변수\nDim r As Integer\n'랜덤값 추출에 사용할 변수\nDim vR(1 To maxNo, 1 To 6) As Integer\n'무작위로 섞은 값을 넣을 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nRandomize\n'초기화\nFor\ny = 1 To maxNo\n'행방향 1 ~ maxNo회 반복\nFor\nx = 1 To 45\n'열방향 6회 반..."}
{"instruction": "Excel VBA code for: (1106) 각 구역(area)별 문자합치기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_Text_Cells1()\nDim rngA As Range\n'각 공백영역 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim strU As String\n'문자를 합쳐갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"C\").ClearContents\n'기존 데이터 삭제\nFor Each\nrngA\nIn\nColumns(\"A\").\nSpecialCells(4).\nAreas\n'각 공백 Area 순환\nSet rngA = rngA.Offset(-1, 1).Resize(rngA.Count + 1)\n'문자영역을 변수에\nFor Each rngC In rngA.\nCells\n'문자영역 각셀을 순환\nstrU = strU & rngC\n'문자를 합쳐감\nNext rngC\nrngA(1, 2).Cells(1) = strU\n'합친 문자를 셀에 뿌림\nstrU = \"\"\n'재사용 위하여 초기화\nNext\nrngA\nFor Each\nrngC\nIn\nColumns(\"A\").SpecialCells(2)\n'A열 각 문자열 순환\nIf rngC.Offset(1) <> \"\" Then\n'아래행이 공백이 아닐 경우\nrngC.Offset(, 2) = rngC.\nNext\n'오른쪽 두칸 위치에 오른쪽값 입력\nEnd If\nNext\nrngC\nColumns.AutoFit\n'열너비 자동맞춤\nSet rngA = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "(B열의 각 셀뒤에는 공백이 하나씩 더 있는 상황이므로 공백없이 각 셀을 합쳐감.)\n매크로 실행 전                                                 매크로 실행 후 결과\nOption Explicit\nSub combine_Text_Cells1()\nDim rngA As Range\n'각 공백영역 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim strU As String\n'문자를 합쳐갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"C\").ClearContents\n'기존 데이터 삭제\nFor Each\nrngA\nIn\nColumns(\"A\").\nSpecialCells(4).\nAreas\n'각 공백 Area 순환\nSet rngA = rngA.Offset(-1, 1).Resize(rngA.Count + 1)\n'문자영역을 변수에\nFor Each rngC In rngA.\nCells..."}
{"instruction": "Excel VBA code for: (1107) xlCalculationAutomatic과 xlCalculationManual의 속도비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub with_xlCalculateAutomatic()                    Sub with_xlCalculateManual()\nDim rngC As Range                                     Dim rngC As Range\nWith Application                                           With Application\n.ScreenUpdating = False                              .ScreenUpdating = False\n.Calculation = xlCalculation\nAutomatic\n.Calculation = xlCalculation\nManual\nFor Each rngC In Range(\"A1:B10000\")            For Each rngC In Range(\"A1:B10000\")\nrngC = Int(Rnd * 2) + 1                                  rngC = Int(Rnd * 2) + 1\nNext rngC                                                   Next rngC\n.Calculation = xlCalculationAutomatic             .Calculation = xlCalculationAutomatic\nEnd With                                                     End With\nEnd Sub", "context": "엑셀에서는 수식을 자동계산 하는 옵션과 수동계산하는 옵션이 있으며 일반적으로는 자동계산으로 사용한다. 아래 예제의 경우 C1:C10000 셀까지 A열과 B열 중 큰 값을 넣는 합수가 입력되어 있다. 이 때 매크로를 이용하여 A1:B10000 까지 1 또는 2를 입력 시 수식을 수동 계산하는 xlCalculationManual을 반드시 사용하여야 한다. 이 경우\nA1:B10000 셀까지 한 번에 값\n입력 => 전체셀 재계산\n을 한 번만 하지만 xlCalculationAutomatic을 사용하는 경우,\nA1셀 입력 => 전체셀 재계산 => B1셀 입력 => 전체셀 재계산 => A2셀입력 => 전체셀 재계산 ......\n의 과정을 반복하게 되어 수동계산에 비하여 훨씬 오랜 시간이 소요된다. 시트내에 수식이 많을 수록 시간차이가 더난다.\n매크로 실행 전(C열에 A열과 B열 중 큰 값을 넣는 합수 입력)          매크로 실행 후 결과\n반복횟수       xlCalculationAuto..."}
{"instruction": "Excel VBA code for: (1109) 셀의 숫자만큼 아래행에 번호붙여 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Private Sub Worksheet_Change(ByVal Target As Range)\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'번호를 늘려갈 변수\nIf Target.\nCount\n> 1 Then Exit Sub\n'1셀 이상 초과하여 선택시 매크로 종료\nIf\nIntersect\n(Range(\"A1:D1\"), Target)\nIs Nothing\nThen Exit Sub\n'셀 주소가 A1:D1 아니면 매크로 종료\nIf Target < 1 Then\n'1 미만 입력 시\nMsgBox \"1이상의 숫자 입력하세요\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nApplication.\nEnableEvents = False\n'이벤트 실행기능을 중지\nRange(Target.Offset(2), Cells(Rows.Count, _\nTarget.Column).End(3)).ClearContents\n'기존값 삭제\nFor Each rngC In Target.Offset(2).Resize(Target)\n'입력한 숫자만큼의 셀을 순환\nr = r + 1\n'번호 1씩 늘려감\nrngC = Target(2, 1) & r\n'각 셀에 이름 + 번호 입력\nNext rngC\nApplication.\nEnableEvents = True\n'이벤트 실행 기능을 복원\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1109) 셀의 숫자만큼 아래행에 번호붙여 복사하기 (엑셀 VBA 매크로)\n재생\n624\n재생 (space/k)\n재생\n00:25\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:25\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n(동영상에서 보는 바와 같이 아래의 코드는 표준모듈이 아닌 시트모듈에 들어감)\nOption Explicit\nPrivate Sub Worksheet_Cha..."}
{"instruction": "Excel VBA code for: (1110) 셀포인터 Highlight 시키기 (엑셀 VBA 매크로)", "input": "", "output": "Sub enable_Event()\n'표준 모듈(Module)에 연결된 코드\nDim strText As String\n'매크로 버튼의 문자를 넣을 변수\nWith ActiveSheet.\nShapes\n(Application.Caller\n)\n'매크로 실행한 도형\nstrText = .\nTextFrame2.TextRange.Text\n'버튼의 문자를 변수에 넣음\nIf strText = \"No Highlight\" Then\n'버튼이 No Highlight일 경우\n.TextFrame2.TextRange.Text = \"Highlight\"\n'버튼을 Highlight로 변경\n.ShapeStyle = 31\n'버튼색을 빨간색으로 바꿈\nApplication.\nEnableEvents = True\n'이벤트 트리거링 활성화\nElseIf strText = \"Highlight\" Then\n'버튼이 Highlight일 경우\nCells(1, 1).Copy\n'A1셀을 복사\nActiveCell.\nPasteSpecial\nPaste:=\nxlPasteFormats\n'현재 셀에 복사\n.TextFrame2.TextRange.Text = \"No Highlight\"\n'버튼을 No Highlight로 변경\nApplication\n.CutCopyMode = False\n'클립보드 비우기\n.ShapeStyle = 30\n'버튼색을 파란색으로 바꿈\nApplication.EnableEvents = False\n'이번트 트리거링 비활성화\nEnd If\nEnd With\nEnd Sub\n\nPrivate Sub Worksheet_SelectionChange\n(ByVal Target As Range)\n'시트 모듈에 연결된 코드\nIf Target.Count > 1 Then Exit Sub\n'복수의 셀 선택 시 매크로 종료\nIf Target.Areas.Count > 1 Then Exit Sub\n'복수의 영역 선택 시 매크로 종료\nStatic\nrngOld As Range\n'선택된 영역을 기억할 변수\nWith Application\n﻿\n'엑셀에서\n.EnableEvents = False\n'이벤트 트리거링을 비활성화\nOn Error\nResume Next\n'에러 발생해도 다음코드 진행\nCells(1, 1).Copy\n'A1셀 복사\nrngOld.PasteSpecial Paste:=xlPasteFormats\n'기존셀에 서식 복사\nTarget.Copy\n'현재 선택셀 복사\nCells(1, 1).PasteSpecial Paste:=xlPasteFormats\n'B1셀에 서식 복사\n.CutCopyMode = False\n'클립보드 비우기\nTarget.Select\n'현재 선택셀 선택\nTarget.\nInterior.ColorIndex\n=\n3\n'셀의 색을 빨간색으로\nSet rngOld = Target\n'현재 선택셀을 변수에 넣음\n.EnableEvents = True\n'이벤트 트리거링을 활성화\nEnd With\nEnd Sub", "context": "아래의 코드는 셀 포인터 즉, ActiveCell을 빨간색으로 활성화시켜 주는 기능. 이미 비슷한 것을 한 두번 해보았지만 셀 포인터 이동 시 기존의 서식을 삭제하는 부작용이 있었다. 아래의 코드는 그 문제를 해결.  매크로 버튼 뒤에 있는\nA1\n셀\n을 임시 복사 영역으로 사용하여 셀 포인터 이동 시 기존의 서식을 복원하여 준다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1110) 셀포인터 Highlight 시키기 (엑셀 VBA 매크로)\n재생\n1,180\n재생 (space/k)\n재생\n00:43\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:43\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다...."}
{"instruction": "Excel VBA code for: (1111) Range/Cells 속성과 Evaluate method의 속도비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub using_Evaluate_Method()                      Sub using_Range()\nDim r As Long                                            Dim r As Long\nApplication.ScreenUpdating = False             Application.ScreenUpdating = False\nFor r = 1 To 10000                                       For r = 1 To 10000\n[A1]\n= r\nCells(1, 1)\n= r\nNext r                                                       Next r\nEnd Sub", "context": "Range(\"A1\") 과 같이 표시하는 Range 속성 코드와 Cells(1, 1) 와 같이 표시하는 Cells 속성 코드는 속도가 거의 비슷하다. 하지만 [A1] 과 같이 표시하는 Evaluate method는 속도가 쳐진다.\n아래의 두 코드는 A1셀에 1 ~ 10,000까지 1씩 증가하며 숫자를 채우는 동일한 코드로서, 왼쪽의 코드는 Evaluate method를 사용하였고 오른쪽 코드는 Cells 속성을 사용하였다.\n매크로 실행 전                                                 매크로 실행 후 결과\n반복횟수\nEvaluate\nmethod 사용한 코드\nCells\nproperty 사용한 코드\n10,000회\n0.7초\n0.15\n초\nSub using_Evaluate_Method()                      Sub using_Range()\nDim r As Long                                           ..."}
{"instruction": "Excel VBA code for: (1112) Index와 For Each 구문의 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub using_Index()                                   Sub using_For_Each()\nDim c As Long                                         Dim rngC As Range\nApplication.ScreenUpdating = False           Application.ScreenUpdating = False\nRange(\"A1:J10000\").Select                        Range(\"A1:J10000\").Select\nWith Selection\nFor c = 1 To 100000\nFor Each\nrngC\nIn\nSelection\n.Cells\n(c)\n= 1                                       rngC = 1\nNext c                                                Next rngC\nEnd With\nEnd Sub", "context": "아래의 두 코드는 A1:J10000 까지 1로 채우는 동일한 기능을 하는 코드이다. 왼쪽의 코드는 index 즉 (선택영역) 각 셀에 부여되는 번호를 이용하였고, 오른쪽의 코드는 For Each 구문을 사용하였다.\nFor Each구문을 사용하는 코드가 index를 사용하는 코드보다는 더 빠르다. 두 코드를 동일하게 표시할 방법이 없어 index를 사용하는 코드가 더 길어져 그렇다고 볼 수도 있지만 책에서도 For Each 구문이 index 보다는 더 빠르다고 언급을 하므로 사실인 것 같다.\n﻿\n매크로 실행 전                                               매크로 실행 후 결과\n﻿\n﻿\n반복횟수\nIndex\n사용한 코드\nFor Each\n사용한 코드\n100,000셀\n3.17초\n2\n.67\n초\nSub using_Index()                                   Sub using_For_Each()\nDim c As Long       ..."}
{"instruction": "Excel VBA code for: (1113) 제목 제외하고 데이터만 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub trans_Data_Only()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim rngC As Range\n﻿'소프트웨어 이름을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)'Sheet2에서\n.UsedRange.\nClear\n'Sheet2의 기존 데이터 삭제\nRange(\"B4:K4\").\nCopy\n.Cells(1, 1)\n'제목 Sheet2에 복사\n.Columns(\"D\").\nInsert\n'D열에 열 삽입\n.Range(\"D1\") = \"프로그램명\"\n'D열에 제목 넣음\n.Columns(\"H:I\").\nNumberFormatLocal\n= \"mm\"\"월\"\"dd\"\"일\"\";@\"\n'H:I 열의 서식을 날짜로\nlastRow = Cells(Rows.Count, \"A\").End(3).\nRow\n'마지막 행을 변수에 넣음\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nIf Cells(r, 1) = \"순번\" Then\n'A열의 셀이 \"순번\"이면\nSet rngC = Cells(r - 1, 1)\n'소프트웨어 이름을 변수에 넣음\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nWith .Cells(Rows.Count, \"A\").End(3)(2)\n.Resize(, 3) = Cells(r, 2).Resize(, 3).Value\n'B:E열 복사\n.Offset(, 3) = rngC\n'프로그램명 복사\n.Offset(, 4).Resize(, 7) = Cells(r, 5).Resize(, 7).Value\n'F:K열 복사\nEnd With\nLoop Until\nCells(r + 1, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nEnd If\nLoop Until\nr = lastRow\n'행이 마지막 행에 도달할 때까지 반복\n.Columns.\nAutoFit\n'열너비 자동맞춤\n.\nActivate\n'Sheet2 활성화\nEnd With\nEnd Sub", "context": "1. 제목행을 제외한 데이터만 Sheet2에 복사\n2. 열을 추가하여 각 프로그램(소프트 웨어)의 이름을 넣음\n매크로 실행 전 (프로그램 이름과 제목이 중간 중간 데이터와 뒤섞여 있음) - Sheet2는 비어 있음\n매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub trans_Data_Only()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim rngC As Range\n﻿'소프트웨어 이름을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)'Sheet2에서\n.UsedRange.\nClear\n'Sheet2의 기존 데이터 삭제\nRange(\"B4:K4\").\nCopy\n.Cells(1, 1)\n'제목 Sheet2에 복사\n.Columns(\"D\").\nInsert\n'D열에 열 삽입\n.Range(\"D1\") = \"프로그램명\"\n'D열에 제목 ..."}
{"instruction": "Excel VBA code for: (1114) 월별 데이터 이름별 찾아 넣기 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_Out_Unique_Name()\nDim rngMar As Range\n'3월을 데이터를 넣을 변수\nDim rngApr As Range\n'4월 데이터를 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim C As Range\n'검색에 일치한 값을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n[G1].CurrentRegion.Offset(1).\nClear\n'기존 데이터 삭제\nSet\nrngMar = Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'3월 데이터 변수에\nSet rngApr = Range(\"D2\", Cells(Rows.Count, \"D\").End(3))\n'4월 데이터 변수에\nWith Cells(Rows.Count, \"G\")\n'G열 마지막셀에서\nrngMar.\nCopy\n.End(3)(2)\n'종단셀 윗방향 아래셀에 3월 자료 복사\nrngApr.Copy .End(3)(2)\n'종단셀 윗방향 아래셀에 4월 자료 복사\nEnd With\nWith Columns(\"G\").SpecialCells(2)\n'G열 문자 데이터에서\n.\nRemoveDuplicates\n1, 0\n'(이름) 중복 제거\n.Offset(1).\nSort\n[G2], 1\n'오름차순 정렬\nEnd With\nFor Each rngC In rngMar\n'3월 데이터 각 셀을 순환\nSet C = Columns(\"G\").\nFind\n(rngC)\n'G열에서 일치하는 셀을 변수에 넣음\nC.\nNext\n= rngC.Next\n'일치한 이름 오른쪽에 값을 넣음\nNext rngC\nFor Each rngC In rngApr\n'3월 데이터 각 셀을 순환\nSet C = Columns(\"G\").Find(rngC)\n'G열에서 일치하는 셀을 변수에 넣음\nC.Offset(, 2) = rngC.Next\n'일치한 이름 오른쪽 두 번째에 값을 넣음\nNext rngC\nSet rngMar = Nothing\n'개체 변수들 초기화(메모리 비우기)\nSet rngApr = Nothing\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 3월, 4월이 구분되어 합쳐진 결과\nOption Explicit\nSub sort_Out_Unique_Name()\nDim rngMar As Range\n'3월을 데이터를 넣을 변수\nDim rngApr As Range\n'4월 데이터를 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim C As Range\n'검색에 일치한 값을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n[G1].CurrentRegion.Offset(1).\nClear\n'기존 데이터 삭제\nSet\nrngMar = Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'3월 데이터 변수에\nSet rngApr = Range(\"D2\", Cells(Rows.Count, \"D\").End(3))\n'4월 데이터 변수에\nWith Cells(Rows.Count, \"G\")\n'G열 마지막셀에서\nrngMar.\nCopy..."}
{"instruction": "Excel VBA code for: (1115) 함수식이 없는 셀들만 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub leave_Formula_Only()\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In ActiveSheet.UsedRange\n'현재시트 사용영역 각셀을 순환\nIf\nNot IsEmpty\n(rngC) Then\n'각 셀이 빈셀이 아니라면\nIf Not rngC.\nHasFormula\nThen\n'각 셀에 수식이 없으면\nrngC = \"\"\n'각 셀을 삭제\nEnd If\nEnd If\nNext rngC\nEnd Sub", "context": "매크로 실행 전                                              (Ctrl + ~ 키를 클릭하여 함수가 입력된 내용 확인시)\n매크로 실행 후 수식있는 셀들만 남고 함수식이 없는 셀들만 삭제된 결과\nOption Explicit\nSub leave_Formula_Only()\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In ActiveSheet.UsedRange\n'현재시트 사용영역 각셀을 순환\nIf\nNot IsEmpty\n(rngC) Then\n'각 셀이 빈셀이 아니라면\nIf Not rngC.\nHasFormula\nThen\n'각 셀에 수식이 없으면\nrngC = \"\"\n'각 셀을 삭제\nEnd If\nEnd If\nNext rngC\nEnd Sub..."}
{"instruction": "Excel VBA code for: (1116) 중복이 있는 숫자만 중복개수 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub duplicates_Counting()\nDim rngA As Range\n'A열 문자셀을 넣을 변수\nDim rngC As Range\n'C열 문자셀을 넣을 변수\nDim rng As Range\n'각 셀을 넣을 변수\nDim wSF As\nWorksheetFunction\n'워크시트 함수를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"E:I\").ClearContents\n'기존 데이터 삭제\nSet wSF = WorksheetFunction\nSet rngA = Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'A열을 변수에\nSet rngC = Range(\"C2\", Cells(Rows.Count, \"C\").End(3))\n'C열을 변수에\nRange(\"E1:F1\") =\nArray\n(\"가격\", \"개수\")\n'제목 입력\nRange(\"H1:i1\") = Array(\"가격\", \"개수\")\n'제목 입력\nFor Each rng In Columns(\"A\").SpecialCells(2)\n'E열 각 문자셀 순환\nIf wSF.\nCountIf\n(rngA, rng) > 1 Then\n'만약 중복값이 있다면\nCells(Rows.Count, \"E\").End(3)(2) = rng\n'E열 종단셀 윗방향 아래셀에 복사\nEnd If\nNext rng\nWith Columns(\"E\")\n'E열에서\n.\nRemoveDuplicates\n1, 0\n'중복 제거\n.SpecialCells(2).Offset(1).\nSort\n[E2], 1\n'오름차순 정렬\nEnd With\nFor Each rng In Columns(\"C\").SpecialCells(2)\n'C열 각 문자셀 순환\nIf wSF.CountIf(rngA, rng) > 1 Then\n'만약 중복값이 있다면\nCells(Rows.Count, \"H\").End(3)(2) = rng\n'H열 종단셀 윗방향 아래셀에 복사\nEnd If\nNext rng\nWith Columns(\"H\")\n'H열에서\n.RemoveDuplicates 1, 0\n'중복 제거\n.SpecialCells(2).Offset(1).Sort [H2], 1\n'오름차순 젇렬\nEnd With\nFor Each rng In Range(\"E2\", Cells(Rows.Count, \"E\").End(3))\n'E열 각 셀 순환\nrng.Next = wSF.CountIf(rngA, rng)\n'각셀 오른쪽에 개수표시\nNext rng\nFor Each rng In Range(\"H2\", Cells(Rows.Count, \"H\").End(3))\n'H열 각 셀 순환\nrng.Next = wSF.CountIf(rngC, rng)\n'각셀 오른쪽에 개수표시\nNext rng\nSet rngA = Nothing\n'개체변수들 초기화\nSet rngC = Nothing\nEnd Sub", "context": "1. A열의 값 중 중복된 값이 있을 경우 E열에 오름차순으로 가격, F열에 중복 개수 표시\n2. C열의 값 중 중복된 값이 있을 경우 H열에 오름차순으로 가격, I열에 중복 개수 표시\n(코드는 약간 긴지만 실제로는 동일한 작업을 두 번 반복하므로 코드의 내용 자체는 단순함)\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub duplicates_Counting()\nDim rngA As Range\n'A열 문자셀을 넣을 변수\nDim rngC As Range\n'C열 문자셀을 넣을 변수\nDim rng As Range\n'각 셀을 넣을 변수\nDim wSF As\nWorksheetFunction\n'워크시트 함수를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"E:I\").ClearContents\n'기존 데이터 삭제\nSet wSF = WorksheetFunction\nSet rngA = Range(\"A2\", ..."}
{"instruction": "Excel VBA code for: (1117) 2행을 기준으로 각 열을 정렬하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub multi_Columns_Sort2()\nDim rngCol As Range\n'각 열을 넣을 변수\nDim rngTemp As Range\n'각 열을 임시로 복사해 넣을 변수\nDim colsCnt As Integer\n'전체 열의 개수를 넣을 변수\nDim i As Integer\n'열 개수만큼 반복할 변수\nDim j As Integer\n'열 개수 -1 만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열 개수를 변수에 넣음\nSet\nrngTemp = Range(Cells(2, 1), Cells(Rows.Count, 1).End(3)).Offset(, colsCnt)\n'임시로 데이터가 복사될 영역을 변수에 넣음\nFor i = 1 To colsCnt\n'열 개수만큼 반복\nFor j = 1 To colsCnt\n- 1\n'열 개수 -1 만큼 반복\nSet rngCol = Range(Cells(2, j), Cells(Rows.Count, j).End(3))\n'각 열을 변수에 넣음\nIf Cells(2, j)\n>\nCells(2, j + 1) Then\n'만약 2행의 앞셀 값이 클 경우\nrngCol.Copy rngTemp\n'열을 임시영역에 복사\nrngCol.Offset(, 1).Copy rngCol\n'뒷열을 앞열에 복사\nrngTemp.Copy rngCol.Offset(, 1)\n'임시영역을 뒷열에 복사\nEnd If\nNext j\nNext i\nrngTemp.\nClear\n'임시 영역 삭제\nSet rngTemp = Nothing\n'개체변수들 초기화\nSet rngCol = Nothing\nEnd Sub", "context": "2행을 기준으로 각 행을 오름차순으로 정렬하기. 아래의 > 를 < 로 방향 바꾸면 내림차순 정렬됨.\n매크로 실행 전\n매크로 실행 후 결과\n윗 기능은 엑셀의 기본 기능에 이미 있는 것이다. 단지 공부를 위해 VBA를 이용하여 따라해본 것이며 당연히 엑셀의 기본 정렬을 사용해야 한다. 아래의 그림 참조.\nOption Explicit\nSub multi_Columns_Sort2()\nDim rngCol As Range\n'각 열을 넣을 변수\nDim rngTemp As Range\n'각 열을 임시로 복사해 넣을 변수\nDim colsCnt As Integer\n'전체 열의 개수를 넣을 변수\nDim i As Integer\n'열 개수만큼 반복할 변수\nDim j As Integer\n'열 개수 -1 만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열 개수를 변..."}
{"instruction": "Excel VBA code for: (1118) 각 열을 정렬하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_Each_Column()\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim rngCol As Range\n'각 열을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\ncolsCnt = ActiveSheet.UsedRange.\nColumns.Count\n'전체 열개수 변수에 넣음\nFor i = 1 To colsCnt\n'전체 열 개수만큼 반복\nSet\nrngCol = Range(Cells(2, i), Cells(Rows.Count, i).End(3))\n'각 열을 변수에 넣음\nrngCol.\nSort\nrngCol.\nCells(1)\n, xlAscending\n'각 열을 오름차순으로 정렬\nNext i\nSet rngCol = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "이미 동일한 코드를 올렸던 것 같은데 비슷한 것들은 있어도 같은 것은 검색해도 찾을 수가 없다. 각 열을 다른 열들과는 별도로 오름차순으로 정렬하는 단순한 기능.\nOption Explicit\nSub sort_Each_Column()\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim rngCol As Range\n'각 열을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\ncolsCnt = ActiveSheet.UsedRange.\nColumns.Count\n'전체 열개수 변수에 넣음\nFor i = 1 To colsCnt\n'전체 열 개수만큼 반복\nSet\nrngCol = Range(Cells(2, i), Cells(Rows.Count, i).End(3))\n'각 열을 변수에 넣음\nrngCol.\nSort\nrngCol.\nCells(1)\n, xlAscending\n'각 ..."}
{"instruction": "Excel VBA code for: (1119) 장비별 데이터 재 정렬하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub relocate_Data_Per_Equipment()\nDim rngA As Range\n'A열 문자셀을 넣을 변수\nDim rngC As Range\n'A열 각 셀을 넣을 변수\nDim rngEach As Range\n'Sheet2의 기능설명 각 셀을 넣을 변수\nDim i As Integer\n'반복 구문에 사용할 변수\nDim rngT As Range\n'복사될 지점 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n.UsedRange.Clear\n'Sheet2의 기존 데이터 삭제\nRows(1).SpecialCells(2).\nCopy\n.Range(\"A1\")\n'제목행 복사\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'A열 각 문자셀 순환\nSet rngT = .Cells(Rows.Count, \"A\").End(3)(2).Resize(rngC.Next)\nrngT = rngC\n'장비명 복사\nrngT.Offset(, 1) = 1\n'Tag합계 복사\nrngT.Offset(, 2) =\n_\nApplication.Transpose\n(rngC.Offset(, 2).Resize(, rngC.Next))\n'Tag1 복사\nFor Each rngEach In rngT.Offset(, 8)\n'I열 각 셀을 순환\ni = i + 1\n'열 값을 1씩 늘려감\nrngEach = rngC & \"_\" & rngC.Offset(, i + 1)\n'각 셀에 장비명 + Tag명 입력\nNext rngEach\ni = 0\n'재사용 위하여 초기화\nNext rngC\n.Columns.AutoFit\n'열너비 자동맞춤\n.UsedRange.\nBorders.LineStyle = 1\n'외곽 테두리\n.Activate\n'활성화\nEnd With\nSet rngT = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "아래 매크로 실행 전과 매크로 실행 후 결과처럼 데이터를 재 배치하는 기능.\n매크로 실행 전 (Sheet2는 비어 있음)\n매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub relocate_Data_Per_Equipment()\nDim rngA As Range\n'A열 문자셀을 넣을 변수\nDim rngC As Range\n'A열 각 셀을 넣을 변수\nDim rngEach As Range\n'Sheet2의 기능설명 각 셀을 넣을 변수\nDim i As Integer\n'반복 구문에 사용할 변수\nDim rngT As Range\n'복사될 지점 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n.UsedRange.Clear\n'Sheet2의 기존 데이터 삭제\nRows(1).SpecialCells(2).\nCopy\n.Range(\"A1\")\n'제목행 복사\nFor Each rngC In Range(\"A2\", Cell..."}
{"instruction": "Excel VBA code for: (1122) 중첩 For 구문과 For Each 구문의 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub using_\nNesting_For\n()                     Sub using_\nFor_Each\n()\nDim c As Integer\nDim r As Long                                    Dim rngC As Range\nApplication.ScreenUpdating = False      Application.ScreenUpdating = False\nFor\nc = 1 To 1000\nFor\nr = 1 To 1000\nFor Each\nrngC\nIn\nRange(\"A1\", \"ALL1000\")\nCells(c, r) = 1                               rngC = 1\nNext\nr\nNext\nrngC\nNext\nc\nEnd Sub", "context": "참고로, 엑셀의 중첩이란 단어는 영어로 Nesting 이라고 한다. 아래의 두 코드는 A1셀에서 ALL1000 셀, 즉 가로 1000개 x 세로 1000개의 셀을 1로 채우는 동일한 기능을 하는 코드이다. 왼족의 코드는 중첩 For 구문(For 구문안에 또 다시 For 구문을 사용하는 것)을 사용하였고, 오른쪽의 코드는 For Each ... Next 구문을 사용하였다.\n반복횟수\nIndex\n사용한 코드\nFor Each\n사용한 코드\n1,000,000셀\n20.15초\n19.25\n초\nSub using_\nNesting_For\n()                     Sub using_\nFor_Each\n()\nDim c As Integer\nDim r As Long                                    Dim rngC As Range\nApplication.ScreenUpdating = False      Application.ScreenUpdating = False\nFor..."}
{"instruction": "Excel VBA code for: (1123) 작업자별 근무개시일 및 최종 근무종료일 찾기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Starting_Ending_Date()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngT As Range\n'Sheet2에서 각 행의 복사될 기준위치\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\n.Columns(\"B:C\").\nNumberFormatLocal\n= \"yyyy\"\"-\"\"mm\"\"-\"\"dd;@\"\n'B:C열 서식 날짜로\nRows(1).Copy\n'1행을 복사\n.Cells(1, 1).\nPasteSpecial\nPaste:=xlPasteColumnWidths '열너비 복사\n.Paste\n'값 복사\nApplication.\nCutCopyMode = False\n'자르기/복사모드 해제(클립보드 비우기)\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'A열 각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nSet rngT = .Cells(Rows.Count, \"A\").End(3)(2)\n'복사위치를 개체변수에 넣음\nrngT = Cells(r, 1)\n'A열에 \"이름\" 복사\nrngT(1, 2)\n= Cells(r - i, 2)\n'B열에 \"근무개시\" 복사\nrngT(1, 3) = Cells(r, 3)\n'C열에 \"근무종료\" 복사\nrngT(1, 4) = Cells(r, 4)\n'D열에 \"비고\" 복사\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\n.Activate\n'활성화\nEnd With\nEnd Sub", "context": "아래의 데이터는 A열과 B열이 오름차순 정렬된 것을 기준으로 작성. 오름차순 정렬 시 최종 \"근무종료\"일은 동일인의 제일 마지막 행 C열에 위치하게 되므로 이를 이용하여 코드 작성. (외곽 테두리와 화살표는 원래 없는 것이지만 설명을 위하여 표시함)\n매크로 실행 전 (Sheet2는 비어 있는 상태)                매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub find_Starting_Ending_Date()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngT As Range\n'Sheet2에서 각 행의 복사될 기준위치\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\n.Columns(\"B:C\").\nNumberFormatLocal\n= \"yyy..."}
{"instruction": "Excel VBA code for: (1124) 각 이름 동일한 그룹별로 재배치하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub grouped_Transpose()\nDim r As Long\n'Sheet1에서 행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim y As Long\n'Sheet2에서 행을 늘려갈 변수\nDim rngA As Range\n'각 그룹을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.\nClear\n'기존 데이터 삭제\nr = 1\n'1행 부터 시작\nDo\n'다음을 실행\nIf\nLeft\n(Cells(r, 1), 2) = Left(Cells(r + 1, 1), 2) Then\n'A열 각 셀의 앞 2글자가 바로 아래 셀의 앞 2글자와 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\ny = y + 1\n'(Sheet2) 행을 1씩 늘려감\nIf i = 0 Then\n'만약 (중복 없는) 1행이면\n.Cells(y, 1) = Cells(r, 1)\n'값을 입력\nElse\n'만약 복수의 행이라면\nSet\nrngA = Cells(r - i + 1, 1).Resize(i)\n'각 그룹의 제일 윗행을 제외하고 변수에 넣음\n.Cells(y, 1) = Cells(r - i, 1)\n'각 그룹 제일 윗행의 값을 입력\nFor Each rngC In rngA\n'각 그룹의 제목 제외한 영역을 순환\n.Cells(y, Columns.Count).\nEnd(1)(1, 2)\n=\nSplit\n(rngC)\n(1)\n'오른쪽 문자만 입력\nNext rngC\nEnd If\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\n.Columns.AutoFit\n'열너비 자동맞춤\n.Activate\n'활성화\nEnd With\nSet rngA = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "동일한 이름을 가진 그룹의 데이터를 제목을 빼고 행열 변환하여 재배치하는 기능\n매크로 실행 전 (Sheet2는 비어 있음)                    매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub grouped_Transpose()\nDim r As Long\n'Sheet1에서 행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim y As Long\n'Sheet2에서 행을 늘려갈 변수\nDim rngA As Range\n'각 그룹을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.\nClear\n'기존 데이터 삭제\nr = 1\n'1행 부터 시작\nDo\n'다음을 실행\nIf\nLeft\n(Cells(r, 1), 2) = Left(Cells(r + 1, 1), 2) Th..."}
{"instruction": "Excel VBA code for: (1125) 각 이름 동일한 그룹별로 재배치하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub grouped_Transpose2()\nDim r As Long\n'Sheet1에서 행(r)ow 늘려갈 변수\nDim y As Long\n'Sheet2에서 행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nr = 1\n'1행 부터 시작\nDo\n'다음을 실행\nIf\nLeft\n(Cells(r, 1), 2) = Left(Cells(r + 1, 1), 2) Then\n'A열 각 셀의 앞 2글자가 바로 아래 셀의 앞 2글자와 같으면\ny = y + 1\n'(Sheet2) 행을 1씩 늘려감\n.Cells(y, 1) = Cells(r, 1)\n'각 그룹 제일 윗행의 값을 입력\nDo\n'다음을 실행\nr = r + 1\n'sheet1 행을 1씩 늘려감\n.Cells(y, Columns.Count).\nEnd(1)(1, 2)\n=\nSplit\n(Cells(r, 1))\n(1)\n'오른쪽 문자만 입력\nLoop Until\nLeft(Cells(r, 1), 2) <> Left(Cells(r + 1, 1), 2)\n'위아래  이름 다르면\nElse\n'만약 (중복 없는) 1행이면\ny = y + 1\n'(Sheet2) 행을 1씩 늘려감\n.Cells(y, 1) = Cells(r, 1)\n'값을 입력\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\n.Columns.AutoFit\n'열너비 자동맞춤\n.Activate\n'활성화\nEnd With\nEnd Sub", "context": "동일한 이름을 가진 그룹의 데이터를 제목을 빼고 행열 변환하여 재배치하는 기능. 이번에는 Do 중첩구문을 사용하여 해보았다. 이렇게 이름이 정렬이 되어 그룹별로 묶여 있는 경우\nDo 중첩구문\n의 사용도 상당히 유용하다.\n매크로 실행 전 (Sheet2는 비어 있음)                    매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub grouped_Transpose2()\nDim r As Long\n'Sheet1에서 행(r)ow 늘려갈 변수\nDim y As Long\n'Sheet2에서 행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nr = 1\n'1행 부터 시작\nDo\n'다음을 실행\nIf\nLeft\n(Cells(r, 1), 2) = Left(Cells(r + 1, 1), 2) Then\n'A열 각 셀의 앞 ..."}
{"instruction": "Excel VBA code for: (1126) 각 이름 동일한 그룹별로 재배치하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub grouped_Transpose3()\nDim rngA As Range\n'각 구역(A)rea 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.\nClear\n'기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Cells(1, 1)\n'데이터 (Sheet2에) 복사\n.Activate\n'활성화\nEnd With\nActiveSheet.UsedRange.\nTextToColumns\n[A1], DataType:=xlDelimited, _\nSpace:=True\n'현재시트 사용영역 문자를 공백으로 분리\nFor Each rngA In Columns(\"B\").SpecialCells(2).\nAreas\n'B열 각 구역(area)을 순환\nrngA.Copy\n'각 구역을 복사\nrngA.Cells(1)(0, 1).\nPasteSpecial\nTranspose:=True\n'행열 변환하여 각 구역 윗셀에 복사\nNext rngA\nActiveSheet.UsedRange.\nRemoveDuplicates\n1, 0\n'1번 필드 제목없이 중복제거\nColumns.AutoFit\n'열너비 자동맞춤\nEnd Sub", "context": "동일한 이름을 가진 그룹의 데이터를 제목을 빼고 행열 변환하여 재배치하는 기능. 구역(area) 속성, 문자분리 및 중복제거(RemoveDuplicates) 메서드를 사용하여 해보았다.\n매크로 실행 전 (Sheet2는 비어 있음)                    매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub grouped_Transpose3()\nDim rngA As Range\n'각 구역(A)rea 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.\nClear\n'기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Cells(1, 1)\n'데이터 (Sheet2에) 복사\n.Activate\n'활성화\nEnd With\nActiveSheet.UsedRange.\nTextToColumns\n[A1], DataType:=xlDelimited, _..."}
{"instruction": "Excel VBA code for: (1127) 각 이름 동일한 그룹별로 재배치하기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub grouped_Transpose4()\nDim r As Long\n'Sheet1에서 행(r)ow 늘려갈 변수\nDim y As Long\n'Sheet2에서 행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nr = 1\n'1행 부터 시작\nDo\n'다음을 실행\nIf\nLeft(Cells(r, 1), 2) = Left(Cells(r + 1, 1), 2) Then\n'A열 각 셀의 앞 2글자가 바로 아래 셀의 앞 2글자와 같으면\nIf\nInStr\n(1, Cells(r, 1), \" \") Then\n'각 셀에 공백이 있다면\n.Cells(y, Columns.Count).\nEnd(1)(1, 2)\n=\nSplit\n(Cells(r, 1))\n(1)\nElse\n'위 아래셀의 앞 2글자가 다르면\ny = y + 1\n'(Sheet2) 행을 1씩 늘려감\n.Cells(y, 1) = Cells(r, 1)\n'셀값을 입력\nEnd If\nElse\n'각 셀이 바로 아래 셀과 다르면\nIf InStr(1, Cells(r, 1), \" \") Then\n'각 셀에 공백이 있다면\n.Cells(y, Columns.Count).End(1)(1, 2) = Split(Cells(r, 1))(1)\n'오른쪽 문자만 입력\nElse\n'각 셀에 공백이 없다면\ny = y + 1                                '\n(Sheet2) 행을 1씩 늘려감\n.Cells(y, 1) = Cells(r, 1)\n'셀값을 입력\nEnd If\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\n.Columns.AutoFit\n'열너비 자동맞춤\n.Activate\n'활성화\nEnd With\nEnd Sub", "context": "동일한 이름을 가진 그룹의 데이터를 제목을 빼고 행열 변환하여 재배치하는 기능. 아래에서는 Do구문 내에 If 구문을 중첩하여 동일한 기능을 구현해 보았다.\n매크로 실행 전 (Sheet2는 비어 있음)                    매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub grouped_Transpose4()\nDim r As Long\n'Sheet1에서 행(r)ow 늘려갈 변수\nDim y As Long\n'Sheet2에서 행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nr = 1\n'1행 부터 시작\nDo\n'다음을 실행\nIf\nLeft(Cells(r, 1), 2) = Left(Cells(r + 1, 1), 2) Then\n'A열 각 셀의 앞 2글자가 바로 아래 셀의 앞 2글자와 같으면\nIf\nInStr\n(1..."}
{"instruction": "Excel VBA code for: (1128) 각 이름 동일한 그룹별로 재배치하기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub grouped_Transpose5()\nDim r As Long\n'Sheet1에서 행(r)ow 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nActiveSheet.UsedRange.\nCopy\n.Cells(1, 1)\n'데이터 (Sheet2에) 복사\n.\nActivate\n'활성화\nEnd With\nr = 1\n'1행 부터 시작\nDo\n'다음을 실행\nIf InStr(1, Cells(r, 1), \" \") Then\n'각 셀에 공백이 있다면\nCells(r - 1, Columns.Count).\nEnd(1)(1, 2)\n=\nSplit\n(Cells(r, 1))\n(1)\nRows(r).Delete\n'행을 삭제\nr = r - 1\n'행을 1 감소\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\nColumns.AutoFit\n'열너비 자동맞춤\nEnd Sub", "context": "동일한 이름을 가진 그룹의 데이터를 제목을 빼고 행열 변환하여 재배치하는 기능. 앞서 이미 4번이나 해본 동일한 기능을 이번에는 행삭제를 이용해서 해보았다. 코드는 제일 짧지만 행을 삭제하므로 다른 방법들에 비하여 속도는 제일 떨어질 것으로 예상된다.\n매크로 실행 전 (Sheet2는 비어 있음)                    매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub grouped_Transpose5()\nDim r As Long\n'Sheet1에서 행(r)ow 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nActiveSheet.UsedRange.\nCopy\n.Cells(1, 1)\n'데이터 (Sheet2에) 복사\n.\nActivate\n'활성화\nEnd With\nr = 1\n'1행 부터 시작\nDo\n'다음을 실행\n..."}
{"instruction": "Excel VBA code for: (1129) 빈번하게 사용되는 그림파일 손쉽게 삽입하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Picture_Stamp()\nDim rngAll As Range\n'선택영역을 넣을 변수\nIf\nTypeName\n(Selection) =\n\"Range\"\nThen\n'선택한 것의 타입이 영역이면\nSet rngAll = Selection\n'선택영역을 변수에 넣음\nElse\n'영역 아닌 개체나 다른 것을 선택 시\nMsgBox \"영역을 선택하지 않았습니다.\", 64, \"영역선택오류\"\nExit Sub\n'매크로 종료\nEnd If\nThisWorkbook.Sheets(1).\nPictures\n(\"Picture 1\").Copy\n'이 매크로 실행파일(개인용 매크로 통합문서) Sheet1의 그림복사\nActiveSheet.Paste\n'현재시트에 붙여넣기\nWith Selection\n'선택영역에서\n.ShapeRange.\nLockAspectRatio\n=\nmsoFalse\n'가로세로 비율고정 해제\n.Left = rngAll.Left + 2\n'그림의 왼쪽위를 선택영역 왼쪽위 + 2로 설정\n.Top = rngAll.Top + 2\n'그림의 높이위치를 선택영역 높이위치 + 2로 설정\n.Height = rngAll.Height - 4\n'그림의 높이를 선택영역 높이 - 4로 설정\n.Width = rngAll.Width - 4\n'그림의 폭을 선택영역의 폭 - 4로 설정\nEnd With\nEnd Sub", "context": "도장그림 또는 회사의 로고와 같이 자주 사용하는 그림파일을 원하는 위치에 빈번하게 복사하여 사용하는 경우 아래와 같이 하면 편리하다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1129) 빈번하게 사용되는 그림파일 손쉽게 삽입하기 (엑셀 VBA 매크로)\n재생\n3,162\n재생 (space/k)\n재생\n01:24\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:24\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서..."}
{"instruction": "Excel VBA code for: (1130) 파일 이름의 + 를 공백(space)으로 바꾸기 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Plus_In_File_Names()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strName As String\n'새로운 파일 이름을 넣을 변수\nDim cnt As Long\n'카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf\n.SelectedItems.Count = 0\nThen\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName =\nDir\n(strPath & \"\n*.*\n\")\n'(폴더내) 파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nIf\nInStr\n(1, fileName, \"+\") Then\n'이름에 + 가 들어가 있다면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nstrName =\nReplace\n(fileName, \"+\", \" \")\n'+를 모두 공백(space)로 바꾸기\nOn Error Resume Next\n'에러 발생해도 다음코드 진행\nName\nstrPath & fileName\nAs\nstrPath & strName\n'새로운 이름으로 변경\nIf\nErr.Number\n=\n58\nThen\n'이미 동일한 파일이름이 존재하면\nMsgBox \"파일 \" & fileName & \"는 + 없앤 파일이 이미존재하여\" & vbCr _\n& \"파일이름 변경 하지 않음\"\n'메시지 출력\ncnt = cnt - 1\n'카운터를 1 줄여감\nEnd If\nOn Error GoTo 0\n'에러 검출기능 복원\nEnd If\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nIf cnt > 0 Then\n'카운터가 0보다 크면\nMsgBox \"총 \" & cnt & \"개의 파일이름을 변경하였습니다.\"\n'메시지 출력\nElse\n'카운터가 0이면\nMsgBox \"폴더내에 +가 들어간 파일이 없습니다.\"\n'메시지 출력\nEnd If\nEnd Sub", "context": "네이버 블로그를 포함하여 웹상에서 파일을 업로드 했다가 다운 받으면 파일이름의 공백(space)이 플러스(+)로 바뀌는 경우가 많다. 즉 \"ABC 123 DEF.xlsx\" 파일이 \"ABC+123+DEF.xlsx\"로 바뀌는 경우이다. 아래의 매크로는 폴더내의 파일 이름내의 + 를 공백으로 바꾸는 기능.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1130) 파일 이름의 + 를 공백(space)으로 바꾸기 (엑셀 VBA 매크로)\n재생\n562\n재생 (space/k)\n재생\n00:23\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:23\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요..."}
{"instruction": "Excel VBA code for: (1132) 고급필터로 다중조건 만족하는 데이터 추출 (엑셀 VBA 매크로)", "input": "", "output": "Sub advanced_Filter_Multiple_Conditions()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nSet rngAll = Range(\"A1\", Cells(Rows.Count, \"D\").End(3))\n'전체 영역을 변수에 넣음\ncolsCnt = rngAll.Columns.Count\n'전체 열 개수를 변수에 넣음\nWith Cells(1, colsCnt + 1)\n'1행 제일오른쪽에\n.Resize(, 3) = \"조건식제목\"\n'\"조건식제목\"을 넣음\n.Offset(1).\nFormula\n= \"=OR(A2=\" &\n\"\"\"\n사과\n\"\"\"\n& _\n\",A2=\" & \"\"\"딸기\"\"\" & \",A2=\" & \"\"\"배\"\"\" & \")\"\n'첫째 조건을 넣음\n.Offset(1, 1).Formula = \"=OR(B2=\" & _\n\"\"\"단맛\"\"\" & \",B2=\" & \"\"\"신맛\"\"\" & \")\"\n'두 번째 조건을 넣음\n.Offset(1, 2).Formula = \"=C2 >=1000\"\n'세 번째 조건을 넣음\nEnd With\nrngAll.\nAdvancedFilter\n2, Cells(1, colsCnt + 1).Resize(2, 3), .Cells(1, 1)\n'조건에 맞는 데이터를 sheet2에 복사\nCells(1, colsCnt + 1).Resize(2, 3).ClearContents\n'임시로 사용한 영역의 조건 삭제\n.Columns.AutoFit\n'열너비 자동 맞춤\n.Activate\n'활성화\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "고급 필터를 이용하여 복수의 조건, 즉,\n(사과 or 딸기 or 배) and (단맛 or 신맛) and (가격 >= 1000)\n조건을 만족하는 데이터를 추출하는 기능. (질문한 분이 계셔서 아래와 같이 코드를 작성해 보았지만 이와 같이 단일한 조건일 경우에는 사실 매크로를 사용할 이유는 없다. 엑셀에서 조건식과 고급필터를 적용해서도 당연히 가능하기 때문이다.).\n매크로 실행 전 (Sheet2는 비어 있음)                                       매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub advanced_Filter_Multiple_Conditions()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'Sheet2에서\n.UsedR..."}
{"instruction": "Excel VBA code for: (1134) 각 그룹내의 숫자 중복개수 구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub dupes_Counting_In_Each_Group()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngUp As Range\n'윗그룹을 넣을 변수\nDim rngMid As Range\n'중간그룹을 넣을 변수\nDim rngDown As Range\n'아랫그룹을 넣을 변수\nDim rngU As Range\n'위아래 그룹을 합칠 변수\nDim u As Long\n'위 또는 아래그룹 행을 줄이거나 늘릴변수\nDim rowT As Long\n'중간그룹 첫째셀 또는 마지막셀 행번호 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim cnt1 As Long\n'윗그룹 중복 개수 카운터로 사용할 변수\nDim cnt2 As Long\n'아랫윗그룹 중복 개수 카운터로 사용할 변수\nDim lngU As Long\n'카운터를 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nRange(\"B2\", Cells(Rows.Count, \"B\").End(3)).Offset(, 1).Clear\n'기존 C열의 데이터 삭제\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nIf i <> 0 Then\n'만약 i가 0이 아니면, 즉 중간그룹이 복수행이면\nSet\nrngMid = Cells(r - i, 1).Resize(i + 1)\n'중간그룹을 변수에 넣음\nrowT = rngMid.\nCells(1).\nRow\n- 1\n'중간그룹 첫째셀의 행 - 1을 rowT에 넣음\nDo While\nLeft(Cells(rowT, 1), 2) = Left(rngMid.Cells(1), 2)\n'앞 두자리가 같으면\nIf\nrngUp Is Nothing\nThen\n'만약 rngUp 이 비어있다면\nSet rngUp = Cells(rowT, 1)\n'첫 번째 셀을 넣음\nElse\n'만약 rngUp이 비어 있지 않다면\nSet rngUp =\nUnion\n(rngUp, Cells(rowT, 1))\n'rngUp과 각 셀을 합쳐 넣음\nEnd If\nrowT = rowT - 1\n'윗그룹 셀의 행을 1씩 빼나감\nLoop\n'무한 반복\nrowT = rngMid.Cells(rngMid.Cells.Count).Row + 1\n'중간그룹 마지막셀의 행 + 1을 rowT에 넣음\nDo While\nLeft(Cells(rowT, 1), 2) = Left(rngMid.Cells(rngMid.Cells.Count), 2)\n'앞 두자리가 같으면\nIf rngDown Is Nothing Then\n'만약 rngDown이 비어 있다면\nSet rngDown = Cells(rowT, 1)\n'첫 번째 셀을 넣음\nElse\n'만약 rngDown이 비어 있지 않다면\nSet rngDown = Union(rngDown, Cells(rowT, 1))\n'rngDown과 각 셀을 합쳐 넣음\nEnd If\nrowT = rowT + 1\n'아랫그룹 셀의 행을 1씩 늘려감\nLoop\n'무한 반복\nIf\nNot rngUp Is Nothing\nAnd\nNot rngDown Is Nothing Then\n'위아래 그룹이 존재하면\nSet rngU = Union(rngUp, rngDown)\n'rngUp과 rngDown을 합쳐 rngU에 넣음\nFor Each rngC In rngMid\n'중간그룹 각 셀을 순환\ncnt1 =\nWorksheetFunction.CountIf\n(rngUp.Offset(, 1), rngC.Next)\n'윗그룹영역에서 중복개수를 구함\nlngU = lngU + cnt1\n'중복 개수를 합쳐감\ncnt2 = WorksheetFunction.CountIf(rngDown.Offset(, 1), rngC.Next)\n'아랫그룹영역에서 중복개수를 구함\nlngU = lngU + cnt2\n'중복 개수를 합쳐감\nNext rngC\nElseIf\nNot rngUp Is Nothing And rngDown Is Nothing Then\n'윗 그룹만 존재하면\nSet rngU = rngUp\n'rngU에 rngUp을 넣음\nFor Each rngC In rngMid\n'중간그룹 각 셀을 순환\ncnt1 = WorksheetFunction.CountIf(rngUp.Offset(, 1), rngC.Next)\n'윗그룹 영역에서 중복개수를 구함\nlngU = lngU + cnt1\n'중복 개수를 합쳐감\nNext rngC\nElseIf\nrngUp Is Nothing And Not rngDown Is Nothing Then\n'아랫그룹만 존재하면\nSet rngU = rngDown\n'rngU에 rngDown을 넣음\nFor Each rngC In rngMid\n'중간그룹 각 셀을 순환\ncnt2 = WorksheetFunction.CountIf(rngDown.Offset(, 1), rngC.Next)\n'아랫그룹영역에서 중복개수를 구함\nlngU = lngU + cnt2\n'중복 개수를 합쳐감\nNext rngC\nEnd\nIf\nrngMid.Cells(1).Offset(, 2) = lngU\n'중복의 개수를 중간그룹 첫행셀에 뿌림\nEnd If\nrowT = 0\n'재사용 위하여 초기화\nlngU = 0\n'재사용 위하여 초기화\ncnt1 = 0\n'재사용 위하여 초기화\ncnt2 = 0\n'재사용 위하여 초기화\nSet rngUp = Nothing\n'재사용 위하여 초기화\nSet rngDown = Nothing\n'재사용 위하여 초기화\nSet rngU = Nothing\n'재사용 위하여 초기화\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\nFor Each rngC In Range(\"B2\", Cells(Rows.Count, \"B\").End(3))\n'B열 각 문자셀을 순환\nIf IsEmpty(rngC.Next) Then\n'C열이 비어 있다면\nrngC.Next = 0\n'C열에 0을 넣음\nEnd If\nNext rngC\nSet rngUp = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngMid = Nothing\nSet rngDown = Nothing\nSet rngU = Nothing\nEnd Sub", "context": "원래는 색이 없지만 구분의 편리를 위하여 색을 넣음. 앞 두 자리수가 같은 것이 같은 그룹이며, 같은 그룹은 같은 색으로 표시함.\n전체영역에서의 중복이 아닌 각 그룹내에서의 중복 숫자 개수를 구하는 것임.\n보라색의 경우 두 그룹이 존재하며, B열의 65가 각 그룹에 1개씩 있음. 중복 개수를 각 그룹의 C열 첫 행에 입력하고 나머지는 0으로 입력.\n파란색의 경우 1행이므로 C열을 0으로 입력.\n고동색의 경우 1개의 그룹이므로 C열을 모두 0으로 입력.\n회색의 경우 세 그룹이 존재하며, B열의 88이 각 그룹에 1개씩 있음. 즉, 88이 다른 그룹에 2개 존재. 중복 개수를 각 그룹의 C열 첫 행에 입력하고 나머지는 0으로 입력.\n매크로 실행 전                                                     매크로 실행 후 결과\nOption Explicit\nSub dupes_Counting_In_Each_Group()\nDim r As Long\n'행(r)o..."}
{"instruction": "Excel VBA code for: (1136) VBA(매크로)를 공부해야 하는 이유", "input": "", "output": "Sub TimeTest()\nDim x As Long\nDim StartTime As Single\nDim i As Long\nx = 0\nStartTime = Timer\nFor i = 1 To 100000000\nIf Rnd <= 0.5 Then x = x + 1 Else x = x - 1\nNext i\nMsgBox Timer - StartTime & \" seconds\"\nEnd Sub", "context": "매크로를 전혀 모르는 사람들 중에 이런 생각을 하는 사람이 있을지 모르겠다, \"매크로가 빠르다고 듣긴 했지만 그까짓게 빨라봐야 뭐 얼마나 빠르겠어. 난 손이 빠르니 Ctrl + C, Ctrl + V 만으로도 왠만한 것은 다한다\"라고.\n아래의 내용은 John Walkenbach씨의 \"\nExcel VBA Programming For Dummies\n\"책에 나오는 내용의 일부를 간단히 번역해 보았다. 회사에서 또는 개인적으로 엑셀을 이용하여 많은 반복 작업을 하는 사람이 아래 내용을 읽고도 매크로를 반드시 공부해야겠다는 생각이 들지 않는다면.... (의외로 그런 분들이 많죠 .... ㅎㅎㅎ)\n엑셀의 반복작업이 얼마나 빠를까?\nVBA의 반복작업이 얼마나 빠를까 궁금한 사람들이 있을 것이다. 실험을 해보기 위해, 아래와 같은 코드를 블로그에 올리고, 결과를 알려달라고 하였다.\nOption Explicit\nSub TimeTest()\nDim x As Long\nDim StartTime As Sing..."}
{"instruction": "Excel VBA code for: (1137) 각 열을 고정된 문자길이의 텍스트파일로 우측정렬 저장하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub fixed_Lenth_Text_Export()\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In [A1].\nCurrentRegion\n'A1셀의 연결영역 각셀을 순환\nSelect Case\nrngC.Column\n'각 셀의 열이\nCase 1:\n'A열인 경우\nIf\nLen\n(rngC) = 1 Then\n'셀의 문자 길이가 1이면\nrngC = \"#\" & rngC\n'셀의 앞에 (임시로) #을 1개 넣음\nEnd If\nCase 2: rngC = \"####\" & rngC\n'B열인 경우 앞에 #을 4개 넣음\nCase Else:\n'다른 열들인 경우\nIf Len(rngC) = 1 Then\n'셀의 문자 길이가 1이면\nrngC = \"##\" & rngC\n'셀의 앞에 #을 2개 넣음\nElse\n'문자길이 1 아니면\nrngC = \"#\" & rngC\n'셀의 앞에 #을 1개 넣음\nEnd If\nEnd Select\nNext rngC\nWith ActiveWorkbook\n'활성화된 파일과 같은 폴더 경로에\n.\nSaveAs\n.\nPath\n& \"\\\" & \"aaa.csv\", _\nFileFormat:=\nxlCSV\n'aaa.csv 파일로 저장\n.Close False\n'저장하지 않고 파일 닫음\nEnd With\nEnd Sub", "context": "1. A열은 2자리, B열은 10자리, 그 이외의 열은 3자리로 내보낸다.\n2. 각 열은 우측 정렬된 상태로 내보낸다. 즉, 아래와 같은 모습의 결과를 얻어야 함.\n1\n307970\n3\n4\n5\n64\n246805\n10\n15\n4\n70\n234674\n54\n75\n46\n80\n373456\n61\n57\n1\n(더 좋은 방법이 있을 것 같은데 ... 언뜻 떠오르는 것은 아래와 같이 임시 문자 삽입하여 바꾸기)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1137) 각 열을 고정된 문자길이의 텍스트파일로 우측정렬 저장하기 (엑셀 VBA 매크로)\n재생\n705\n재생 (space/k)\n재생\n00:34\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:34\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도..."}
{"instruction": "Excel VBA code for: (1138) Dynamic 과 Fixed-Length string의 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub dynamic_String()                           Sub fixed_Length_String()\nDim str As\nString\nDim str As\nString\n* 10\nDim i As Long                                      Dim i As Long\nApplication.ScreenUpdating = False       Application.ScreenUpdating = False\nFor i = 1 To 100000000                           For i = 1 To 100000000\nstr = \"FixedOrDyn\"                                str = \"FixedOrDyn\"\nNext i                                                 Next i\nEnd Sub", "context": "아래의 두 코드는 str이라고 하는 변수에 \"FixedOrDyn\"이라는 문자를 1억번 넣는 동일한 기능을 한다. 왼쪽의 코드는 일반적으로 하듯이 Dim str As String 으로 변수를 선언하여 사용자가 입력하는 문자크기에 따라 동적(dynamic)으로 변동되도록 하였으며, 오른쪽의 코드는 Dim str As String * 10으로 변수의 크기를 10개의 문자로 고정(fixed-lengh)하였다.\n반복횟수\n크기를 고정하지 않은\n(dynamic)코드\n크기를 고정\n(fxed-length)한 코드\n1억번\n5.8초\n4.2\n초\n﻿\nSub dynamic_String()                           Sub fixed_Length_String()\nDim str As\nString\nDim str As\nString\n* 10\nDim i As Long                                      Dim i As Long\nApplication.ScreenUpdat..."}
{"instruction": "Excel VBA code for: (1140) 메인파일로 데이터파일의 데이터 가져오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub go_Get_Data()\nDim strAll As String\n'데이터파일을 넣을 변수\nDim wkSht As Worksheet\n'통합파일 시트를 넣을 변수\nDim rngA As Range\n'복사할 데이터 넣을 변수\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n.Calculation = xlCalculationManual\n'수동계산으로 설정\nSet wkSht = ActiveSheet\n'현재시트를 변수에 넣음\nColumns(\"H:I\").\nNumberFormatLocal\n= \"yyyy\"\"-\"\"mm\"\"-\"\"dd;@\"\n'H:I열 서식 날짜로\nIf Range(\"F2\") <> \"\" Then\n'기존 데이터가 있다면\n.Range(\"F2\", Cells(Rows.Count, \"F\").End(3)).Resize(, 4).ClearContents\nEnd If\n'기존 데이터 삭제\nstrAll = Application.\nGetOpenFilename\n(\"Excel Files (*.xls*),*.xls*\", , _\n\"데이터파일을 선택\", MultiSelect:=False)\n'데이터 파일을 선택\nIf strAll = \"False\" Then Exit Sub\n'취소 선택 시 매크로 종료\nWorkbooks.Open strAll\n'데이터파일 열기\nSheets(1).\nActivate\n'1번시트(제일 왼쪽시트) 활성화\n'본인데이터가 Sheet1번이 아닐 경우 시트명 Sheets(\"본인의 데이터 시트명\")로 수정\nSet rngA = Range(\"A8\", Cells(Rows.Count, \"B\").End(3))\n'복사할 영역을 변수에 넣음\nrngA.Copy wkSht.Range(\"F2\")\n'Index/Desc 복사\nrngA.Offset(, 8).Copy wkSht.Range(\"H2\")\n'시작/종료일 복사\nActiveWorkbook.\nClose\nFalse\n'데이터파일 저장하지 않고 닫음\nColumns.AutoFit\n'열너비 자동맞춤\n.Calculation = xlCalculationAutomatic\n'자동계산으로 되돌려놓음\nEnd With\nSet rngA = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. 매크로가 삽입된 메인파일과 수시로 데이터가 바뀌는 데이터파일이 있음\n2. 매크로 실행 시 데이터파일의 특정 영역에 있는 데이터를 메인파일로 복사해 가져온다.\n위와 같은 작업은 많은 사람들이 사용하는 작업들 중의 하나이다. 아래의 코드를 필요에 따라 본인의 데이터 위치로 수정하여 사용하면 유사한 작업을 해야하는 분들은 누구든지 사용가능하다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1140) 메인파일로 데이터파일의 데이터 가져오기 (엑셀 VBA 매크로)\n재생\n2,842\n재생 (space/k)\n재생\n00:24\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:24\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. ..."}
{"instruction": "Excel VBA code for: (1142) 선택 영역을 차트로 출력하기 (엑셀 VBA 매크로)", "input": "", "output": "Private Sub Worksheet_\nSelectionChange\n(ByVal Target As Range)\nIf\nIntersect\n(Range(\"A2\", Cells(Rows.Count, \"A\").End(3)), _\nTarget) Is Nothing Then Exit Sub\n'A열 데이터 영역이 아닐경우 매크로 중단\nTarget.\nName\n= \"data\"\n'선택영역의 이름을 data로 설정\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1142) 선택 영역을 차트로 출력하기 (엑셀 VBA 매크로)\n재생\n1,190\n재생 (space/k)\n재생\n01:18\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:18\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n데이터 영역을 선택하고 이름 정의에서 data로 이름을 정의\n차트를 삽입하고 차트모양을 본인이 선호하는 종류로 선택\n차트의 데이터 영역(..."}
{"instruction": "Excel VBA code for: (1143) Select Case와 If ElseIf의 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub select_Case()                                      Sub mutiple_ElseIf()\nDim i As Long                                             Dim i As Long\nDim r As Long                                             Dim r As Long\nApplication.ScreenUpdating = False               Application.ScreenUpdating = False\nFor i = 1 To 10000000                                    For i = 1 To 10000000\nr = Int(\nRnd\n* 5) + 1                                       r = Int(\nRnd\n* 5) + 1\nSelect Case\nr\nIf\nr = 1 Then\nCase\n1: r = 1                                               r = 1\nCase\n2: r = 1\nElseIf\nr = 2 Then\nCase\n3: r = 1                                               r = 1\nCase\n4: r = 1\nElseIf\nr = 3 Then\nCase Else\n: r =1                                           r = 1\nEnd Select\nElseIf\nr = 4 Then\nNext i                                                                  r = 1\nEnd Sub", "context": "아래의 두 코드는 rnd 함수를 이용하여 1 ~ 5 사이의 무작위 값을 생성한 뒤 이를 각 값에 따라 변수에 넣는 기능으로 동일한 기능을 한다. 왼쪽 코드는 Select Case 구문을 사용하였고 오른쪽 코드는 If ElseIf 구문을 사용하였다.\n반복횟수\nSelect Case\n를 사용한 코드\nIf ElseIf\n를 사용한 코드\n10,000,000번\n2.50초\n2.50\n초\n﻿\nSub select_Case()                                      Sub mutiple_ElseIf()\nDim i As Long                                             Dim i As Long\nDim r As Long                                             Dim r As Long\nApplication.ScreenUpdating = False               Application.ScreenUp..."}
{"instruction": "Excel VBA code for: (1144) 통합시트로 데이터시트의 데이터 복사해오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub get_Data_From_Other_Sheet()\nDim rngT As Range\n'복사될 지점을 넣을 변수\nDim rngA As Range\n'Sheet2 B열의 데이터 영역을 넣을 변수\nDim rowsCnt As Integer\n'행 개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngT = Cells(Rows.Count, \"A\").\nEnd(3)(2)\n'복사될 지점을 변수에 넣음\nWith Sheets(\"Sheet2\")\n'Sheet2에서\nIf .Range(\"B1\") <> \"\"\nAnd\n.Range(\"E1\") <> \"\" Then\n'Sheet2의 B1셀과 E1셀에 데이터 존재하면\nSet rngA = .Range(.[B1], .Cells(Rows.Count, \"B\").End(3))\n'B열의 데이터영역을 변수에 넣음\nrowsCnt = rngA.\nCount\n'rngA의 행 개수를 변수에 넣음\nrngT.Resize(rowsCnt, 2) = rngA.Resize(, 2).\nValue\n'B:C열의 데이터를 복사하여 A열에 append\nrngT(1, 4).Resize(rowsCnt) = rngA.Offset(, 3).Value\n'P열의 데이터를 복사하여 X열에 append\nEnd If\nEnd With\nSet rngT = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngA = Nothing\nEnd Sub", "context": "통합시트(Sheet1)로 다른 시트(Sheet2)의 데이터를 가져오는 기본 기능. 다른 분의 질문에 답하기 위해 작성한 것으로 쉬운 내용이라 올리지 않을까 하다가 초보님들이 참고할 내용이 있어 올려둔다. 코드의 반복을 줄이기 위해 복사지점(rngT)을 변수에 넣어 사용하는 것이나, 복사해올 기준열(Sheet2의 B열)을 변수에 넣고 resize를 이용하여 데이터를 가져오는 것을 참고. 특히, 데이터를 빠르게 가져오기 위해 복사(copy)를 사용하지 않고 값(value)만을 가져오기 위해 rowsCnt로 행을 추출한 것을 꼭 기억해두었다가 활용하시길 ....\n1. Sheet1은 통합시트로서 데이터를 축적해가는 시트임\n2. Sheet2의 데이터는 매번 값이 업데이트 되는 데이터 시트임\n3. Sheet2의 B:C열을 복사하여 Sheet1의 A:B열에 추가(append) 시킴\n4. Sheet2의 E열을 복사하여 Sheet1의 D열에 추가(append) 시킴\n5. (버튼을 연속으로 클릭 시 ..."}
{"instruction": "Excel VBA code for: (1145) \"If 변수 Then\" 과 \"If 변수 = True Then\"의 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub If_True()                                              Sub If_Equal_True()\nDim i As Long                                             Dim i As Long\nDim blnTF As Boolean                                 Dim blnTF As Boolean\nApplication.ScreenUpdating = False              Application.ScreenUpdating = False\nFor i = 1 To 10000000                                   For i = 1 To 10000000\nblnTF = Not blnTF                                       blnTF = Not blnTF\nIf blnTF\nThen\nIf blnTF = True\nThen\nEnd If                                                       End If\nNext i                                                        Next i\nEnd Sub", "context": "아래의 두 코드는 참 거짓을 판단하는 Boolean으로 선언된 blnTF 변수가 참인지 거짓인지를 판명하는 동일한 기능을 하는 코드이다. blnTF는 For 구문을 순환할 때마다 Not에 의하여 참과 거짓 값을 반복한다. 왼쪽 코드는 If blnTF Then 구문을 사용하였고 오른쪽 코드는 If blnTF = True Then 구문을 사용하였다.\n반복횟수\nIf 변수 Then\n을 사용한 코드\nIf 변수\n= True\nThen\n을 사용한 코드\n10,000,000번\n0.50초\n0.39\n초\nSub If_True()                                              Sub If_Equal_True()\nDim i As Long                                             Dim i As Long\nDim blnTF As Boolean                                 Dim blnTF As Boolean\nApp..."}
{"instruction": "Excel VBA code for: (1148) 병합된 셀 개수만큼 오른쪽에 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_Merged_Cell()\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"B\").Clear\n'B열의 기존 데이터 삭제\nIf WorksheetFunction.\nCountA\n(Columns(\"A:A\")) > 0 Then\n'A열에 문자가 있을경우\nFor Each rngC In Columns(\"A\").SpecialCells(2)\n'A열 문자셀 순환\nIf Len(rngC) > 0 And rngC.\nMergeCells\nThen\n'문자가 있고 셀병합 되어 있다면\nrngC(1, 2).Resize(rngC.\nMergeArea\n.Count) = rngC.Value\n'각 셀값을 복사해 넣음\nElseIf Not rngC.MergeCells Then\n'셀병합된 셀이 아니면\nrngC.Next = rngC\n'오른쪽 셀에 왼쪽 셀값을 넣음\nEnd If\nNext rngC\nEnd If\nEnd Sub", "context": "A열은 셀병합이 되어 있음. 셀 병합 개수만큼 B열에 복사해 넣는 간단한 기능.\n매크로 실행 전                                            매크로 실행 후 결과\nOption Explicit\nSub copy_Merged_Cell()\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"B\").Clear\n'B열의 기존 데이터 삭제\nIf WorksheetFunction.\nCountA\n(Columns(\"A:A\")) > 0 Then\n'A열에 문자가 있을경우\nFor Each rngC In Columns(\"A\").SpecialCells(2)\n'A열 문자셀 순환\nIf Len(rngC) > 0 And rngC.\nMergeCells\nThen\n'문자가 있고 셀병합 되어 있다면\nrngC(1, 2).Resize(rngC.\nMergeArea\n.Count) = rngC..."}
{"instruction": "Excel VBA code for: (1149) 문자분리 후 중복개수 구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub dupes_Count_Of_Unique_No()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varC\n'각 셀을 쪼개어 넣을 배열변수\nDim i As Long\n'배열요소 개수만큼 반복할 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"A2:H2\")\n'A2:H2 영역의 각셀을 순환\nIf Len([I2]) > 0\nAnd Len([J2]) > 0 Then\n'I2와 J2셀에 값이 있으면\nRange(\"I2\", Cells(Rows.Count, \"J\").End(3)).Clear\n'기존 데이터 삭제\nEnd If\nWith\nSheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'사용영역에 있는 기존 데이터 삭제\nFor Each rngC In rngAll\n'A2:H2 영역 각셀을 순환\nvarC =\nSplit\n(rngC, \",\")\n'각 셀값을 콤마로 나누어 배열에 넣음\nFor i =\nLBound\n(varC) To\nUBound\n(varC)\n'배열요소 개수만큼 반복\nr = r + 1\n'행을 1씩 늘려감\n.Cells(r, 1) = varC(i)\n'행을 1씩 늘려가면서 배열값을 복사\nNext i\nNext rngC\n.Columns(\"A\").\nCopy\n.Cells(1, 2)\n'A열을 B열에 복사\nWith .Columns(\"B\").SpecialCells(2)\n'B열 문자가 입력된 셀에서\n.\nRemoveDuplicates\n1, 0\n'(제목없이) 1번필드 기준 중복제거\n.\nSort\nSheets(2).Cells(1, 2), 1\n'Sheet2 B1셀 기준 오름차순 정렬\n.Copy Cells(2, \"I\")\n'B열을 복사하여 I2셀에 복사\nEnd With\nFor Each rngC In Range(\"I2\", Cells(Rows.Count, \"I\").End(3))\n'I열 각셀순환\nrngC.Next =\nWorksheetFunction.CountIf\n(.Columns(\"A\"), rngC)\n'각 셀의 오른쪽에 중복 개수를 입력\nNext rngC\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "A2:H2 영역의 각 셀에는 숫자들이 콤마(,)를 이용하여 구분되어 있다. 콤마를 이용하여 숫자들을 분리하고 유일한 값을 구한 후 중복 개수를 구하는 기능.\n개인적으로 이런 코드는 별로 좋아하지 않는다. 왜냐하면, 데이터가 연속적이지 않고 일종의 1회용이기 때문이다. 아래 코드에서 보듯 Sheet2를 데이터를 복사하고 조작하는 임시영역으로 사용한다.\n매크로 실행 전 (Sheet2는 비어 있는 상태임)\n매크로 실행 후 결과\nOption Explicit\nSub dupes_Count_Of_Unique_No()\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varC\n'각 셀을 쪼개어 넣을 배열변수\nDim i As Long\n'배열요소 개수만큼 반복할 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range..."}
{"instruction": "Excel VBA code for: (1150) 수식에 사용자가 값 더하거나 뺀 셀만 삭제/표시하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Manipulated_Cells()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp\n'(임시) 배열로 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In ActiveSheet.UsedRange\n'현재시트 사용영역 각 셀을 순환\nIf rngC.\nHasFormula\nThen\n'각 셀에 수식이 있다면\nIf\nInStr\n(rngC.Formula, \"+\") Or InStr(rngC.Formula, \"-\") Then\n'각 셀에 플러스(+) 또는 마이너스(-) 가 있다면\nFor i = Len(rngC.\nFormula\n) To 1 Step -1\n'각 셀의 문자 길이만큼 반복\nIf\nMid\n(rngC.Formula, i, 1) = \"+\" Then\n'오른쪽 처음오는 연산자가 + 일 경우\nvarTemp =\nSplit\n(rngC.Formula, \"+\")\n'셀값을 + 로 쪼개어 배열에 넣음\nIf\nNot\nLeft(varTemp(UBound(varTemp, 1)), 1)\nLike \"[A-Z]\"\nThen\n'배열 제일 마지막 값의 제일왼쪽 문자가 영어면\nCall\nerrCell(rngC, \"+\")\n'각 셀을 이용 errCell 코드 호출\nEnd If\nExit For\nElseIf Mid(rngC.Formula, i, 1) = \"-\" Then\n'오른쪽 처음오는 연산자가 - 일 경우\nvarTemp = Split(rngC.Formula, \"-\")\n'셀값을 - 로 쪼개어 배열에 넣음\nIf Not Left(varTemp(UBound(varTemp, 1)), 1) Like \"[A-Z]\" Then\n'배열 제일 마지막 값의 제일왼쪽 문자가 영어면\nCall errCell(rngC, \"+\")\n'각 셀을 이용 errCell 코드 호출\nEnd If\nExit For\nEnd If\nNext i\nEnd If\nEnd If\nNext rngC\nEnd Sub", "context": "문의하신 분의 요청사항 :\n아래 그림과 같이 수식이 들어 있는 셀의 제일 뒤에 임의로 숫자가 더하거나 빼어진 셀을 찾기(아래 예제 그림에서는 그런 셀들의 구분을 위해 외곽 테두리를 하여 두었다.)\n그런 셀이 존재할 경우 메시지 창에 셀의 주소와 입력된 수식을 출력\n메시지창에서 확인(Yes) 선택 시 더하거나 뺀 값을 삭제하고 노란색으로 채우고, 취소(No)를 선택 시 삭제없이 노란색으로만 채움\n(파일을 내부에서만 사용하지 아니하고 외부에 배포하여 다른 사람이 값을 채워야하므로 시트를 잠그거나 할 수 없는 상황.)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1150) 수식에 사용자가 값 더하거나 뺀 셀만 삭제/표시하기 (엑셀 VBA 매크로)\n재생\n442\n재생 (space/k)\n재생\n00:41\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:41\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함..."}
{"instruction": "Excel VBA code for: (1151) 그림 클릭 시 확대/축소하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub toggle_Picture_Zoom()\nWith ActiveSheet.Shapes(\nApplication.Caller\n)\n'매크로 실행한 도형\n.LockAspectRatio = msoTrue\n'그림 가로세로 고정비율 설정\nIf .Height <=\n100\nThen\n'높이가 100보다 작거나 같을 경우\n.\nScaleHeight\n4, 0, msoScaleFromTopLeft\n'왼쪽 윗지점 기준으로 그림을 4배 확대\n.\nZOrder\nmsoBringToFront\n'그림을 제일 앞으로 가져옴\nElse\n'높이가 100보다 클 경우\n.ScaleHeight 0.25, 0, msoScaleFromTopLeft\n'왼쪽 윗지점 기준으로 그림을 1/4로 축소\n.ZOrder msoBringToFront\n'그림을 제일 앞으로 가져옴\nEnd If\nEnd With\nEnd Sub", "context": "윗 제목과 아래의 동영상으로 무슨 기능인지는 설명을 더 안해도 알 수 있는 내용. 그림은 왼쪽윗지점을 기준으로 확대 축소된다. 왼쪽에 여백이 없을 경우 그림을 확대하였다 축소하면 그림이 움직이므로 가운데가 아닌 왼쪽 윗지점을 기준으로 확대 축소시킴.\n그림 높이가 100보다 작은 것은 4배 확대, 100보다 큰 것은 1/4로 축소를 시키도록 함. 필요 시 아래의 코드값을 수정해서 사용하면 됨.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1151) 그림 클릭 시 확대/축소하기 1 (엑셀 VBA 매크로)\n재생\n5,185\n재생 (space/k)\n재생\n00:26\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:26\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x..."}
{"instruction": "Excel VBA code for: (1153) 1열을 10행씩 번갈아가며 2열에 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub trans_Every_Other()\nDim i As Long\n'반복구문에서 행을 20씩 늘려갈 변수\nDim rngT As Range\n'복사될 타겟(T)arget 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"C:D\").SpecialCells(2).Offset(1).\nClear\n'C:D열의 기존 데이터 삭제\nFor i = 1 To Cells(Rows.Count, \"A\").End(3).\nRow\nStep 20\n'A열 마지막 행까지 20씩 건너뛰며 반복\nSet\nrngT = Cells(Rows.Count, \"C\").\nEnd(3)(2)\n'C열의 복사될 지점을 개체변수에 넣음\nWith rngT\n'복사될 지점에서\n.Resize(10) = Cells(i + 1, 1).Resize(10).Value\n'10행씩 데이터 복사\n.Offset(, 1).Resize(10) = Cells(i + 11, 1).Resize(10).Value\n'오른쪽 열에 10행씩 복사\nEnd With\nNext i\nSet rngT = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "A열에 있는 데이터를 10행씩 C열과 D열에 번갈아 가면서 복사하는 기능. 이와 유사한 내용을 여러번 다루었으므로 제 블로그에 방문하시는 모든 분들은 이런 정도는 간단히 하실수 있을거라고 믿습니다.\n매크로 실행 전 (아래로 계속 데이터가 있음)                       매크로 실행 후 결과\nOption Explicit\nSub trans_Every_Other()\nDim i As Long\n'반복구문에서 행을 20씩 늘려갈 변수\nDim rngT As Range\n'복사될 타겟(T)arget 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"C:D\").SpecialCells(2).Offset(1).\nClear\n'C:D열의 기존 데이터 삭제\nFor i = 1 To Cells(Rows.Count, \"A\").End(3).\nRow\nStep 20\n'A열 마지막 행까지 20씩 건너뛰며 반복\nSet\nrngT = Cel..."}
{"instruction": "Excel VBA code for: (1154) 최댓값, 최솟값을 찾기 (엑셀 VBA 매크로)", "input": "", "output": "Private Sub Worksheet_\nChange\n(ByVal Target As Range)\nIf Target.Count > 1 Then Exit Sub\n'복수의 셀을 선택 시 매크로 종료\nIf Target.\nAddress(0, 0)\n<> \"A2\" Then Exit Sub\n'값 변경셀이 A2가 아닐경우 매크로 종료\nWith Application\n'엑셀에서\n.\nEnableEvents = False\n'이벤트 트리거링 기능을 중지\n.\nCalculation = xlCalculationManual\n'셀 계산을 수동으로 전환\nIf [B2] = \"\" Then\n'B2셀이 비어 있다면\n[B2] = [A2]\n'B2셀에 A2셀의 값을 넣음\nElseIf [A2] > [B2] Then\n'A2셀이 B2셀보다 크면\n[B2] = [A2]\n'B2셀에 A2셀의 값을 넣음\nEnd If\nIf [C2] = \"\" Then\n'C2셀이 비어 있다면\n[C2] = [A2]\n'C2셀에 A2셀의 값을 넣음\nElseIf [A2] < [C2] Then\n'A2셀이 C2셀보다 작으면\n[C2] = [A2]\n'C2셀에 A2셀의 값을 넣음\nEnd If\nIf [A2] = \"\" Then\n'A2셀이 비어 있다면\n[B2] = vbNullString\n:\n[C2] = vbNullString\n'B2셀과 C2셀을 비움\nEnd If\n.Calculation = xlCalculationAutomatic\n'셀 계산을 자동으로 복원\n.EnableEvents = True\n'이벤트 트리거링 기능을 복원\nEnd With\nEnd Sub", "context": "A2셀은 DDE를 통하여 값이 계속하여 바뀌는 상황. A2셀이 변동될 때 최댓값을 B2셀에, 최솟값을 C2셀에 추출하는 기능. A2셀이 삭제되면 B2셀과 C2셀도 초기화 됨. 아래 예제 동영상에서는 A2값을 수동으로 변경해가면서 값을 확인한다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1154) 최댓값, 최솟값을 찾기 (엑셀 VBA 매크로)\n재생\n649\n재생 (space/k)\n재생\n00:33\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:33\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 ..."}
{"instruction": "Excel VBA code for: (1155) 그림 클릭 시 확대/축소하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub toggle_Picture_Zoom2()\nWith ActiveSheet.Shapes(\nApplication.Caller\n)\n'매크로 실행한 도형\n.LockAspectRatio = msoTrue\n'그림 가로세로 고정비율 설정\nIf Right(.Name, 1) <> \"#\" Then\n'그림의 제일 마지막 문자가 \"#\"이면\n.\nScaleHeight\n4\n, 0, msoScaleFromTopLeft\n'왼쪽 윗지점 기준으로 그림을 4배 확대\n.\nZOrder\nmsoBringToFront\n'그림을 제일 앞으로 가져옴\n.Name = .Name\n& \"#\"\n'그림 이름 뒤에 \"#\"을 추가함\nElse\n.ScaleHeight\n0.25\n, 0, msoScaleFromTopLeft\n'왼쪽 윗지점 기준으로 그림을 1/4로 축소\n.ZOrder msoBringToFront\n'그림을 제일 앞으로 가져옴\n.Name =\nLeft(.Name, Len(.Name) - 1)\n'그림 이름 제일 뒤의 \"#\"을 제거\nEnd If\nEnd With\nEnd Sub", "context": "앞서 해보았던 \"그림 클릭 시 확대/축소하기\n1\n\" 에서는 그림의 크기를 100으로 지정하여 사진을 확대/축소하여 제한이 많았다. 기존 코드를 약간 업그레이드하여 아래와 동영상에서 보는 바와 같이 그림을 마구 섞어가면서 선택하여도 각 그림이 한 번 클릭 시 확대, 두 번째 클릭 시 축소되도록 하였다. 초기 그림 크기의 제한이 없으며 한 번 클릭 시 4배로 커지고, 두 번 클릭 시 1/4배로 축소된다. 필요 시 이 값을 조정하면 된다.\n그림 클릭 시 그림 이름의 제일 뒤에 # 을 붙였다가 재차 클릭 시 이를 제거하는 방식을 사용하였다. 단순한 방법이지만 각 그림이 확대/축소된 상태인지 간단히 알 수 있어서 나름 괜찮은 방법이라는 생각이든다. 하나의 단점은 그림 삽입 후 회전된 그림의 사용시 주의해야 하는 것. 회전된 그림은 확대되면서 엑셀의 가장자리애 충돌하며 그림 위치가 이동된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1155) 그림..."}
{"instruction": "Excel VBA code for: (1156) 문자 조합하여 합치기 (엑셀 VBA 매크로)", "input": "", "output": "Sub three_Text_Combination()\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim i As Integer\n'시작문자 위치 넣을 변수\nDim j As Integer\n'중간문자 위치 넣을 변수\nDim k As Integer\n'끝문자 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"Q\").SpecialCells(2).Offset(1).Clear\n'기존데이터 삭제\nFor r = 2 To Cells(Rows.Count, \"A\").End(3).Row\n'2 ~ A열 마지막 행까지 반복\nFor i = 1 To 5\n'시작문자 위치 5번 반복\nFor j = 6 To 10\n'중간문자 위치 5번 반복\nFor k = 11 To 15\n'끝문자 위치 5번 반복\nCells(Rows.Count, \"Q\").\nEnd(3)(2)\n= _\nCells(r, i)\n& \" \"\n& Cells(r, j) & \" \" & Cells(r, k)\n'시작/중간/끝 문자를 합쳐서 Q열에 뿌림\nNext k\nNext j\nNext i\nNext r\nColumns(\"Q\").\nAutoFit\n'Q열 열너비 자동맞춤\nEnd Sub", "context": "시작문자, 중간문자, 끝문자를 순서대로 조합하여 문자를 합치는 기능\n매크로 실행 전\n매크로 실행 후 시작/중간/끝문자가 순서대로 조합하여 합쳐진 결과\nOption Explicit\nSub three_Text_Combination()\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim i As Integer\n'시작문자 위치 넣을 변수\nDim j As Integer\n'중간문자 위치 넣을 변수\nDim k As Integer\n'끝문자 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"Q\").SpecialCells(2).Offset(1).Clear\n'기존데이터 삭제\nFor r = 2 To Cells(Rows.Count, \"A\").End(3).Row\n'2 ~ A열 마지막 행까지 반복\nFor i = 1 To 5\n'시작문자 위치 5번 반복\nFor j = 6 To 10\n'중간문자 위치 5번 반복\nFor k = 11 To 1..."}
{"instruction": "Excel VBA code for: (1157) 그림을 선택영역에 회전하여 삽입하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub rotate_And_Insert_A_Picture()\nDim rngC As Range\n'현재 선택셀 넣을 변수\nDim strPath As String\n'경로를 넣을 변수\nDim rotationDegree As Integer\n'도형의 회전각도 넣을 변수\nrotationDegree =\n90\n'본인의 그림 회전하고 싶은 각도를 입력\nIf rotationDegree <> 0 And_\nrotationDegree <> 90 And_\nrotationDegree <> 180 And_\nrotationDegree <> 270 Then\n'입력한 회전각이 0, 90, 180, 270이 아닐경우\nMsgBox \"회전각은 0, 90, 180, 270도만 허용됩니다.\", 64, \"회전각 오류\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nIf Not TypeOf Selection Is Range Then\n'만일 그림 등을 선택하거나 하였을 경우\nMsgBox \"영역이 선택되지 않음\", 64, \"영역선택 오류\"\n'경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nSet rngC = Selection\n'현재셀을 개체변수에 넣음\nstrPath = Application.\nDialogs\n(\nxlDialogInsertPicture\n).Show\n'파일창 띄움\nIf strPath = \"False\" Then Exit Sub\n'취소선택 시 중단\nWith Selection\n'선택된 그림파일에서\n.ShapeRange.\nRotation\n= rotationDegree\n'그림의 회전값을 입력\nIf\nrotationDegree = 90 Or rotationDegree = 270 Then\n'그림이 90 또는 270도 회전되어 있다면\n.\nShapeRange\n.\nLockAspectRatio\n= msoFalse\n'그림 좌우고정비율 해제\n.ShapeRange.Rotation = 0\n'그림 회전을 원상태로 돌려놓음\n.\nHeight\n= rngC.Width - 8\n'그림 높이를 현재셀 크기  - 8\n.\nWidth\n= rngC.Height - 8\n'그림 폭을 현재셀 크기 - 8\n.\nLeft\n= rngC.Left + (rngC.Width - .Width) / 2\n'그림 폭 가운데 위치가 셀의 중앙에 오도록 정렬\n.\nTop\n= rngC.Top + (rngC.Height - .Height) / 2\n'그림위쪽 가운데 위치가 셀의 중앙에 오도록 정렬\n.ShapeRange.Rotation = rotationDegree\n'그림 회전 각도를 복원\nElseIf\nrotationDegree = 180 Or rotationDegree = 0 Then\n'그림이 0 또는 180도 회전되어 있다면\n.ShapeRange.LockAspectRatio = msoFalse\n'좌우고정비율 해제\n.ShapeRange.Rotation = 0\n'그림 회전을 원상태로 돌려놓음\n.Left = rngC.Left + 2\n'그림왼쪽위치를 현재셀 왼쪽 + 2 위치에\n.Top = rngC.Top + 2\n'그림위쪽 위치를 현재셀 윗쪽 + 2 위치에\n.Height = rngC.Height - 4\n'그림 높이를 현재셀 -4 크기로\n.Width = rngC.Width - 4\n'그림 폭을 현재셀 -4 크기로\n.ShapeRange.Rotation = rotationDegree\n'그림 회전 각도를 복원\nEnd If\nEnd With\nSet rngC = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "저장된 사진을 회전하여 엑셀의 선택한 영역에 삽입하는 것은 의외로 까다로운 작업이다. 지면의 제한으로 설명은 하지 않겠지만, 왜 그런지는 직접 해보시면 알 수 있을 것으로 생각된다.\n일반적으로 사진은 보통 가로 또는 세로로 찍는다. 그래서,그림의 회전각은 0, 90, 180, 270도로 제한하였다(입력창을 띄워 각도를 입력하도록 할 수 있지만 코드가 길어져 생략함). 아래 코드에서\n본인이 회전하고 싶은 각을\n수정\n하여 입력\n하면 된다. 아래 예제는 그림이 90도 회전된 것을 기준으로 작성. 회전하지 않고 원본 그대로 가져오려면 rotationDegree =\n0\n이라고 수정하면 된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1157) 그림을 선택영역에 회전하여 삽입하기 (엑셀 VBA 매크로)\n재생\n1,931\n공유하기\n재생 (space/k)\n재생\n00:48\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00..."}
{"instruction": "Excel VBA code for: (1159) 두 시트에 중복된 데이터만 새로운 시트에 합치기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_Matching_Data()\nDim rngSht2 As Range\n'Sheet2의 A열을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim C As Range\n'검색하여 찾은 영역을 넣을 변수\nDim rngT As Range\n'복사될 지점을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'Sheet2에서\nSet rngSht2 = .Range(.[A2], .Cells(Rows.Count, 1).End(3))\nEnd With\n'제목뺀 A열 영역을 변수에 넣음\nWith Sheets(3)\n'Sheet3에서\n.UsedRange.Offset(1).\nClear\n'Sheet3의 기존 데이터 삭제\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, 1).End(3))\n'A열 각 셀을 순환\nSet C = rngSht2.\nFind\n(What:=rngC, Lookat:=xlWhole)\n'검색 일치하는 셀을 찾아 C에 넣음\nIf\nNot C Is Nothing\nThen\n'만일 일치하는 데이터가 있으면\nSet rngT = .Cells(Rows.Count, 1).End(3)(2)\n'A열 종단셀 윗방향 아래셀을 변수에 넣음\nrngT.Resize(, 2) = rngC.Resize(, 2).Value\n'이름과 나이를 복사\nrngT.Offset(, 2) = C.\nNext\n'경력을 C열에 복사\nEnd If\nNext rngC\n.\nActivate\n'(Sheet3) 활성화\nEnd With\nSet rngSht2 = Nothing\n'개체변수들 초기화(메모리 비우기\nSet C = Nothing\nSet rngT = Nothing\nEnd Sub", "context": "Sheet1과 Sheet2에 일치하는 중복된 데이터만 Sheet3에 합치는 기능.\n매크로 실행 전 Sheet1                       매크로 실행 전 Sheet2                     매크로 실행 후 결과\n(매크로 실행 전에 Sheet3는 제목행만 있고 비어 있는 상태)\nOption Explicit\nSub combine_Matching_Data()\nDim rngSht2 As Range\n'Sheet2의 A열을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim C As Range\n'검색하여 찾은 영역을 넣을 변수\nDim rngT As Range\n'복사될 지점을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'Sheet2에서\nSet rngSht2 = .Range(.[A2], .Cells(Rows.Count, 1).End(3))\nEnd With\n'제목뺀 A열..."}
{"instruction": "Excel VBA code for: (1160) 사라진 마우스 오른쪽 메뉴 복원하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub show_And_Enable_All_Menu()\nDim cmdBar As\nCommandBar\n'메뉴를 넣을 변수\nOn Error Resume Next\n'에러 발생해도 중단없이 다음코드 진행\nFor Each cmdBar In Application.CommandBars\n'각 메뉴를 순환\nIf cmdBar.Type =\nmsoBarTypePopup\nThen\ncmdBar.\nVisible\n= True\n'메뉴를 보이도록 설정\ncmdBar.\nEnabled\n= True\n'메뉴를 활성황\nEnd If\nNext\nOn Error GoTo 0\n'에러 검출기능 초기화\nMsgBox \"메뉴가 모두 보이도록 재설정하였습니다.\"\n'메시지 출력\nEnd Sub", "context": "VBA 공부를 하면서 이것 저것 만지다 보면 갑자기 오른쪽 마우스 메뉴가 뜨지 않아서 당황하는 경우가 생긴다. 엑셀을 삭제하였다가 다시 깔거나 해도 문제가 해결되지 않는다고 하소연하는 분들도 여러번 보았다. 이럴 경우 아래의 코드를 실행하면 엑셀의 메뉴를 전부 보이도록 초기화 해준다.\n(하지만, 엑셀의 모든 CommandBar를 감추었다가 다시 활성화하고 보이도록 하였더니 메뉴가 깨지면서 엑셀이 안전모드(Safety Mode)에서 실행이 되었다. 하는수 없이 엑셀을 삭제하고 기존 엑셀폴더 삭제 뒤에 재설치해야했다. 무엇이 문제인지 한 참을 찾았지만 원인불명. 결국 CommandBar메뉴 전체가 아닌 msoBarTypePopup 타입 메뉴만 활성화하고 보이도록 하니 문제가 없다.\n그러므로, 오른쪽 메뉴가 정상작동하는 분들은 아래의 코드를 실행하지 마시고, 오른쪽 메뉴가 나타나지 않거나 메뉴에 이상이 있어서 불가피하게 엑셀을 재설치해야하는 분들만\n최후의 수단\n으로 실행하시는 것이 좋을듯..."}
{"instruction": "Excel VBA code for: (1161) GetOpenFileName, FileDialog를 이용한 파일(들)의 선택 기본코드 (엑셀 VBA 매크로)", "input": "", "output": "Sub getOpenFileName_With_MultiSelect()\nDim strFilter As String\n'필터링될 파일 확장자 넣을 변수\nDim fileNames As\nVariant\n'모든 파일 넣을 배열 변수\nDim fileName As Variant\n'각 파일을 넣을 변수\nDim wkb As Workbook\n'workbook을 넣을 변수\nChDir ThisWorkbook.Path\n'매크로 실행파일과 동일한 경로 기준\nstrFilter = \"Excel Files (*.xls*),*.xls\"\n'엑셀파일 선택 시 활성화\n'    strFilter = \"All Files (*.*),*.*\"\n'모든 파일 선택 시 활성화\n'    strFilter = \"Text Files (*.txt;*.prn;*.csv;*.asc),*.txt*\"\n'\n'텍스트파일 선택 시 활성화\n'    strFilter = \"JPG Files (*.jpg*;*.gif;*.bmp;*.png;*.wmf;*.cur;*.ico),*.jpg*\" _\n'\n'그림파일 선택 시 활성화\nfileNames = Application.GetOpenFilename(strFilter, , _\n\"엑셀 파일(들)을 선택\",\nMultiSelect\n:=True\n)\n'엑셀 파일(들)을 선택\nIf\nTypeName\n(fileNames) = \"\nBoolean\n\" Then Exit Sub\n'취소 선택 시 매크로 종료\nFor Each fileName In fileNames\n'선택한 각 엑셀 파일을 순환\nSet wkb = Workbooks.Open(fileName)\n'파일을 열고 개체변수에 넣음\n'이곳에 원하는 작업을 넣으면 됨\nwkb.Close False\n'열은 파일을 저장없이 닫음\nNext fileName\nSet wkb = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nSub getOpenFileName_Without_MultiSelect()\nDim fileName As\nString\n'선택한 파일을 넣을 변수\nDim wkb As Workbook\n'workbook을 넣을 변수\nChDir ThisWorkbook.Path\n'매크로 실행파일과 동일한 경로 기준\nActiveSheet.UsedRange.ClearContents\n'기존 데이터 삭제\nfileName = Application.\nGetOpenFilename\n(\"Excel Files (*.xls*),*.xls\", , _\n\"엑셀 파일을 선택\",\nMultiSelect:=False\n)\n'엑셀 파일을 선택\nIf fileName =\n\"\nFalse\n\"\nThen Exit Sub\n'취소 선택 시 매크로 종료\nSet wkb = Workbooks.Open(fileName)\n'파일을 열고 개체변수에 넣음\n'이곳에 원하는 작업을 넣으면 됨\nwkb.Close False\n'열은 파일을 저장없이 닫음\nSet wkb = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nSub open_Excel_Files()\nDim fileDia As FileDialog\nDim varFile As Variant\nChDir ThisWorkbook.Path\n'매크로 실행파일과 동일한 경로 기준\nApplication.\nFileDialog\n(\nmsoFileDialogFilePicker\n).Filters.Add _\n\"Excel Files\", \"*.xls*\"\nSet fileDia = Application.FileDialog(msoFileDialogFilePicker)\nWith fileDia\n.\nAllowMultiSelect\n= True\n'False 일 경우 한 파일만\nIf .Show Then\nFor Each varFile In .SelectedItems\nWorkbooks.Open varFile\n'여기에 각 열린 파일 작업할 내용 넣으면 됨\nActiveWorkbook.Close False\nNext\nEnd If\nEnd With\nEnd Sub", "context": "GetOpenFileName을 사용하여 복수의 파일을 작업할 때와, 한 개의 파일에 작업할 때 사용하는 기본코드를 정리해 놓음. 기본코드 카테고리는 반복적으로 사용되는 기본적인 코드들을 미리 정리하여 놓았다가 필요할 때마다 복사해서 사용하기 위해 만들어 놓은 것임.\n'\n'파일창에서 Ctrl 또는 Shift키 이용하여 복수의 파일을 선택하여\n작업할 때\nOption Explicit\nSub getOpenFileName_With_MultiSelect()\nDim strFilter As String\n'필터링될 파일 확장자 넣을 변수\nDim fileNames As\nVariant\n'모든 파일 넣을 배열 변수\nDim fileName As Variant\n'각 파일을 넣을 변수\nDim wkb As Workbook\n'workbook을 넣을 변수\nChDir ThisWorkbook.Path\n'매크로 실행파일과 동일한 경로 기준\nstrFilter = \"Excel Files (*.xls*),*.xls\"\n'엑셀파..."}
{"instruction": "Excel VBA code for: (1165) 그림을 행열 변환하여 옮기기 (엑셀 VBA 매크로)", "input": "", "output": "Sub picture_Transpose()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim msg As String\n'yes, no, cancel의 선택결과 넣을 변수\nDim rngSel As Range\n'선택영역 전체를 넣을 변수\nDim rngShp As Range\n'각 그림의 왼쪽위가 속한 영역을 넣을 변수\nDim shpC As Shape\n'각각의 도형(shape)을 넣을 변수\nIf\nNot TypeOf\nSelection Is Range Then\n'만일 그림 등을 선택하거나 하였을 경우\nMsgBox \"영역이 선택되지 않음\", 64, \"영역선택 오류\"\n'경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel = Application.\nInputBox\n(\"마우스로 복사될 위치를 선택하시오!\", Type:=8)\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nmsg =\nMsgBox\n(\"세로를 가로로 복사는 Yes, 가로를 세로 복사는 No 선택\", _\nvbYesNoCancel, \"Yes/No 선택\")\n'메시지창 출력\nIf msg =\nvbCancel\nThen Exit Sub\n'취소 선택 시 매크로 종료\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nFor Each shpC In ActiveSheet.\nShapes\n'전체영역내 각 그림을 순환\nIf shpC.Type = 13 Then\n'만일 각 도형이 그림이라면\nSet rngShp = shpC.\nTopLeftCell\n'각 도형의 왼쪽위 영역을 변수에 넣음\nIf Not\nIntersect\n(rngC, rngShp) Is Nothing Then\n'각 도형이 각셀영역에 포함되면\nIf rngSel.\nMergeCells\nThen\n'rngShp가 셀병합된 셀이라면\nSet rngSel = rngSel.\nMergeArea\n'영역을 셀병합 영역으로 확장\nEnd If\nWith shpC\n'각 그림으로 작업\n.\nLockAspectRatio\n= msoFalse\n'그림 좌우고정비율 해제\n.Left = rngSel.Left + 4\n'그림왼쪽위치를 셀의 왼쪽위 + 4\n.Top = rngSel.Top + 4\n'그림위쪽 위치를  셀의 왼쪽위 위치  +4\n.Height = rngSel.Height - 8\n'그림 높이를 현재셀 크기  - 8\n.Width = rngSel.Width - 8\n'그림 폭을 현재셀 크기 - 8\nEnd With\nIf msg =\nvbYes\nThen\n'만약 Yes를 선택했다면\nSet rngSel = rngSel.Offset(, 1)\n'복사위치를 우측으로 이동\nElseIf msg =\nvbNo\nThen\n'만약 No를 선택했다면\nSet rngSel = rngSel.Offset(1)\n'복사위치를 아래로 이동\nEnd If\nEnd If\nEnd If\nNext shpC\nNext rngC\nSet rngSel = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngShp = Nothing\nEnd Sub", "context": "아래의 코드는 그림을 행열 변환하는 기능이다. 자세한 내용은 동영상을 참조. A1:B6 영역은 셀병합이 되어 있으며, 이의 해결을 위해 조금 시간이 소요되었다. 즉, 셀병합된 영역으로 옮겨도 무방하다. 단, 입력창에서\n셀의 선택은 1개만\n해야하며, 복수의 행/열은 안되고\n1행\n또는 1열\n로 옮겨진다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1165) 그림을 행열 변환하여 옮기기 (엑셀 VBA 매크로)\n재생\n969\n재생 (space/k)\n재생\n00:41\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:41\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상..."}
{"instruction": "Excel VBA code for: (1166) 빈 셀에만 선택영역 값을 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_Blank_Cells()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim C As Range\n'선택영역 전체를 넣을 변수\nDim r As Long\n'행 늘려갈 변수\nDim cnt As Long\n'선택한 셀의 개수 카운터로 사용할 변수\nIf Selection.Count = 1 Then\n'1개의 셀을 선택하였을 경우\nIf\nMsgBox\n(\"1셀 선택. 진행할까요?\", 64 + 4, \"1셀 선택\") = vbNo Then\n'No 선택 시\nExit Sub\n'매크로 종료\nEnd If\nEnd If\nOn Error\nResume Next\n'에러 발생해도 다음 코드 진행\nSet C = Application.\nInputBox\n(\"마우스로 복사될 위치를 선택하시오!\", Type:=8)\nIf\nC Is Nothing\nThen Exit Sub\n'취소 선택시 매크로 중단\nOn Error\nGoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nDo\n'다음을 실행\nIf\nIsEmpty\n(Cells(C.Row + r, C.Column)) Then\n'각 셀이 빈셀이면\ncnt = cnt + 1\n'셀 개수 카운터 1씩 늘려감\nCells(C.Row + r, C.Column) = Selection.\nCells\n(cnt)\n'선택영역 각 셀값을 복사\nEnd If\nr = r + 1\n'행을 1씩 늘려감\nLoop Until\nSelection.Count = cnt\n'카운터가 선택영역 개수될 때까지 무한반복\nSet C = Nothing\n'개체변수들 초기화(메모리 비우기)\nEnd Sub", "context": "입력창에서 선택한 셀 아래로 빈 셀이 있는 곳에만 복사를 하는 기능. 동영상에 보듯 한 칸씩 건너 뛰거나 또는 여러 칸이 빈셀이어도 상관 없다. 당연히 불규칙하게 셀병합된 셀들어 적용되지 않는다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1166) 빈 셀에만 선택영역 값을 복사하기 (엑셀 VBA 매크로)\n재생\n1,536\n재생 (space/k)\n재생\n00:29\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:29\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도..."}
{"instruction": "Excel VBA code for: (1168) 선택한 그림을 특정 영역에 맞추어넣기 (엑셀 VBA 매크로)", "input": "", "output": "Sub fit_A_Picture_In_Selection()\nDim rngSel As Range\n'선택영역 전체를 넣을 변수\nIf\nTypeOf\nSelection Is Range Then\n'선택한 것이 영역이라면\nMsgBox \"그림이 선택되지 않음\", 64, \"영역선택 오류\"\n'경고 메시지 출력\nExit Sub\nEnd If\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel = Application.\nInputBox\n(\"마우스로 복사될 위치를 선택하시오!\", Type:=8)\nIf\nrngSel Is Nothing\nThen Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nIf rngSel.\nMergeCells\nThen\n'rngShp가 셀병합된 셀이라면\nSet rngSel = rngSel.\nMergeArea\n'영역을 셀병합 영역으로 확장\nEnd If\nWith Selection\n'선택영역\n.ShapeRange.\nLockAspectRatio\n= msoFalse\n'그림 좌우고정비율 해제\n.Left = rngSel.Left + 4\n'그림왼쪽위치를 셀의 왼쪽위 + 4\n.Top = rngSel.Top + 4\n'그림위쪽 위치를  셀의 왼쪽위 위치  +4\n.Height = rngSel.Height - 8\n'그림 높이를 현재셀 크기  - 8\n.Width = rngSel.Width - 8\n'그림 폭을 현재셀 크기 - 8\nEnd With\nSet rngSel = Nothing\n'개체변수들 초기화(메모리 비우기)\nActiveWindow.\nRangeSelection\n.Select\n'영역을 선택\nEnd Sub", "context": "생각해 보니 폴더내의 그림을 가져오거나, 행열로 넣는 등의 여러 기능을 해보았지만 정작 제일 필요한 기능중의 하나인 엑셀에 삽입된 그림을 특정 영역에 맞추어 넣는 기능은 하지 않았던 것 같다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1168) 선택한 그림을 특정 영역에 맞추어넣기 (엑셀 VBA 매크로)\n재생\n3,589\n재생 (space/k)\n재생\n00:41\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:41\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도..."}
{"instruction": "Excel VBA code for: (1169) 데이터 사이에 행삽입 후 값을 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_And_fill_Blank_Cells()\nDim C As Range\n'입력창에서 선택한 영역을 넣을 변수\nDim rngCol As Range\n'선택영역의 첫 열 영역을 넣을 변수\nDim colsCnt As Integer\n'열 개수를 넣을 변수\nDim rowsCnt As Long\n'선택영역의 행 개수를 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'행삽입 시 반복구문에 사용할 변수\nDim i As Long\n'셀 번호 늘려갈 변수\nWith Selection\nIf .\nCount\n= 1 Then\n'1개의 셀을 선택하였을 경우\nMsgBox\n\"1셀만 선택되어 종료합니다.\", 64, \"셀선택 오류\"\nExit Sub\n'매크로 종료\nEnd If\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet C = Application.\nInputBox\n(\"마우스로 복사될 위치를 선택하시오!\", Type:=8)\nIf C Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\ncolsCnt = .Columns.Count\n'선택영역 열 개수를 변수에 넣음\nrowsCnt = .Rows.Count\n'선택영역 행 개수를 변수에 넣음\nSet rngCol = C.Resize(rowsCnt)\n'선택영역 첫 열을 변수에 넣음\nFor r = rowsCnt To 2\nStep -1\n'전체열 숫자에서 1씩 빼가면서 1까지 반복\nrngCol.Cells(r).Resize(, colsCnt).\nInsert\nshift:=xlDown\n'각 데이터 빈 셀행을 삽입\nNext r\nFor Each rngC In C.Resize(rowsCnt * 2)\n'전체 행 개수 곱하기 2만큼의 셀을 순환\nIf\nIsEmpty\n(rngC) Then\n'만약 각 셀이 빈셀이면\ni = i + 1\n'셀 번호 값을 1씩 늘려감\nrngC.Resize(, colsCnt) = _\n.Columns(1).Cells(i).Resize(, 3).Value\n'값을 셀에 뿌림\nEnd If\nNext rngC\nEnd With\nSet C = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngCol = Nothing\nEnd Sub", "context": "가끔 기존 데이터의 각 행에 빈 셀(행)을 삽입하고 그 곳에 다른 곳의 데이터를 사이사이 껴넣는 작업을 할 때가 있다. 아래의 코드는 그런작업을 할 때 유용할 것이다. VBA와 데이터베이스의 적(敵)인 셀병합된 셀에는 적용되지 않는다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1169) 데이터 사이에 행삽입 후 값을 복사하기 (엑셀 VBA 매크로)\n재생\n3,196\n재생 (space/k)\n재생\n00:12\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:12\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화..."}
{"instruction": "Excel VBA code for: (1170) 알파벳 나열하기 (엑셀 매크로 VBA)", "input": "", "output": "Sub list_Alphabet()\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim i As Long\n'각 셀의 주소 길이 만큼 반복할 변수\nDim strU As String\n'각 셀의 주소 문자를 합쳐갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor r = 1 To 16384\n'1 ~ 16,384 까지 반복\nDo\n'다음을 실행\ni = i + 1\n'각 셀주소 문자의 위치를 1씩 늘려감\nIf\nMid\n(Cells(1, r).\nAddress(0, 0)\n, i, 1)\nLike \"[0-9]\"\nThen Exit Do\n'각 셀주소에 숫자가 포함되면 Do구문 종료\nstrU = strU & Mid(Cells(1, r).Address(0, 0), i, 1)\n'(숫자 아닐경우) 셀주소 각 알파벳 문자를 합쳐감\nLoop\n'무한 반복\nCells(r, 2) = strU\n'합친 문자를 (B열) 셀에 뿌려줌\nstrU = \"\"\n'재사용 위하여 초기화\ni = 0\n'재사용 위하여 초기화\nNext r\nEnd Sub", "context": "(아래 글 올린 이후에 더 쉬운 방법을 알게됨. 간단히\n알파벳을 나열하는 기능. A, B, C, D ...... AA, AB, AC, AD, ...........XFA, XFB, XFC, XFD 까지 모두 총 16384 즉, 엑셀 2007 / 2010 의 마지막 열(XFD) 개수까지 추출 가능하다. For 중첩구문에 Choose 함수 등을 사용하면 4자리 또는 그 이상의 문자도 추출할 수 있을 것 같지만 별로 쓸일도 없을 것 같아서 시도해 보지는 않음.\n세로가 아닌 가로로 입력하는 것은 숙제로 여러분들이 직접 해보시기를 ....\n아무 셀에서나 수식     =SUBSTITUTE(ADDRESS(COLUMN(), ROW(),\n4\n),COLUMN(),\"\")\n입력 후 아래로 복사하면 된다.\n또는 아래의 매크로 실행 시 B열에 위와 같이 알파벳을 A ~ XFD까지 나열해준다.\nOption Explicit\nSub list_Alphabet()\nDim r As Long\n'행을 1씩 늘려갈 변수\nDi..."}
{"instruction": "Excel VBA code for: (1171) 두 시트 비교하여 빈셀에 다른 시트 값으로 채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_And_Fill_Blanks()\nDim rng1 As Range\n'Sheet1의 N열 문자 넣을 변수\nDim rng2 As Range\n'Sheet2의 N열 문자 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim C As Range\n'선택영역 전체를 넣을 변수\nDim rngA As Range\n'Sheet1의 행을 넣을 변수\nDim rngB As Range\n'Sheet1의 행을 넣을 변수\nDim rngEach As Range\n'Sheet1 행의 각 셀을 넣을 변수\nDim r As Long\n'반복구문 및 셀번호에 사용할 변수\nSet rng1 = Range(\"N2\", Cells(Rows.Count, \"N\").End(3))\n'Sheet1 N열 문자 변수에 넣음\nWith Sheets(2)\n'Sheet2에서\nSet rng2 = .Range(.[N2], .Cells(Rows.Count, \"N\").End(3))\nEnd With\n'N열 문자 변수에 넣음\nFor Each rngC In rng1\n'Sheet1 N열의 각 셀을 순환\nSet C = rng2.\nFind\n(rngC, , , xlWhole)\n'Sheet2에서 일치한 셀을 변수에 넣음\nIf\nNot C Is Nothing\nThen\n'일치한 셀이 존재하면\nSet rngA = rngC.Offset(, -13).Resize(, 13)\n'Sheet1 셀의 행을 변수에\nSet rngB = C.Offset(, -13).Resize(, 13)\n'Sheet2 셀의 행을 변수에\nFor r = 1 To 13\n'13회 반복\nIf\nIsEmpty\n(rngA.Cells(r)) Then\n'만일 빈셀이 있다면\nrngA.Cells(r) = rngB.Cells(r)\n'Sheet2의 데이터를 Sheet1의 빈셀에 입력\nEnd If\nNext r\nEnd If\nNext rngC\nSet C = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rng1 = Nothing\nSet rng2 = Nothing\nSet rngA = Nothing\nSet rngB = Nothing\nEnd Sub", "context": "두 시트를 비교하여 빈셀을 다른 시트에 있는 데이터의 값으로 채우는 기능.\n매크로 실행 전 Sheet1\n매크로 실행 전 Sheet2\n매크로 실행 후\nSheet1의 결과\nOption Explicit\nSub find_And_Fill_Blanks()\nDim rng1 As Range\n'Sheet1의 N열 문자 넣을 변수\nDim rng2 As Range\n'Sheet2의 N열 문자 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim C As Range\n'선택영역 전체를 넣을 변수\nDim rngA As Range\n'Sheet1의 행을 넣을 변수\nDim rngB As Range\n'Sheet1의 행을 넣을 변수\nDim rngEach As Range\n'Sheet1 행의 각 셀을 넣을 변수\nDim r As Long\n'반복구문 및 셀번호에 사용할 변수\nSet rng1 = Range(\"N2\", Cells(Rows.Count, \"N\").End(3))\n'Sheet1 N열 문자 변수에 넣음\n..."}
{"instruction": "Excel VBA code for: (1172) 선택영역을 별도의 파일에 값으로 저장하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub save_Selection()\nDim rngAll As Range\n'선택영역을 넣을 변수\nDim i As Integer\n'반복구문 및 loop guard로 사용할 변수\nDim strName As String\n'파일이름 넣을 변수\nSet rngAll =\nSelection\n'선택영역을 변수에 넣음\nWorkbooks.Add\n'새로운 파일을 열기\nrngAll.Copy\n'선택영역을 복사\nCells(1, 1).\nPasteSpecial\nPaste:=xlPasteValues\n'값을 A1셀에 붙여넣기\nColumns.AutoFit\n'열너비 자동맞춤\nstrName = \"C:\\\" & \"파일이름_\" &\nFormat\n(Date, \"\nyymmdd\n\") & \".xlsx\"\n'파일 이름 + 오늘날짜 + .xlsx 를 변수에 넣음\nDo\n'다음을 실행\ni = i + 1\n'1씩 값을 늘려감\nIf\nDir\n(strName) = vbNullString Then\n'만약 파일이 이미 존재하면\nActiveWorkbook.\nSaveAs\nstrName\n'활성화된 시트를 저장\nActiveWorkbook.Close False\n'활성화된 시트를 닫음\nExit Sub\n'매크로 종료\nElse\nstrName = \"C:\\\" & \"파일이름_\" & Format(Date, \"yymmdd\") & \"_\" & i & \".xlsx\"\n'이미 파일이 존재할 경우 기존파일 이름 뒤에 숫자 늘려감\nEnd If\nIf i > 100 Then Exit Sub\n'숫자가 100을 넘으면 loop 걸러지 않기 위해 종료\nLoop\n'무한 반복\nEnd Sub", "context": "선택한 영역을 별도의 엑셀파일로 저장하는 기능.\n복사 시 기존 수식을 없애고 A1셀에 값으로 붙여 넣는다.\n파일 이름은 \"파일이름_\" + \"오늘의 날짜\" + \".xlsx\" 로 하며 이미 동일한 파일이 있을 경우 뒤에 숫자를 1씩 늘려가며 저장\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1172) 선택영역을 별도의 파일에 값으로 저장하기 (엑셀 VBA 매크로)\n재생\n1,762\n재생 (space/k)\n재생\n00:43\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:43\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운..."}
{"instruction": "Excel VBA code for: (1173) 그림과 파일명 행으로 가져오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_FileName_With_Pictures()\nDim fileNames As Variant\n'모든 파일 넣을 배열 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim var\n'파일이름 쪼개어 넣을 변수\nDim strName As String\n'추출한 파일이름 넣을 변수\nDim A As Range\n'파일이름 들어갈 영역을 넣을 변수\nDim C As Range\n'그림 들어갈 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet A = ActiveCell\n'현재 선택한 셀을 변수에 넣음\nfileNames = Application.\nGetOpenFilename\n(\"Picture Files (*.jp*; *.gif; *.png),*.xls\", , _\n\"그림 파일을 선택\",\nMultiSelect\n:=True)\n'그림 파일을 선택\nIf TypeName(fileNames) = \"Boolean\" Then Exit Sub\n'취소 선택 시 매크로 종료\nFor i = 1 To UBound(fileNames)\n'선택한 파일 개수만큼 반복\nvar =\nSplit\n(fileNames(i), \"\\\")\n'\\ 로 전체이름을 나누어 배열에 넣음\nstrName = var(\nUBound\n(var))\n'제일 뒤의 파일 이름만 추출\nA = strName\n'추출한 이름을 셀에 뿌림\nActiveSheet.Pictures.\nInsert\n(fileNames(i)).Select\n'각 그림파일 삽입\nIf A.Offset(-1).MergeCells Then\n'만약 이름 윗셀이 셀병합 셀이면\nSet C = A.Offset(-1).MergeArea\n'셀병합 셀을 C에 넣음\nElse\n'셀병합셀 아닐 경우\nSet C = A.Offset(-1)\n'그냥 바로 윗셀을 C에 넣음\nEnd If\nWith Selection\n'선택된 그림파일\n.Name = \"Temp#\"\n'(임시로) 이름을 \"Temp#\"로 지정\n.ShapeRange.LockAspectRatio = msoFalse\n'그림의 가로/세로비율 고정 해제\n.Height = C.Height - 4\n'그림의 가로크기 지정\n.Width = C.Width - 4\n'그림의 세로크기 지정\n.Copy\n'그림을 복사\nActiveSheet.\nPasteSpecial\nLink:=False\n'그림 링크깨고 붙여넣기\nActiveSheet.Pictures(\"Temp#\").Delete\n'원본 그림파일 삭제\nEnd With\nWith Selection\n'(복사되어)선택된 그림파일\n.Left = C.Left + 2\n'그림의 왼쪽위치 지정\n.Top = C.Top + 2\n'그림의 윗쪽위치 지정\nEnd With\nSet A = A.Offset(, 1)\n'이름 들어갈 위치를 오른쪽으로 하나씩 늘려감\nNext i\nSet A = Nothing\n'개체변수 초기화(메모리 비우기)\nSet C = Nothing\nEnd Sub", "context": "참고로 그림은 그림이름 셀의 바로 위에 들어간다(물론 아래 또는 다른 곳에 넣을 수도 있다.). 그리고,수국이 들어간 셀은 단일셀, 코알라가 들어간 셀은 3개의 셀이 가로로 셀병합, 펭귄이 들어간 셀은 2개의 셀이 세로로 셀병합, 튤립은 가로2, 세로 2개의 셀이 셀병합된 영역임.\n그림은 삽입 후 링크를 깨고 복사하여 영구삽입한다. 그림의 개수만큼 오른쪽으로 계속 삽입된다. 복수의 행인 경우 한 번에 삽입할 수 없어 여러번 실행해야 하지만 파일이름과 그림을 하나씩 삽입하는 것보다는 훨 편리할 듯.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1173) 그림과 파일명 행으로 가져오기 (엑셀 VBA 매크로)\n재생\n3,060\n공유하기\n재생 (space/k)\n재생\n00:23\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:23\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기..."}
{"instruction": "Excel VBA code for: (1174) 각 데이터를 별도의 파일로 저장하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub each_Row_As_File()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim strU As String\n'문자를 합쳐넣을 변수\nDim strPath As String\n'저장할 폴더의 경로를 넣을 변수\nDim rngTitle As Range\n'제목행을 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim rngA As Range\n'각 행의 데이터영역 넣을 변수\nWith Application.FileDialog(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nWith Application\n.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n.Calculation = xlCalculationManual\n'셀 계산 수동으로 전환\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, \"A\").End(3)).Resize(, 2)\n'이름, ID 영역의 각 셀을 순환\nFor i = 1 To Len(rngC)\n'1 ~ 셀 길이만큼 반복\nIf\nMid\n(rngC, i, 1) <>\nChr(10)\nThen\n'각 문자가 Alt + Enter가 아닐 경우\nstrU = strU & Mid(rngC, i, 1)\n'문자를 합쳐감\nEnd If\nNext i\nrngC = strU\n'합쳐진 문자를 셀에 넣음\nstrU = \"\"\n'재사용 위하여 초기화\nNext rngC\nSet rngTitle = Range(\"A1\", Cells(1, Columns.Count).End(1))\n'제목행을 변수에 넣음\ncolsCnt = rngTitle.Columns.Count\n'전체 열 개수를 변수에 넣음\nSet rngA = rngTitle.Offset(1)\n'제목 바로 아래행을 rngA영역에 넣음\nWorkbooks.\nAdd\n'새로운 파일을 열기\nrngTitle.\nCopy\n'제목을 복사\nActiveSheet.\nPaste\nCells(1, 1)\n'제목을 A1셀에 붙여 넣음\nDo Until\nrngA.Cells(1).Value = \"\"\n'A열에 빈 셀이 나올때까지 무한 반복\nCells(2, 1).Resize(, colsCnt) = rngA.Value\n'각 행의 값을 복사\nColumns(\"F\").\nNumberFormat\n= \"yyyy-mm-dd\"\n'F열의 서식을 날짜로 설정\nColumns.AutoFit\n'열너비 자동맞춤\nActiveWorkbook.\nSaveAs\nstrPath & Cells(2, 1) & \" \" & Cells(2, 2)\n'활성화된 시트를 A2 + B2 셀의 값으로 저장\nSet rngA = rngA.Offset(1)\n'rngA영역을 1행씩 아래로 offset시킴\nLoop\n'무한 반복\nActiveWorkbook.\nClose\nFalse\n'저장 없이 파일을 닫음\n.CutCopyMode = False\n'자르기/붙여넣기 모드해제(클립보드 비우기)\n.Calculation = xlCalculationAutomatic\n'셀계산 자동으로 전환\nEnd With\nMsgBox \"파일 분리가 완료되었습니다.\"\nSet rngTitle = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngA = Nothing\nEnd Sub", "context": "제목행과 각 행의 데이터를 별도의 파일로 저장하는 기능. 아래 예제에서는 각 행별로 파일을 생성하였지만 정렬만 되어 있으면 각 그룹별 데이터도 별도의 파일로 저장할 수 있을 것으로 생각됨.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1174) 각 데이터를 별도의 파일로 저장하기 (엑셀 VBA 매크로)\n재생\n2,878\n재생 (space/k)\n재생\n00:32\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:32\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변..."}
{"instruction": "Excel VBA code for: (1175) 사진 데이터베이스 만들기 (엑셀 VBA 매크로)", "input": "", "output": "Sub picture_Database()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim C As Range\n'그림 들어갈 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Application.FileDialog(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 종료\nElse\n'파일이 있을 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName =\nDir\n(strPath & \"*.*\")\n'(폴더내)각 그림파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\n[B1:F1] =\nArray\n(\"그림\", \"파일명\", \"경로\", \"크기\", \"날짜\")\nSet C = Cells(Rows.Count, \"A\").\nEnd(3)(2)\n'B열 종단셀 윗방향 아래셀을 변수에 넣음\nC = C.Offset(-1) + 1\n'행번 입력\nC.Next.\nColumnWidth\n= 10\n'그림들어갈 셀의 폭을 10으로\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nC.\nRowHeight\n= 50\n'그림들어갈 셀의 높이를 50으로\nActiveSheet.\nPictures.Insert(\nstrPath & fileName).Select\n'각 그림파일 삽입\nWith Selection\n'선택된 그림파일\n.Name = \"Temp#\"\n'(임시로) 이름을 \"Temp#\"로 지정\n.ShapeRange.LockAspectRatio = msoFalse\n'그림의 가로/세로비율 고정 해제\n.Height = C.Next.Height - 4\n'그림의 가로크기 지정\n.Width = C.Next.Width - 4\n'그림의 세로크기 지정\n.Copy\n'그림을 복사\nActiveSheet.\nPasteSpecial Link:=False\n'그림 링크깨고 붙여넣기\nActiveSheet.Pictures(\"Temp#\").Delete\n'원본 그림파일 삭제\nEnd With\nWith Selection\n'(복사되어)선택된 그림파일\n.Placement =\nxlMoveAndSize\n'크기변하고 이동되도록 설정\n.Left = C.Next.Left + 2\n'그림의 왼쪽위치 지정\n.Top = C.Next.Top + 2\n'그림의 윗쪽위치 지정\nEnd With\nWith C\nC = .Offset(-1) + 1\n'행번 입력\n.Offset(, 2) =\nfileName\n'그림 아래에 파일이름 입력\n.Offset(, 3) =\nstrPath\n'그림의 경로를 입력\n.Offset(, 4) =\nFileLen\n(strPath & fileName)\n'파일 크기 입력\n.Offset(, 5) =\nFileDateTime\n(strPath & fileName)\n'파일 날짜시간 입력\nIf .Row > 1000000 Then\n'행이 1000000행을 벗어나면\nMsgBox \"행의 끝단입니다. 더이상 삽입할 수 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 종료\nElse\n'전체 행개수 보다 적으면\nSet C = .Offset(1)\n'그림 들어갈 위치를 두행 내림\nEnd If\nEnd With\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nRange(\"A:A,C:F\").EntireColumn.AutoFit\n'열너비 자동맞춤\nSet C = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "사진의 관리로 스트레스를 받는 분들이 상당히 있으신 것 같다. 아래의 매크로는 폴더내에 있는 사진 및 사진파일의 이름, 사진의 저장 경로, 파일 크기 및 파일날짜를 일반 데이터베이스와 마찬가지 구조로 입력을 하여준다. 참고로 사진은 링크가 아닌 영구삽입됨. 자세한 내용은 동영상을 참조.\n메모리의 제한이 있으므로 한 파일에 그림을 넣는 개수가 제한이 있을듯. 자신의 컴퓨터 메모리가 허락하는 한계내에서 사진을 그룹별로 구분하여 별도파일로 관리하면 될듯. 또한 B:F열을 선택하고 메뉴 => 데이터 =>\n중복 제거\n시 중복된 사진들은 사진만 남고 삭제되므로 관리하기도 편하다. 물론\n필터\n를 적용하여도 된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1175) 사진 데이터베이스 만들기 (엑셀 VBA 매크로)\n재생\n5,133\n재생 (space/k)\n재생\n00:49\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:..."}
{"instruction": "Excel VBA code for: (1176) 일치하는 \"품목\" 찾아 값 옮기기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Matching_Data_And_Move2()\nDim rngC As Range\n'(A열)각 셀을 넣을 변수\nDim rngAll As Range\n'L열 전체 영역을 넣을 변수\nDim C As Range\n'(L열) 각 셀을 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim r  As Long\n'각 행을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"L2\", Cells(Rows.Count, \"L\").End(3))\n'L열 전체영역을 변수에 넣음\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'일치하는값 옮길 코드\nFor Each C In rngAll\n'L열 각 셀을 순환\nIf Not\nIsEmpty\n(C) Then\n'만약 빈셀이 아니라면\nIf rngC = C Then\n'A열과 L열이 일치하면\nrngC.Offset(, 2).Resize(, 4) = C.Offset(, 1).Resize(, 4).Value\n'M:P 열의 값을 C:F열에 복사\nC.Resize(, 5).\nClearContents\n'(서식은 놔두고) M:P열의 값만 삭제\nEnd If\nEnd If\nNext C\nNext rngC\nReDim\nvarTemp(1 To rngAll.Rows.Count, 1 To 5)\n'배열크기 재지정\nFor Each C In rngAll\n'L열 각 셀을 순환\nIf Not IsEmpty(C) Then\n'각 셀이 빈셀이 아니라면\nr = r + 1\n'행을 1씩 늘려감\nFor i = 1 To 5\n'5회 반복\nvarTemp(r, i) = C.Offset(, i - 1)\n'배열에 값을 넣음\nNext i\nEnd If\nNext C\nrngAll.Offset(1).\nClear\n'제목 제외한 기존 데이터(서식까지) 삭제\nCells(2, \"L\").Resize(UBound(varTemp, 1), 5) = varTemp\n'배열값 셀에 뿌림\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. A열과 일치하는 품목을 L열에서 찾음\n2. 일치하는 품목이 있을 경우 M:P열의 값을 C:F열로 이동\n3. 값이 이동하여 공백이 생기 M:P열의 값을 L열을 포함 삭제하며 위로 끌어올림.\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub find_Matching_Data_And_Move2()\nDim rngC As Range\n'(A열)각 셀을 넣을 변수\nDim rngAll As Range\n'L열 전체 영역을 넣을 변수\nDim C As Range\n'(L열) 각 셀을 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim r  As Long\n'각 행을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"L2\", Cells(Rows.Count, \"L\").End(3))\n'L열 전체영역을 변수에 넣음\nFor Each ..."}
{"instruction": "Excel VBA code for: (1177) 특정시트만 남겨서 백업폴더에 저장하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub create_Data_Copy()\n'메인 프로시저\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim r As Long\n'배열크기 늘려갈 변수\nDim varTemp()\n'동적배열로 사용할 변수\nDim blnYN As Boolean\n'폴더 존재여부 확인할 변수\nDim fldName As String\n'폴더이름 넣을 변수\nDim var As Variant\n'전체경로를 \"\\\"로 나누어 넣을 배열변수\nDim oldFile As String\n'기존 폴더내 각 파일을 넣을 변수\nDim wkBk As Workbook\n'각 파일을 넣을 변수\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n.Calculation = xlCalculationManual\n'셀 계산 수동으로 전환\nWith .FileDialog(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 종료\nElse\n'파일 존재 시\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName =\nDir\n(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nr = r + 1\n'배열크기 1씩 늘려감\nReDim Preserve\nvarTemp(1 To r)\n'배열크기 재지정\nvarTemp(r) = fileName\n'배열에 파일이름을 넣음\nfileName = Dir\n'다음 파일을 변수에 넣음\nLoop\n'무한 반복\nvar =\nSplit\n(strPath, \"\\\")\n'전체 파일 경로를 \"\\\" 로 나누어 배열에 넣음\nfldName = var(\nUBound\n(var) - 1)\n'마지막 하위폴더 이름을 변수에 넣음\nblnYN = folder_Exists(strPath & fldName)\n'폴더 확인 함수 호출\nIf blnYN = False Then\n'blnYN가 거짓, 즉 폴더가 존재하지 않으면\nMkDir\nstrPath & fldName\n'폴더를 생성\nElse\n'이미 폴더가 존재할 경우\noldFile = Dir(strPath & fldName & \"\\\" & \"*.xls*\")\n'폴더내의 파일을 변수에 넣음\nDo While\noldFile <> \"\"\n'엑셀파일이 존재하면\nKill\nstrPath & fldName & \"\\\" & oldFile\n'각 엑셀파일을 삭제\noldFile = Dir\n'다음 파일을 변수에 넣음\nLoop\n'무한반복\nEnd If\nFor r = LBound(varTemp) To UBound(varTemp)\n'배열 개수만큼 반복\nSet wkBk = Workbooks.Open(strPath & varTemp(r))\n'각 파일을 열고 변수에 넣음\nCall\nsheet_Handling\n'각 시트의 작업을 하는 sheet_Handling 매크로호출\nwkBk.\nSaveAs\nstrPath & fldName & \"\\\" & ActiveWorkbook.Name\n'복사될 폴더에 각 파일 복사\nwkBk.Close False\n'열려진 파일을 닫음\nNext r\n.Calculation = xlCalculationAutomatic\n'셀계산 자동으로 전환\nEnd With\nEnd Sub\n\nPrivate Function folder_Exists\n(fldName As String) As Boolean\n'폴더 존재여부 확인할 함수\nIf\nLen(Dir(fldName, vbDirectory)) <> 0\nThen\n'폴더 존재하여 폴더문자길이 0 아니면\nfolder_Exists = True\n'폴더가 이미 존재\nElse\n'폴더 문자길이가 0이면\nfolder_Exists = False\n'폴더는 존재하지 않음\nEnd If\nEnd Function\n\nPrivate Sub sheet_Handling()\n'각 시트에 해당작업을 할 sub procedure\nDim s As Integer\n'파일 개수만큼 반복할 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nFor s = Sheets.Count To 1 Step -1\n'마지막 시트에서 1번시트까지 반복\nIf s = 3 Then\n'3번째 시트일 경우\nFor Each rngC In Sheets(s).UsedRange\n'시트의 사용영역 각 셀을 순환\nWith rngC\n'각 셀에서\n.Value = .Value\n'각 셀의 수식을 없애고 모두 값으로 변환\nEnd With\nNext rngC\nElse\n'3번 시트가 아니라면\nApplication.\nDisplayAlerts = False\n'화면 경고기능 중지\nSheets(s).Delete\n'각 시트 삭제\nApplication.\nDisplayAlerts = True\n'화면 경고기능 복원\nEnd If\nNext s\nEnd Sub", "context": "기존 폴더에 기존 폴더와 동일한 이름으로 하위 폴더를 생성\n만일 하위폴더가 이미 존재할 경우 하위 폴더내의 기존 파일들을 삭제\n폴더내의 모든 파일을 열고, 3번 시트만 남기고 나머지 시트는 모두 삭제\n3번 시트의 모든 셀은 함수를 없애고 값으로 붙여넣어 저장\n각 파일을 하위 폴더에 저장\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1177) 특정시트만 남겨서 백업폴더에 저장하기 (엑셀 VBA 매크로)\n재생\n786\n재생 (space/k)\n재생\n01:14\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:14\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니..."}
{"instruction": "Excel VBA code for: (1179) 그림 가로로 정렬하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub align_Pictures_Horizontally()\nDim shp As Object\n'각 개체를 넣을 변수\nDim sngW As Single\n'선택된 첫 도형의 가로 크기 넣을 변수\nDim sngH As Single\n'선택된 첫 도형의 세로 크기 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim cnt As Integer\n'선택된 도형의 카운터로 사용할 변수\nDim gapBtwn As Integer\n'개체 사이의 여백을 넣을 변수\nIf\nTypeName\n(Selection) <> \"\nDrawingObjects\n\" Then\n'선택된 것이 복수의 도형이 아니라면\nMsgBox \"복수의 개체가 선택되지 않았습니다.\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nIf Selection.Count < 2 Then\n'2개 이상의 개체선택하지 않았을 경우\nMsgBox \"2개 이상의 개체를 선택하세요.\" '메시지 출력\nExit Sub\n'매크로 종료\nEnd If\ngapBtwn =\n3\n'개체 사이의 여백을 넣을 변수\nWith Selection.\nShapeRange\n'선택된 것의 shaperange\nsngW =\n.Item(1)\n.Width\n'첫 번째 개체의 가로크기를 변수에\nsngH = .Item(1).Height\n'첫 번째 개체의 세로 크기를 변수에\n.\nLockAspectRatio = msoFalse\n'개체의 가로/세로비율 고정 해제\nFor i = 1 To Selection.Count\n'선택한 개체의 개수만큼 반복\nIf .Item(i).Width = sngW And .Item(i).Height = sngH Then\n'개체의 크기들을 비교하여 같을 경우\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nEnd If\nNext i\nIf Selection.Count = cnt And .Item(2).Left = _\n.Item(1).Left + sngW + gapBtwn Then\n'개체크기가 모두 같고 첫째 도형 두 번째 도형이 정렬되어 있다면\nMsgBox \"개체가 이미 정렬되어 있습니다.\"\n'메시지 출력\nExit Sub\n'매크로 종료\nElse\n'정렬되어 있지 않다면\nFor i = 2 To Selection.Count\n'2 ~ 선택된 개체 개수만큼 반복\n.Item(i).\nWidth\n= sngW\n'각 개체 가로를 첫개체 크기로\n.Item(i).\nHeight\n= sngH\n'각 개체 높이를 첫 개체 크기로\n.Item(i).\nLeft\n= .Item(i - 1).Left + .Item(i).Width + gapBtwn\n'각 개체에 gap을 주며 배치\n.Item(i).\nTop\n= .Item(1).Top\n'각 개체의 윗쪽위치를 첫 개체 윗쪽위치로\nNext i\nEnd If\nEnd With\nEnd Sub", "context": "선택된 도형의 크기를\n처음선택된 도형(그림)크기로\n모두 일치\n시킨 다음 사이에 약간의 여백을 두고 가로로 정렬하는 기능. 도형(그림) 사이의 여백을 조절하고 싶을 경우 gapBtwn =\n3\n의 값을 조정.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1179) 그림 가로로 정렬하기 (엑셀 VBA 매크로)\n재생\n1,140\n재생 (space/k)\n재생\n00:32\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:32\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 ..."}
{"instruction": "Excel VBA code for: (1180) 분기(分期) 표시 아이콘 입력하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Quarter_Section()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim C As Range\n'각 그림의 위치를 넣을 변수\nDim rngShp As Range\n'각 그림의 왼쪽위가 속한 영역을 넣을 변수\nDim shpC As Shape\n'각각의 도형(shape)을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nIf rngC = 1 Or rngC = 2 Or rngC = 3 Or rngC = 4 Then\n'각 셀이 1 ~ 4 라면\nSelect Case\nrngC\n'rngC가\nCase 1: Set C = [B1]\n'1일 경우 B1셀을 변수 C에 넣음\nCase 2: Set C = [D1]\n'2일 경우 D1셀을 변수 C에 넣음\nCase 3: Set C = [F1]\n'3일 경우 F1셀을 변수 C에 넣음\nCase 4: Set C = [H1]\n'4일 경우 H1셀을 변수 C에 넣음\nEnd Select\nFor Each shpC In ActiveSheet.\nShapes\n'전체영역내 각 그림을 순환\nSet rngShp = shpC.\nTopLeftCell\n'각 도형의 왼쪽위 영역을 변수에 넣음\nIf Not\nIntersect\n(C, rngShp) Is Nothing Then\n'각 도형이 각셀영역에 포함되면\nshpC.\nCopy\n'해당 도형을 복사\nActiveSheet.\nPaste\n'도형을 붙여넣기\nWith rngC.Next\n'복사되어 선택된 도형에서\nSelection.Left = .Left + (.Width - Selection.Width) / 2\n'폭을 셀 중앙에\nSelection.Top = .Top + (.Height - Selection.Height) / 2\n'높이를 셀 중앙에\nEnd With\nEnd If\nNext shpC\nEnd If\nNext rngC\nSet C = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngShp = Nothing\nEnd Sub", "context": "단순한 기능이므로 동영상만으로 설명이 충분할 것 같다. 조건부 서식에도 이와 비슷하게 아이콘을 넣는 기능이 있지만 색깔이나 크기조절이 되지 않는다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1180) 분기(分期) 표시 아이콘 입력하기 (엑셀 VBA 매크로)\n재생\n606\n재생 (space/k)\n재생\n00:12\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:12\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순..."}
{"instruction": "Excel VBA code for: (1181) 복수의 차트 삽입/삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Multiple_Charts()\n'차트생성 버튼에 연결된 매크로\nDim lastRow As Long\n'마지막 행의 행번호 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngTitle As Range\n'제목 영역을 넣을 변수\nDim rngR As Range\n'각 행 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, \"A\").End(3).\nRow\n'A열 마지막 행을 변수에\nSet rngTitle = Cells(1, 1).Resize(, 6)\n'제목 영역을 변수에 넣음\nFor i = 2 To lastRow\n'2부터 마지막 행까지 반복\nActiveSheet.Shapes.\nAddChart\n.Select\n'현재시트 차트를 삽입하고 선택\nActiveChart.\nChartType\n=\nxlLineMarkersStacked\n'차트의 종류를 결정\nSet rngR = Cells(i, 1).Resize(, 6)\n'각 행을 변수에 넣음\nActiveChart.\nSetSourceData Source\n:= _\nUnion\n(rngTitle, rngR)\n'제목과 행을 합쳐서 넣음\nWith Selection\n'선택된 차트에서\n.Width = 200\n'폭을 200으로\n.Height = 150\n'높이를 150으로\n.Left = 250\n'왼쪽 위치 250으로\n.Top = (i - 3) * .Height + .Height + (i * 10)\n'각 차트의 윗쪽 위치 결정\nEnd With\nNext i\nEnd Sub\n\nSub delete_Charts()\n'삭제 버튼에 연결된 매크로\nDim shp As\nShape\n'각 도형을 넣을 변수\nFor Each shp In ActiveSheet.Shapes\n'현재시트내 각 도형을 순환\nIf shp.\nType\n=\nmsoChart\nThen\n'도형이 차트라면\nshp.Delete\n'도형을 삭제\nEnd If\nNext shp\nEnd Sub", "context": "데이터 계열을 바꿔가면서 복수의 차트를 연속으로 생성하는 기능.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1181) 복수의 차트 삽입/삭제하기 (엑셀 VBA 매크로)\n재생\n3,563\n재생 (space/k)\n재생\n00:17\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:17\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n입력된 데이터가 보인다.\n매크로 실행 시 각 데이터에 따라 차트를 생성\n삭..."}
{"instruction": "Excel VBA code for: (1183) 미화원 무작위 배치 순서 (엑셀 VBA 매크로)", "input": "", "output": "Sub distribute_Cleaning_Crew()\nDim rngA As Range\n'6명씩 들어갈 영역을 넣을 변수\nDim x As Integer\n'열방향 늘려갈 변수\nDim y As Long\n'행방향 늘려갈 변수\nDim var As Variant\n'6명의 이름을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.\nClear\n'기존 데이터 삭제\nFor y = 1 To 102\n'1 ~ 102층까지 반복\nCells(y, 1) = Cells(y, 1).Row & \"층\"\n'A열에 층을 기록\nNext y\nFor y = 1 To 100 Step 3\n'행방향 반복\nFor x = 1 To 10 Step 3\n'열방향 반복\nSet rngA = Cells(y, x + 1).Resize(3, 2)\n'반복하여 이름 넣을 영역을 변수에 넣음\nFor i = 7 To 10\n'7 ~ 10까지 반복\nrngA.\nBorders\n(i).\nLineStyle = 1\n'외곽선 상/하/좌/우에 테두리\nNext i\nvar =\nArray\n(\"김미정\", \"이수정\", \"안수정\", \"안수빈\", \"김효정\", \"한지민\")\nFor i = 1 To 6\n'6회 반복\nrngA.Cells(i) = var(i - 1)\n'각 영역에 이름을 넣음\nNext i\nCall\nrandom_Reshuffle3(rngA)\n'입력한 이름을 섞어주는 코드 호출\nCall random_Reshuffle3(rngA)\n'확실히 하기 위해 한 번 더 섞어줌\nNext x\nNext y\nEnd Sub\n\nSub random_Reshuffle3(ByVal rngA As Range)\nDim maxNo As Long\n'선택영역 셀 개수 넣을 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nRandomize\n'랜덤 초기화\nWith rngA\n'선택영역에서\nmaxNo = .Count\n'셀 개수를 변수에 넣음\nReDim\nvarTemp(1 To maxNo)\n'배열크기 재지정\nFor Each rngC In rngA\n'선택영역 각 셀을 순환\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = rngC\n'각 셀을 배열에 넣음\nNext rngC\nFor i = maxNo To 1 Step -1\n'최대값 부터 1씩 줄여가며 반복\nr = Int(\nRnd\n() * i) + 1\n'무작위 값을 추출\n.Cells(i) = varTemp(r)\n'랜덤값을 채워감\nvarTemp(r) = varTemp(i)\n'배열 윗값을 추출된 위치에 채움\nNext i\nEnd With\nEnd Sub", "context": "1. 6명의 미화원이 작업을 함.\n2. 각 층에는 2명이 무작위로 배치됨(예, 1층 2명, 2층 2명, 3층 2명)\n3. 각 층에 4번 누적되어 작업 후 층을 이동(예, 4층 2명, 5층 2명, 6층 2명 ..........)\n아직 우리나라에 100층 넘는 건물이 없어 102층까지로 제한함.\n매크로 실행 후 결과\nOption Explicit\nSub distribute_Cleaning_Crew()\nDim rngA As Range\n'6명씩 들어갈 영역을 넣을 변수\nDim x As Integer\n'열방향 늘려갈 변수\nDim y As Long\n'행방향 늘려갈 변수\nDim var As Variant\n'6명의 이름을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.\nClear\n'기존 데이터 삭제\nFor y = 1 To 102\n'1 ~ 102층까지 ..."}
{"instruction": "Excel VBA code for: (1185) 10행씩 건너뛴 데이터끼리 재배치하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub trans_Ten_Rows_Apart()\nDim colsCnt As Integer\n'전체영역 열 개수 넣을 변수\nDim i As Long\n'정적배열 개수를 늘려갈 변수\nDim rngC As Range\n'A1 ~ A10 셀을 순환하며 넣을 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n[A1].\nEnd(2).End(2)\n.\nCurrentRegion\n.Clear\n'기존 데이터 삭제\ncolsCnt = ActiveSheet.UsedRange.\nColumns.Count\n'현재시트 사용영역 열개수를 변수에\nFor i = 1 To 10\n'10회 반복\nSet rngC = Cells(i, 1)\n'A1 ~ A10까지의 값을 개체변수에 넣음\nDo\n'다음을 실행\nCells(Rows.Count, colsCnt + 2).End(3)(2).Resize(, colsCnt) = _\nrngC.Offset(r).Resize(, colsCnt).Value\n'종단셀 윗방향 아래셀에 10행씩 건너뛴 행값을 뿌려줌\nr = r + 10\n'행을 10씩 늘려감\nLoop Until\nCells(r, 1) = \"\"\n'빈셀 나올때까지 무한 반복\nr = 0\n'재사용 위하여 초기화\nNext i\nCells(1, colsCnt + 2).Resize(, colsCnt).\nDelete\nshift:=xlUp\n'1행 삭제\nSet rngC = Nothing\n'개체변수 초기화\nEnd Sub", "context": "항상 이런 코드는 여러가지의 접근 방법이 있다. 아래는 종단셀 기능을 이용하여 10행씩 건너 뛰면서 복사하였음. 물론 배열에 넣는 셀에 다시 뿌릴 수도 있다.\n매크로 실행 전                                                   매크로 실행 후 결과\nOption Explicit\nSub trans_Ten_Rows_Apart()\nDim colsCnt As Integer\n'전체영역 열 개수 넣을 변수\nDim i As Long\n'정적배열 개수를 늘려갈 변수\nDim rngC As Range\n'A1 ~ A10 셀을 순환하며 넣을 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n[A1].\nEnd(2).End(2)\n.\nCurrentRegion\n.Clear\n'기존 데이터 삭제\ncolsCnt = ActiveSheet.UsedRange.\nColumns.Count\n'현재시트 사용..."}
{"instruction": "Excel VBA code for: (1186) 데이터통합(Consolidate) 기본코드 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub basic_Sheets_Consolidation()\nDim varTemp()\n'배열로 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngA As Range\n'각 데이터 영역을 넣을 변수\nFor i = 2 To Sheets.Count\n'2 부터 전체시트 개수만큼 반복\nSet rngA = Sheets(i).Cells(1, 1).Resize(5, 5)\n'각 시트의 데이터영역을 변수에 넣음\nReDim Preserve varTemp(1 To i - 1)\n'배열크기 재지정\nvarTemp(i - 1) = rngA.\nAddress(1, 1, xlR1C1, 1)\n'배열에 각 시트의 데이터주소를 넣음\nNext i\n[A1].\nConsolidate\nSources:=varTemp, Function:=xlSum, _\nTopRow:=True, LeftColumn:=True, CreateLinks:=False\n'제목행 있으며 A열 기준으로 통합\nSet rngA = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "이미 여러번 사용하고 있는 코드. 코드 작업 시 마다 재 타이핑 하지 않고 가져다 사용하기 위해 \"기본코드\" 카테고리에 정리하여 넣어둠.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1186) 데이터통합(Consolidate) 기본코드 1 (엑셀 VBA 매크로)\n재생\n1,581\n공유하기\n재생 (space/k)\n재생\n00:18\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:18\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:0..."}
{"instruction": "Excel VBA code for: (1187) 폴더내 모든파일/모든시트 특정영역 바꾸기 (엑셀 VBA 매크로)", "input": "", "output": "Sub replace_All_Data_In_Folder() '메인 프로시저\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim wkBk As Workbook\n'각 파일을 넣을 변수\nDim wkSht As Worksheet\n'각 시트를 넣을 변수\nDim rngAll As Range\n'검색할 영역을 넣을 변수\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n.Calculation = xlCalculationManual\n'셀계산 수동으로 전환\nWith .FileDialog(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 종료\nElse\n'파일 존재 시\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName =\nDir\n(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nSet wkBk = Workbooks.Open(strPath & fileName)\n'파일을 열고 변수에 넣음\nFor Each wkSht In wkBk.Worksheets\n'열린파일 각 시트를 순환\nSet rngAll = wkSht.\nRange(\"A1:J10\")\n'검색영역을 변수에 넣음\nCall\nreplace_Data(rngAll)\n'바꾸기 코드를 호출\nNext wkSht\nwkBk.Close True\n'파일을 저장하고 닫음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\n.Calculation = xlCalculationAutomatic\n'셀계산 자동으로 복원\nEnd With\nSet wkBk = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngAll = Nothing\nEnd Sub\n\nPrivate Sub replace_Data(ByVal rngAll As Range)\n'검색일치한 값을 바꾸는 하위 프로시저\nDim strAddr As String\n'처음 검색하여 찾은 셀의 주소 넣을 변수\nDim C As Range\n'검색하여 찾은 영역을 넣을 변수\nWith rngAll\n'검색할 영역에서\nSet C = .\nFind\n(What:=\"\n갑\n\", Lookat:=\nxlWhole\n)\n'처음 모두 일치하는 데이터를 찾아 C에 넣고\nIf Not C Is Nothing Then\n'만일 일치하는 데이터가 있으면\nstrAddr = C.Address\n'첫 일치하는 주소를 strAddr에 넣고\nDo\n'다음을 실행\nC.Interior.ColorIndex = 6\n'셀의 색을 노란색으로\nC = \"\nZZZ\n\"\n'검색 일치한 셀에 바꾸려는 값 입력\nSet C = .\nFindNext\n(C)\n'다음 일치하는 데이터를 찾아 변수에 넣고\nLoop While\nNot C Is Nothing\nEnd If\n'일치하는 데이터 없을 때까지 반복\nEnd With\nSet C = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "폴더내에 들어 있는 모든 엑셀파일, 모든 시트의 특정 영역을 검색하여 자신이 원하는 값을 찾고 검색에 일치시 이를 바꾸는 기능. 동영상에서는 A1:J10영역의 모든\n\"\n갑\n\"을 \"\nZZZ\n\"으로 수정\n하며, 구분하기 쉽도록 노란색으로 표시되도록 함. 노란색 표시(C.Interior.ColorIndex = 6 라고 된 코드)는 필요 없을 경우 주석처리 또는 그행을 삭제하면 된다. \"갑\"과 모두 일치하는 데이터만 바꾸며, 일부 일치하는 데이터도 바꾸고 싶을 경우 xlWhole 을\nxlPart\n로 바꿔주면 된다. A1:J10는 자신의 영역으로 수정.\n폴더내에 파일이 너무 많거나 파일에 이상이 있는 경우 제대로 변경되지 않고 에러가 뜨며 임시파일이 화면에 나타나는 경우가 있는데 이 때에는 임시파일을 저장하지 않고 모두 닫은 다음, 폴더내의 모든 임시파일을 삭제하고 매크로를 한 번 더 돌리면 바꿔지지 않은 파일들도 다시 바꾸기가 된다. 이 경우 정상적으로 바뀐파일은 바꿀 내용이 없어 열고 닫..."}
{"instruction": "Excel VBA code for: (1188) 폴더내 각 파일을 데이터 통합하는 기본코드 (엑셀 VBA 매크로)", "input": "", "output": "Sub open_And_Consolidate()\nConst\nrowsCnt As Integer = 3\n'데이터의 행 개수 넣을 변수\nConst colsCnt As Integer = 3\n'데이터의 열 개수 넣을 변수\nDim varTemp()\n'통합된 값을 넣을 배열 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim wkb As Workbook\n'엑셀 파일 넣을 변수\nDim r As Long\n'행 반복에 사용될 변수\nDim c As Integer\n'열 반복에 사용될 변수\nReDim\nvarTemp(1 To rowsCnt, 1 To colsCnt)\n'배열크기 재지정\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nRange(\"A1\").Resize(rowsCnt, colsCnt).ClearContents\n'기존데이터 삭제\n'----------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'----------------------------------------------\nChDir ThisWorkbook.Path\n'매크로 실행파일과 동일한 경로 기준\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'--------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'--------------------------------\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\n'----------------------------------------\n' 파일을 열고 닫으며 데이터를 가져오는 코드\n'----------------------------------------\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nSet\nwkb = Workbooks.\nOpen\n(strPath & fileName)\n'파일을 개체변수에 넣음\nFor r = 1 To rowsCnt\n'데이터 행만큼 반복\nFor c = 1 To colsCnt\n'데이터 열만큼 반복\nvarTemp(r, c) = varTemp(r, c) + wkb.ActiveSheet.Cells(r, c)\n'배열에 각 데이터를 합쳐 넣음\nNext c\nNext r\nwkb.Close\nFalse\n'각 파일을 저장하지 않고 닫음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\n[A1].Resize(rowsCnt, colsCnt) = varTemp\n'배열값을 셀에 뿌림\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "폴더내의 각 파일의 Sheet1 에 있는 데이터를 통합파일로 합쳐 합계를 구하는 기능. (물론 코드를 일부 수정 시 각 파일의 전체시트도 통합할 수 있다.).\n폴더내의 각 파일을 화면에 띄우지 않고\n데이터를 배열에 합쳐 넣음. 실제 파일을 화면에 띄우는 것보다 훨씬 빠르다. 간단하지만 손쉽게\n데이터를\n가져와 통합할 수 있다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1188) 폴더내 각 파일을 데이터 통합하는 기본코드 (엑셀 VBA 매크로)\n재생\n1,163\n공유하기\n재생 (space/k)\n재생\n00:28\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:28\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 ..."}
{"instruction": "Excel VBA code for: (1189) 폴더내 파일 열지 않고 데이터 통합 기본코드 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub get_From_Closed_Files2()\nConst rowsCnt As Integer = 3\n'데이터의 행 개수 넣을 변수\nConst colsCnt As Integer = 3\n'데이터의 열 개수 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim strAddr As String\n'각 파일의 데이터 주소 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim varTemp(1 To rowsCnt, 1 To colsCnt)\n'각 시트의 값을 넣을 배열변수\nDim r As Integer\n'행방향 늘려갈 변수\nDim c As Long\n'열방향 늘려갈 변수\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nRange(\"A1\").Resize(rowsCnt, colsCnt).ClearContents\n'기존데이터 삭제\n'----------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'----------------------------------------------\nChDir ThisWorkbook.Path\n'매크로 실행파일과 동일한 경로 기준\nWith .\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'--------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'--------------------------------\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nFor r = 1 To rowsCnt\n'행 개수만큼 반복\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nstrAddr = \"'\" & strPath & \"[\" & fileName & \"]\" & \"Sheet1\" & \"'!\" & _\nCells(r, c).\nAddress\n(, , xlR1C1)\n'지정 폴더내 각 파일의 셀주소를 변수에 넣음\nvarTemp(r, c) = varTemp(r, c) +\nExecuteExcel4Macro\n(strAddr)\n'배열에 각 파일의 값을 넣음\nNext c\nNext r\nCells(1, 1).Resize(rowsCnt, colsCnt) = varTemp\n'배열의 합계를 셀에 뿌림\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nEnd With\nEnd Sub", "context": "폴더내의 각 파일의 Sheet1 에 있는 데이터를 통합파일로 합쳐 합계를 구하는 기능. (물론 코드를 일부 수정 시 각 파일의 전체시트도 통합할 수 있다.).\n폴더내의 파일을 열지 않고 ExecuteExcel4Macro 메서드를 이용\n하여 각 파일내의 데이터를 배열에 합쳐 넣음.\n각 시트에 통합할 데이터가 적을 경우\n데이터를 상당히 빠르게 가져와 통합할 수 있다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1189) 폴더내 파일 열지 않고 데이터 통합 기본코드 1 (엑셀 VBA 매크로)\n재생\n2,233\n공유하기\n재생 (space/k)\n재생\n00:28\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:28\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (..."}
{"instruction": "Excel VBA code for: (1190) 폴더내 각 파일을 열고 통합하는 것과 파일을 열지 않고 통합하는 것의 속도비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub open_And_Consolidate()\nConst rowsCnt As Integer = 3\n'데이터의 행 개수 넣을 변수\nConst colsCnt As Integer = 3\n'데이터의 열 개수 넣을 변수\nDim varTemp()\n'통합된 값을 넣을 배열 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim r As Long\n'행 반복에 사용될 변수\nDim c As Integer\n'열 반복에 사용될 변수\nReDim varTemp(1 To rowsCnt, 1 To colsCnt)\n'배열크기 재지정\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nRange(\"A1\").Resize(rowsCnt, colsCnt).ClearContents\n'기존데이터 삭제\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nWorkbooks.\nOpen\n(strPath & fileName)\n'각 파일을 열기\nFor r = 1 To rowsCnt\n'데이터 행만큼 반복\nFor c = 1 To colsCnt\n'데이터 열만큼 반복\nvarTemp(r, c) = varTemp(r, c) + Cells(r, c)\n'배열에 각 데이터를 합쳐 넣음\nNext c\nNext r\nActiveWorkbook.\nClose\nFalse\n'각 파일을 저장하지 않고 닫음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\n[A1].Resize(rowsCnt, colsCnt) = varTemp\n'배열값을 셀에 뿌림\nEnd Sub\n\nSub get_From_Closed_Files2()\nConst rowsCnt As Integer = 3\n'데이터의 행 개수 넣을 변수\nConst colsCnt As Integer = 3\n'데이터의 열 개수 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim strAddr As String\n'각 파일의 데이터 주소 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim varTemp(1 To rowsCnt, 1 To colsCnt)\n'각 시트의 값을 넣을 배열변수\nDim r As Integer\n'행방향 늘려갈 변수\nDim c As Long\n'열방향 늘려갈 변수\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nRange(\"A1\").Resize(rowsCnt, colsCnt).ClearContents\n'기존데이터 삭제\nWith .\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nFor r = 1 To rowsCnt\n'행 개수만큼 반복\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nstrAddr = \"'\" & strPath & \"[\" & fileName & \"]\" & \"Sheet1\" & \"'!\" & _\nCells(r, c).\nAddress\n(, , xlR1C1)\n'지정 폴더내 각 파일의 셀주소를 변수에 넣음\nvarTemp(r, c) = varTemp(r, c) +\nExecuteExcel4Macro\n(strAddr)\n'배열에 각 파일의 값을 넣음\nNext c\nNext r\nCells(1, 1).Resize(rowsCnt, colsCnt) = varTemp\n'배열의 합계를 셀에 뿌림\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nEnd With\nEnd Sub", "context": "일단 제목부터가 어렵고 내용도 길다. 설명이 힘들것 같아서 혼자만 알고 있으려다가 폴더내의 많은 파일 또는 많은 데이터를 통합해야 하는 분들이 알아두시면 도움이 될 내용이어서 이를 알려드리는 것이므로 필요한 분들은 끈기를 가지고 읽어보시기를 ...\n각 년도별로 파일이 있고, 파일마다 12개의 시트가 월별로 있고, 동일한 셀 위치에 일별 데이터가 있는 경우 ..... 이를 통합해야 하는 분들이 계시다면 ... 그리고 그러한 파일이 많다면 .... 아래의 두 코드의 비교는 상당히 유용할 것이며, 어떤 경우에 어떤 코드를 사용해야 더 효율적으로 데이터를 통합할 수 있는지 판단하는데 도움이 될 것이다.\n첨부된 Data 폴더에는 50개의 데이터 파일이 있으며, 각 파일의 Sheet1에 데이터가 입력된 상태(아래는 예제이므로 1개의 시트에서 데이터를 가져와 통합하지만 코드를 일부 수정하면 모든 시트의 데이터를 가져와 통합할 수 있다.). 첨부된 각 매크로 파일을 열고 매크로 실행 시 아래 동영..."}
{"instruction": "Excel VBA code for: (1191) 지그재그로 영역을 선택하며 숫자채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub leftToright_rightToleft()\nDim bln As\nBoolean\n'방향전환에 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim c As Integer\n'열방향 늘려갈 변수\nDim cnt As Long\n'카운터로 사용할 변수\nDim y As Long\n'행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor i = 1 To 10\n'10회 반복\ny = y + 1\n'행을1씩 늘려감\nIf bln = False Then\n'만약 bln 값이 거짓이면\nFor c = 1 To 10\n'1 ~ 10까지 반복\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nCells(y, c) = cnt\n'각셀에 카운터 값을 입력\nNext c\nbln =\nTrue\n'bln 값을 참으로 변환\nElse\nFor c = 10 To 1\nStep -1\n'10 ~ 1 까지 반복\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nCells(y, c) = cnt\n'각셀에 카운터 값을 입력\nNext c\nbln =\nFalse\n'bln 값을 거짓으로 변환\nEnd If\nNext i\nEnd Sub", "context": "다양한 영역 선택의 연습은 반복구문의 숙달과 엑셀의 셀 선택 구조를 공부하는데 많은 도움이 된다. 초보때 개인적으로 가장 어려웠던 것 중의 하나가 지그재그로 셀에 값을 입력하는 것이었다. 아래와 같이 지그재그로 값을 채우는 경우는 거의 없겠지만 공부를 하여두면 향후 번갈아 가면서 데이터를 입력하는데 참고가 될 것이다.\n매크로 실행 전 (물론 화살표는 없는 것이며, 데이터가 입력되는 순서를 표시하기 위하여 화면 캡춰 후 넣은 것이다.)\n매크로 실행 후 결과 (행이 바뀔 때마다 숫자가 입력되는 방향이 전환됨)\nOption Explicit\nSub leftToright_rightToleft()\nDim bln As\nBoolean\n'방향전환에 사용할 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim c As Integer\n'열방향 늘려갈 변수\nDim cnt As Long\n'카운터로 사용할 변수\nDim y As Long\n'행을 늘려갈 변수\nApplication.ScreenUpdati..."}
{"instruction": "Excel VBA code for: (1194) 학년별 반별 과목점수 통합하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub consolidate_Same_Group3()\nDim rngC As Range\n'각 셀을 순환할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).UsedRange.Offset(1).ClearContents\n'기존 데이터 삭제\nWith Sheets(3)\n'Sheet3에서\n.\nCells.Delete\nShift:=xlUp\n'기존 (임시) 데이터 삭제\nActiveSheet.UsedRange.Copy .Cells(1, 1)\n'현재시트 Sheet3에 복사\n.Columns(1).Delete\n'이름이 들어간 열을 삭제\nWith .UsedRange\n'사용 영역에서\n.Offset(1).\nSort\nkey1\n:=.Cells(2, 1),\nkey2\n:=.Cells(2, 2), Header:=xlNo\n'학년과 반을 기준으로 오름차순 정렬\n.\nSubtotal\nGroupBy:=2, Function:=xlSum, _\nTotalList:=\nArray\n(3, 4, 5), SummaryBelowData:=True\nEnd With\n'반을 기준으로 부분합 실행\nFor Each rngC In .Columns(\"A\").\nSpecialCells(4)\n'A열의 각 공백셀을 순환\nWith Sheets(2).Cells(Rows.Count, \"A\").End(3)(2)\n'Sheet2의 A열 종단셀 윗방향 아래셀에\n.Resize(, 2) = rngC.Offset(-1).Resize(, 2).Value\n'학년, 반을 입력\n.Offset(, 2).Resize(, 3) = rngC.Offset(, 2).Resize(, 3).Value\nEnd With\n'각 과목의 반별 합계을 입력\nNext rngC\nEnd With\nWith Sheets(2)\n'Sheet2에서\n.Cells(Rows.Count, \"A\").End(3)(2).\nEntireRow.ClearContents\n'불필요하게 복사된 총계행을 삭제\n.Activate\n'Sheet2를 활성화\nEnd With\nEnd Sub", "context": "마구 섞여서 입력된 각 학년 및 반의 과목 점수를 통합하는 기능. 여러 방법이 있을 수 있지만 아래는\n정렬\n과\n부분합\n을 이용함.\n매크로 실행 전 Sheet1  (아래로 데이터가 더 있음)\n매크로 실행 전 Sheet2                                          매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub consolidate_Same_Group3()\nDim rngC As Range\n'각 셀을 순환할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).UsedRange.Offset(1).ClearContents\n'기존 데이터 삭제\nWith Sheets(3)\n'Sheet3에서\n.\nCells.Delete\nShift:=xlUp\n'기존 (임시) 데이터 삭제\nActiveSheet.UsedRange.Copy .Cells(1, 1)\n'현재시트 Sheet3에 복사\n.Columns..."}
{"instruction": "Excel VBA code for: (1195) 학년별 반별 과목점수 통합하기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub consolidate_Same_Group4()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim intG As Integer\n'학년 추출해 넣을 변수\nDim intD As Integer\n'반 추출해 넣을 변수\nDim c As Integer\n'열 늘려갈 변수\nDim r As Long\n'행 늘려갈 변수\nDim x As Integer\n'배열내 열 위치 늘려갈 변수\nDim y As Long\n'배열내 행 위치 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet\nrngAll = Range(\"B2\", Cells(Rows.Count, \"B\").End(3))\n'제목 제외한 B열 전체를 변수에 넣음\nReDim\nvarTemp(1 To 3, 1 To 9)\n'배열크기 재지정\nFor Each rngC In rngAll\n'전체영역(rngAll)의 각셀(rngC)을 순환\nintG =\nLeft\n(rngC, 1)\n'학년의 왼쪽 숫자 추출해 변수에 넣음\nintD = Left(rngC.Next, 1)\n'반의 왼쪽 숫자 추출해 변수에 넣음\nFor c = 1 To 3\n'3회 반복\nvarTemp(intG, (intD - 1) * 3 + c) = _\nvarTemp(intG, (intD - 1) * 3 + c) + rngC.Offset(, c + 1)\nNext c\n'각 과목의 합계를 배열에 축적해 넣음\nNext\nFor r = 1 To 9\n'9회 반복\nIf r\nMod\n3 = 1 Then y = y + 1\n'r을 나눈 나머지가 1일 경우\nFor c = 1 To 3\n'3회 반복\nx = x + 1\n'배열내 열 위치 늘려감\nSheets(2).Cells(r + 1, c + 2) = varTemp(y, x)\n'배열값을 셀에 뿌림\nIf x = 9 Then x = 0\n'x가 9가 되면 0으로 초기화\nNext c\nNext r\nSheets(2).\nActivate\n'활성화\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "마구 섞여서 입력된 각 학년 및 반의 과목 점수를 통합하는 기능. 여러 방법이 있을 수 있지만 아래는\n배열\n을 이용함.\n매크로 실행 전 Sheet1  (아래로 데이터가 더 있음)\n매크로 실행 전 Sheet2                                          매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub consolidate_Same_Group4()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim intG As Integer\n'학년 추출해 넣을 변수\nDim intD As Integer\n'반 추출해 넣을 변수\nDim c As Integer\n'열 늘려갈 변수\nDim r As Long\n'행 늘려갈 변수\nDim x As Integer\n'배열내 열 위치 늘려갈 변수\nDim y As Long\n'배열내 행 위치 늘..."}
{"instruction": "Excel VBA code for: (1197) 학년별 반별 과목점수 통합하기 6 (엑셀 VBA 매크로)", "input": "", "output": "Sub consolidate_Same_Group6()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nDim intG As Integer\n'학년 추출해 넣을 변수\nDim intD As Integer\n'반 추출해 넣을 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Range(\"B2\", Cells(Rows.Count, \"B\").End(3))\n'제목 제외한 B열 전체를 변수에 넣음\nWith Sheets(2)\n'Sheet2에서\n.Range(\"C2:E10\").ClearContents\n'기존 데이터 삭제\nFor Each rngC In rngAll\n'전체영역 각셀을 순환\nintG =\nLeft\n(rngC, 1)\n'학년의 왼쪽 숫자 추출해 변수에 넣음\nintD = Left(rngC.Next, 1)\n'반의 왼쪽 숫자 추출해 변수에 넣음\nFor r = 1 To 3\n'3회 반복\nWith .Cells(1, 1).\nOffset\n((intG - 1) * 3 + 1 + (intD - 1), 1 + r)\n'학년과 반에 따른 각 셀의 위치에\n.\nValue\n= .Value + rngC.Offset(, r + 1)\n'각 과목의 점수를 축적해 감\nEnd With\nNext r\nNext\n.Activate\n'활성화\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "마구 섞여서 입력된 각 학년 및 반의 과목 점수를 통합하는 기능. 여러 방법이 있을 수 있지만 아래는\nOffset\n속성을 이용함.\n매크로 실행 전 Sheet1  (아래로 데이터가 더 있음)\n매크로 실행 전 Sheet2                                          매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub consolidate_Same_Group6()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nDim intG As Integer\n'학년 추출해 넣을 변수\nDim intD As Integer\n'반 추출해 넣을 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Range(\"B2\", Cells(Rows.Count, \"B\").End(3)..."}
{"instruction": "Excel VBA code for: (1198) 학년별 반별 과목점수 통합하기 7 (엑셀 VBA 매크로)", "input": "", "output": "Sub consolidate_Same_Group7()\nDim lastRow As Long\n'마지막 행을 넣을변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim y As Long\n'행을 1씩 늘려갈 변수\nDim varTemp()\n'배열로 사용할 변수\nDim r As Long\n'배열위치 1씩 늘려갈 변수\nDim j As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).UsedRange.Offset(1).ClearContents\n'Sheet2 기존 데이터 삭제\nWith Sheets(3)\n'Sheet3에서\n.\nCells.\nDelete\nShift:=xlUp\n'기존 (임시) 데이터 삭제\nActiveSheet.UsedRange.Offset(, 1).\nCopy\n.Cells(1, 1)\n'현재시트 Sheet3 에 복사\nWith .UsedRange\n'사용 영역에서\n.Offset(1).\nSort\nkey1\n:=.Cells(2, 1),\nkey2\n:=.Cells(2, 2), Header:=xlNo\nEnd With\n'학년과 반을 기준으로 오름차순 정렬\n.Activate\n'활성화\nEnd With\nlastRow = Cells(Rows.Count, 1).End(3).\nRow\n'마지막 행을 변수에 넣음\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열개수를 변수에 넣음\ny = 1\n'1행부터 시작\nReDim\nvarTemp(1 To lastRow, 1 To colsCnt)\n'배열크기 재지정\nDo\n'다음을 실행\ny = y + 1\n'행을 1씩 늘려감\nIf Cells(y, 2) = Cells(y - 1, 2) Then\n'B열의 위아래 셀값이 같다면\nFor j = 1 To colsCnt\n'1 ~ colsCnt 만큼 반복\nIf j = 1 Or j = 2 Then\n'j가 1또는 2일 경우\nCells(r, j) = Cells(y, j)\n'학년과 반을 배열에 입력\nElse\n:\nvarTemp(r, j) = varTemp(r, j) + Cells(y, j)\n'기존 배열값에 새로운 행 값을 더함\nEnd If\nNext j\nElse\n'A열의 위아래 셀값이 다르면\nr = r + 1\n'배열위치 1씩 늘려감\nFor j = 1 To colsCnt\n'1 ~ colsCnt 만큼 반복\nvarTemp(r, j) = Cells(y, j)\n'새로운 행 값을 배열에 추가함\nNext j\nEnd If\nLoop Until\nCells(y + 1, 1) = \"\"\n'A열에 빈셀이 나올때까지 무한 반복\nSheets(2).Activate\n'Sheet2 활성화\nCells(2, 1).Resize(\nUBound\n(varTemp, 1), colsCnt) = varTemp\n'배열 값을 셀에 뿌림\nEnd Sub", "context": "마구 섞여서 입력된 각 학년 및 반의 과목 점수를 통합하는 기능. 여러 방법이 있을 수 있지만 아래는 Sheet3에 임시로 데이터 복사 후\n정렬\n과\n배열\n을 이용함.\n매크로 실행 전 Sheet1  (아래로 데이터가 더 있음)\n매크로 실행 전 Sheet2                                          매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub consolidate_Same_Group7()\nDim lastRow As Long\n'마지막 행을 넣을변수\nDim colsCnt As Integer\n'전체열의 개수 넣을 변수\nDim y As Long\n'행을 1씩 늘려갈 변수\nDim varTemp()\n'배열로 사용할 변수\nDim r As Long\n'배열위치 1씩 늘려갈 변수\nDim j As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).Us..."}
{"instruction": "Excel VBA code for: (1199) 학년별 반별 과목점수 통합하기 8 (엑셀 VBA 매크로)", "input": "", "output": "Sub consolidate_Same_Group8()\nDim r As Long\n'행(r)row 늘려갈 변수\nDim i As Long\n'동일 반의 중복개수 구할 변수\nDim rngA As Range\n'각 반의 영역을 넣을 변수\nDim rngT As Range\n'Sheet2의 각 데이터 복사영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).UsedRange.Offset(1).ClearContents\n'Sheet2 기존 데이터 삭제\nWith Sheets(3)\n'Sheet3에서\n.Cells.Delete Shift:=xlUp\n'기존 (임시) 데이터 삭제\nActiveSheet.UsedRange.Offset(, 1).Copy .Cells(1, 1)\n'현재시트 Sheet3에 복사\nWith .UsedRange\n'사용 영역에서\n.Offset(1).\nSort\nkey1\n:=.Cells(2, 1),\nkey2\n:=.Cells(2, 2), Header:=xlNo\nEnd With\n'학년과 반을 기준으로 오름차순 정렬\n.Activate\n'활성화\nEnd With\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 2) = Cells(r + 1, 2) Then\n'B열 각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nSet\nrngA = Cells(r - i, 2).Resize(i + 1, 4)\n'반이 중복되는 영역을 변수에 넣음\nSet rngT = Sheets(2).Cells(Rows.Count, \"A\").\nEnd(3)(2)\n'Sheet2 A열 종단셀 윗방향 아래셀을 변수에 넣음\nrngT = rngA.\nCells(0)\n'학년을 입력\nrngT.Next.\nConsolidate\nSources:=rngA.\nAddress\n(1, 1, xlR1C1, 1), _\nFunction:=xlSum, LeftColumn:=True\n'각 반의 영역을 통합하여 Sheet2 각 셀에 뿌림\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\nSheets(2).Activate\n'Sheet2 활성화\nEnd Sub", "context": "마구 섞여서 입력된 각 학년 및 반의 과목 점수를 통합하는 기능. 여러 방법이 있을 수 있지만 아래는 Sheet3에 임시로 데이터 복사 후\n정렬\n과\n데이터통합\n을 이용함.\n50,000행에 0.85초\n정도 소요.\n매크로 실행 전 Sheet1  (아래로 데이터가 더 있음)\n매크로 실행 전 Sheet2                                          매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub consolidate_Same_Group8()\nDim r As Long\n'행(r)row 늘려갈 변수\nDim i As Long\n'동일 반의 중복개수 구할 변수\nDim rngA As Range\n'각 반의 영역을 넣을 변수\nDim rngT As Range\n'Sheet2의 각 데이터 복사영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).UsedRange.Offset(1).Cle..."}
{"instruction": "Excel VBA code for: (1200) 연속되는 숫자있는행 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Continious_No()\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim cnt As Integer\n'카운터로 사용할 변수\nDim r As Long\n'A열 행을 늘려갈 변수\nDim y As Long\n'H열 행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n[H1].CurrentRegion.ClearContents\n'기존데이터 삭제\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nFor Each rngC In Cells(r, 1).Resize(, 6)\n'A~F열 각 셀을 순환\nIf rngC = rngC.\nNext\nThen\n'각 셀값이 오른쪽셀과 같다면\nExit For\n'For 구문 종료\nElse\n'값이 같지 않다면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nEnd If\nNext rngC\nIf cnt = 6 Then\n'카운터가 6이라면(연속숫자 없다면)\ny = y + 1\n'(H열) 행을 1씩 늘려감\nCells(y, 8).Resize(, 6) = Cells(r, 1).Resize(, 6).Value\nEnd If\n'H~M열에 A~F열의 값을 복사\ncnt = 0\n'재사용 위하여 카운터 초기화\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈 셀이 나올때까지 무한 반복\nEnd Sub", "context": "A~F열 각 행에서 연속되는 숫자가 있는 행은 삭제 후 H열 위치로 나머지 데이터를 복사하는 기능\n매크로 실행 전 (색으로 표시한 것과 같이 연속되는 숫자가 있는 행은 삭제 후 H열 위치로 옮김)\n매크로 실행 후 결과\nOption Explicit\nSub delete_Continious_No()\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim cnt As Integer\n'카운터로 사용할 변수\nDim r As Long\n'A열 행을 늘려갈 변수\nDim y As Long\n'H열 행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n[H1].CurrentRegion.ClearContents\n'기존데이터 삭제\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nFor Each rngC In Cells(r, 1).Resize(, 6)\n'A~F열 각 셀을 순환\nIf rngC = rngC.\nNext\nThen\n'각 ..."}
{"instruction": "Excel VBA code for: (1201) 6자리 숫자만 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Six_Digits_Only()\nDim rngC As Range\n'A열 각 셀을 넣을 변수\nDim varTemp\n'각 셀을 공백으로 나누어 넣을 배열변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"B\").NumberFormatLocal = \"@\"\n'B열 서식을 문자(text)로\nFor Each rngC In Columns(\"A\").SpecialCells(2)\n'A열 각 문자셀을 순환\nvarTemp =\nSplit\n(\nTrim\n(rngC), \" \")\n'A열의 연속된 공백 제거후 공백(space)기준으로 분리하여 배열에 넣음\nFor i =\nLBound\n(varTemp) To\nUBound\n(varTemp)\n'배열 개수만큼 반복\nIf\nLen\n(varTemp(i)) = 6 Then\n'각 배열요소의 길이가 6인경우\nIf\nLeft\n(varTemp(i), 1)\nLike\n\"[0-9]\"\nAnd _\nRight\n(varTemp(i), 1) Like \"[0-9]\" Then\n'제일 앞과 뒤가 숫자일 경우\nr = r + 1\n'행을 1씩 늘려감\nCells(r, 2) = varTemp(i)\n'셀에 추출한 6자리 숫자를 입력\nEnd If\nEnd If\nNext i\nNext rngC\nEnd Sub", "context": "여러 문자가 섞여 있는 상태에서 6자리 숫자만 추출하는 기능\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub extract_Six_Digits_Only()\nDim rngC As Range\n'A열 각 셀을 넣을 변수\nDim varTemp\n'각 셀을 공백으로 나누어 넣을 배열변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"B\").NumberFormatLocal = \"@\"\n'B열 서식을 문자(text)로\nFor Each rngC In Columns(\"A\").SpecialCells(2)\n'A열 각 문자셀을 순환\nvarTemp =\nSplit\n(\nTrim\n(rngC), \" \")\n'A열의 연속된 공백 제거후 공백(space)기준으로 분리하여 배열에 넣음\nFor i =\nLBound\n(varTemp) To\nUB..."}
{"instruction": "Excel VBA code for: (1202) IIf와 If Else 구문의 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub using_IIF()                                        Sub using_IF()\nDim i As Long                                              Dim i As Long\nApplication.ScreenUpdating = False               Application.ScreenUpdating = False\nFor i = 1 To 100000                                        For i = 1 To 100000\nCells(1, 1) =\nIIf\n(Cells(1, 1) = 1, 1, 3 / 10)\nIf\nCells(1, 1) = 1 Then\nNext i                                                                Cells(1, 1) = 1\nElse\n: Cells(1, 1) = 3 / 10\nEnd Sub", "context": "IIf 구문이 If Else 구문보다 속도가 떨어지므로 책에서는 아예 사용하지 말라고 한다. 그런데, 오늘 어떤 분이 Iif 구문과 관련된 질문을 하셔서 갑자기 얼마나 차이가 나는지 궁금하여 비교하여 보았더니 아주 약간의 차이가 난다. 아래에서 보는 바와 같이 If Else 구문이 IIf구문 보다는 조금 더 빠르다.\n매크로 실행 전\n반복횟수\nIIF\n를 사용한 코드\nIf Else\n를 사용한 코드\n100,000번\n2.68초\n2.56\n초\nSub using_IIF()                                        Sub using_IF()\nDim i As Long                                              Dim i As Long\nApplication.ScreenUpdating = False               Application.ScreenUpdating = False\nFor i = 1 To 100000          ..."}
{"instruction": "Excel VBA code for: (1205) 배열(Array)의 이해와 사용 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_Array1()\nDim var(1 to 3) As Integer\nvar(1) = 1 :   var(2) = 2 :    var(3) = 3\nEnd Sub", "context": "앞서 배열의 가장 기초적인 것들을 공부해 보았다. 이번에는\n1차원\n배열\n에 값을 입력하고 이를 사용하는 것을 중점적으로 공부해보도록 하겠다. 배열의 궁극적인 목표는 배열내에 입력된 값들을 가져와 사용하는 것이지만, 처음\n배열을 선언 시 배열은 비어 있으므로 먼저 자신이 원하는 데이터를 배열에 채워 넣어야 한다.\n책꽂이(배열)가 비어 있으면 책(데이터)을 읽을 수 없다. 책을 읽으려면 먼저 책을 구매하여 빈 책꽂이(배열)에 책을 보관하여 두었다가 필요할 때마다 꺼내어 읽는 것과 유사하다.\n배열\n크\n기 지정\n방법\n: 보통 두 가지 정도를 사용한다.\n가) 처음 배열변수의 선언 시 변수의 타입과 함께 배열의 크기를 미리 지정하는 방법\nDim var(1 to 3) As Integer\n나) 먼저 빈 배열을 선언만하고\nRedim\n을 이용하여 동적배열로 크기를 재지정하는 방법.\nRedim은 Re-Dimension의 약자로서 배열의 차원 즉, 크기를 재지정 한다는 의미이다.\nDim var (또는 D..."}
{"instruction": "Excel VBA code for: (1206) 배열(Array)의 이해와 사용 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub array_For_Next()\nDim var()\nDim i As Long\nReDim var(1 To 100)\n'배열크기 재지정\nFor i = 1 To 100\n'100회 반복\nvar(i)\n= Cells(i, 1)\n'A열의 셀값을 배열에 넣음\nNext i\nFor i = 1 To 100\n'100회 반복\nCells(i, 3) =\nvar(i)\n'배열값을 C열에 뿌려줌\nNext i\nEnd Sub", "context": "앞서 1차원 배열에 값을 하나씩 입력하고 이를 꺼내어 사용하는 것을 공부해 보았다. 그런데, 앞서 공부한 것은 배열에 겨우 3개의 값을 넣었다. 만일 더 많은 데이터를 1차원 배열에 넣어야 한다면 어떻게 해야할까?\n배열에\narray 함수를 이용한 값의 입력\n: 엑셀 시트의 제목(또는 1 ~ 100까지의 숫자)을 입력하거나 할 때에는 배열크기를 지정하지 않고 array 함수를 이용하여 아래와 같이 하면 된다.\nDim var As Variant\n'\n배열크기 지정없이\n배열만 선언\nvar =\nArray\n(\"열1\", \"열2\", \"열3\", \"열4\", \"열5\", \"열6\")    '배열에 array내의 값을 입력\nCells(1, 1).Resize(, 6) = var                                   '셀에 배열값을 뿌려줌\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1206) 배열(Array)의 이해와 사용 3 (엑셀 VBA 매..."}
{"instruction": "Excel VBA code for: (1208) 배열(Array)의 이해와 사용 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub array_For_Next()\nDim var(1 To 5, 1 To 3)\n, r As Long, c As Integer\n'변수들의 선언\nFor\nr = 1 To 5\nFor\nc = 1 To 3\nvar(r, c) = Cells(\nr, c\n)\nNext\nc\nNext\nr\nEnd Sub\n\nSub array_For_Next()\nDim var(1 To 5, 1 To 3), r As Long, c As Integer\n'변수들의 선언\nFor r = 1 To 5\nFor c = 1 To 3\nvar(r, c) = Cells(r\n+ 4\n, c\n+ 5\n)\nNext c\nNext r\nEnd Sub\n\nSub array_For_Next()\nDim var(1 To 5, 1 To 3)\n, r As Long, c As Integer\n'변수들의 선언\nFor r = 1 To 5\n'A1:C5 영역의 값을 배열에 넣는 코드\nFor c = 1 To 3\nvar(r, c) = Cells(r, c)\nNext c\nNext r\nFor r = 1 To 5\n'배열내 값을 F5:H9 영역에 뿌려주는 코드\nFor c = 1 To 3\nCells(r\n+ 4\n, c\n+ 5\n) = var(r, c)\nNext c\nNext r\nEnd Sub\n\nSub array_For_Next()\nDim var(1 To 5, 1 To 3)\n, r As Long, c As Integer\n'변수들의 선언\nFor r = 1 To 5\n'A1:C5 영역의 값을 배열에 넣는 코드\nFor c = 1 To 3\nvar(r, c) = Cells(r, c)\nNext c\nNext r\nFor\nc\n= 1 To\n3\n'배열내 값을 F5:H9 영역에 뿌려주는 코드\nFor\nr\n= 1 To\n5\nCells(r + 4, c + 5) = var(r, c)\nNext\nr\nNext\nc\nEnd Sub\n\nSub fill_and_Spread()\nDim var(4, 2)\nDim r As Long\nDim c As Long\nFor r =\nLBound\n(var, 1) To\nUBound\n(var, 1)\nFor c =\nLBound\n(var, 2) To\nUBound\n(var, 2)\nvar(r, c) = Cells(r + 1, c + 1)\nNext c\nNext r\nRange(\"E1:G5\") = var\nEnd Sub", "context": "이번에는\n2차원 정적배열\n에 대해서 설명을 한다. 2차원 정적배열은 그나마 2차원 동적배열에 비하여 조금 쉽다. 왜냐하면 2차원 정적배열은 배열선언 시 크기가 고정되기 때문이다.\n2차원 정적배열의\n선언(declaration)\n: 앞서 설명한 바와 같이 배열은 \"선언\"을 하여 생성한다. 아래와 같은 선언으로 5행 3열 크기의 정적배열이 생성된다.\nDim var(1 To 5, 1 To 3)                        ' 배열의 선언\n또는 Dim var(1 To 5, 1 To 3) As Variant\n위의 경우는 배열에 데이터를 넣고, 이 데이터를 A1:C5 영역(또는 D5:H9 등과 같은\n5\n개의 행\n,\n3개의 열\n을 가진 영역)에 데이터를 되돌려 뿌려줄 때 사용할 수 있다.\n정적배열의\n초기화\n(reset) :\nErase\nvar\n라는 한 줄의 명령으로 배열은 초기화 된다. 동적배열의 초기화도 마찬가지 방법을 사용.\nErase var, varData, varR   : 여러개..."}
{"instruction": "Excel VBA code for: (1209) 배열(Array)의 이해와 사용 6 (엑셀 VBA 매크로)", "input": "", "output": "Sub dynamic_2D_Array()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim var()\n'동적배열의 선언\nDim r As Long\n'배열크기 늘려갈 변수\nDim y As Long\n'행방향 늘려갈 변수\nFor Each rngC In Range(\"A1\", Cells(1, Columns.Count).End(1))\n'1행의 각 셀을 순환\nIf rngC\nMod\n2 = 1 Then\n'셀 값을 나눈 나머지가 1, 즉 홀수면\nr = r + 1\n'배열크기 1씩 늘려감\nReDim\nPreserve\nvar(1 To 5,\n1 To r\n)\n'동적배열 기존값 유지하며 크기 재지정\nFor y = 1 To 5\n'행개수(5) 만큼 반복\nvar(y, r) = rngC.Offset(y - 1)\n'배열에 각 셀의 열값을 넣음\nNext y\nEnd If\nNext rngC\n[A7].Resize(\nUBound\n(var,\n1\n),\nUBound\n(var,\n2\n)) = var\n'배열값 셀에 뿌림\nEnd Sub", "context": "이번에는\n2차원 동적배열\n에 대해서 파고들어 보자.\n동적배열은 ReDim과 함께 사용\n한다. ReDim은 Re(다시, 재(再)) + Dimension(차원)을 의미하므로 차원을 재정의를 의미하여, 배열의 크기를 재지정 한다고 이해하면 되겠다. 홀로 VBA를 독학하면서 나를 제일 괴롭혔던 녀석중의 하나가 2차원 동적배열이다. 2차원 배열은 \"배열이름(\n1\n차원\n, 2차원)\"의 구조를 갖는다. 당시 차원(dimension)에 대한 확실한 이해가 부족하여 어느 때는 되고, 가끔은 에러가 발생하고 하여 참 많이 헤매었다.\n동적배열을 사용하는 이유\n: 정적배열이 더 쉬우니 요즘 메모리도 커졌는데 그냥 무조건 2차원 정적배열을 사용하면 되지 뭐하러 머리 아프게 2차원 동적배열을 사용하는 것일까? 2차원 정적배열을 아래와 같이 전체 시트크기로 선언하여 사용하면 편할텐데 ...\nRedim var(1 to 1046576, 1 to 16384)\n또는 Redim var(1 to 1046576, 1 to..."}
{"instruction": "Excel VBA code for: (1210) 배열(Array)의 이해와 사용 7 (엑셀 VBA 매크로)", "input": "", "output": "Sub dynamic_2D_Array2()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim var()\n'배열의 선언\nDim r As Long\n'배열크기 늘려갈 변수\nDim y As Long\n'열방향 늘려갈 변수\nFor Each rngC In Range(\"A1\",\nCells(Rows.Count, \"A\").End(3)\n)\n'1열의 각 셀을 순환\nIf rngC Mod 2 = 1 Then\n'셀 값을 나눈 나머지가 1, 즉 홀수면\nr = r + 1\n'배열크기 1씩 늘려감\nReDim Preserve var(1 To 3, 1 To r)\n'배열크기 재지정\nFor y = 1 To\n3\n'열개수(3) 만큼 반복\nvar(y, r) = rngC.Offset\n(, y - 1)\n'배열에 각 셀의 행값을 넣음\nNext y\nEnd If\nNext rngC\n[E1]\n.Resize(UBound(var,\n2\n), UBound(var,\n1\n)) = _\nApplication.\nTranspo\ns\ne\n(var)\n'배열값 셀에 뿌림\nEnd Sub", "context": "이번에는 위에서 아래로 (행방향으로) 늘어나는 데이터를\n2차원 동적배열\n에 넣었다가\nTranspose\n즉, 행열변환을 시켜서 셀에 뿌려주는 기능에 대해서 공부해본다. 다음에 공부할 다차원 배열보다는 그래도 쉽지만, 초보님들에게는 백두산 만큼의 높이로 다가올 내용이며, 솔직히 초보님들은 앞서 강의한 내용들에 지쳐 벌써 나가 떨어졌을 것으로 생각된다. 그래도, 꾹참고 여기까지 무사히 따라 오신 분들이 몇 분은 계실것으로 상상하며 설명을 계속한다.\n7. 데이터가 위에서 아래로 (\n행방향\n으로) 늘어나는 경우 : 아래 그림에서 보는 바와 같이 홀 수로 시작\n하는 각 행의 데이터를 2차원 동적배열에 넣었다가 이를 E1셀 영역에 뿌려주려고 함.\n매크로 실행 전                                                원하는 매크로 실행 후 결과\n\"이거 ... 앞에 거랑 비슷한거 아닌가?\" 라는 생각을 하는 분들이 있을 수 있다. 맞다. 비슷해 보인다. 그러니까 그냥 ..."}
{"instruction": "Excel VBA code for: (1211) 배열(Array)의 이해와 사용 8 (엑셀 VBA 매크로)", "input": "", "output": "Sub multi_Dimensional_Array()\nDim var() As Long\n'배열로 사용할 변수\nDim s As Long\n'시트(s)heet 의 개수 늘려갈 변수\nDim c As Long\n'열(c)olumn 방향 늘려갈 변수\nDim r As Long\n'행(r)ow 방향 늘려갈변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim lngU As Long\n'각 시트의 동일한 셀위치를 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nReDim\nvar(1 To 3, 1 To 4, 1 To 5)\n'3차원 정적배열의 크기를 재지정\nFor s\n= 2 To Sheets.Count\n'Sum 시트 제외한 2 ~ 마지막 시트까지 반복\nFor r\n= 1 To 3\n'행방향 5회 반복\nFor c\n= 1 To 4\n'열방향 3회 반복\nvar(r, c, s - 1) = Sheets(s).Cells(r, c)\n'각 시트의 셀값을 배열에 넣음\nNext\nc\nNext\nr\nNext\ns\nFor Each rngC In Range(\"A1:D3\")\n'A1:D3셀의 각 셀을 순환\nFor s = 1 To 4\n'배열의 1차원 개수만큼 반복\nlngU = lngU + var(rngC.\nRow\n, rngC.\nColumn\n, s)\n'배열내 동일 셀위치를 합쳐감\nNext s\nrngC = lngU\n'각 셀에 합쳐진 값을 넣음\nlngU = 0\n'재사용 위하여 초기화\nNext rngC\nEnd Sub\n\nSub extract_Column()\nDim var1()\n'A1:J10 영역을 넣을 배열변수\nDim var2()\n'var1에서 특정열 추출해 넣을 배열변수\nvar1 = Range(\"A1:J10\")\n'배열에 A1:J10 영역을 넣음\nvar2 = Application.Index(var1, ,\n2\n)\n'index 함수를 이용 var1 배열에서 2번째 열을 추출하여 var2 배열에 넣음\n[J12].Resize(UBound(var2)) = var2\n'var2 배열값을 셀에 뿌림\nEnd Sub", "context": "시트2 ~ 시트5에 5행 3열로 입력된 데이터의 합계를 제일 앞에 있는 Sum 시트에 구하는 기능을\n3차원 배열\n에 넣어서 구하는 기능.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1211) 배열(Array)의 이해와 사용 8 (엑셀 VBA 매크로)\n재생\n1,944\n공유하기\n재생 (space/k)\n재생\n00:30\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:30\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의..."}
{"instruction": "Excel VBA code for: (1212) C열과 E열에 데이터 있는 행만 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Eul_Jung()\nDim colsCnt As Integer\n'전체 열개수를 변수에 넣음\nDim rngAll As Range\n'A열 전체영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp()\n'전체 데이터를 넣을 배열변수\nDim r As Long\n'배열크기 늘려갈 변수\nDim y As Long\n'열방향 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.\nClearContents\n'기존 데이터 삭제\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'열개수 변수에 넣음\nSet\nrngAll = Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'A열 전체영역을 변수에 넣음\nFor Each rngC In rngAll.Offset(, 2)\n'C열의 각 셀을 순환\nIf rngC = \"\"\nAnd\nrngC(1, 3) = \"\" Then\n'C열과 E열이 빈셀이라면\nr = r + 1\n'배열크기 1씩 늘려감\nReDim Preserve\nvarTemp(1 To colsCnt, 1 To r)\n'배열크기 재지정\nFor y = 1 To colsCnt\n'열개수 만큼 반복\nvarTemp(y, r) = rngC.Offset(, y - 3)\n'배열에 각 행의 각 셀값을 넣음\nNext y\nEnd If\nNext rngC\nRange(\"A1\", Cells(1, Columns.Count).End(1)).\nCopy\n.Cells(1, 1)\n'제목행 Sheet2에 복사\n.[A2].Resize(\nUBound\n(varTemp, 2), UBound(varTemp, 1)) = _\nApplication.\nTranspose\n(varTemp)\n'배열값 Sheet2 A2셀에 뿌림\n.Columns.AutoFit\n'열너비 자동맞춤\n.Activate\n'활성화\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "이름이 \"을돌\" 또는 \"정돌\"인 열에 데이터가 있을 경우 그 전체 행을 삭제하는 기능. (행 전체를 삭제하면 시간이 많이 소요되므로, \"을돌\"과 \"정돌\"이 빈셀인 행들만을 배열에 넣고 이를 Sheet2에 뿌림. 참고로\n5만행에 1.9초\n정도 소요)\n매크로 실행 전 (Sheet2는 비어 있는 상태)                    매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub delete_Eul_Jung()\nDim colsCnt As Integer\n'전체 열개수를 변수에 넣음\nDim rngAll As Range\n'A열 전체영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp()\n'전체 데이터를 넣을 배열변수\nDim r As Long\n'배열크기 늘려갈 변수\nDim y As Long\n'열방향 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'..."}
{"instruction": "Excel VBA code for: (1214) Offset 약식코드와 정식코드의 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub short_Form_Offset()                         Sub full_Form_Offset()\nDim r As Long                                        Dim r As Long\nApplication.ScreenUpdating = False         Application.ScreenUpdating = False\nFor r = 1 To 1000000                                For r = 1 To 1000000\nCells(1, 1).Offset\n(r)\n= r                            Cells(1, 1).Offset\n(r, 0)\n= r\nNext r                                                    Next r\nEnd Sub", "context": "yi_sh 아이디를 가진 님이 질문을 하셔서 답변을 하고보니 문득 궁금해져서 Offset의 약식코드와 정식코드의 속도를 비교해 보았다.\nOffset 약식코드                 Offset 정식코드\n아래로 한 셀이동:             Offset(1)                         Offset(1, 0)\n위로 한 셀이동 :               Offset(-1)                       Offset(-1, 0)\n오른쪽으로 한 셀이동 :      Offset(, 1)                       Offset(0, 1)\n왼쪽으로 한 셀이동 :         Offset(, -1)                     Offset(0, -1)\n서로 비슷하거나 또는 약식코드가 약간이라도 더 빠를 것이라고 생각하였으나 내 생각과는 반대로 정식코드를 사용하는 것이 아래와 같이 약간 더 빠르다. 여러번 비교를 해보았는데 서로 거의 비슷한 시..."}
{"instruction": "Excel VBA code for: (1215) 셀병합 영역을 단일셀로 / 단일셀을 셀병합 영역으로 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_To_From_MergeCells()\nDim rngSel As Range\n'선택영역 전체를 넣을 변수\nDim rowsCnt As Long\n'전체영역 행개수 넣을 변수\nDim colsCnt As Integer\n'전체영역 열 개수 넣을 변수\nDim varTemp()\n'2차원 정적배열로 사용할 변수\nDim r As Long\n'행방향 늘려갈 변수\nDim c As Long\n'열방향 늘려갈 변수\nOn Error\nResume Next\n'에러 발생해도 중단 없이 다음 코드 진행\nSet rngSel =\nApplication.InputBox\n(\"마우스로 복사될 위치를 선택하시오!\", Type:=8)\n'입력창에서 선택한 영역을 변수에 넣음\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error\nGoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Selection\n'선택 영역에서\nrowsCnt = .Rows.Count\n'선택영역 행 개수를 변수에\ncolsCnt = .Columns.Count\n'선택영역 열 개수를 변수에\nReDim\nvarTemp(1 To rowsCnt, 1 To colsCnt)\n'배열 크기 재지정\nFor r = 1 To rowsCnt\n'전체영역 행 개수만큼 반복\nFor c = 1 To colsCnt\n'전체영역 열 개수만큼 반복\nvarTemp(r, c) = .Cells(1).\nOffset\n(r - 1, c - 1)\n'배열에 선택영역의 값을 입력\nNext c\nNext r\nEnd With\nFor r = 1 To rowsCnt\n'배열의 행 개수만큼 반복\nFor c = 1 To colsCnt\n'배열의 열 개수만큼 반복\nrngSel.Offset(r - 1, c - 1) = varTemp(r, c)\n'선택영역에 배열의 값을 입력\nNext c\nNext r\nEnd Sub", "context": "셀병합 영역을 단일셀로 / 단일셀을 셀병합 영역으로 복사하는 기능으로서 아래 동영상과 같이 규칙적인 영역에는 잘 되는 편이다. 하지만\n불규칙하게 셀병합된 셀에서는 적용되지 않으므로\n빈 시트에 연습을 하여보고 자신이 원하는 기능이면 응용하여 사용하시기를 ...\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1215) 셀병합 영역을 단일셀로 / 단일셀을 셀병합 영역으로 복사하기 (엑셀 VBA 매크로)\n재생\n6,208\n공유하기\n재생 (space/k)\n재생\n00:39\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:39\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 ..."}
{"instruction": "Excel VBA code for: (1218) 종단셀(ctrl + 방향키) 윗방향의 위치에 따른 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub from_Mid_Row()                                  Sub from_Bottom_Row()\nDim r As Long                                            Dim r As Long\nApplication.ScreenUpdating = False             Application.ScreenUpdating = False\nFor r = 1 To 100000                                     For r = 1 To 100000\nCells(\nRows.Count, \"A\"\n).End(3) = 1               Cells(\n65536, \"A\"\n).End(3) = 1\nNext r                                                       Next r\nEnd Sub", "context": "빈 시트에서 종단셀(Ctrl + 방향키) 윗방향을 중간행에서 실행하는 것과 마지막행에서 실행하는 것의 시간차이를 비교하여 보았다. 100,000행에 0.1초 차이면 큰 차이는 아니지만 역시 예상한 대로 마지막행 보다는 중간행에서 종단셀 윗방향을 실행하는 것이 약간 빨랐다. 요건 당연한 것 같다.\n﻿\n반복횟수\n마지막행\n에서의 종단셀 윗방향\n65536행\n에서의 종단셀 윗방향\n100,000번\n2.98초\n2.87\n초\nSub from_Mid_Row()                                  Sub from_Bottom_Row()\nDim r As Long                                            Dim r As Long\nApplication.ScreenUpdating = False             Application.ScreenUpdating = False\nFor r = 1 To 100000                       ..."}
{"instruction": "Excel VBA code for: (1219) 마지막 열의 우측에 1개의 빈열 유지하기 (엑셀 VBA 매크로)", "input": "", "output": "Private Sub Worksheet_Change\n(ByVal Target As Range)\n'메인 프로시저\nDim rngT As Range\n'\"합계\"셀 영역을 넣을 변수\nDim rngAll As Range\n'전체 영역을 넣을 변수\nIf Target.Count > 1 Then Exit Sub\n'1개 이상의 셀을 선택시 매크로 종료\nIf Target.Column > ActiveSheet.UsedRange.Columns.Count Then Exit Sub\n'합계 우측열에 값 삽입/삭제 시 매크로 종료\nApplication\n.EnableEvents = False\n'이벤트 트리거링 기능을 비활성화\nSet rngT = Cells(3, Target.Column + 1)\n'\"합계\"셀 영역을 변수에 넣음\nIf rngT = \"합  계\" Then\n'rngT가 합계 셀이라면\nWith rngT\n.\nEntireColumn.Insert\n'오른쪽에 빈 열을 추가\n.Offset(, -1).\nNumberFormatLocal\n= \"m/d\"\n'셀의 서식을 \"월/일\"로 설정\n.Offset(, -1) = Cells(3, Target.Column) + 1\n'기존날짜 + 1을 셀에 입력\nEnd With\nSet rngAll = Range(Cells(4, \"B\"), Cells(53, Target.Column + 1))\n'전체 영역을 변수에 넣음\nCall\ndraw_Borders(rngAll)\n'테두리 그리는 하위 프로시저 호출\nEnd If\nIf\nWorksheetFunction.CountA\n(Range(Cells(4, Target.Column), _\nCells(53, Target.Column + 1))) = 0 Then\n'만일 값을 입력하는 열과 우측열에 값이 없으면\nColumns(Target.Column + 1).Delete\n'값을 입력하는 셀의 우측열을 삭제\nSet rngAll = Range(Cells(4, \"B\"), Cells(53, Target.Column))\n'전체 영역을 변수에 넣음\nCall\ndraw_Borders(rngAll)\n'테두리 그리는 하위 프로시저 호출\nEnd If\nSet rngT = Nothing\n'개체변수 초기화(메모리 비우기)\nApplication.EnableEvents = True\n'이벤트 트리거링 기능을 활성화\nEnd Sub\n\nPrivate Sub draw_Borders\n(rngAll As Range)\n'외곽 테두리 그리는 하위 프로시저\nDim i As Integer\n'반복구문에 사용할 변수\nWith rngAll\n'전체 영역에서\n.\nBorders.LineStyle = 1\n'테두리를 가는 선으로 넣음\nFor i = 7 To 10\n'7 ~ 10까지 반복\n.Borders(i).\nWeight\n=\nxlThick\n'바깥쪽에 굵은 테두리\n.Borders(i).\nColorIndex\n= 16\n'테두리 색을 회색으로\nNext i\nEnd With\nEnd Sub", "context": "값이 있는 제일 오른쪽 열과 합계열 사이에 항상 1개의 빈 열을 유지하는 기능. 질문하신 분에게 뭐하러 이런 쓸데 없는 기능을 꼭 매크로를 사용하시려고 하냐고 물었더니 주변의 컴맹들 때문이란다. 나와 비슷한 상황이신가 보다 .....^^\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1219) 마지막 열의 우측에 1개의 빈열 유지하기 (엑셀 VBA 매크로)\n재생\n486\n재생 (space/k)\n재생\n00:21\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:21\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화..."}
{"instruction": "Excel VBA code for: (1220) 해당 열에서 가까운 위아래 숫자의 평균 구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Nearst_Average()\nDim c As Integer\n'전체 열(c)olumn 개수 넣을 변수\nDim y As Long\n'전체 선택영역의 열 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'0의 중복(i)teration 개수 구할 변수\nDim rngA As Range\n'각 0이 있는 구역(A)rea를 넣을 변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim sngDiff As Single\n'평균차이 값을 계산해 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Selection\n'전체 선택영역에서\nIf .\nCount\n= 1 Then\n'선택영역이 1개의 셀이면\nMsgBox\n\"1개의 셀만선택하여 종료합니다.\"\n'메시지 출력\nEnd If\nFor c = 1 To .\nColumns.Count\n'전체 선택영역 열 개수만큼 반복\nr = 1\n'1행은 건너뜀\nFor y = 1 To .\nRows.Count\n'전체 선택영역 행 개수만큼 반복\nr = r + 1\n'행을 1씩 증가\nIf .Cells(r, c) = 0 Then\n'각 셀값이 0일 경우\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀0이 아닐 경우\nIf i <> 0 Then\n'중복 개수가 0이 아니면\nSet\nrngA = .Cells(r - i, c).Resize(i)\n'각 0 구역을 변수에 넣음\nsngDiff =\n(.Cells(r, c) - .Cells(r - i - 1, c)) / 2\n'평균차이 값을 계산하여 변수에 넣음\nFor Each rngC In rngA\n'각 0 구역의 각 셀을 순환\nrngC = .Cells(r - i - 1, c) + sngDiff\n'각 셀에 값을 입력\nNext rngC\ni = 0\n'재사용 위하여 초기화\nsngDiff = 0\n'재사용 위하여 초기화\nEnd If\nEnd If\nNext y\ni = 0\n'재사용 위하여 초기화\nr = 0\n'재사용 위하여 초기화\nSet rngA = Nothing\n'개체변수 초기화(메모리 비우기)\nNext c\nEnd With\nEnd Sub", "context": "제목이 좀 왠지 어정쩡하다. 아래 그림에서 각 공백 구간의 값을 채우는 것으로써 공백 구간의 바로 위아래 두 셀의 평균값으로 채우는 것. 먼저 영역을 선택하고 매크로를 실행한다. 아래의 색깔은 단지 값이 채워지는 영역의 구분을 위해 넣은 것임.\n매크로 실행 전 영역을 선택한 모습                        매크로 실행 후 결과\nB열의 경우,\n233과 205 사이 B4:B5 구역의 경우 ... 233 + (205 - 233) / 2 = 219\n205와 250 사이에 있는 B7 셀의 경우 ... 205 + (250 - 205) / 2 = 227.5     ...............\nOption Explicit\nSub find_Nearst_Average()\nDim c As Integer\n'전체 열(c)olumn 개수 넣을 변수\nDim y As Long\n'전체 선택영역의 열 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'0의 ..."}
{"instruction": "Excel VBA code for: (1221) 각 셀에 하나씩 넣는 것과 배열에 넣어 한 번에 뿌리는 것의 속도 비교(엑셀 VBA 매크로)", "input": "", "output": "Sub direct_Each_Filling()                       Sub fill_Through_Array_At_Once()\nDim rowsCnt As Long                           Dim rowsCnt As Long\nDim colsCnt As Integer                          Dim colsCnt As Integer\nDim r As Long                                      Dim r As Long\nDim c As Integer                                   Dim c As Integer\nDim\nvar()\nApplication.ScreenUpdating = False         Application.ScreenUpdating = False\nrowsCnt = 10000                                    rowsCnt = 10000\ncolsCnt = 10                                         colsCnt = 10\nFor r = 1 To rowsCnt                              For r = 1 To rowsCnt\nFor c = 1 To colsCnt                              For c = 1 To colsCnt\nCells(r, c)\n= Cells(r, c) + 1\nvar\n(r, c)\n= Cells(r, c) + 1\nNext c                                                  Next c\nNext r                                                   Next r\nCells(1, 1).Resize(UBound(var, 1), _\nUBound(var, 2)) = var\nEnd Sub", "context": "아래의 두 코드는 A1:J10000 영역의 각 셀에 각기 1씩 더하여 주는 코드로서 동일한 기능을 한다. 왼쪽의 코드는 각 셀마다 하나씩 1씩 더하여 넣는 방식을 사용하였고, 오른쪽의 코드는 각 셀마다 1씩 더한 값을 배열에 넣고 나중에 배열의 모든 값을 한 번에 셀에 뿌려주는 방식을 취하였다.\n매크로 실행 전 (A1:J10000 영역까지 값이 입력되어 있음)\n매크로 실행 후 결과 (각 셀의 값이 1씩 늘어난 모습)\n반복횟수                   각셀에\n하나씩 입력\n배열에 넣었다\n한 번에 뿌리기\n100,000번\n2.45초\n0.42\n초\nSub direct_Each_Filling()                       Sub fill_Through_Array_At_Once()\nDim rowsCnt As Long                           Dim rowsCnt As Long\nDim colsCnt As Integer                       ..."}
{"instruction": "Excel VBA code for: (1222) 월(月)이 바뀔때마다 행삽입 후 순번 재지정 (엑셀 VBA 매크로)", "input": "", "output": "Sub blank_Every_Month()\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim varTemp()\n'동적배열로 사용할 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 월(月) 중복개수 구할 변수\nDim cnt As Long\n'순번매길 카운터로 사용할 변수\nDim rngA As Range\n'중복 구역을 넣을 변수\nDim y As Long\n'중복구역 행 개수만큼 반복할 변수\nDim a As Long\n'배열크기 늘려갈 변수\nDim x As Integer\n'2 ~ 열개수 만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).UsedRange.Clear\n'Sheet2의 기존 데이터 삭제\ncolsCnt = Cells(1, Columns.Count).End(1).Column\n'전체 열개수를 변수에 넣음\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nIf\nMonth\n(Cells(r, 2)) = Month(Cells(r + 1, 2)) Then\n'B열 각 셀의 위아래 월(月)이 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nSet rngA = Cells(r - i, 1).Resize(i + 1, colsCnt)\n'중복 구역을 변수에 넣음\nFor y = 1 To rngA.Rows.Count\n'중복구역 행 개수만큼 반복\na = a + 1\n'배열 행을 1씩 늘려감\nReDim Preserve\nvarTemp(1 To colsCnt, 1 To a)\n'배열크기 재지정\nIf y = 1 Then\n'y = 1 이면, 즉 중복구역 첫행이면\nvarTemp(1, a) = cnt\n'배열에 순번(cnt)을 입력\nEnd If\nFor x = 2 To colsCnt\n'2 ~ 열개수만큼 반복\nvarTemp(x, a) = rngA.Cells(y, x)\n'배열에 날짜와 이름을 입력\nNext x\nNext y\na = a + 1\n'배열크기 1 늘려감(공백행 넣기 위해)\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nWith Sheets(2)\n'Sheet2에서\n[A1].Resize(, colsCnt).\nCopy\n.[A1]\n'제목행 복사\n.Columns(\"B\").\nNumberFormatLocal\n= \"yyyy-mm-dd\"\n'B열 서식을 날짜로\n.Cells(2, 1).Resize(\nUBound\n(varTemp, 2), _\nUBound(varTemp, 1)) = Application.\nTranspose\n(varTemp)\n'배열 값을 Sheet2에 뿌림\n.Columns.AutoFit\n'열너비 자동맞춤\n.UsedRange.Borders.LineStyle = 1\n'사용영역 전체에 외곽선 그리기\n.Activate\n'활성화\nEnd With\nSet rngA = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "B열에서 월(月)이 바뀔 때마다 빈행을 1개씩 삽입하고, A열의 순번은 그 월의 첫 번째 행에만 순번을 붙여가는 기능. 전체 생성될 행의 개수를 정할 수 없는 상황이므로 동적배열에 넣어 행열변환(Transpose)를 시켰음. Transpose는 정수형(2바이트)으로 65536개 까지만 사용할 수 있으므로 65536행을 넘는 경우에는 정적배열에 넣어야한다. 아래 예제는 30,000행 데이터의 경우 약 1.67초 정도가 소요됨.\n매크로 실행 전 (Sheet2는 비어 있는 상태)                  매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub blank_Every_Month()\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim varTemp()\n'동적배열로 사용할 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 월(月) 중복개수 구할 변수\nDim cnt As Long\n'순번매길 카운터로..."}
{"instruction": "Excel VBA code for: (1223) MSO Image 생성코드 (엑셀 VBA 매크로)", "input": "", "output": "Private Sub cbLargeIcons_Click()\nCall\nUpdateImages\nEnd Sub\n\nSub UpdateImages()\n'   Uses CommandButtons rather than Image controls because\n'   the image quality is better on a CommandButton\nDim i As Long, Size As Long\nDim ImageName As String\nIf cbLargeIcons = True Then Size = 32 Else Size = 16\nFor i = 1 To 50\nImageName = ActiveCell.Offset(i - 1, 0).Value\nIf ImageName = \"\" Then\nActiveSheet.\nOLEObjects\n(i).\nObject\n.\nPicture\n= Nothing\n'기존 그림 삭제\nActiveSheet.OLEObjects(i).Object.Caption = \"\"\n'기존 이미지 번호 삭제\nElse\nActiveSheet.OLEObjects(i).Object.Picture = _\nApplication.CommandBars.\nGetImageMso\n(ImageName, Size, Size)\n'MSO 이미지 생성\nActiveSheet.OLEObjects(i).Object.Caption = ActiveCell.Row + i - 1\n'이미지 번호 넣기\nEnd If\nNext i\nEnd Sub", "context": "위와 같이 리본 메뉴에 사용자정의 tab메뉴를 만들 때 참고할\nMSO\n(MicroSoft Object)\nImage\n를 생성하는 코드. VBA의 거목 John Walkenbach님의 코드이다. (지난 이틀 동안 아래와 같은 나만의 메뉴 생성을 위한 내용을 공부하였다. 뭐든 그렇지만, 꽤 어려울줄 알았는데 알고보니 별로 어렵지도 않다. ^^   물론 제대로 하려면 한참 공부를 해야겠지만 위와 같이 자신만의 메뉴를 만들어 버튼에 매크로를 연결하는 정도라면 난이도가 높진 않다.)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1223) MSO Image 생성코드 (엑셀 VBA 매크로)\n재생\n2,592\n공유하기\n재생 (space/k)\n재생\n00:25\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:25\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n..."}
{"instruction": "Excel VBA code for: (1224) 셀병합된 빈셀만 색으로 채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_BlankCells_In_Color()\nDim r As Long\n'행 늘려갈 변수\nDim rngM As Range\n'셀병합 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nIf Cells(r, 1) = \"\" Then\n'셀이 비어 있다면\nSet rngM = Cells(r, 1).\nMergeArea\n'빈셀의 병합영역을 변수에 넣음\nIf\nApplication.Count\n(rngM) = 0 Then\n'병합영역이 비어 있다면\nrngM.Interior.ColorIndex = 15\n'셀을 회색으로 칠함\nEnd If\nEnd If\nLoop Until\nCells(r + 1, 1).\nMergeCells\n=\nFalse\n'병합안된 셀이 나올때까지 무한 반복\nSet rngM = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "아래와 같은 경우 F5 (또는 ctrl + g) 키를 누르고 바로가기를 이용하여 빈셀(Blanks)만을 선택하려고 하여도 셀병합으로 인하여 빈셀만 선택되지 않는다. 아래의 코드는 셀병합된 영역의 빈셀만 색으로 채우는 기능.\n매크로 실행 전                                                     매크로 실행 후 결과\nOption Explicit\nSub fill_BlankCells_In_Color()\nDim r As Long\n'행 늘려갈 변수\nDim rngM As Range\n'셀병합 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nIf Cells(r, 1) = \"\" Then\n'셀이 비어 있다면\nSet rngM = Cells(r, 1).\nMergeArea\n'빈셀의 병합영역을 변수에 넣음\nIf\nApplication.Count\n(rngM)..."}
{"instruction": "Excel VBA code for: (1227) 굵은 bold 체가 들어간 셀만 색칠하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Font_Bold()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'각 셀의 문자 길이 만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each rngC In ActiveSheet.UsedRange\n'현재시트 사용영역의 각셀을 순환\nFor i = 1 To\nLen\n(rngC)\n'각 셀의 길이 만큼 반복\nIf rngC.\nCharacters\n(i, 1).\nFont.Bold\n= True Then\n'각 문자중에 굵은 bold체가 있으면\nrngC.Interior.ColorIndex = 20\n'셀을 옅은 파란색으로 표시.\nExit\nFor\n'For 구문 종료\nEnd If\nNext i\nNext rngC\nEnd Sub", "context": "각 셀에 여러 글자가 들어가 있음. 일부만 또는 전체가 굵은 볼드(bold)체가 들어간 셀들만 색으로 표시하는 기능. (화면 캡춰 시 Bold체가 눈에 잘 안띄어 아래 그림에서는 폰트를 약간 크게함.)\n매크로 실행 전                                                     매크로 실행 후 결과\nOption Explicit\nSub find_Font_Bold()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'각 셀의 문자 길이 만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each rngC In ActiveSheet.UsedRange\n'현재시트 사용영역의 각셀을 순환\nFor i = 1 To\nLen\n(rngC)\n'각 셀의 길이 만큼 반복\nIf rngC.\nCharacters\n(i, 1).\nFont.Bold\n= True Then\n'각 문자중에 굵은 b..."}
{"instruction": "Excel VBA code for: (1228) 유저폼에 차트 불러오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub chart_In_Form()\n'표준 모듈(module1)에 들어갈 코드\nUserForm1.\nShow\nvbModeless\n'영역이 선택되도록 하여 폼 열기\nEnd Sub\n\nPrivate Sub CommandButton1_Click()\n'유저폼의 \"차트 불러오기\" 버튼에 연결된 코드\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim cht As ChartObject\n'임시 차트를 넣을 변수\nDim strFile As String\n'임시 그림파일 경로 + 이름 넣을 변수\nstrPath = ActiveWorkbook.Path & \"\\\"\n'이 엑셀파일이 저장된 폴더의 경로\nActiveSheet.ChartObjects(\"Chart 1\").\nCopyPicture\n'선택된 차트를 그림으로 복사\nSet cht = ActiveSheet.ChartObjects.Add(0, 0, Image1.Width, Image1.Height)\n'새로운 차트개체를 각 Image1크기로 생성\ncht.\nChart.Paste\n'그림을 복사해서 차트에 붙여 넣음\nstrFile = strPath & ActiveWorkbook.Name & \" \" _\n& ActiveSheet.Name & \".gif\"\n'경로 + 파일이름 + 시트이름 + .gif로 저장\nOn Error\nResume Next\n'파일이 없어 에러 발생해도 다음코드 진행\nKill\nstrFile\n'기존 그림파일 삭제\nOn Error\nGoTo 0\n'에러 검출기능 복원\ncht.\nChart.Export\nstrFile\n'그림을 내보냄\ncht.Delete\n'임시로 삽입했던 차트개체를 삭제\nImage1.Picture =\nLoadPicture\n(strFile)\n'그림을 Image1에 불러오기\nSet cht = Nothing\n'개체변수 초기화\nEnd Sub\n\nPrivate Sub CommandButton2_Click()\n'유저폼의 종료 버튼에 연결된 코드\nUnload Me\n'폼 닫기\nEnd Sub", "context": "유저폼의 이미지 컨트롤에 시트에 있는 차트를 불러오는 기능으로, 유저폼을 Modeless로 지정하여 유저폼을 닫지 않고 시트내에서 차트의 값을 변동하여 차트를 변경 후 유저폼의 \"차트 불러오기\" 버튼을 클릭하면 변경된 차트가 유저폼에 업데이트되도록 함.\n많은 분들이 VBA(매크로)의 기본을 다지지 않고 유저폼부터 먼저 공부하는 분들이 있는데, 매크로에 능숙하면 단지 알고 있는 코드를 유저폼에 넘기기만 하면 되므로 유저폼의 사용이 별로 어렵지 않다. 그러므로, 유저폼을 서둘러 사용하기 보다는 VBA(매크로)의 기본기를 다지시기를 권해드린다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1228) 유저폼에 차트 불러오기 (엑셀 VBA 매크로)\n재생\n6,590\n재생 (space/k)\n재생\n00:37\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:37\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안..."}
{"instruction": "Excel VBA code for: (1229) str = Choose(i, \"갑\", Empty, \"을\", \"병\", \"정\") 의 뜻 (엑셀 VBA 매크로)", "input": "", "output": "Sub choose_Function()\nDim str As String\nDim i As Long\nFor i = 1 To 5\nstr =\nChoose\n(i, \"갑\", Empty, \"을\", \"병\", \"정\")\nCells(1, i) = str\nNext i\nEnd Sub\n\nSub array_Function()\nDim str As String\nDim i As Long\nFor i = 1 To 5\nstr =\nArray\n(\"갑\", Empty, \"을\", \"병\", \"정\")\n(i - 1)\nCells(1, i) = str\nNext i\nEnd Sub\n\nSub copy_Irregular_Columns()\nDim i As Integer\nDim intNo As Integer\nFor i  = 1 to 5\nintNo = Choose(i, 2, 3, 6, 7, 9)\nColumns(intNo).Copy Sheets(2).Cells(1, i)\nNext i\nEnd Sub", "context": "str\n= Choose(i, \"갑\", Empty, \"을\", \"병\", \"정\") : str은 string을 줄여서 사용한 것으로 문자를 넣을 수 있는\n변수\n이다. 그러므로 앞서 Dim str As String 와 같은 변수의 선언이 선행되야 한다.\nstr =\nChoose\n(i, \"갑\", Empty, \"을\", \"병\", \"정\") : Choose 함수는 뒤 괄호안에 오는 인덱스(i) 뒤의\n값을 순서대로 선택하는 함수\n이다.\nstr = Choose\n(\ni, \"갑\", Empty, \"을\", \"병\", \"정\"\n)\n: 괄호안의 문자들은 Choose 함수의 인수를 넣는 곳으로 제일 앞에는 인덱스가 오며, 그 뒤에는 선택값을 순서대로 넣으면 된다.\nstr = Choose(\ni\n, \"갑\", Empty, \"을\", \"병\", \"정\") : i는 Choose함수에 사용될\n인덱스\n(index)이다. i 또한 변수이므로 Dim i As Integer와 같은 변수 선언이 선행되어야 한다. 인덱스인 i가 1이면 \"갑\", 2..."}
{"instruction": "Excel VBA code for: (1230) 특정 서식 찾아 바꾸기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_And_Feplace_Format()\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Application\n'엑셀에서\nWith .\nFindFormat\n'찾을서식\n.\nClear\n'찾기 서식 초기화\n.\nInterior.Color\n= 49407\n'찾을 색 지정\n.\nBorders.Weight\n= xlMedium\n'찾을 테두리 두께\nEnd With\nWith .\nReplaceFormat\n'바꿀 서식\n.Clear\n'바꿀 서식 초기화\n.Interior.Color = 13995347\n'바꿀 색 지정\n.Borders.Weight = xlThin\n'바꿀 테두리 두께\n.Borders.ColorIndex = 3\n'테두리 색\nEnd With\nCells.Replace\nWhat:=\"\", _\nReplacement:=\"\", _\nSearchFormat:=True, _\nReplaceFormat:=True\n'전체영역에서 바꾸기\n.FindFormat.Clear\n'찾을 서식 초기화\n.ReplaceFormat.Clear\n'바꿀 서식 초기화\nEnd With\nEnd Sub", "context": "전체 시트 영역에서 오렌지색으로 채워지고 굵게 테두리가 된 셀들을 찾아서 파란색으로 채우고 테두리는 빨간색으로 바꾸는 기능.\n매크로 실행 전                                            매크로 실행 후 결과\n셀의 Color값 추출은 아래 동영상과 같이 즉석창(Immediate)창을 활용하면 된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1230) 특정 서식 찾아 바꾸기 (엑셀 VBA 매크로)\n재생\n718\n재생 (space/k)\n재생\n00:25\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:25\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주..."}
{"instruction": "Excel VBA code for: (1231) Switch 함수와 Select Case의 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub using_Switch_Function()\n.......................................................................\n5.88\n초\nDim r As Long\nDim i As Long\nApplication.ScreenUpdating = False\nFor i = 1 To 20000\nFor r = 1 To 5\nCells(r, 1).Next =\nSwitch\n(Cells(r, 1) = 1, 1, Cells(r, 1) = 2, 2, _\nCells(r, 1) = 3, 3, Cells(r, 1) = 4, 4, Cells(r, 1) = 5, 5)\nNext r\nNext i\nEnd Sub\n\nSub using_Select_Case()\n........................................................................\n4.15\n초\nDim r As Long\nDim i As Long\nApplication.ScreenUpdating = False\nFor i = 1 To 20000\nFor r = 1 To 5\nSelect Case\nCells(r, 1)\nCase 1: Cells(r, 1).Next = 1\nCase 2: Cells(r, 1).Next = 2\nCase 3: Cells(r, 1).Next = 3\nCase 4: Cells(r, 1).Next = 4\nCase 5: Cells(r, 1).Next = 5\nEnd Select\nNext r\nNext i\nEnd Sub", "context": "Select Case 구문과 유사한 제어문에\n스위치 함수(\nSwitch Function)\n가 있다. 아래의 두 코드는 A열 각 값의 오른쪽에 같은 값을 반복하여 입력하는 동일한 기능을 하는 코드이다.\n매크로 실행 전                                                      매크로 실행 후 결과\n﻿\n반복횟수 (100,000회)                                                                                          소요시간\nOption Explicit\nSub using_Switch_Function()\n.......................................................................\n5.88\n초\nDim r As Long\nDim i As Long\nApplication.ScreenUpdating = False\nFor i = 1 To 200..."}
{"instruction": "Excel VBA code for: (1232) 셀값을 배열에 넣어 빈셀 없이 채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_The_Blank_Cells()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nDim r As Long\n'배열크기 늘려갈 변수\nDim\nvarTemp() As Long\n'장정수형 배열로 사용할 변수\nDim i As Long\n'배열크기 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet\nrngAll = Range(\"A1:M5\")\n'전체 데이터 영역을 변수에 넣음\nFor Each rngC In rngAll\n'전체영역(rngAll)의 각셀(rngC)을 순환\nIf\nNot IsEmpty\n(rngC) Then\n'빈 셀이 아닐 경우\nr = r + 1\n'배열크기 1씩 늘려감\nReDim Preserve\nvarTemp(1 To r)\n'배열크기 재지정\nvarTemp(r) = rngC\n'배열에 셀값을 넣음\nEnd If\nNext\nrngAll.ClearContents\n'기존 데이터 삭제\nFor Each rngC In rngAll\n'전체영역(rngAll)의 각셀(rngC)을 순환\nIf rngC.Column\nMod\n3 = 1 Then\n'각 열을 3으로 나눈 나머지가 3일 경우\nIf\nUBound\n(varTemp) > i Then\n'배열에 값이 있다면\ni = i + 1\n'배열크기 1씩 늘려감\nrngC = varTemp(i)\n'배열값을 셀에 뿌림\nElse\n'배열에 더이상 값이 없다면\nExit Sub\n'매크로 종료\nEnd If\nEnd If\nNext\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "위와 같은 상황에서 중간의 7, 14, 23이 삭제되어 아래와 같이 되었을 때\n매크로를 실행 전\n매크로 실행 후 결과 (빈 셀 없이 값을 앞으로 당겨서 채움)\nOption Explicit\nSub fill_The_Blank_Cells()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nDim r As Long\n'배열크기 늘려갈 변수\nDim\nvarTemp() As Long\n'장정수형 배열로 사용할 변수\nDim i As Long\n'배열크기 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet\nrngAll = Range(\"A1:M5\")\n'전체 데이터 영역을 변수에 넣음\nFor Each rngC In rngAll\n'전체영역(rngAll)의 각셀(rngC)을 순환\nIf\nNot IsEmpty\n(rngC) Then\n'빈 셀이 아닐 경우\nr = r + 1\n'..."}
{"instruction": "Excel VBA code for: (1233) 특정 영역에 순차적으로 값 채우기 연습 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_1()\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each\nrngC\nIn\nRange(\"A1:E4\")\n'전체영역의 각셀(rngC)을 순환\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nrngC = cnt\n'각 셀에 1씩 늘린 값을 넣음\nNext\nEnd Sub\n\nSub range_Fill_2()\nDim r As Long\n'행 늘려갈 변수\nDim c As Integer\n'열 늘려갈 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor\nr = 1 To 4\n'1씩 늘려가며 행 개수만큼 반복\nFor\nc = 1 To 5\n'1씩 늘려가며 열 개수만큼 반복\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nCells(r, c) = cnt\n'셀에 값을 넣음\nNext\nc\nNext\nr\nEnd Sub", "context": "자신이 데이터를 입력하려는 영역에 원하는 순서대로 순차적으로 값을 입력하는 것은 VBA(매크로)를 공부하려면 반드시 거쳐가야할 기본적인 내용이며, 이를 통해 영역의 이해 및 For Each 구문과 For Next 중첩구문을 숙달하게 된다. 10 회에 걸쳐 특정 영역에 순차적으로 값을 채우는 것을 공부해보자.\n아래의 두 코드는\n왼쪽에서 오른쪽으로, 위에서 아래로\n숫자를 순차적으로 채워가는 코드이며, 두 코드의 실행 결과는 동일하다.\n매크로 실행 전                                                 매크로 실행 후 결과\nOption Explicit\nSub range_Fill_1()\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each\nrngC\nIn\nRange(\"A1:E4\")\n'전..."}
{"instruction": "Excel VBA code for: (1234) 특정 영역에 순차적으로 값 채우기 연습 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_3()\nDim rngR As Range\n'전체영역 각 행을 순환\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nDim i As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each\nrngR\nIn\nRange(\"A1:E4\").\nRows\n'전체영역의 각행(rngR)을 순환\nFor i = rngR.\nCells\n.\nCount\nTo 1\nStep -1\n'각 열의 개수 1씩 줄여가며 반복\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nrngR.\nCells(i)\n= cnt\n'각 행의 각 셀에 1씩 늘린 값을 넣음\nNext\ni\nNext\nEnd Sub\n\nSub range_Fill_4()\nDim r As Long\n'행 늘려갈 변수\nDim c As Integer\n'열 늘려갈 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor\nr = 1 To 4\n'1씩 늘려가며 행 개수만큼 반복\nFor\nc = 5 To 1\nStep -1\n'1씩 줄여가며 열 개수만큼 반복\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nCells(r, c) = cnt\n'셀에 값을 넣음\nNext\nc\nNext\nr\nEnd Sub", "context": "자신이 데이터를 입력하려는 영역에 원하는 순서대로 순차적으로 값을 입력하는 것은 VBA(매크로)를 공부하려면 반드시 거쳐가야할 기본적인 내용이며, 이를 통해 영역의 이해 및 For Each 구문과 For Next 중첩구문을 숙달하게 된다. 10 회에 걸쳐 특정 영역에 순차적으로 값을 채우는 것을 공부해보자.\n아래의 두 코드는\n오른\n쪽에서 왼\n쪽으로, 위에서 아래로\n숫자를 순차적으로 채워가는 코드이며, 두 코드의 실행 결과는 동일하다.\n매크로 실행 전                                                 매크로 실행 후 결과\nOption Explicit\nSub range_Fill_3()\nDim rngR As Range\n'전체영역 각 행을 순환\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nDim i As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor ..."}
{"instruction": "Excel VBA code for: (1235) 특정 영역에 순차적으로 값 채우기 연습 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_5()\nDim rngCol As Range\n'전체영역 각 열을 순환\nDim rngC As Range\n'각 셀을 넣을 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nDim i As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each\nrngCol\nIn\nRange(\"A1:E4\").\nColumns\n'전체영역의 각열(rngCol)을 순환\nFor Each\nrngC\nIn\nrngCol.\nCells\n'각 열의 각 셀을 순환\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nrngC = cnt\n'각 셀에 1씩 늘린 값을 넣음\nNext\nrngC\nNext\nrngCol\nEnd Sub\n\nSub range_Fill_6()\nDim r As Long\n'행 늘려갈 변수\nDim c As Integer\n'열 늘려갈 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor\nc = 1 To 5\n'1씩 늘려가며 열 개수만큼 반복\nFor\nr = 1 To 4\n'1씩 늘려가며 행 개수만큼 반복\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nCells(r, c) = cnt\n'셀에 값을 넣음\nNext\nr\nNext\nc\nEnd Sub", "context": "자신이 데이터를 입력하려는 영역에 원하는 순서대로 순차적으로 값을 입력하는 것은 VBA(매크로)를 공부하려면 반드시 거쳐가야할 기본적인 내용이며, 이를 통해 영역의 이해 및 For Each 구문과 For Next 중첩구문을 숙달하게 된다. 10 회에 걸쳐 특정 영역에 순차적으로 값을 채우는 것을 공부해보자.\n아래의 두 코드는\n위에서 아래로, 왼쪽에서 오름쪽으로\n숫자를 순차적으로 채워가는 코드이며, 두 코드의 실행 결과는 동일하다.\n매크로 실행 전                                                 매크로 실행 후 결과\nOption Explicit\nSub range_Fill_5()\nDim rngCol As Range\n'전체영역 각 열을 순환\nDim rngC As Range\n'각 셀을 넣을 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nDim i As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating..."}
{"instruction": "Excel VBA code for: (1236) 특정 영역에 순차적으로 값 채우기 연습 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_7()\nDim rngCol As Range\n'전체영역 각 열을 순환\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nDim i As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each\nrngCol\nIn\nRange(\"A1:E4\").Columns\n'전체영역의 각열(rngCol)을 순환\nFor\ni = rngCol.Cells.Count To 1 Step\n-1\n'각 열의 개수 1씩 줄여가며 반복\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nrngCol.Cells(i) = cnt\n'각 열의 각 셀에 1씩 늘린 값을 넣음\nNext\ni\nNext\nEnd Sub\n\nSub range_Fill_8()\nDim r As Long\n'행 늘려갈 변수\nDim c As Integer\n'열 늘려갈 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor\nc = 1 To 5\n'1씩 늘려가며 열 개수만큼 반복\nFor\nr = 4 To 1\nStep -1\n'1씩 줄여가며 행 개수만큼 반복\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nCells(r, c) = cnt\n'셀에 값을 넣음\nNext\nr\nNext\nc\nEnd Sub", "context": "자신이 데이터를 입력하려는 영역에 원하는 순서대로 순차적으로 값을 입력하는 것은 VBA(매크로)를 공부하려면 반드시 거쳐가야할 기본적인 내용이며, 이를 통해 영역의 이해 및 For Each 구문과 For Next 중첩구문을 숙달하게 된다. 10 회에 걸쳐 특정 영역에 순차적으로 값을 채우는 것을 공부해보자.\n아래의 두 코드는\n아래에서 위로, 왼쪽에서 오른쪽으로\n숫자를 순차적으로 채워가는 코드이며, 두 코드의 실행 결과는 동일하다.\n매크로 실행 전                                                 매크로 실행 후 결과\nOption Explicit\nSub range_Fill_7()\nDim rngCol As Range\n'전체영역 각 열을 순환\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nDim i As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor ..."}
{"instruction": "Excel VBA code for: (1237) 특정 영역에 순차적으로 값 채우기 연습 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_9()\nDim r As Long\n'행 늘려갈 변수\nDim c As Integer\n'열 늘려갈 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor\nc = 5 To 1\nStep -1\n'1씩 줄여가며 열 개수만큼 반복\nFor\nr = 4 To 1\nStep -1\n'1씩 줄여가며 행 개수만큼 반복\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nCells(r, c) = cnt\n'셀에 값을 넣음\nNext\nr\nNext\nc\nEnd Sub\n\nSub range_Fill_10()\nDim r As Long\n'행 늘려갈 변수\nDim c As Integer\n'열 늘려갈 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor\nr = 4 To 1\nStep -1\n'1씩 줄여가며 행 개수만큼 반복\nFor\nc = 5 To 1\nStep -1\n'1씩 줄여가며 열 개수만큼 반복\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nCells(r, c) = cnt\n'셀에 값을 넣음\nNext\nc\nNext\nr\nEnd Sub", "context": "자신이 데이터를 입력하려는 영역에 원하는 순서대로 순차적으로 값을 입력하는 것은 VBA(매크로)를 공부하려면 반드시 거쳐가야할 기본적인 내용이며, 이를 통해 영역의 이해 및 For Each 구문과 For Next 중첩구문을 숙달하게 된다. 10 회에 걸쳐 특정 영역에 순차적으로 값을 채우는 것을 공부해보자.\n아래의 코드는\n아래에서 위로, 오른쪽에서 왼쪽으로\n숫자를 순차적으로 채워가는 코드이다.\n매크로 실행 전                                                 매크로 실행 후 결과\nSub range_Fill_9()\nDim r As Long\n'행 늘려갈 변수\nDim c As Integer\n'열 늘려갈 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor\nc = 5 To 1\nStep -1\n'1씩 줄여가며 열 개수만큼 반복\nFor\nr = 4 To 1..."}
{"instruction": "Excel VBA code for: (1238) 특정 영역에 순차적으로 값 채우기 연습 6 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_11()\nDim rngR As Range\n'전체영역 각 행을 순환\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each\nrngR\nIn\nRange(\"A1:E4\").\nRows\n'전체영역의 각행(rngR)을 순환\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nrngR = cnt\n'각 행에 값을 넣음\nNext\nEnd Sub\n\nSub range_Fill_12()\nDim r As Long\n'행 개수만큼 반복할 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor\nr = 1 To 4\n'1씩 늘려가며 행 개수만큼 반복\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nCells(r, 1).\nResize\n(, 5) = cnt\n'각 행의 열길이 늘린 후 값을 넣음\nNext\nr\nEnd Sub", "context": "자신이 데이터를 입력하려는 영역에 원하는 순서대로 순차적으로 값을 입력하는 것은 VBA(매크로)를 공부하려면 반드시 거쳐가야할 기본적인 내용이며, 이를 통해 영역의 이해 및 For Each 구문과 For Next 중첩구문을 숙달하게 된다. 10 회에 걸쳐 특정 영역에 순차적으로 값을 채우는 것을 공부해보자.\n아래의 두 코드는\n위에서 아래로, 각\n행\n에 동일한 값을\n순차적으로 채워가는 코드이며, 두 코드의 실행 결과는 동일하다.\n매크로 실행 전                                                 매크로 실행 후 결과\nOption Explicit\nSub range_Fill_11()\nDim rngR As Range\n'전체영역 각 행을 순환\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each\nrngR\nIn\nRange(\"A1:E4\").\nRows\n'..."}
{"instruction": "Excel VBA code for: (1239) 특정 영역에 순차적으로 값 채우기 연습 7 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_13()\nDim rngCol As Range\n'전체영역 각 열을 순환\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each\nrngCol\nIn\nRange(\"A1:E4\").Columns\n'전체영역의 각열(rngCol)을 순환\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nrngCol = cnt\n'각 열에 값을 넣음\nNext\nEnd Sub\n\nSub range_Fill_14()\nDim c As Long\n'열 개수만큼 반복할 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor\nc = 1 To 5\n'1씩 늘려가며 열 개수만큼 반복\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nCells(1, c).\nResize\n(4) = cnt\n'각 열의 길이 늘린 후 값을 넣음\nNext\nc\nEnd Sub", "context": "자신이 데이터를 입력하려는 영역에 원하는 순서대로 순차적으로 값을 입력하는 것은 VBA(매크로)를 공부하려면 반드시 거쳐가야할 기본적인 내용이며, 이를 통해 영역의 이해 및 For Each 구문과 For Next 중첩구문을 숙달하게 된다. 10 회에 걸쳐 특정 영역에 순차적으로 값을 채우는 것을 공부해보자.\n아래의 두 코드는\n왼쪽에서 오른쪽으로, 각\n열\n에 동일한 값을\n순차적으로 채워가는 코드이며, 두 코드의 실행 결과는 동일하다.\n매크로 실행 전                                                 매크로 실행 후 결과\nOption Explicit\nSub range_Fill_13()\nDim rngCol As Range\n'전체영역 각 열을 순환\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each\nrngCol\nIn\nRange(\"A1:E4\")...."}
{"instruction": "Excel VBA code for: (1240) 특정 영역에 순차적으로 값 채우기 연습 8 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_15()\nDim c As Long\n'열 개수만큼 반복할 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor\nc = 5 To 1\nStep -1\n'1씩 줄여가며 열 개수만큼 반복\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nCells(1, c).\nResize\n(4) = cnt\n'각 열의 길이 늘린 후 값을 넣음\nNext\nc\nEnd Sub\n\nSub range_Fill_16()\nDim c As Long\n'열 개수만큼 반복할 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nDim rngCol As Range\n'각 열을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet\nrngCol = Range(\"F1:F4\")\nFor\nc = 1 To 5\n'1씩 늘려가며 열 개수만큼 반복\nSet rngCol = rngCol.\nOffset\n(, -1)\n'열 위치를 1열씩 왼쪽으로 설정\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nrngCol = cnt\n'각 열에 값을 입력\nNext\nc\nEnd Sub", "context": "자신이 데이터를 입력하려는 영역에 원하는 순서대로 순차적으로 값을 입력하는 것은 VBA(매크로)를 공부하려면 반드시 거쳐가야할 기본적인 내용이며, 이를 통해 영역의 이해 및 For Each 구문과 For Next 중첩구문을 숙달하게 된다. 10 회에 걸쳐 특정 영역에 순차적으로 값을 채우는 것을 공부해보자.\n아래의 두 코드는\n오른쪽에서 왼쪽으로, 각\n열\n에 동일한 값을\n순차적으로 채워가는 코드이며, 두 코드의 실행 결과는 동일하다.\n매크로 실행 전                                                 매크로 실행 후 결과\nOption Explicit\nSub range_Fill_15()\nDim c As Long\n'열 개수만큼 반복할 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor\nc = 5 To 1\nStep -1\n'1씩 줄여가며 열 개수만큼 ..."}
{"instruction": "Excel VBA code for: (1241) 특정 영역에 순차적으로 값 채우기 연습 9 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_17()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rowsCnt As Long\n'전체영역의 행 개수 넣을 변수\nDim colsCnt As Integer\n'전체영역의 열 개수 넣을 변수\nDim rngT As Range\n'각 셀을 선택할 변수\nDim cnt As Long\n'숫자를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.ClearContents\n'기존 데이터 삭제\nSet rngAll =\nRange(\"A1:J10\")\n'전체영역을 변수에 넣음\nrowsCnt = rngAll.\nRows.Count\n'전체영역의 행을 변수에 넣음\ncolsCnt = rngAll.\nColumns.Count\n'전체영역의 열을 변수에 넣음\nSet rngT = Cells(1, 1)\n'시작위치를 변수에 넣음\nDo\n'다음을 실행\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nrngT = cnt\n'각 셀에 값을 넣음\nIf\nrngT.\nRow\n<> 1 And rngT.\nColumn\n<> colsCnt Then\n'셀의 행이 1이 아니고 마지막열 아니면\nSet rngT = rngT.Offset(-1, 1)\n'오른쪽 윗셀을 변수에 넣음\nElseIf\nrngT.Column = colsCnt Then\n'셀의 열이 마지막 열이면\nSet rngT = Cells(rowsCnt, Columns.Count).\nEnd(1)(1, 2)\n'마지막행 오른쪽셀을 변수에\nElseIf\nrngT.Row = 1 Then\n'셀의 행이 1이면\nIf Cells(Rows.Count, \"A\").End(3).Row < rowsCnt Then\n'마지막행이 전체행 개수보다 작으면\nSet rngT = Cells(Rows.Count, \"A\").\nEnd(3)(2)\n'A열 종단셀 윗방향 아래셀을 변수에\nElseIf Cells(Rows.Count, \"A\").End(3).Row = rowsCnt Then\n'A열 마지막행이 전체행 개수면\nSet rngT = Cells(rowsCnt, Columns.Count).End(1)(1, 2)\n'마지막행 오른쪽셀을 변수에\nEnd If\nElseIf\nrngT.Row = rowsCnt Then\n'셀의 행이 마지막행이라면\nSet rngT = rngT.Offset(, 1)\n'셀의 오른쪽 셀을 변수에\nEnd\nIf\nLoop Until\nrngAll.Count = cnt\n'cnt가 전체영역의 셀개수 될때까지 반복\nSet rngAll = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngT = Nothing\nEnd Sub", "context": "자신이 데이터를 입력하려는 영역에 원하는 순서대로 순차적으로 값을 입력하는 것은 VBA(매크로)를 공부하려면 반드시 거쳐가야할 기본적인 내용이며, 이를 통해 영역의 이해 및 For Each 구문과 For Next 중첩구문을 숙달하게 된다. 10 회에 걸쳐 특정 영역에 순차적으로 값을 채우는 것을 공부해보자.\n이번에는 좀 어렵게 채워보자. 아래의 코드는\n숫자를 대각선으로\n순차적으로 채워가는 코드이다. 앞서 공부했던 내용들이 너무 쉬었다면, 아래의 코드를 보지 않고 자기 자신 스스로 아래와 같이 데이터를 채울 수 있는지 시도해보자. ^^\nSet rngAll = Range(\"\nA1:E4\n\") 로 하였을 때의 결과\n매크로 실행 전                                                 매크로 실행 후 결과\nSet rngAll = Range(\"\nA1:J10\n\") 로 하였을 때의 결과\n매크로 실행 전                                    ..."}
{"instruction": "Excel VBA code for: (1244) 숨겨진 모든 시트 보이기 (엑셀 VBA 매크로)", "input": "", "output": "Sub unhide_All_Sheets()\nDim wks As Worksheet\n'각 시트를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each\nwks\nIn\nActiveWorkbook.\nSheets\n'현재파일 각 시트를 순환\nwks.\nVisible = True\n'각 시트를 보이도록\nNext\nwks\nEnd Sub", "context": "파일에 1 ~ 15 까지 15개의 시트가 있으며 짝수 시트는 모두 숨겨진 상태. 숨겨진 시트를 한 번에 보이도록 하는 기능이 엑셀 2010에서도 없는 것 같다(엑셀의 기능이 날로 발전하므로 이런말 하기 무섭다. 혹시 엑셀 기본 기능으로 숨겨진 파일을 한 번에 보이도록 하는 방법이 있다면 알려주세요. ^^)\n숨겨진 시트를 보여주는 윗 창에서 Ctrl 키 또는 Shift 키가 먹지 않아 한 번에 한 시트씩 숨기기를 해제해야 한다. 아래의 코드를 실행 시 숨겨진 모든 시트를 보이도록 함.\n매크로 실행 전 (짝수 이름의 시트들이 숨겨진 상황)\n매크로 실행 후 결과 (숨겨진 모든 시트들이 나타남)\nOption Explicit\nSub unhide_All_Sheets()\nDim wks As Worksheet\n'각 시트를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each\nwks\nIn\nActiveWorkbook.\nSheets\n'현..."}
{"instruction": "Excel VBA code for: (1245) 복수조건, 복수열/복수행 자동필터 (엑셀 VBA 매크로)", "input": "", "output": "Sub multiple_Conditional_Autofilter()\nDim strText As String\n'매크로 버튼의 문자를 넣을 변수\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nDim r As Long\n'행 늘려갈 변수\nDim i As Long\n'열 늘려갈변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet\nrngAll = Range(\"A3:D30\")\n'전체영역을 변수에 넣음\nReDim\nvarTemp(1 To 3)\n'배열크기 재지정\nWith ActiveSheet.Shapes(\nApplication.Caller\n)\n'매크로 실행한 도형\nstrText = .TextFrame2.\nTextRange.Text\n'버튼의 문자를 변수에 넣음\nIf strText = \"필터실행\" Then\n'버튼이 \"필터실행\"일 경우\n.TextFrame2.TextRange.Text = \"필터제거\"\n'버튼을 \"필터제거\"로 변경\n.\nShapeStyle = 31\n'버튼색을 빨간색으로 바꿈\nFor i = 1 To 4\n'4회(조건표의 열 개수) 반복\nFor r = 1 To 3\n'3회(조건표의 행 개수) 반복\nvarTemp(r) =\nCStr\n(Cells(r, i + 5))\n'각 필터조건을 배열에 넣음\nNext r\nrngAll.\nAutoFilter\ni, varTemp, xlFilterValues, , 1\n'Drop-down 표시하며 자동필터 실행\nNext i\nElseIf strText = \"필터제거\" Then\n'버튼이 \"필터제거\"일 경우\n.TextFrame2.TextRange.Text = \"필터실행\"\n'버튼을 \"필터실행\"으로 변경\n.ShapeStyle =\n30\n'버튼색을 파란색으로 바꿈\nWith ActiveSheet\n'현재 시트에서\nIf .\nFilterMode\n= True Then\n'필터링 되어 있으면\n.\nAutoFilter.Range.AutoFilter\n'필터 해제함\nEnd If\nEnd With\nEnd If\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "필터를 할 열의 개수가 많고, 더군다나 동일한 열에서 필터를 적용할 항목이 엄청 많은 상태에서 자신이 원하는 항목만을 선택해야 할 경우, 즉 아래와 같은 그림에서 네모안의 작은 v 모양을 일일이 클릭하여 선택하거나 또는 해제하는 것은 많은 인내심을 요한다.\n아래의 매크로는 자신이 필터링할 조건을 미리 표로 만들어 놓고 지정해 놓은 표 안의 데이터만 필터링이 되도록 하는 기능이다. 동영상의 한 화면에 보이도록 하기 위해 동일한 시트에 데이터와 조건을 함께 넣었지만, 필터 조건이 더 많을 경우 필터링할 조건은 다른 시트에 입력하고 코드를 일부 수정하면 된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1245) 복수조건, 복수열/복수행 자동필터 (엑셀 VBA 매크로)\n재생\n2,300\n재생 (space/k)\n재생\n00:33\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:33\n실시간\n설정\n전체 화면 (f)\n해..."}
{"instruction": "Excel VBA code for: (1246) 영어, 한글, 숫자를 선택적으로 필터하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub selective_Filter()\n'메인 프로시저\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim strBtn As String\n'매크로 버튼의 문자를 넣을 변수\nDim strText As String\n'검색조건 넣을 변수\nDim var\n'함수값 돌려받은 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = [A2].CurrentRegion\n'전체영역을 변수에 넣음\nWith ActiveSheet.Shapes\n(Application.Caller)\n'현재시트 매크로 실행한 도형\nstrBtn = .TextFrame2.TextRange.Text\n'버튼의 문자를 변수에 넣음\nIf\nstrBtn = \"필터실행\" Then\n'버튼이 \"필터실행\"일 경우\n.TextFrame2.TextRange.Text = \"필터제거\"\n'버튼을 \"필터제거\"로 변경\n.ShapeStyle = 31\n'버튼색을 빨간색으로 바꿈\nIf [A4] <> \"\" Then\n'데이터가 존재하면\nWith ActiveSheet\n'현재 시트에서\nIf .\nbtnOpt1.Value = True\nThen\n'옵션버튼1이 선택되었으면\nstrText = \"\n[가-힣]\n\"\n'한글을 변수에 넣음\nvar =\npass_Array(strText)\n'pass_Array호출 후 배열을 돌려받음\nrngAll.\nAutoFilter\n1, var, xlFilterValues, , 1\n'Drop-down 표시하며 자동필터 실행\nEnd If\nIf .btnOpt2.Value = True Then\n'옵션버튼2이 선택되었으면\nstrText =\n\"[a-zA-Z]\n\"\n'영어를 변수에 넣음\nvar = pass_Array(strText)\n'pass_Array호출 후 배열을 돌려받음\nrngAll.\nAutoFilter\n1, var, xlFilterValues, , 1\n'Drop-down 표시하며 자동필터 실행\nEnd If\nIf .btnOpt3.Value = True Then\n'옵션버튼3이 선택되었으면\nstrText = \"\n[0-9]\n\"\n'숫자를 변수에 넣음\nvar = pass_Array(strText)\n'pass_Array호출 후 배열을 돌려받음\nrngAll.\nAutoFilter\n1, var, xlFilterValues, , 1\n'Drop-down 표시하며 자동필터 실행\nEnd If\nEnd With\nEnd If\nElseIf\nstrBtn = \"필터제거\" Then\n'버튼이 \"필터제거\"일 경우\n.TextFrame2.TextRange.Text = \"필터실행\"\n'버튼을 \"필터실행\"으로 변경\n.ShapeStyle = 30\n'버튼색을 파란색으로 바꿈\nWith ActiveSheet\n'현재 시트에서\nIf .\nFilterMode\n= True Then\n'필터링 되어 있으면\n.\nAutoFilter.Range.AutoFilter\n'현재시트내의 필터 해제함\nEnd If\nEnd With\nEnd\nIf\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nPrivate Function pass_Array(strText As String)\n'조건 따라 데이터 추출후 배열에 넣을 함수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'배열크기 늘려갈 변수\nDim varTemp()\n'함수값 되돌려줄 배열변수\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'A열 각 셀을 순환\nIf Left(rngC, 1)\nLike\nstrText Then\n'왼쪽 첫 문자가 \"한글,영어,숫자\"면\nr = r + 1\n'배열크기 1씩 늘려감\nReDim Preserve\nvarTemp(1 To r)\n'기존값 유지하며 배열크기 재지정\nvarTemp(r) =\nCStr\n(rngC)\n'각 필터조건을 배열에 넣음\nEnd If\nNext rngC\npass_Array = varTemp\n'함수에 배열을 되돌려줌\nEnd Function", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1246) 영어, 한글, 숫자를 선택적으로 필터하기 (엑셀 VBA 매크로)\n재생\n1,854\n재생 (space/k)\n재생\n00:28\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:28\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\nA열에 한글, 영어, 숫자가 뒤섞인 데이터가 있음\n(매크로 버튼 클릭 시 \"필터실행\", \"필터제거\"로 토글(toggle)됨)..."}
{"instruction": "Excel VBA code for: (1248) 선택영역의 사진만 선택하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub select_Pictures_In_Selection()\nDim shpC As\nShape\n'각각의 도형(사진)을 넣을 변수\nDim rngShp As Range\n'각 도형의 왼쪽위가 속한 영역을 넣을 변수\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim r As Long\n'배열크기 늘려갈 변수\nDim varTemp()\n'동적배열로 사용할 변수\nSet rngAll = Selection\n'선택영역을 삭제할 영역으로 설정\nFor Each shpC In ActiveSheet.Shapes\n'삭제영역내의 각 도형을 순환\nIf shpC.\nType\n=\nmsoPicture\nThen\n'선택된 것이 사진이라면\nSet rngShp = shpC.TopLeftCell\n'각 사진의 왼쪽위지점이 속한 영역을 변수에 넣음\nIf\nNot Intersect(rngAll, rngShp) Is Nothing\nThen\n'사진과 삭제영역이 겹치면\nr = r + 1\n'배열크기 1씩 늘려감\nReDim Preserve\nvarTemp(1 To r)\n'기존값 유지하며 배열크기 재지정\nvarTemp(r) = shpC.Name\n'배열에 각 사진 이름을 넣음\nEnd If\nEnd If\nNext shpC\nIf r > 0 Then\n'만약 그림이 존재하면\nActiveSheet.\nShapes.Range\n(varTemp).\nSelect\n'전체사진을 선택\nEnd If\nSet rngAll = Nothing\n'개체변수들\n초기화(메모리 비우기\n)\nSet rngShp = Nothing\nEnd Sub", "context": "엑셀에서 개체(object)를 선택하는 방법에는 여러가지가 있다. 대개 Ctrl + 마우스, 개체선택 도구, 바로가기(F5) 등을 이용해서 한다. 아래의 코드는 여러개의 개체 중에 사진만 선택을 하는 기능.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1248) 선택영역의 사진만 선택하기 (엑셀 VBA 매크로)\n재생\n1,791\n재생 (space/k)\n재생\n00:30\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:30\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해..."}
{"instruction": "Excel VBA code for: (1249) 각 페이지에 테두리 그려 인쇄하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub draw_Borders_Around()\n'메인 프로시저\nDim strMsg As String\n'메시지창 결과를 넣을 변수\nDim intCnt As Integer\n'전체 인쇄 페이지 개수 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim rngP As Range\n'각 페이지 영역을 넣을 변수\nstrMsg =\nMsgBox\n(\"마지막 셀을 선택하셨나요?\", vbYesNo, \"셀선택 주의\")\nIf strMsg =\nvbNo\nThen Exit Sub\n'No를 선택시 매크로 종료\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n.Calculation = xlCalculationManual\n'셀 자동계산을 수동으로 전환\nActiveCell.Offset(-1) = \" \"\n'현재셀에 공백(space)를 하나 입력\nWith ActiveSheet\n'현재 시트에서\nintCnt = .\nHPageBreaks.Count\n'수평 페이지 구분선 개수를 변수에 넣음\nIf intCnt = 0 Then\n'인쇄할 페이지가 1페이지면\nSet rngP = Range(Cells(1, 1), Cells(ActiveCell.Row + 1, 1))\n'첫 페이지 1열을 추출해 변수에 넣음\nCall\ndraw_Outline(rngP)\n'테두리 그리는 하위 프로시저 호출\nElseIf intCnt = 1 Then\n'인쇄할 페이지가 2페이지면\nSet rngP = Range(Cells(1, 1), .HPageBreaks(1).\nLocation\n.Address)\n'첫 페이지 첫 열을 변수에 넣음\nCall draw_Outline(rngP)\n'테두리 그리는 하위 프로시저 호출\nSet rngP = Range(Range(.HPageBreaks(intCnt).Location.Address), _\nCells(ActiveCell.Row + 1, 1))\n'마지막 페이지 첫 열을 변수에 넣음\nCall draw_Outline(rngP)\nElse\n'인쇄할 페이지가 2페이지 넘어가면\nSet rngP = Range(Cells(1, 1), .HPageBreaks(1).Location.Address)\n'첫 페이지 첫 열을 변수에 넣음\nCall draw_Outline(rngP)\nFor i = 1 To intCnt - 1\n'전체 페이지 개수 - 1 만큼 반복\nSet rngP = Range(.HPageBreaks(i).Location.\nAddress\n, _\n.HPageBreaks(i + 1).Location.Address)\n'처음과 마지막 페이지 이외의 페이지에서 첫열을 변수에 넣음\nCall draw_Outline(rngP)\nNext i\nSet rngP = Range(Range(.HPageBreaks(intCnt).Location.Address), _\nCells(ActiveCell.Row + 1, 1))\n'마지막 페이지 첫 열을 변수에 넣음\nCall draw_Outline(rngP)\nEnd If\nActiveSheet.\nPrintPreview\n'인쇄 미리보기\n'ActiveSheet.\nPrintOut\n'(윗행 삭제하고 주석 제거시 실제 인쇄)\nEnd With\nSet rngP = Nothing\n'개체변수 초기화(메모리 비우기)\n.Calculation = xlCalculationAutomatic\n'셀 수동계산을 자동으로 복원\n.ScreenUpdating = True\n'화면 업데이트 복원\nEnd With\nEnd Sub\n\nPrivate Sub draw_Outline(rngP As Range)\n'각 페이지에 외곽 테두리 넣을 하위 프로시저\nDim colsCnt As Integer\n'인쇄영역의 전체 열 개수 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\ncolsCnt = 9\n'인쇄영역의 전체 열 개수(필요 시 수정)\nSet rngP = rngP.Resize(rngP.Rows.Count - 1, colsCnt)\n'테두리 그려진 영역을 변수에 넣음\nFor i = 7 To 10\n'7 ~ 10까지 반복\nrngP.\nBorders(i).LineStyle = 1\n'복수영역 바깥쪽에 상/하/좌/우에 테두리\nNext i\nEnd Sub", "context": "각 페이지에 테두리를 그려 인쇄해보려고 여러 가지를 시도하였으나 많은 문제점에 부닥쳤다. 특히 페이지가 1열로 되어 있는게 아니고 복수의 열로 되어 있으면 너무 복잡하여 하다가 그만두었다. 그런데,\n1열로 된 경우\n간단할지 알았는데 이것마저 걸리적 거리는게 많았다. 특히, 아래와 같이 병합한 셀이 그 페이지의 마지막 행에서 잘릴 경우 선을 그을 방법이 없다.\n또한, 인쇄할 마지막 셀의 위치를 찾는 것도 어렵다. 하지만, 아래 동영상에서 보는 것과 같이, 마지막 셀을 수동으로 선택해야 하지만, 일반적인 경우에는 각 페이지에 테두리를 넣을 수 있다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1249) 각 페이지에 테두리 그려 인쇄하기 (엑셀 VBA 매크로)\n재생\n2,315\n재생 (space/k)\n재생\n00:46\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:46\n실시간\n설정\n전체 화면 (f)\n해상도\n27..."}
{"instruction": "Excel VBA code for: (1250) 중복된 데이터 모두 삭제하고 유일한 행만 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Dupes_Multiple_Columns()\n'-------------------------------------------------------\n'  Sheet2에 데이터 임시로 복사후 중복행을 삭제하는 코드\n'-------------------------------------------------------\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim j As Integer\n'열 개수만큼 반복할 변수\nDim i As Long\n'중복행 개수 구할 변수\nDim cnt As Long\n'카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.\nClearContents\n'Sheet2의 기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Cells(1, 1)\n'데이터를 복사\n.\nActivate\n'활성화\nEnd With\nSet rngAll = ActiveSheet.\nUsedRange\n'전체 영역을 변수에 넣음\nrowsCnt = rngAll.Rows.Count\n'전체 행 개수를 변수에 넣음\ncolsCnt = rngAll.Columns.Count\n'전체 열개수를 변수에 넣음\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nFor j = 1 To colsCnt\n'전체 열 개수만큼 반복\nIf Cells(r, j) = Cells(r + 1, j) Then\n'만약 각 열의 위아래 값이 일치하면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nElse\n'위아래가 다른 경우\nExit For\n'For 구문 종료\nEnd If\nNext j\nIf cnt = colsCnt Then\n'각 행이 바로 아래 행과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nIf i <> 0 Then\n'위아래 중복행이 있다면\nCells(r - i, 1).Resize(i + 1, colsCnt).ClearContents\n'중복행을 삭제\ni = 0\n'재사용 위하여 초기화\nEnd If\nEnd If\ncnt = 0\n'재사용 위하여 카운터 초기화\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\n'---------------------------------------------------------------\n'  중복 삭제 후 남은 데이터를 배열에 넣어 Sheet3로 이동하는 코드\n'---------------------------------------------------------------\nDim varTemp()\n'중복 삭제 후 남은 데이터 넣을 배열변수\nDim rngC As Range\n'A열 각 셀을 넣을 변수\nDim k As Long\n'반복 구문에 사용할 변수\nDim y As Long\n'배열위치 1씩 늘려갈 변수\nReDim\nvarTemp(1 To rowsCnt, 1 To colsCnt)\n'배열크기 재지정\nFor Each rngC In rngAll.Resize(, 1)\n'A열 각 셀을 순환\nIf\nNot IsEmpty\n(rngC) Then\n'각 셀이 빈셀이 아니라면\ny = y + 1\n'배열 위치 1씩 늘려감\nFor k = 1 To colsCnt\n'열 개수만큼 반복\nvarTemp(y, k) = rngC.Offset(, k - 1)\n'셀 값을 배열에 넣음\nNext\nEnd If\nNext rngC\nWith Sheets(3)\n'Sheet3에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\n.Activate\n'활성화\n.Cells(1, 1).Resize(rowsCnt, colsCnt) = varTemp\n'배열값을 시트에 뿌림\n.Columns.\nAutoFit\n'열너비 자동맞춤\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "중복된 데이터는 모두 삭제하고 중복되지 않은 데이터만 추출하는 기능. 데이터는 오름 또는 내림차순으로\n정렬된 것을 기준\n으로 함. 참고로 아래의 코드는\n50,000 행에 약 4.7초\n정도 소요.\n매크로 실행 전 (구분하기 쉽도록 중복되지 않은 행은 옅은 초록색으로 표시하였으며, Sheet2와 Sheet3은 비어 있는 상태)\n매크로 실행 후 Sheet3의 결과\nOption Explicit\nSub remove_Dupes_Multiple_Columns()\n'-------------------------------------------------------\n'  Sheet2에 데이터 임시로 복사후 중복행을 삭제하는 코드\n'-------------------------------------------------------\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣..."}
{"instruction": "Excel VBA code for: (1251) 행열 변환하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub transpose_Three_Times()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim c As Integer\n'반복구문에 사용할 변수\nDim rngT As Range\n'복사될 기준 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\n.Columns(1).\nNumberFormatLocal\n= \"yyyy-mm-dd\"\n'A열 서식 날짜로\n.Cells(1, 1).Resize(, 3) =\nArray\n(\"날짜\", \"이름\", \"별명\")\n'제목 복사\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'A열 각셀순환\nSet rngT = .Cells(Rows.Count, \"A\").\nEnd(3)(2)\n'각 행의 복사될 기준위치\nrngT.Resize(3) = rngC\n'날짜 복사\nFor c = 1 To 3\n'3회 반복\nrngT.Offset(c - 1, 1).Resize(, 2) = _\nrngC.Offset(, (c - 1) * 2 + 1).Value\n'이름, 나이 복사\nNext c\nNext rngC\n.Columns.\nAutoFit\n'열너비 자동 맞춤\n.Activate\n'활성화\nEnd With\nSet rngT = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1행에 3번씩 반복 입력된 데이터를 행열변환하는 기능.\n매크로 실행 전 (Sheet2는 비어 있음)                                        매크로 실행 후 결과\nOption Explicit\nSub transpose_Three_Times()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim c As Integer\n'반복구문에 사용할 변수\nDim rngT As Range\n'복사될 기준 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\n.Columns(1).\nNumberFormatLocal\n= \"yyyy-mm-dd\"\n'A열 서식 날짜로\n.Cells(1, 1).Resize(, 3) =\nArray\n(\"날짜\", \"이름\", \"별명\")\n'제목 복사\nFor Each rngC In Range(..."}
{"instruction": "Excel VBA code for: (1252) 색칠해진 가장 작은수로 부터의 거리평균 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Distance_Average()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngT As Range\n'최저값 영역을 넣을 변수\nDim cnt As Byte\n'카운터로 사용할 변수\nDim sngU As Single\n'거리의 합계를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Range(\"A1:F8\")\n'전체 영역을 변수에 넣음\nCells(1, 10) = 999999999\n'J1셀에 임시 값을 넣음\nSet rngT = Cells(1, 10)\n'J1셀을 변수에 넣음\n'------------------------------------\n' 최저값이 있는 셀을 추출하는 코드\n'------------------------------------\nFor Each rngC In rngAll\n'전체 영역 각 셀을 순환\nIf rngC.\nInterior.ColorIndex = 3\nThen\n'셀이 빨간색이면\ncnt = cnt + 1\n'카운터 1씩 늘려감\nIf rngC < rngT Then\n'기존값보다 작으면\nSet rngT = rngC\n'새로운 셀을 최저값 변수에 넣음\nEnd If\nEnd If\nNext rngC\nIf cnt > 1 Then\n'색칠해진 셀이 2개 이상이면\n'-------------------------------------------------------\n' 최저값 셀과 나머지 색칠해진 셀간의 거리 구하는 코드\n'-------------------------------------------------------\nFor Each rngC In rngAll\n'전체 영역 각 셀을 순환\nIf rngC <> rngT And _\nrngC.Interior.ColorIndex = 3 Then\n'각 셀이 최저값 셀이 아니고 빨간색이면\nsngU = sngU +\nSqr\n((rngC.\nRow\n- rngT.Row) ^ 2 + _\n(rngC.\nColumn\n- rngT.Column) ^ 2)\n'각 숫자간의 거리를 축적해감\nEnd If\nNext rngC\nMsgBox rngT.\nAddress(0, 0)\n& \"셀로부터 다른 \" & cnt - 1 _\n& \"개 셀까지의 거리 평균은 \" &\nvbCr\n& vbCr _\n&\nFormat\n(sngU / (cnt - 1), \"#0.00\") & \"    입니다.\"\n'평균거리 메시지로 출력\nElse\n'색칠해진 셀이 2개 미만이면\nMsgBox\n\"색칠해진 셀의 개수가 1개 이하입니다.\"\n'메시지 출력\nEnd If\nCells(1, 10).ClearContents\n'J1의 임시값 삭제\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "색칠해진 숫자들 중 가장 작은 숫자(아래는 8)로 부터 나머지 숫자들까지의 거리 평균을 구하는 기능. 즉, 8→11, 8→21, 8→31, 8→35, 8→40 까지의 거리 평균. 예를 들어, 8(좌표 2, 2)에서 40(좌표 7, 4) 까지의 거리는 SQRT((7-2)^2 + (4-2)^2). 색칠해진 개수는 5개가 될 수도 있고 20 개가 될 수도 있음.\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub find_Distance_Average()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngT As Range\n'최저값 영역을 넣을 변수\nDim cnt As Byte\n'카운터로 사용할 변수\nDim sngU As Single\n'거리의 합계를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Range(\"A1..."}
{"instruction": "Excel VBA code for: (1253) Range(\"셀범위\").Dirty 의 뜻 (엑셀 VBA 매크로)", "input": "", "output": "Sub dirty_Method()\nRange(\"A1\").Value = 1                           'A1셀에 1 입력\nRange(\"A2\").Value = 2                           'A2셀에 2 입력\nRange(\"A3\").Formula = \"=A1+A2\"            'A3셀에 A1 + A2 입력\nActiveWorkbook.Save                            '활성화된 파일 저장\nRange(\"A1:A3\").\nDirty\n'A1:A3 영역에 dirty 메서드 실행\nActiveSheet.\nCalculate\n'전체시트 재계산\nActiveWorkbook.Close                           '활성화된 파일 닫기\nEnd Sub", "context": "알고 계시는 것처럼 엑셀에서의 계산 모드는\n자동\n과\n수동\n이 있다. 일반적으로 자동모드로 사용하며, 이 경우 특정셀의 재계산 시, 엑셀이 재계산이 필요하다고 인식하는 모든 셀이 재계산된다. 수동모드는 사용자가 F9(Shift + F9, Ctrl + Alt + Shift + F9) 키를 클릭하거나 하여 강제로 셀의 계산을 강요하지 않는 한 재계산을 하지 않는다.\n자동으로 설정된 모습\nVBA의 메서드 중에\nDirty 메서드\n라는 것이 있다. Range(\"A1:A3\")\n.Dirty\n와 같이 사용하며, 이 경우\n지정된 범위에서 값의 변경이 없더라도 셀의 재계산 시\n반드시 지정된 셀 범위를 무조건\n재계산\n한다. 아래 코드의 경우, Range(\"A1:A3\").Dirty 행이 없을 경우, 마지막행에서 파일 닫기를 하면 파일저장 여부를 묻는 창이 나타나지 않지만, Range(\"A1:A3\").Dirty 코드에 의하여 A1:A3 셀이 재계산되어 파일을 닫으려 할 경우 파일이 변경된 것으로 간주하고 파..."}
{"instruction": "Excel VBA code for: (1254) 시간이 5분 간격 아닌 곳에 행 삽입하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_The_Time_Gap()\n'메인 프로시저\nDim y As Long\n'배열크기 늘려갈 변수\nDim r As Long\n'행 늘려갈 변수\nDim var() As Single\n'배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).UsedRange.ClearContents\n'Sheet2의 기존 데이터 삭제\nr = 2\n'2행부터 시작\nDo\n'다음을 실행\nDo\n'다음을 실행\nIf\nFormat\n(Cells(r + 1, 2) - Cells(r, 2), \"hh:mm:ss\") = \"00:05:00\" Then\n'B열 위아래가 5분 차이면\n'--------------------------------------\n' 시간이 5분 간격일 때 배열에 넣는 코드\n'--------------------------------------\nvar = fill_Array(var(), r, y)\n'배열에 값을 채워감\nElse\n'B열 위아래가 5분 차이 이상이 난다면\n'-----------------------------------------------\n' 시간이 5분 간격이 넘을 때 윗행 배열에 넣는 코드\n'-----------------------------------------------\nvar = fill_Array(var(), r, y)\n'배열에 값을 채워감\n'--------------------------------\n' 삽입하는 행 배열에 넣는 코드\n'--------------------------------\nvar = fill_Array2(var(), r, y)\n'배열에 값을 채워감\nEnd If\nr = r + 1\n'행을 1씩 늘려감\nLoop Until Cells(r, 1) <> Cells(r + 1, 1)\n'날짜가 달라질 때까지 무한 반복\n'-------------------------------------------------\n' 날짜가 바뀌는 제일 마지막 행을 배열에 넣는 코드\n'-------------------------------------------------\nvar = fill_Array(var(), r, y)\n'배열에 값을 채워감\nr = r + 1\n'행을 1씩 늘려감\nLoop Until Cells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nWith Sheets(2)\n'Sheet2에서\nRange(\"A1:F1\").\nCopy\n.Cells(1, 1)\n'제목 복사\n.Columns(1).\nNumberFormatLocal\n= \"yyyy-mm-dd\"\n'A열을 날짜로\n.Columns(2).NumberFormatLocal = \"h:mm;@\"\n'B열을 시간으로\n.Cells(2, 1).Resize(\nUBound\n(var, 2), UBound(var, 1)) = _\nApplication\n.\nTranspose\n(var)\n'배열값을 행열 변환하여 Sheet2에 뿌림\n.Columns.AutoFit\n'열너비 자동맞춤\n.Columns(\"C\").ClearContents\n'C열 0 삭제\n.Activate                                             '\n활성화\nEnd With\nEnd Sub\n\nPrivate Function fill_Array(var()\nAs Single, ByVal r As Long, y As Long)\n'5분 차이날때 배열에 값 넣을 함수\nDim i As Integer\n'반복구문에 사용할 변수\ny = y + 1\n'배열크기 1씩 늘려감\nFor i = 1 To 6\n'6회 반복\nReDim Preserve\nvar(1 To 6, 1 To y)\n'기존값 유지하며 배열크기 재지정\nvar(i, y) = Cells(r, i)\n'배열에 행 값을 넣음\nNext i\nfill_Array = var\n'배열값 함수에 돌려줌\nEnd Function\n\nPrivate Function fill_Array2(var()\nAs Single, ByVal r As Long, y As Long)\n'5분이상 차이날때 배열에 값 넣을 함수\nDim startT As Single\n'5분이상 차이날 때 윗행 시간을 넣을 변수\nDim endT As Single\n'5분이상 차이날 때 아래행 시간을 넣을 변수\nConst\nstrT As String = \"00:05:00\"\n'5분을 넣을 변수\nDim midT As Single\n'5분씩 더해갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim cnt As Long\n'루프 방지용 카운터로 사용할 변수\nConst strF As String = \"hh:mm:ss\"\n'시간 포맷을 넣을 변수\nstartT = Cells(r, 2)\n'startT(시작시간)을 변수에 넣음\nendT = Cells(r + 1, 2)\n'endT(종료시간)을 변수에 넣음\nDo\n'다음을 실행\ny = y + 1\n'배열크기 1씩 늘려감\nReDim Preserve\nvar(1 To 6, 1 To y)\n'기존값 유지하며 배열크기 재지정\nmidT = midT +\nTimeValue\n(strT)\n'5분씩 늘려감\nvar(1, y) = Cells(r, 1)\n'배열에 날짜 값을 넣음\nvar(2, y) = Cells(r, 2) + midT\n'배열에 시간 값을 넣음\nFor i = 4 To 6\n'3회 반복\nvar(i, y) = 0\n'배열에 0 걊을 넣음\nNext i\n'----------------------------------------------\n' 에러가 있어 Loop에 걸리는 것을 방지하는 코드\n'----------------------------------------------\ncnt = cnt + 1\n'Loop 방지용 카운터를 1씩 더해감\nIf cnt > 1000 Then\n'에러로 1000 회 반복하였다면\nMsgBox Cells(r, 2).Address(0, 0) & \" 데이터에 오류가 있습니다.\"\nEnd\n'매크로 종료\nEnd If\nstartT = startT + TimeValue(strT)\n'startT(시작시간)을 5분씩 늘려감\nLoop Until Format(startT + TimeValue(strT), strF) = Format(endT, strF)\n'endT(종료시간) - 5분 이 될때까지 무한반복\nfill_Array2 = var\n'배열값 함수에 돌려줌\nEnd Function", "context": "B열의 시간이 5분 간격이 아닌 곳에 행을 삽입하고 날짜와 시간을 입력하고 D:F열 까지는 0으로 채우는 기능. 물론 행삽입을 하면 코드는 간단하지만 속도가 떨어지므로 배열에 넣었다가 Sheet2에 뿌리는 방법을 택하여 여러가지 공부해본 코드. 배열에 넣었다가 셀에 뿌리므로 당연히 행삽입 코드보다는 훨씬 빠르지만 코드가 너무 늘어진 느낌.\n매크로 실행 전 (Sheet2는 비어 있음. 시간 간격이            매크로 실행 후 결과 (삽입된 행 알아보기\n5분이 아닌행 알아보기 쉽도록 색으로 채워표시함)           쉽도록 색과 테두리 수작업으로 넣음)\nOption Explicit\nSub fill_The_Time_Gap()\n'메인 프로시저\nDim y As Long\n'배열크기 늘려갈 변수\nDim r As Long\n'행 늘려갈 변수\nDim var() As Single\n'배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지..."}
{"instruction": "Excel VBA code for: (1255) 시간이 5분 간격 아닌 곳에 행 삽입하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_The_Time_Gap2()\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'Sheet2의 기존 데이터 삭제\nr = 2\n'2행부터 시작\nDo\n'다음을 실행\nDo\n'다음을 실행\nIf\nFormat\n(Cells(r + 1, 2) - Cells(r, 2),\n\"hh:mm:ss\")\n= \"00:05:00\" Then\n'B열 위아래가 5분 차이면\n'-----------------------------------------\n' 시간이 5분 간격일 때 데이터 옮기는 코드\n'-----------------------------------------\n.Cells(Rows.Count, \"A\").\nEnd(3)(2)\n.Resize(, 6) = _\nCells(r, 1).Resize(, 6).Value\nElse\n'B열 위아래가 5분 차이 이상이 난다면\n'----------------------------------------------------\n' 시간이 5분 간격이 넘을 때 윗행 데이터 복사하는 코드\n'----------------------------------------------------\n.Cells(Rows.Count, \"A\").End(3)(2).Resize(, 6) = _\nCells(r, 1).Resize(, 6).Value\n'-------------------------------------\n'  삽입하는 행의 데이터 입력하는 코드\n'-------------------------------------\nCall\nfill_Array(r)\n'행을 삽입하는 하위 프로시저 실행\nEnd If\nr = r + 1\n'행을 1씩 늘려감\nLoop Until\nCells(r, 1) <> Cells(r + 1, 1)\n'날짜가 달라질 때까지 무한 반복\n'-------------------------------------------------\n' 날짜가 바뀌는 제일 마지막 행 데이터 복사하는 코드\n'-------------------------------------------------\n.Cells(Rows.Count, \"A\").End(3)(2).Resize(, 6) = _\nCells(r, 1).Resize(, 6).Value\nr = r + 1\n'행을 1씩 늘려감\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nRange(\"A1:F1\").\nCopy\n.Cells(1, 1)\n'제목 복사\n.Columns(1).\nNumberFormatLocal\n= \"yyyy-mm-dd\"\n'A열을 날짜로\n.Columns(2).NumberFormatLocal = \"h:mm;@\"\n'B열을 시간으로\n.Columns.\nAutoFit\n'열너비 자동맞춤\n.Activate\n'활성화\nEnd With\nEnd Sub\n\nPrivate Sub fill_Array(ByVal r As Long)\n'5분이상 차이날때 빈행 삽입하는 코드\nDim startT As Single\n'5분이상 차이날 때 윗행 시간을 넣을 변수\nDim endT As Single\n'5분이상 차이날 때 아래행 시간을 넣을 변수\nConst\nstrT As String = \"00:05:00\"\n'5분을 넣을 변수\nDim midT As Single\n'5분씩 더해갈 변수\nDim rngT As Range\n'복사될 위치 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim cnt As Long\n'루프 방지용 카운터로 사용할 변수\nConst strF As String = \"hh:mm:ss\"\n'시간 포맷을 넣을 변수\nstartT = Cells(r, 2)\n'startT(시작시간)을 변수에 넣음\nendT = Cells(r + 1, 2)\n'endT(종료시간)을 변수에 넣음\nDo\n'다음을 실행\nmidT = midT +\nTimeValue\n(strT)\n'5분씩 늘려감\nSet rngT = Sheets(2).Cells(Rows.Count, \"A\").End(3)(2)\nrngT = Cells(r, 1)\n'날짜 값을 넣음\nrngT(1, 2) = Cells(r, 2) + midT\n'시간 값을 넣음\nFor i = 4 To 6\n'3회 반복\nrngT(1, i) = 0\n'D:F열에 0 값을 넣음\nNext i\n'----------------------------------------------\n' 에러가 있어 Loop에 걸리는 것을 방지하는 코드\n'----------------------------------------------\ncnt = cnt + 1\n'Loop 방지용 카운터를 1씩 더해감\nIf cnt > 1000 Then\n'에러로 1000 회 반복하였다면\nMsgBox Cells(r, 2).Address(0, 0) & \" 데이터에 오류가 있습니다.\"\nEnd\n'매크로 종료\nEnd If\nstartT = startT + TimeValue(strT)\n'startT(시작시간)을 5분씩 늘려감\nLoop Until\nFormat(startT + TimeValue(strT), strF) = Format(endT, strF)\n'endT(종료시간) - 5분 이 될때까지 무한반복\nEnd Sub", "context": "B열의 시간이 5분 간격이 아닌 곳에 행을 삽입하고 날짜와 시간을 입력하고 D:F열 까지는 0으로 채우는 기능. 물론 행삽입을 하면 코드는 간단하지만 속도가 떨어지므로 Sheet2로 종단셀을 이용하여 데이터를 옮기도록 함.\n매크로 실행 전 (Sheet2는 비어 있음. 시간 간격이            매크로 실행 후 결과 (삽입된 행 알아보기\n5분이 아닌행 알아보기 쉽도록 색으로 채워표시함)           쉽도록 색과 테두리 수작업으로 넣음)\nOption Explicit\nSub fill_The_Time_Gap2()\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'Sheet2의 기존 데이터 삭제\nr = 2\n'2행부터 시작\nDo\n'다음을 실행\nDo\n'다음을 실행\nIf\nFormat\n(Cells(r + 1, 2)..."}
{"instruction": "Excel VBA code for: (1258) 여러 바꿀 내용을 전체 시트에 적용하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub multi_Sheets_Replacement()\nDim\nvarC\n'Before, After 영역 넣을 변수\nDim y As Long\n'배열의 행 방향 개수 넣을 변수\nDim\nvarA\n'각 시트의 전체(A)ll 데이터 넣을 배열변수\nDim rowsCnt As Integer\n'행의 개수 넣을 변수\nDim colsCnt As Long\n'열의 개수 넣을 변수\nDim s As Integer\n'시트(s)heet 의 개수 늘려갈 변수\nDim c As Long\n'열(c)olumn 방향 늘려갈 변수\nDim r As Long\n'행(r)ow 방향 늘려갈변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nvarC = Range(\"A2\", Cells(Rows.Count, \"B\").End(3))\n'제목 제외한 A:B열을 변수에 넣음\nFor s = 2 To\nSheets.Count\n'Main 시트 제외한 2 ~ 마지막 시트까지 반복\nWith Sheets(s)\n'각 시트에서\nvarA = .\nUsedRange\n'사용영역을 배열에 넣음\nrowsCnt = .UsedRange.\nRows.Count\n'행 개수를 변수에 넣음\ncolsCnt = .UsedRange.\nColumns.Count\n'열 개수를 변수에 넣음\nFor r = 1 To rowsCnt\n'행방향 반복\nFor c = 1 To colsCnt\n'열방향 반복\nFor y = 1 To\nUBound\n(varC, 1)\n'varC 배열의 행 개수만큼 반복\nIf varA(r, c) <>\nEmpty\nThen\n'배열내의 값이 Empty가 아니라면\nIf varA(r, c) = varC(y, 1) Then\n'varA 배열과 varC 배열값 일치 시\nvarA(r, c) = varC(y, 2)\n'varA 배열에 바꿀문자를 넣음\nEnd If\nEnd If\nNext y\nNext c\nNext r\n.UsedRange = varA\n'각 시트에 배열값을 뿌림\nEnd With\nNext s\nMsgBox \"매크로가 완료되었습니다.\"\n'매크로 완료 메시지 출력\nEnd Sub", "context": "복수의 시트가 있고, 바꿀 내용 또한 복수로 있을 때 이를 배열에 넣어 빠르게 바꾸는 기능. 아래 동영상에서 보듯 순식간에 전체 데이터 시트의 값들이 바뀐다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1258) 여러 바꿀 내용을 전체 시트에 적용하기 1 (엑셀 VBA 매크로)\n재생\n1,302\n재생 (space/k)\n재생\n00:38\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:38\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기..."}
{"instruction": "Excel VBA code for: (1259) 여러 바꿀 내용을 전체 시트에 적용하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub multi_Sheets_Replacement2()\nDim varC\n'Before, After 영역 넣을 변수\nDim y As Long\n'배열의 행 방향 개수 넣을 변수\nDim varA\n'각 시트의 전체(A)ll 데이터 넣을 배열변수\nDim rowsCnt As Integer\n'행의 개수 넣을 변수\nDim colsCnt As Long\n'열의 개수 넣을 변수\nDim s As Integer\n'시트(s)heet 의 개수 늘려갈 변수\nDim c As Long\n'열(c)olumn 방향 늘려갈 변수\nDim r As Long\n'행(r)ow 방향 늘려갈변수\nDim str As String\n'바뀐 값을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nvarC = Range(\"A2\", Cells(Rows.Count, \"B\").End(3))\n'제목 제외한 A:B열을 변수에 넣음\nFor s = 2 To\nSheets.Count\n'Main 시트 제외한 2 ~ 마지막 시트까지 반복\nWith Sheets(s)\n'각 시트에서\nvarA = .\nUsedRange\n'사용영역을 배열에 넣음\nrowsCnt = .UsedRange.\nRows.Count\n'행 개수를 변수에 넣음\ncolsCnt = .UsedRange.\nColumns.Count\n'열 개수를 변수에 넣음\nFor r = 1 To rowsCnt\n'행방향 반복\nFor c = 1 To colsCnt\n'열방향 반복\nFor y = 1 To\nUBound\n(varC, 1)\n'varC 배열의 행 개수만큼 반복\nIf varA(r, c) <>\nEmpty\nThen\n'배열내의 값이 Empty가 아니라면\nstr =\nReplace$\n(varA(r, c), varC(y, 1), varC(y, 2))\n'문자가 일치할 경우 바꾸어 변수에 넣음\nvarA(r, c) = str\n'배열에 바뀐 값을 넣음\nEnd If\nNext y\nNext c\nNext r\n.UsedRange = varA\n'각 시트에 배열값을 뿌림\nEnd With\nNext s\nMsgBox \"매크로가 완료되었습니다.\"\n'매크로 완료 메시지 출력\nEnd Sub", "context": "복수의 시트가 있고, 바꿀 내용 또한 복수로 있을 때 이를 배열에 넣어 빠르게 바꾸는 기능. 아래 동영상에서 보듯 순식간에 전체 데이터 시트의 값들이 바뀐다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1259) 여러 바꿀 내용을 전체 시트에 적용하기 2 (엑셀 VBA 매크로)\n재생\n1,018\n재생 (space/k)\n재생\n00:38\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:38\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기..."}
{"instruction": "Excel VBA code for: (1261) 폴더내 모든 파일, 모든 시트, 특정열의 특정 검색어 행 추출 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_In_A_Column_In_Folder()\nDim sht As Worksheet\n'현재시트 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim wkBk As Workbook\n'각 파일을 넣을 변수\nDim wkSht As Worksheet\n'각 시트를 넣을 변수\nDim strAddr As String\n'처음 검색하여 찾은 셀의 주소 넣을 변수\nDim C As Range\n'검색에 일치한 영역(C)ell을 넣을 변수\nDim rngLast As Range\n'A열 마지막(Last) 행 넣을 변수\nDim rngR As Range\n'검색에 일치한 행(R)ow 전체를 넣을 변수\nDim rngT As Range\n'각 행의 복사될 위치(T)arget 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet sht = ActiveSheet\n'현재 시트를 변수에 넣음\nsht.UsedRange.ClearContents\n'기존 데이터 삭제\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName =\nDir\n(strPath & \"\n*.xls*\n\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nSet wkBk = Workbooks.\nOpen\n(strPath & fileName)\n'파일을 열고 변수에 넣음\nFor Each wkSht In wkBk.\nWorksheets\n'열린파일 각 시트를 순환\nWith wkSht\n'각시트 A열에서\nSet rngLast = .Cells(Rows.Count, \"A\").End(3)\n'A열 마지막 행을 변수에 넣음\nSet C = .Columns(\"A\").\nFind\n(What:=\"가\", After:=rngLast, Lookat:=\nxlWhole\n)\n'마지막행 이후 전체일치하는 값 찾아 C에 넣고\nIf Not C Is Nothing Then\n'만일 일치하는 데이터가 있으면\nstrAddr = C.\nAddress\n'첫 일치하는 주소를 strAddr에 넣고\nDo\n'다음을 실행\nSet rngR = .Range(.Cells(C.Row, \"A\"), _\n.Cells(C.Row, Columns.Count).End(1))\n'검색에 일치한 셀의 전체행을 변수에 넣음\nSet rngT = sht.Cells(Rows.Count, \"A\").End(3)(2)\nrngT = wkBk.\nName\n'파일 이름을 입력\nrngT.Offset(, 1) = wkSht.Name\n'시트 이름을 입력\nrngT.Offset(, 2).Resize(, rngR.Columns.Count) = rngR.Value\n'각 행의 데이터를 복사\nSet C = .Columns(\"A\").\nFindNext\n(C)\n'다음 일치하는 데이터를 찾아 변수에 넣고\nIf strAddr = C.Address Then Exit Do\n'일치하는 주소가 처음 일치한 셀이면 Do종료\nLoop While\nNot C Is Nothing\n'일치하는 데이터 없을때까지 무한 반복\nEnd If\nEnd With\nNext wkSht\nwkBk.Close False\n'열려진 파일을 닫음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nColumns.AutoFit\n'열너비 자동맞춤\nSet sht = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet wkBk = Nothing\nSet rngLast = Nothing\nSet C = Nothing\nSet rngR = Nothing\nSet rngT = Nothing\nEnd Sub", "context": "특정 폴더내에 여러개의 엑셀 2003 파일(.xls) 및 엑셀 2007/2010 파일(.xlsx)이 들어 있을 때, 모든 파일내에 있는 모든 시트의 A열에 있는 값들 중 값이 \"\n가\n\"인 행의 전체 데이터를 파일이름, 시트 이름과 함께 가져오는 기능. 일부만 일치(즉, \"가나\", \"나가다\" 등)하는 데이터를 가져오려면 코드를\nxlWhole\n에서\nxlPart\n로 수정 필요. 각 파일내의 열 개수가 다를 것을 대비하여 아래와 같이 코딩하였지만, 열개수가 동일한 경우 배열에 넣었다 뿌리는 것이 당연히 정답임.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1261) 폴더내 모든 파일, 모든 시트, 특정열의 특정 검색어 행 추출 (엑셀 VBA 매크로)\n재생\n3,245\n재생 (space/k)\n재생\n01:03\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:03\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용..."}
{"instruction": "Excel VBA code for: (1262) 문자 없는 빈열만 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub compress_Columns()\nDim rngA As Range\n'선택영역을 넣을 영역 변수\nDim rngU As Range\n'합쳐진 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet\nrngA = Selection\n'선택 영역을 변수에 넣음\nDo\n'다음을 실행\nIf rngA.Cells(1).Interior.ColorIndex = xlNone And _\nWorksheetFunction.CountA\n(rngA) = 0 Then\n'영역에 색이 없고 모두 빈셀이면\nIf rngU Is Nothing Then\n'rngU 가 비어 있다면\nSet rngU = rngA\n'rngA를 rngU에 넣음\nElse\n'rngU가 비어 있지 않다면\nSet rngU =\nUnion\n(rngU, rngA)\n'rngU와 rngA를 합쳐 rngU에 넣음\nEnd If\nEnd If\nSet rngA = rngA.Offset(, -1)\n'선택 영역을 왼쪽으로 1열씩 이동\nLoop Until\nrngA.Column = 2\n'열의 번호가 2가 될때까지 무한 반복\nIf Not rngU Is Nothing Then\n'rngU의 영역이 비어 있지 않다면\nrngU.\nEntireColumn.Delete\n'합쳐진 rngU 영역의 전체열을 삭제\nElse\n'rngU 영역이 비어 있다면\nMsgBox \"삭제할 영역이 없습니다.\"\n'메시지 출력\nEnd If\nSet rngA = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngU = Nothing\nEnd Sub", "context": "문자가 한 행도 없는 빈 열만 삭제하는 기능. 선택영역을 왼쪽으로 한 칸씩 옮겨가며 색이 없거나 빈 열만을 전부 변수에 합쳐 넣은 뒤 이를 한 번에 삭제.\n매크로 실행 전 제일 오른쪽 행을 선택한 모습\n매크로 실행 후 결과 (전체가 비어 있는 열만 삭제)\nOption Explicit\nSub compress_Columns()\nDim rngA As Range\n'선택영역을 넣을 영역 변수\nDim rngU As Range\n'합쳐진 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet\nrngA = Selection\n'선택 영역을 변수에 넣음\nDo\n'다음을 실행\nIf rngA.Cells(1).Interior.ColorIndex = xlNone And _\nWorksheetFunction.CountA\n(rngA) = 0 Then\n'영역에 색이 없고 모두 빈셀이면\nIf rngU Is Nothing Then\n'rngU 가 비어 있다면\nS..."}
{"instruction": "Excel VBA code for: (1263) 건너 뛰면서 복수의 열 열너비 조절하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub change_ColumnWidth_Skipping_Columns()\nDim input_Value As String\n'입력값을 넣을 변수\nConst\nsngMin As Integer =\n0\n'최솟값을 넣을 변수\nConst sngMax As Integer =\n255\n'최댓값을 넣을 변수\nDim msg As String\n'메시지 넣을 문자 변수\nDim intSkip As Integer\n'건너뛸 열의 개수 넣을 변수\nDim S As Range\n'선택(S)election된 셀 넣을 변수\nDim intCnt As Integer\n'전체 열개수 넣을 변수\nDim rngU As Range\n'영역을 합쳐갈 변수\nDim c As Integer\n'열방향 반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nintSkip = 3\n'건너뛸 열의 개수를 변수에 넣음\nSet S = ActiveCell\n'현재 활성화된 셀 영역을 변수에 넣음\nintCnt = ActiveSheet.UsedRange.Columns.Count\n'현재시트 사용영역의 열 개수 추출\n'-----------------------------------\n' 열너비를 숫자로 입력받는 코드\n'-----------------------------------\nDo\n'다음을 실행\ninput_Value =\nInputBox\n(sngMin & \" 과 \" & _\nsngMax & \" 사이의 숫자를 입력(소수도 가능).\")\n'입력창 값을 변수에 넣음\nIf input_Value = \"\" Then Exit Sub\n'입력값 없으면 매크로 중단\nIf\nIsNumeric\n(input_Value) Then\n'입력값이 숫자이면\nIf input_Value >= sngMin And input_Value <= sngMax Then\n'입력값이 최솟값보다 크거나 같고, 최댓값보다 작거나 같으면\nExit Do\n'Do 구문 종료\nEnd If\nEnd If\nmsg = \"번호입력 오류.\" & vbCr & vbCr\n'메시지창 내용 + 줄바꿈 2번\nmsg = msg & sngMin & \" 과 \" & sngMax & \" 사이의 숫자(소수 가능)를 입력.\"\n'메시지창 내용\nMsgBox\nmsg, vbCritical, \"입력오류\"\n'메시지 출력\nLoop\n'무한 반복\n'---------------------------------------\n' 열너비를 변경할 영역을 설정하는 코드\n'---------------------------------------\nFor c = 1 To intCnt\nStep intSkip\n'intSkip 만큼 건너 뛰면서 반복\nIf rngU Is Nothing Then\n'rngU가 비어 있다면\nSet rngU = S\n'S를 rngU에 넣음\nElse\n'rngU가 비어 있지 않다면\nSet rngU =\nUnion\n(rngU, S)\n'rngU와 S 영역을 합쳐 rngU에 넣음\nEnd If\nSet S = S.Offset(, intSkip)\n'S 영역을 오른쪽으로 intSkip 칸씩 이동\nNext c\n'----------------\n' 열너비를 변경\n'----------------\nIf Not rngU Is Nothing Then\n'rngU의 영역이 비어 있지 않다면\nrngU.\nColumnWidth\n= input_Value\n'합쳐진 rngU 영역의 열너비 변경\nEnd If\nEnd Sub", "context": "매크로 실행하면 값을 입력할 수 있는 입력창이 나타남. 입력창에 열너비 입력하면 3열마다 열너비를 변경하는 코드. intSkip = 2 로 변경 시 2열마다, intSkip = 5 로 변경 시 5열마다 열너비가 변경됨. 아래와 같은 코드는 '개인용 매크로 통합문서'에 넣고 단축키를 할당하여 사용하면 편리할 듯.\n매크로 실행 전 (A열의 아무 셀이나 선택한 모습)\n매크로 실행 후 나타나는 입력창\n매크로 실행 후 (\nintSkip = 3\n인 상태에서) 입력창에 10을 입력하여 3열마다 열너비를 변경한 결과\n매크로 실행전 B열을 선택       매크로 실행 후 (\nintSkip = 2\n인 상태에서)입력창에 10 입력한 결과\nOption Explicit\nSub change_ColumnWidth_Skipping_Columns()\nDim input_Value As String\n'입력값을 넣을 변수\nConst\nsngMin As Integer =\n0\n'최솟값을 넣을 변수\nConst sngMax A..."}
{"instruction": "Excel VBA code for: (1264) If Len(Dir(strPath, vbDirectory)) <> 0 Then 의 뜻 (엑셀 VBA 매크로)", "input": "", "output": "Sub mkDir_And_Save()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nstrPath = \"C:\\Temp\"\n'폴더의 경로\nIf Len(Dir(strPath, vbDirectory)) <> 0 Then\n'폴더 존재하면\nActiveWorkbook.SaveAs Filename:=strPath & \"\\\" & \"Test1.xlsx\"\n'현재 시트를 Test1.xlsx 으로 저장\nElse\n'폴더가 존재하지 않으면\nMkDir\nstrPath\n'폴더를 생성\nActiveWorkbook.SaveAs Filename:=strPath & \"\\\" & \"Test1.xlsx\"\n'현재 시트를 Test1.xlsx 으로 저장\nEnd If\nEnd Sub", "context": "If\nLen(Dir(strPath, vbDirectory)) <> 0 Then : If는\n조건문\n에 사용되며 설명할 것이 없음.\nIf\nLen\n(Dir(strPath, vbDirectory)) <> 0 Then : Len 함수는 length(길이)의 약자로 다음에 오는 괄호안 문자의 전체\n길이를 반환\n한다.\nIf Len\n(\nDir(strPath, vbDirectory)\n)\n<> 0 Then : Len 함수의 인수로서 이 괄호안의 개수가 Len 함수의 결과로 반환된다.\nIf Len(\nDir\n(strPath, vbDirectory)) <> 0 Then : Dir 함수는 directory의 약자로서 다음에 오는 괄호안의 마지막 인수인 vbDirectory의 종류에 따라\n파일이름, 폴더이름 등을 반환\n한다. 지금은 폴더(folder)라고 부르지만 예전 DOS 시절에는 폴더를 directory라고 불렀다.\nIf Len(Dir\n(\nstrPath, vbDirectory\n)\n) <> 0 Then :..."}
{"instruction": "Excel VBA code for: (1265) ADO SQL을 이용한 데이터 추출 (엑셀 VBA 매크로)", "input": "", "output": "Sub runSQL()\n'--------------------------------------------------\n'  VBE 도구(Tools) => 참조(References)에서\n'  Microsoft ActiveX Data Object Library 2.8 참조후\n'--------------------------------------------------\nDim strSQL As String\n'SQL 조건을 넣을 변수\nDim strConn As String\n'Connection 넣을 변수\nDim adoRS As\nADODB.Recordset\n'ADO Recordset 넣을 변수\nDim i As Integer\n'반복 구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nstrSQL = \"SELECT       대표자, 설립일, 종목 \" & _\n\"FROM          [Data$] \" & _\n\"WHERE        설립일 >= #2001-01-01#  AND 설립일 <= #2001-12-31# \" & _\n\"ORDER BY   대표자;\"\n'SQL 조건을 변수에 넣음\nstrConn = \"Provider=                      Microsoft.ACE.OLEDB.12.0;\" & _\n\"Data Source=                \" & ThisWorkbook.FullName & \";\" & _\n\"Extended Properties=     Excel 12.0;\"\n'연결 조건을 변수에 넣음\nSet adoRS =\nNew ADODB.Recordset\n'Early binding으로 ADO recordset을 변수에\nadoRS.\nOpen\nstrSQL, strConn, adOpenForwardOnly, adLockReadOnly, adCmdText\n'SQL 조건에 따라 연결하여 파일을 열기\nIf Not adoRS.\nEOF\nThen\n'파일의 마지막이 아니라 데이터가 존재하면\nWith Sheets(\"Query\")\n'Query라는 시트에서\n.Range(\"a1\").CurrentRegion.Clear\n'기존 데이터 삭제\nFor i = 0 To adoRS.\nFields\n.Count - 1\n'recordset의  필드 개수만큼 반복\n.Cells(1, i + 1).Value = adoRS.Fields(i).Name\n'각 필드 이름을 넣음\nNext\n.Range(\"a2\").\nCopyFromRecordset\nadoRS\n'데이터 복사\n.Columns.AutoFit\n'열너비 자동맞춤\n.Activate\n'활성화\nEnd With\nElse\nMsgBox \"자료가 없습니다\", 64, \"데이터 오류\"\n'메시지 출력\nEnd If\nadoRS.\nClose\n'recordset 닫음\nSet adoRS = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "전체 데이터에서 대표자, 설립일, 종목 필드 중 날짜가 2001년인 데이터를 추출하여 대표자를 기준으로 오름차순 정렬하는 기능.\n물론 아래의 기능은 VBA(고급필터 + 정렬)만을 이용해서도 가능하지만, 조건이 복잡해질 경우 엑셀의 필터/고급필터와 VBA(정규식) 등의 사용만으로는 한계가 있는 것 같아서 최근 시간이 날 때마다 ADO, SQL 관련된 내용을 조금씩 공부중임. 지금은 걸음마 단계지만 VBA를 공부하였던 것처럼 꾸준히 공부하여 언젠가 좋은 내용을 올렸으면 한다.\n매크로 실행 전 Data 시트 (Query 시트는 비어 있음)                 매크로 실행 후 결과\nOption Explicit\nSub runSQL()\n'--------------------------------------------------\n'  VBE 도구(Tools) => 참조(References)에서\n'  Microsoft ActiveX Data Object Library 2.8 참조후\n'--..."}
{"instruction": "Excel VBA code for: (1266) For Each와 배열(array) 이용한 검색의 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub search_In_Sheet()\n.......................................................................................\n3.46\n초\nDim rngAll As Range\n'A열 데이터 넣을 영역변수\nDim rngC As Range\n'A열 각 셀을 넣을 영역변수\nDim rngData As Range\n'C열 데이터 넣을 영역변수\nDim rngEach As Range\n'C열 각 셀을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Range(\"A1\", Cells(Rows.Count, \"A\").End(3))\n'A열을 변수에 넣음\nSet rngData = Range(\"C1\", Cells(Rows.Count, \"C\").End(3))\n'C열을 변수에 넣음\nFor Each\nrngC\nIn\nrngAll\n'A열 각 셀을 순환\nFor Each\nrngEach\nIn\nrngData\n'C열 각 셀을 순환\nIf rngC = rngEach Then\n'A열과 C열 값이 일치 시\nrngC.Next = rngEach.Next\n'B열에 D열 값을 입력\nExit For\n'For 구문 종료\nEnd If\nNext\nrngEach\nNext\nrngC\nEnd Sub\n\nSub search_In_Array()\n﻿\n...................................................................................\n0.20\n초\nDim varA\n'A:B 열을 넣을 배열 변수\nDim varC\n'C:D 열을 넣을 배열 변수\nDim varR\n'결과값 넣을 배열변수\nDim i As Long\n'반복구문에 사용할 변수\nDim j As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nvarA = Range(\"A1\", Cells(Rows.Count, \"A\").End(3)).Resize(, 2)\n'A:B열을 배열에 넣음\nvarC = Range(\"C1\", Cells(Rows.Count, \"D\").End(3))\n'C:D열을 배열에 넣음\nFor\ni = 1 To\nUBound(varA, 1)\n'1 ~ varA 배열 상한값까지 반복\nFor\nj = 1 To\nUBound(varC, 1)\n'1 ~ varC 배열 상한값까지 반복\nIf varA(i, 1) = varC(j, 1) Then\n'배열내 두 값이 일치하면\nvarA(i, 2) = varC(j, 2)\n'varA열의 오른쪽에 일치한 값 입력\nExit For\n'For 구문 종료\nEnd If\nNext\nj\nNext\ni\nReDim\nvarR(1 To UBound(varA, 1), 1 To 1)\n'(결과를 넣을) 배열크기 재지정\nFor i = 1 To UBound(varA, 1)\n'1 ~ varA 배열 상한값까지 반복\nvarR(i, 1) = varA(i, 2)\n'결과 배열에 값을 옮김\nNext i\nCells(1, 2).Resize(UBound(varA, 1), 1)\n= varR\n'배열 값을 B열에 뿌림\nEnd Sub", "context": "A열에는 1, 3, 5, .... 999 까지 입력되어 있고, C열에는 1, 2, 3, ... 2000까지, D열에는 d1, d2, d3, ...D2000 까지 입력된 상황. 아래의 두 코드는 A열과 C열이 일치하는 값을 찾아 D열의 값을 B열에 입력하는 동일한 기능을 함.\n첫 번째 코드는 For Each 중첩 구문을 사용하여 일치한 값을 셀에 바로 입력하는 것이며, 두 번째 코드는 A:B열과 C:D열을 각각 배열(array)에 넣고 배열내에서 검색한 뒤 결과를 또 다른 결과배열에 넣어 이를 한 번에 셀에 뿌리는 것으로 모든 것이 배열내 즉 메모리에서 일어난다.\n사용이 간편하여 첫 번째 코드와 같은 For Each 중첩구문을 많이 사용하였는데 역시 배열에 넣어 검색하고 한 번에 시트에 입력하는 것이 각 셀에 입력하는 것과 속도면에서 비교가 안될 정도로 빠르다.\n매크로 실행 전(아래로 데이터 더 있음)                     매크로 실행 후 결과(아래로 데이터 더 있음)\n..."}
{"instruction": "Excel VBA code for: (1269) 최초 시작일과 최후 종료일 찾기 (엑셀 VBA 매크로)", "input": "", "output": "Sub start_End_Date()\nDim colsCnt As Integer\n'전체 열 크기 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngA As Range\n'중복 영역을 넣을 변수\nDim y As Long\n'배열크기 늘려갈 변수\nDim varTemp()\n'배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\ncolsCnt = ActiveSheet.UsedRange.\nColumns.Count\n'전체 열개수 변수에 넣음\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nSet\nrngA = Cells(r - i, 3).Resize(i + 1, 2)\n'중복영역을 변수에 넣음\n'----------------------------------\n' 배열에 중복된 영역의 값을 넣음\n'----------------------------------\ny = y + 1\n'배열 크기 1씩 늘려감\nReDim Preserve\nvarTemp(1 To colsCnt, 1 To y)\n'배열크기 재지정\nvarTemp(1, y) = Cells(r, 1)\n'코드를 넣음\nvarTemp(2, y) = Cells(r, 2)\n'이름을 넣음\nvarTemp(3, y) =\nApplication.Min\n(rngA)\n'최초 시작일을 넣음\nvarTemp(4, y) =\nApplication.Max\n(rngA)\n'최후 종료일을 넣음\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\n'------------------------------------\n' 제목과 배열내 값을 Sheet2에 뿌림\n'------------------------------------\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'사용영역내 기존 데이터 삭제\nCells(1, 1).Resize(, colsCnt).Copy .[A1]\n'제목을 복사\n.Columns(\"C:D\").\nNumberFormatLocal\n=\n\"yyyy-mm-dd\"\n'C:D열 서식을 날짜로\n.Cells(2, 1).Resize(\nUBound\n(varTemp, 2), colsCnt) = _\nApplication.Transpose\n(varTemp)\n'배열값을 행열 변환하여 Sheet2에 뿌림\n.Columns.AutoFit\n'열너비 자동맞춤\n.Activate\n'활성화\nEnd With\nSet rngA = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "각 중복 코드(또는 이름) 구간의 최초 시작일과 최후 종료일을 찾는 기능. (데이터는 정렬되어 있는 것을 기준으로 하며, 찾을 날짜는 구분을 쉽게 하기 위하여 색으로 표시함)\n매크로 실행 전 (Sheet2 는 비어 있음)                       매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub start_End_Date()\nDim colsCnt As Integer\n'전체 열 크기 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngA As Range\n'중복 영역을 넣을 변수\nDim y As Long\n'배열크기 늘려갈 변수\nDim varTemp()\n'배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\ncolsCnt = ActiveSheet.UsedRange.\nColumns.Count\n'전체 열개수 변수에 넣음..."}
{"instruction": "Excel VBA code for: (1271) 선택영역을 랜덤(random)하게 뒤섞기 9 (엑셀 VBA 매크로)", "input": "", "output": "Sub random_Reshuffle_4()\nDim rowsCnt As Long\n'전체 행의 개수 넣을 변수\nDim colsCnt As Integer\n'전체 열의 개수 넣을 변수\nDim maxNo As Long\n'선택영역 셀 개수 넣을 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim varTemp()\n'임시배열로 사용할 배열변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nDim y As Long\n'행 방향 늘려갈 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim x As Integer\n'열 방향 늘려갈 변수\nDim varR()\n'결과 값을 넣을 배열 변수\nDim cnt As Long\n'카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nRandomize\n'랜덤값 발생기 초기화\n'(계속 새로운 랜덤 기준값 생성)\nWith Selection\n'선택영역에서\nIf .\nAreas\n.Count > 1 Then\n'2개 이상의 구역(area) 선택 시\nMsgBox \"선택 구역(area)은 1개만 선택\", 64, \"영역선택 오류\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nrowsCnt = .\nRows.Count\n'전체 행 개수를 변수에 넣음\ncolsCnt = .\nColumns.Count\n'전체 열 개수를 변수에 넣음\nmaxNo = .Count\n'선택영역 셀 개수를 변수에 넣음\nEnd With\nReDim\nvarTemp(1 To maxNo)\n'임시배열의 크기 재지정\nReDim varR(1 To rowsCnt, 1 To colsCnt)\n'결과 열의 크기 재지정\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = rngC\n'각 셀을 배열에 넣음\nNext rngC\ny = 1\nFor i = maxNo To 1\nStep -1\n'최댓값 부터 1씩 줄여가며 반복\nr = Int(\nRnd\n() * i) + 1\n'무작위 값을 추출\ncnt = cnt + 1\n'카운터를 늘려감\nIf cnt = colsCnt + 1 Then\n'카운터가 열개수에 도달하면\ny = y + 1\n'행을 1씩 늘려감\ncnt = 1\n'카운터 초기화\nx = 0\n'재사용 위하여 초기화\nEnd If\nx = x + 1\n'열방향 값을 1씩 늘려감\nvarR(y, x) = varTemp(r)\n'배열에 랜덤값을 채워감\nvarTemp(r) = varTemp(i)\n'배열 윗값을 추출된 위치에 채움\nNext i\nSelection = varR\n'결과배열 값을 선택영역에 뿌림\nEnd Sub", "context": "선택영역을 무작위로 섞어주는 기능. 빈 셀이 있어도 상관은 없지만 선택영역은 한 개의 구역(area)만을 선택해야함. 지금까지 해왔던 어떤 코드보다도 속도가 빠르다. 1,000 개의 열 x 1,000개의 행, 즉,\n1,000,000 개의 셀\n을 뒤 섞는데\n약 3.4초\n소요\n. 배열에 넣은 값을 무작위로 뒤 섞어 다시 결과배열에 넣었다가 셀에 한 번에 뿌리므로 속도는 정말 빠르지만, 아무래도 초보님들은 이해하기 쉽지 않을 것으로 생각된다.\n매크로 실행 전                                                        매크로 실행 후 결과\nOption Explicit\nSub random_Reshuffle_4()\nDim rowsCnt As Long\n'전체 행의 개수 넣을 변수\nDim colsCnt As Integer\n'전체 열의 개수 넣을 변수\nDim maxNo As Long\n'선택영역 셀 개수 넣을 변수\nDim rngC As Range\n'선택영역 각 ..."}
{"instruction": "Excel VBA code for: (1272) 특정 개수만큼 0과 1을 무작위로 채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_Zero_Or_One()\n'메인 프로시저\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rngA As Range\n'전체영역 각 열을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim c As Long\n'행을 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"B2:M21\")\n'전체 영역을 변수에 넣음\nrngAll.ClearContents\n'기존 데이터 삭제\nrngAll.Resize(5) = 1\n'2~6행에 1을 입력\nrngAll.Offset(5).Resize(15) = 0\n'7~21행에 0을 입력\nFor Each rngA In Range(\"B2:M20\").\nColumns\n'전체영역 각 열을 순환\nCall\nrandom_Reshuffle_Final(rngA)\n'값을 섞는 하위 프로시저 호출\nNext rngA\nc = 1\n'제목열 제외하기 위해 1부터 시작\nFor Each rngC In Range(\"N2:N20\")\n'N2:N20영역의 각 셀을 순환\nIf rngC <> 3 Then\n'각 셀값이 3이 아니라면\nDo\n'다음을 실행\nIf c = 13 Then c = 1\n'c가 13이면 다시 초기화\nc = c + 1\n'c 즉 열의 위치를 1씩 늘려감\nSet\nrngA = Range(Cells(rngC.Row, c), Cells(21, c))\n'각 열을 변수에\nCall random_Reshuffle_Final(rngA)\n'값을 섞는 하위 프로시저 호출\nLoop Until rngC = 3\n'값이 3이 될때까지 무한 반복\nEnd If\nNext rngC\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nPrivate Sub random_\nReshuffle_Final(rngA As Range)\n'\n값을 섞는 하위 프로시저\nDim rowsCnt As Long\n'전체 행의 개수 넣을 변수\nDim colsCnt As Integer\n'전체 열의 개수 넣을 변수\nDim maxNo As Long\n'선택영역 셀 개수 넣을 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim varTemp()\n'임시배열로 사용할 배열변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nDim y As Long\n'행 방향 늘려갈 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim x As Integer\n'열 방향 늘려갈 변수\nDim varR()\n'결과 값을 넣을 배열 변수\nDim cnt As Long\n'카운터로 사용할 변수\nRandomize\n'랜덤값 발생기 초기화\n'(계속 새로운 랜덤 기준값 생성)\nWith rngA\n'선택영역에서\nrowsCnt = .Rows.Count\n'전체 행 개수를 변수에 넣음\ncolsCnt = .Columns.Count\n'전체 열 개수를 변수에 넣음\nmaxNo = .Cells.Count\n'선택영역 셀 개수를 변수에 넣음\nEnd With\nReDim\nvarTemp(1 To maxNo)\n'임시배열의 크기 재지정\nReDim varR(1 To rowsCnt, 1 To colsCnt)\n'결과 열의 크기 재지정\nFor Each rngC In rngA.\nCells\n'선택영역 각 셀을 순환\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = rngC\n'각 셀을 배열에 넣음\nNext rngC\ny = 1\nFor i = maxNo To 1 Step -1\n'최대값 부터 1씩 줄여가며 반복\nr = Int(\nRnd\n() * i) + 1\n'무작위 값을 추출\ncnt = cnt + 1\n'카운터를 늘려감\nIf cnt = colsCnt + 1 Then\n'카운터가 열개수에 도달하면\ny = y + 1\n'행을 1씩 늘려감\ncnt = 1\n'카운터 초기화\nx = 0\n'재사용 위하여 초기화\nEnd If\nx = x + 1\n'열방향 값을 1씩 늘려감\nvarR(y, x) = varTemp(r)\n'배열에 랜덤값을 채워감\nvarTemp(r) = varTemp(i)\n'배열 윗값을 추출된 위치에 채움\nNext i\nrngA = varR\n'결과배열 값을 선택영역에 뿌림\nEnd Sub", "context": "B2:M21영역을 0과 1로 무작위로 채우는데 ... 각 세로(열)에는 1 이 5개, 0 이 15개 들어가도록 하며, 각 가로(행)에는 1 이 3개 들어가도록 하는 기능. 매크로 버튼을 클릭하여 실행 시 마다 기존 값이 없어지고 새로운 값으로 업데이트 됨.\n색으로 칠해진 영역에는 =COUNTIF(B2:M2, 1) 와 같은 0 또는 1의 개수를 세는 간단한 함수가 입력됨. Application.Calculation = xlCalculationManual 코드를 넣으면 속도는 빨라지지만 데이터가 몇 개 안되므로 생략함.\n매크로 실행 전 값이 비어 있는 상태\n매크로 실행 후 결과(버튼 클릭 시 마다 새로운 값으로 업데이트 됨)\nOption Explicit\nSub fill_Zero_Or_One()\n'메인 프로시저\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rngA As Range\n'전체영역 각 열을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nD..."}
{"instruction": "Excel VBA code for: (1274) 불필요한 하위 프로시저의 유무에 따른 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub with_Sub_Procedure()                           Sub without_Sub_Procedure()\nDim i As Long                                              Dim i As Long\nApplication.ScreenUpdating = False                Application.ScreenUpdating = False\nFor i = 1 To 100000                                       For i = 1 To 100000\nCells(i, 1) =\ninput_One\n(Cells(i, 1))                Cells(i, 1) = 1\nNext i                                                         Next i\nEnd Sub", "context": "아래의 두 코드는 A1:A100000 영역에 1을 입력하는 코드로서 동일한 기능을 한다. 왼쪽의 코드는 각 셀마다 하위 프로시저에 들려서 값을 가져오는 반면, 오른쪽의 코드는 하위 프로시저의 사용 없이 독립적으로 작동한다. 물론 실제 코딩을 할 때 이런 말도 안되는 코드를 사용하지는 않겠지만, 두 코드의 속도를 비교하기 위해서 아래와 같이 해보았다.\n코드가 길다고 해서 무조건 시간이 더 걸리는 것은 아니지만, 일반적으로 코드가 길어지거나 불필요한 코드가 들어간 경우 점(.) 하나만 더 들어가도 매크로의 속도는 저하\n된다. 반복되는 영역이 있어 코드의 중복의 피하기 위해서, 또는 코드의 모듈화를 위한 하위 프로시저의 사용은 너무 당연하겠지만, 불필요한 하위 프로시저는 속도저하의 원인이 될 수도 있다.\n아래에서는 매개변수(parameter)로 하나의 셀(코드 내의 rngC)만을 주고 받지만, 매개변수로 배열(array)를 주고 받거나 하면 엄청나게 시간이 많이 걸릴 수 있으므로 주의하여..."}
{"instruction": "Excel VBA code for: (1275) 중복데이터의 윗행만 표시하고 행 삽입하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub easy_View_Inserting_Row1()\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim y As Long\n'배열의 행 늘려갈 변수\nDim c As Integer\n'열 방향 반복할 변수\nDim j As Long\n'반복구문에 사용할 변수\nDim k As Long\n'중복구역내 행을 늘려갈 변수\nDim varTemp()\n'배열변수로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\ncolsCnt = ActiveSheet.UsedRange.\nColumns.Count\n'전체영역 열개수를 변수에 넣음\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\n'--------------------------------------------------\n' 중복 없거나, 중복 시 제일 윗행을 배열에 넣는 코드\n'--------------------------------------------------\ny = y + 1\n'배열의 행을 1씩 늘려감\nReDim\nPreserve\nvarTemp(1 To colsCnt, 1 To y)\n'배열크기 재지정\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nvarTemp(c, y) = Cells(r - i, c)\n'배열에 전체 행을 넣음\nNext c\n'--------------------------------------------------\n' 중복 시 제일 윗행 제외한 영역을 배열에 넣는 코드\n'--------------------------------------------------\nIf i > 0 Then\n'중복 구역이 있다면\nk = 1\n'중복구역내 첫행을 변수에 넣음\nFor j = 1 To i\n'중복구역의 행개수 -1 만큼 반복\ny = y + 1\n'배열의 행을 1씩 늘려감\nReDim Preserve varTemp(1 To colsCnt, 1 To y)\n'배열크기 재지정\nFor c = 4 To colsCnt\n'D:G열 까지 반복\nvarTemp(c, y) = Cells(r - i + k, c)\n'중복구역 첫행 제외한 데이터를 배열에 넣음\nNext c\nk = k + 1\n'중복구역내 행을 1씩 늘려감\nNext j\nEnd If\n'---------------------\n' 공백행을 넣는 코드\n'---------------------\ny = y + 1\n'배열의 행을 1씩 늘려감\nReDim Preserve varTemp(1 To colsCnt, 1 To y)\n'배열크기 재지정\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\n'------------------------------------\n' 제목과 배열내 값을 Sheet2에 뿌림\n'------------------------------------\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.\nClearContents\n'사용영역내 기존 데이터 삭제\nCells(1, 1).Resize(, colsCnt).Copy .[A1]\n'제목을 복사\n.Cells(2, 1).Resize(\nUBound\n(varTemp,\n2\n), colsCnt) = _\nApplication.Transpose\n(varTemp)\n'배열값을 행열 변환하여 Sheet2에 뿌림\n.Columns.AutoFit\n'열너비 자동맞춤\n.Activate\n'활성화\nEnd With\nEnd Sub", "context": "(광고 덧글을 삭제한다는 것이 앞서 올렸던 이 포스팅을 삭제해버려 다시 올림.)\n아래의 코드는 윗 그림을 아래 그림과 같이 변경하는 코드이다. EntireRow.Delete 코드를 사용하면 속도가 너무 떨어지므로 데이터를 추출하여 배열에 넣고, 기존 데이터 삭제하고, 배열내의 데이터를 셀에 다시 뿌려주는 기능으로 40,000행의 데이터를 입력하고 매크로 실행하여 결과데이터로\n52,000행이 생성되었을 때 대략 7.7초 정도 소요\n.\n매크로 실행 전 (Sheet2 는 비어 있는 상태)\n매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub easy_View_Inserting_Row1()\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim y As Long\n'배열의 행 늘려갈 변수\nDim c As Integer\n'열 방향 반복할 변수\nDim..."}
{"instruction": "Excel VBA code for: (1276) ByVal 와 ByRef 의 차이 (엑셀 VBA 매크로)", "input": "", "output": "Sub mainPro()\nDim i As Integer\nDim j As Integer\ni = 99\nj = 99\nCall\nsubPro\n(i, j)\nMsgBox \"i : \" & i & vbCr & _\n\"j : \" & j\nEnd Sub\n\nSub subPro(\nByVal\ni As Integer,\nByRef\nj As Integer)\ni = 999\nj = 999\nEnd Sub\n\nSub fill_ByVal()                                               Sub fill_ByRef()\nDim i As Integer                                               Dim i As Integer\nDim r As Integer                                               Dim r As Integer\nr = 1                                                               r = 1\nFor i = 1 To 5                                                   For i = 1 To 5\nCells(r,\n1\n) = by_Val(r)                                      Cells(r,\n5\n) = by_Ref(r)\nNext i                                                             Next i\nEnd Sub\n\nFunction by_Val(\nByVal\nr As Integer)                 Function by_Ref(\nByRef\nr As Integer)\nr = r + 1                                                          r = r + 1\nby_Val = r                                                       by_Ref = r\nEnd Function", "context": "이 형배님의 \"엑셀 2000 VBA\" 책에 나온 두 키워드의 정의를 살펴 보면 아래와 같다.\nByVal (인수의 값 건네기) : 인수 값의 복사를 건넵니다. 호출된 프로시저(subPro()) 측에서 값을 변경해도\n메인 프로시저(mainPro())\n값은\n변경되지\n않음\n.\nByRef (인수의 참조 건네기) : 인수 값을 직접 건네는 것이 아니라, 인수가 저장된 메모리 어드레스를 나타내는 지표(포인터)를 건넵니다. 인수에 키워드를 지정하지 않는 경우도 이 방법으로 건네집니다. 호출된 프로시저측에서 인수의 값을 변경하면\n메인 프로시저\n값도\n변경\n되어 버리므로 주의가 필요.\n컴퓨터 프로그래밍 공부좀 한 사람은 위 내용만으로 무슨말인지 알아듣지만, 엑셀만을 사용하는 일반인에게는 수수께끼와 같다. 하지만 하나 확실한 것은, 위에서 보듯 두 키워드의 차이는 메인 프로시저의 값이 변경되느냐, 변경되지 않느냐의 차이이다. 책에 있는 예제 코드를 이용하여 비교해보자.\nSub mainPro()\nDim i..."}
{"instruction": "Excel VBA code for: (1279) 셀병합된 데이터 정렬하기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_Merged_Cells3()\nDim rngAll As Range\n'전체 사용영역을 넣을 변수\nDim rowsCnt As Long\n'행 개수 넣을 변수\nDim colsCnt As Integer\n'열 개수 넣을 변수\nDim i As Long\n'행 2씩 늘려갈 변수\nDim r As Long\n'행 1씩 늘려갈 변수\nDim c As Long\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet\nrngAll = [A1].\nCurrentRegion\n'전체사용 영역을 변수에\nrowsCnt = rngAll.Rows.Count\n'전체영역의 행 개수를 변수에 넣음\ncolsCnt = rngAll.Columns.Count\n'전체영역의 열 개수를 변수에 넣음\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.\nClearContents\n'기존 데이터 삭제\n'-------------------------------------------------\n' Sheet1의 데이터를 변형하여 Sheet2로 이동 후 정렬\n'-------------------------------------------------\nFor i = 1 To rowsCnt - 2 Step 2\n'(셀병합)행 개수만큼 반복\nr = r + 1\n'배열크기 1씩 늘려감\nFor c = 1 To colsCnt\n'열 개수만큼 반복\n.Cells(r, c) = Cells(2 + i, c).Value\n'셀병합된 2행중 윗행값 배열에 입력\nNext c\n.Cells(r, c) =\nAbs\n(Cells(3 + i, c - 1).Value)\n'\"동호수\"의 '호'를 입력\nNext i\n.UsedRange.\nSort\nkey1\n:=\n.Cells(1, 5),\nkey2:=\n.Cells(1, 6)\n'E:F열 오름차순 정렬\nr = 0\n'재사용 위하여 초기화\n'------------------------------------------------\n' Sheet2의 데이터를 변형하여 Sheet1로 이동\n'------------------------------------------------\nFor i = 1 To rowsCnt - 2 Step 2\n'(셀병합)행 개수만큼 반복\nr = r + 1\n'행을 1씩 늘려감\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nCells(2 + i, c) = .Cells(r, c)\n'셀병합된 2행 중 윗행값을 입력\nNext c\nCells(3 + i, c - 1) =\n\"-\" &\n.Cells(r, c)\n'\"동호수\"의 '호'를 입력\nNext i\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화 (메모리 비우기)\nEnd Sub", "context": "2행으로 입력된 '동호수'를 기준으로 오름차순 정렬하는 기능. 데이터를 임시로 Sheet2에 1행으로 만들어 옮겨서 동호수의 '동' 및 '호'를 기준으로 오름차순 정렬하고 정렬된 데이터를 다시 Sheet1으로 가져와 입력하는 방법을 사용함.\n셀병합을 하지 않았을 경우 단순히 정렬만 하면 되지만, 셀병합을 하는 경우 이런 복잡한 코드를 사용해야한다. 그러므로 셀병합은 가능하면 피하고, 불가피할 경우에도 이런 것들을 고려하여 데이터를 입력해야 한다.\n매크로 실행 전\n매크로 실행 후 결과 ('동호수'를 기준으로 오름차순으로 정렬)\nSheet2의 임시 데이터 모습\n.UsedRange.Sort key1:=.Cells(1, 5), key2:=.Cells(1, 6) 라고 되어 있는 코드를\n.UsedRange.Sort\nkey1:=\n.Cells(1, 5),\norder1:=\n2, key2:=.Cells(1, 6), order2:=2 으로 수정할 경우 내림차순으로 정렬된다.\nOption Explicit..."}
{"instruction": "Excel VBA code for: (1280) 중복된 데이터만 추출하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_The_Same_ID()\nDim varAll As Variant\n'전체(All) 데이터를 임시로 넣을 배열변수\nDim varR()\n'검색 일치한 결과(R)esult 값을 넣을 배열변수\nDim rowsA As Long\n'A열 전체 행의 개수 넣을 변수\nDim rowsD As Long\n'D열 전체 행의 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim y As Long\n'배열내 행 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim j As Long\n'배열크기 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith ActiveSheet.\nUsedRange\n'현재시트 사용영역\nvarAll = .Offset(1).Resize(.Rows.Count - 1)\n'제목뺀 전체 데이터를 배열에 넣음\nEnd With\nrowsA = Cells(Rows.Count, \"A\").End(3).\nRow\n- 1\n'A열 전체 행 개수를 변수에 넣음\nrowsD = Cells(Rows.Count, \"D\").End(3).Row - 1\n'D열 전체 행 개수를 변수에 넣음\nReDim\nvarR(1 To rowsA, 1 To 5)\n'배열크기 재지정\nFor r = 1 To rowsA\n'전체 행 개수만큼 반복\nFor y = 1 To rowsD\n'전체 행 개수만큼 반복\nIf varAll(y, 4) <>\nEmpty\nThen\n'(배열내)D열이 Empty 아니면\n'-------------------------------------------------------------------------\n'중복데이터만 결과 배열에 넣고, 찾은 데이터는 또 찾지 않기 위해 배열에서 삭제\n'-------------------------------------------------------------------------\nIf varAll(r, 1) = varAll(y, 4) Then\n'(배열내)A열과 D열이 같으면\nj = j + 1\n'배열의 행 1씩 증가\nFor i = 4 To 8\n'(배열내)'4 ~ 9열까지 반복\nvarR(j, i - 3) = varAll(y, i)\n'일치한 값을 결과배열로 옮김\nNext i\nvarAll(y, 4) = Empty\n'찾은 데이터는 삭제하여 Empty 만듬.\nExit For\n'For 구문 종료\nEnd If\nEnd If\nNext y\nNext r\n'------------------------------------------------------------\n' 기존 데이터 삭제하고 배열내 결과값 시트에 뿌리고 서식지정\n'------------------------------------------------------------\nWith Worksheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nRange(\"D1:H1\").Copy .Cells(1, 1)\n'제목 복사\n.Cells(2, 1).Resize(\nUBound\n(varR,\n1\n), UBound(varR,\n2\n)) = _\nvarR\n'배열값 셀에 뿌림\n.Columns(\"C\").\nNumberFormatLocal\n= \"yyyy-mm-dd\"\n'C열 서식을 날짜로\n.Columns(\"D\").NumberFormatLocal = \"hh-mm\"\n'D열 서식을 시간으로\n.Columns.AutoFit\n'열너비 자동맞춤\n.Activate\n'활성화\nEnd With\nEnd Sub", "context": "A열과 D열에 중복된 데이터가 있을 경우 D:H열의 데이터를 Sheet2에 추출하는 기능. A열에 데이터 10,000개  x  D열 데이터 10,000개(즉, 1억개 셀의 비교)의 경우 대략 5.7초 정도 소요.\n매크로 실행 전 (Sheet2는 비어 있음)\n매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub find_The_Same_ID()\nDim varAll As Variant\n'전체(All) 데이터를 임시로 넣을 배열변수\nDim varR()\n'검색 일치한 결과(R)esult 값을 넣을 배열변수\nDim rowsA As Long\n'A열 전체 행의 개수 넣을 변수\nDim rowsD As Long\n'D열 전체 행의 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim y As Long\n'배열내 행 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim j As Long\n'배열크기 1씩 늘려갈 변수\nApplication.Scre..."}
{"instruction": "Excel VBA code for: (1281) 3열 데이터를 1열 데이터로 변환하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub data_Trans_By_Area()\nDim r As Long\n'Sheet2 행을 1씩 늘려갈 변수\nDim i As Long\n'Sheet1 행을 1씩 늘려갈 변수\nDim rngA As Range\n'각 area를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.\nClearContents\n'기존 데이터 삭제\nr = 1\n'Sheet2 1행부터 시작\nDo\n'다음을 실행\ni = i + 1\n'Sheet1 행을 1씩 늘려감\nFor Each rngA In Rows(i).SpecialCells(2).\nAreas\n'Sheet1 각 행의 각 area순환\nrngA.\nCopy\n.Cells(r, 1)\n'각 area를 Sheet2에 순차적으로 복사\nr = r + 1\n'Sheet2 행을 1씩 늘려감\nNext rngA\nLoop Until\nCells(i + 1, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\n.\nActivate\n'활성화\nEnd With\nEnd Sub", "context": "매번 속도가 가장 빠른 코드를 찾아보려고 하다보니 배열을 남용하여 코드가 한 동안 너무 어려워지지 않았나 생각된다. 아래의 코드는 배열에 넣는 것보다 속도는 한참 떨어지지만 단순히 각 행의 각 구역(area)을 복사하므로 이해하기는 더 쉽다.\n매크로 실행 전 (Sheet2는 비어 있음)\n매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub data_Trans_By_Area()\nDim r As Long\n'Sheet2 행을 1씩 늘려갈 변수\nDim i As Long\n'Sheet1 행을 1씩 늘려갈 변수\nDim rngA As Range\n'각 area를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.\nClearContents\n'기존 데이터 삭제\nr = 1\n'Sheet2 1행부터 시작\nDo\n'다음을 실행\ni = i + 1\n'Sheet1 행을 1씩 늘려감\n..."}
{"instruction": "Excel VBA code for: (1282) 선택영역의 행 또는 열을 서로 뒤집기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub switch_All_Rows_Columns2()\nDim varTemp\n'선택영역을 넣을 배열변수\nDim rowsCnt As Long\n'선택영역의 행 개수 넣을 변수\nDim colsCnt As Integer\n'선택영역의 열 개수 넣을 변수\nDim vbYN As String\n'메시지박스 입력받은 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'행 또는 열 복사위치 늘려갈 변수\nvarTemp = Selection\n'선택영역을 변수에 넣음\nWith Selection\nrowsCnt = .Rows.Count\n'선택영역 행 개수를 변수에 넣음\ncolsCnt = .Columns.Count\n'선택영역 열 개수를 변수에 넣음\n'-------------------------------------------\n'선택영역의 셀 개수 및 area 개수 확인 코드\n'-------------------------------------------\nIf .\nCount\n= 1 Then\n'만일 한 셀만 선택하였을 경우\nMsgBox \"한 셀만 선택함. Switch할 행, 또는 열이 없음.\", 64, \"영역선택 오류\"\nExit Sub\n'매크로 종료\nEnd If\nIf .\nAreas\n.Count > 1 Then\n'만약 2개 이상의 영역을 선택하였을 경우\nMsgBox \"한 영역만을 선택하셔야합니다.\", 64, \"영역선택 오류\"\nExit Sub\n'매크로 종료\nEnd If\nEnd With\n'-------------------------------------------------\n'선택영역의 행 / 열을 바꾸어 시트에 뿌리는 코드\n'-------------------------------------------------\nvbYN =\nMsgBox\n(\"행을 switch하려면 Yes, 열은 No를 선택\", 3, \"방향 선택\")\nSelect Case\nvbYN\n'Yes, No, Cancel 중에서\nCase\nvbYes\n'Yes를 선택 시\nr = rowsCnt\n'r에 행 개수를 넣음\nFor i = 1 To rowsCnt\n'행 개수 만큼 반복\nCells(r, 1).Resize(, UBound(varTemp, 2)) = _\nApplication.Index\n(varTemp, i)\n'행을 뒤집어 시트에 뿌림\nr = r - 1\n'복사될 행위치 1씩 줄여감\nNext i\nCase\nvbNo\n'No를 선택 시\nr = colsCnt\n'r에 열 개수를 넣음\nFor i = 1 To colsCnt\n'열 개수 만큼 반복\nCells(1, r).Resize(UBound(varTemp, 1)) = _\nApplication.Index(varTemp, , i)\n'열을 뒤집어 시트에 뿌림\nr = r - 1\n'복사될 열 위치 1씩 줄여감\nNext i\nCase\nvbCancel\n: Exit Sub\n'Cancel선택시 매크로 종료\nEnd Select\nEnd Sub", "context": "매크로 실행 전 행 또는 열방향으로 데이터를 뒤집을 영역을 선택한 모습\n매크로 실행 후 행 방향(위 아래)으로 뒤집기를 선택한 모습\n매크로 실행 후 결과\n매크로 실행 후 열 방향(좌우)으로 뒤집기를 선택한 모습\n매크로 실행 후 결과\nOption Explicit\nSub switch_All_Rows_Columns2()\nDim varTemp\n'선택영역을 넣을 배열변수\nDim rowsCnt As Long\n'선택영역의 행 개수 넣을 변수\nDim colsCnt As Integer\n'선택영역의 열 개수 넣을 변수\nDim vbYN As String\n'메시지박스 입력받은 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'행 또는 열 복사위치 늘려갈 변수\nvarTemp = Selection\n'선택영역을 변수에 넣음\nWith Selection\nrowsCnt = .Rows.Count\n'선택영역 행 개수를 변수에 넣음\ncolsCnt = .Columns.Count\n'선택영역 ..."}
{"instruction": "Excel VBA code for: (1284) Cross Join을 이용한 조합(경우의 수) 구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Full_Combination2()\n'---------------------------------------------------------\n'  VBE 도구(Tools) => 참조(References)에\n'  Microsoft ActiveX Data Object Library 2.8 또는 6.0 참조후\n'---------------------------------------------------------\nDim strSQL As String\n'SQL 조건을 넣을 변수\nDim strConn As String\n'Connection 넣을 변수\nDim adoRS As\nADODB.Recordset\n'ADO Recordset 넣을 변수\nDim i As Integer\n'반복 구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nstrSQL = \"SELECT\nDISTINCT\nA$.이름, B$.과목, C$.점수, D$.주소 \" & _\n\"FROM\n[A$], [B$], [C$], [D$]\n;\"\n'중복 없는 Cross Join 조건을 변수에 넣음\nstrConn = \"Provider=                      Microsoft.ACE.OLEDB.12.0;\" & _\n\"Data Source=                 \" & ThisWorkbook.FullName & \";\" & _\n\"Extended Properties=      Excel 12.0;\"\n'연결 조건을 변수에 넣음\nSet adoRS = New ADODB.Recordset\n'Early binding으로 recordset을 변수에\nadoRS.Open strSQL, strConn, adOpenForwardOnly, adLockReadOnly, adCmdText\n'SQL 조건에 따라 연결하여 파일을 열기\nIf Not adoRS.EOF Then\n'파일의 마지막이 아니라 데이터가 존재하면\nWith Sheets(\"Result\")\n.Range(\"A1\").CurrentRegion.Clear\n'기존 데이터 삭제\nFor i = 0 To adoRS.\nFields.Count\n- 1\n'필드 개수만큼 반복\n.Cells(1, i + 1).Value = adoRS.Fields(i).Name\n'각 필드 이름을 넣음\nNext\nIf\nadoRS.Properties.Count\n< 1048576 Then\n'결과가 시트 전체행 개수보다 작으면\n.Range(\"A2\").\nCopyFromRecordset\nadoRS\n'데이터를 시트에 복사\nElse\n'시트 전체행 개수보다 큰 경우\nMsgBox \"시트 전체행 개수 초과\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\n.Columns.AutoFit\n'열너비 자동맞춤\n.Activate\n'활성화\nEnd With\nElse\nMsgBox \"자료가 없습니다\", 64, \"데이터 오류\"\n'메시지 출력\nEnd If\nadoRS.Close\n'recordset 닫음\nSet adoRS = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "전체 조합을 구하는 코드. Result 시트에\n24,000 행의 데이터가 입력될 경우 대략\n1.1초\n정도 소요\n됨.\n(A시트 3행 x B시트 2행 x C시트 2000행 x D시트 x 2 = 24,000행 )\nA 시트                    B시트                       C시트(2000행)                  D시트\n매크로 실행 전 Result 시트                                   매크로 실행 후 결과 (밑으로 데이터 더 있음)\nOption Explicit\nSub find_Full_Combination2()\n'---------------------------------------------------------\n'  VBE 도구(Tools) => 참조(References)에\n'  Microsoft ActiveX Data Object Library 2.8 또는 6.0 참조후\n'-------------------------..."}
{"instruction": "Excel VBA code for: (1285) 전체 조합(경우의 수) 구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Full_Combination()\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim rngA As Range\n'A열 각셀 넣을 영역변수\nDim rngB As Range\n'B열 각셀 넣을 영역변수\nDim rngC As Range\n'C열 각셀 넣을 영역변수\nDim rngD As Range\n'D열 각셀 넣을 영역변수\nConst\nlngMax As Long = 1048576\n'마지막행 넣을 변수\nr = 1\n'제목행 건너 뛰기위해 1부터 시작\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\n.Cells(1, 1).Resize(, 4) =\nArray\n(\"이름\", \"과목\", \"점수\", \"주소\")\n'제목입력\nFor Each rngA In Range(\"A2:A4\")\n'(제목 제외한)  A열 각셀 순환\nFor Each rngB In Range(\"B2:B3\")\n'(제목 제외한)  B열 각셀 순환\nFor Each rngC In Range(\"C2:C2001\")\n'(제목 제외한)  C열 각셀 순환\nFor Each rngD In Range(\"D2:D3\")\n'(제목 제외한)  D열 각셀 순환\nr = r + 1\n'행을 1씩 늘려감\nIf r < lngMax Then\n'행이 전체행보다 작으면\n.Cells(r, 1).\nResize\n(, 4) = _\nArray(rngA, rngB, rngC, rngD)\n'셀에 값을 뿌림\nElse\n'카운터가 전체행보다 크면\nMsgBox\n\"시트 전체행 개수 초과\"\n'오류 메시지 출력\nEnd If\nNext rngD\nNext rngC\nNext rngB\nNext rngA\n.Columns.AutoFit\n'열너비 자동맞춤\n.Activate\n'활성화\nEnd With\nEnd Sub", "context": "앞서 올렸던 ADO SQL을 이용한 조합(경우의 수) 구하기와 비교해 보기 위하여 만들은 것으로 매크로 실행한 결과가\n24,000 행일 경우 약\n1.75\n초 정도 소요\n.\n매크로 실행 전 (Sheet2 는 비어 있음)                              매크로 실행 후 Shee2의 결과\nOption Explicit\nSub find_Full_Combination()\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim rngA As Range\n'A열 각셀 넣을 영역변수\nDim rngB As Range\n'B열 각셀 넣을 영역변수\nDim rngC As Range\n'C열 각셀 넣을 영역변수\nDim rngD As Range\n'D열 각셀 넣을 영역변수\nConst\nlngMax As Long = 1048576\n'마지막행 넣을 변수\nr = 1\n'제목행 건너 뛰기위해 1부터 시작\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터..."}
{"instruction": "Excel VBA code for: (1286) 빈셀 있는 행 삭제하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_All_Blank_Cells()\n'---------------------------------------------------\n'  VBE 도구(Tools) => 참조(References)에\n'  Microsoft ActiveX Data Object Library 2.8 참조후\n'---------------------------------------------------\nDim strSQL As String\n'SQL 조건을 넣을 변수\nDim strConn As String\n'Connection 넣을 변수\nDim adoRS As\nADODB.Recordset\n'ADO Recordset 넣을 변수\nDim i As Integer\n'반복 구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nstrSQL = \"SELECT       대표자, 설립일, 종목, 주소 \" & _\n\"FROM          [Data$] \" & _\n\"WHERE\nNOT\n(대표자\nAND\n설립일 AND 종목 AND 주소)\nIS NULL\n;\"\n'SQL 조건을 변수에 넣음\nstrConn = \"Provider=                      Microsoft.ACE.OLEDB.12.0;\" & _\n\"Data Source=                 \" & ThisWorkbook.FullName & \";\" & _\n\"Extended Properties=      Excel 12.0;\"\n'연결 조건을 변수에 넣음\nSet adoRS = New ADODB.Recordset\n'Early binding으로 recordset을 변수에\nadoRS.Open strSQL, strConn, adOpenForwardOnly, adLockReadOnly, adCmdText\n'SQL 조건에 따라 연결하여 파일을 열기\nIf\nNot adoRS.EOF\nThen\n'파일의 마지막이 아니라 데이터가 존재하면\nWith Sheets(\"Query\")\n'Query 시트에서\n.Range(\"A1\").CurrentRegion.ClearContents\n'기존 데이터 삭제\nFor i = 0 To\nadoRS.Fields.Count\n- 1\n'recordset의  필드 개수만큼 반복\n.Cells(1, i + 1).Value = adoRS.Fields(i).Name\n'각 필드 이름을 넣음\nNext\n.Range(\"A2\").\nCopyFromRecordset\nadoRS\n'데이터 복사\n.Columns.AutoFit\n'열너비 자동맞춤\n.Activate\n'활성화\nEnd With\nElse\nMsgBox \"자료가 없습니다\", 64, \"데이터 오류\"\n'메시지 출력\nEnd If\nadoRS.Close\n'recordset 닫음\nSet adoRS = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "전체 데이터 중 빈 셀이 있는 전체행을 삭제하는 기능. 왼쪽 아래와 같이 데이터를 넣고 돌렸을 때\n10,000행에 약\n0.37\n초 정도 소요\n.\n매크로 실행 전 (Query 시트는 비어 있음)                       매크로 실행 후 Query 시트의 결과\nOption Explicit\nSub delete_All_Blank_Cells()\n'---------------------------------------------------\n'  VBE 도구(Tools) => 참조(References)에\n'  Microsoft ActiveX Data Object Library 2.8 참조후\n'---------------------------------------------------\nDim strSQL As String\n'SQL 조건을 넣을 변수\nDim strConn As String\n'Connection 넣을 변수\nDim adoRS As\nADODB.Recordset\n'ADO Re..."}
{"instruction": "Excel VBA code for: (1288) 3열 데이터를 1열 데이터로 변환하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub data_Trans_By_Area2()\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim r As Long\n'행(r)ow을 늘려갈 변수\nDim x As Long\n'배열의 열방향 늘려갈 변수\nDim y As Long\n'배열의 위치 늘려갈 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngA As Range\n'각 구역(area)을 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nrowsCnt = ActiveSheet.\nUsedRange\n.Rows.Count\n'현재시트 사용영역 행 개수를 변수에 넣음\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nReDim\nvarTemp(1 To rowsCnt * 3, 1 To 7)\n'배열크기 재지정\n'------------------------------------------\n' 1차원 정적배열에 각 구역(area)을 넣음\n'------------------------------------------\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nFor Each rngA In Rows(r).\nSpecialCells(2).Areas\n'Sheet1 각 행의 각 area순환\ny = y + 1\n'Sheet1 행을 1씩 늘려감\nFor i = 1 To 7\n'1 ~ 7까지 증가하며 반복\nvarTemp(y, i) = rngA.Cells(i)\n'각 행의 각 area를 배열에 넣음\nNext i\nNext rngA\nLoop Until\nCells(r + 1, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\n'-------------------------\n' 배열의 값을 셀에 뿌림\n'-------------------------\n.Cells(1, 1).Resize(\nUBound\n(varTemp,\n1\n),\nUBound\n(varTemp,\n2\n)) = varTemp\n'배열 값을 시트에 뿌림\n.Activate\n'활성화\nEnd With\nEnd Sub", "context": "앞서는 동일한 내용을 단순히 복사하여 3열 데이터를 1열로 변환하여 옮겨보았다. 아래는 배열(array)를 사용함. 20,000행을 넣고 돌려서 Sheet2에\n60,000행의 데이터가 생성되었을 때 3.43초\n정도 소요.\n매크로 실행 전 (Sheet2는 비어 있음)\n매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub data_Trans_By_Area2()\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim r As Long\n'행(r)ow을 늘려갈 변수\nDim x As Long\n'배열의 열방향 늘려갈 변수\nDim y As Long\n'배열의 위치 늘려갈 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngA As Range\n'각 구역(area)을 넣을 변수\nDim varTemp()\n'배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nrowsCnt = ActiveSheet...."}
{"instruction": "Excel VBA code for: (1289) 배열(Array)의 이해와 사용 9 (엑셀 VBA 매크로)", "input": "", "output": "Sub data_Trans_By_Area3()\nDim i As Long\n'행을 1씩 늘려갈 변수\nDim r As Long\n'배열크기 1씩 늘려갈 변수\nDim rngA As Range\n'각 구역(area)을 넣을 변수\nDim varTemp()\n'동적배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\n'----------------------------------------\n' 1차원 동적배열에 각 구역(area)을 넣음\n'----------------------------------------\nDo\n'다음을 실행\ni = i + 1\n'Sheet1 행을 1씩 늘려감\nFor Each rngA In Rows(i).SpecialCells(2).\nAreas\n'Sheet1 각 행의 각 area순환\nr = r + 1\n'배열크기 1씩 늘려감\nReDim Preserve\nvarTemp(1 To r)\n'배열크기 재지정\nvarTemp(r) = rngA\n'각 행의 각 area를 배열에 넣음\nNext rngA\nLoop Until\nCells(i + 1, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\n'---------------------------------------------\n' 배열의 값을 각 구역(area) 단위로 셀에 뿌림\n'---------------------------------------------\nFor r = 1 To UBound(varTemp, 1)\n'varTemp의 1차원 상한값 만큼 반복\n.Cells(r, 1).Resize(, 7) = varTemp(r)\n'배열의 값을 area단위로 셀에 뿌림\nNext r\n.Activate\n'활성화\nEnd With\nEnd Sub", "context": "지금까지는 속도가 빠르므로 배열내 값을 셀에 한 번에 뿌리거나, 또는 각 셀 단위로 시트에 데이터를 뿌렸다. 그런데, 배열(array)의 각 요소(element)에는 다양한 값을 넣을 수 있으며, 아래와 같이 특정 영역을 한 번에 넣을 수도 있다.\n위와 같이 배열변수 var에 값을 삽입하면, 3번째 index위치에는 아래 그림과 같이 A1:G1 영역 전체가 한 번에 들어간다.\n지역창(Locals)에서 보는 바와 같이 var(0), var(1), var(3)에는 + 표시가 없으며 한 개의 값만 입력되었지만, 빨간색으로 표시한 var(2)에는 (뭔가 더 있다는) + 표시가 되어 있으며, var(2)에는 개체인 range 즉, A1:G1 영역이 들어가 있다. 결국 Range(\"A1:G1\") = var(2).\n위와 같은, 배열내에 값을 넣거나 가져올 때 주의해야 한다.\n배열에 값을 넣을 때 : var(2).Range(\"A1\") = \"입력값\"\n배열 값을 셀에 넣을 때 : Range(\"M5\")..."}
{"instruction": "Excel VBA code for: (1290) 폴더내 모든파일 동일 시트끼리 합치기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_The_Same_Sheets()\nDim intSht As Integer\n'시트의 개수를 넣을 변수\nDim s As Integer\n'시트 개수만큼 반복할 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim wkBk As Workbook\n'각 파일을 넣을 변수\nDim varTemp\n()\n'동적배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nintSht = Worksheets.Count\n'시트 개수를 변수에 넣음\nFor s = 1 To intSht\n'시트 개수만큼 반복\nSheets(s).UsedRange.Offset(1).ClearContents\n'모든 시트의 기존 데이터 삭제\nNext s\n'-----------------------------\n' 폴더선택 창을 띄우는 코드\n'-----------------------------\nWith Application.\nFileDialog\n(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 종료\nElse\n'파일 존재 시\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName =\nDir\n(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\n'----------------------------------\n' 폴더내 각 파일을 순환하며 작업\n'----------------------------------\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nSet wkBk = Workbooks.\nOpen\n(strPath & fileName) '파일을 열고 변수에 넣음\nReDim Preserve\nvarTemp(1 To intSht )\n'배열크기 재지정\nIf wkBk.Sheets.Count <> intSht Then\n'시트 개수가 일치하지 않을 경우\nMsgBox \"데이터파일의 시트개수 불일치\", 64, \"시트개수 오류\" '메시지 출력\nExit Sub\n'매크로 종료\nEnd If\n'-------------------------------------\n' 열린 파일의 각 시트를 배열에 넣음\n'-------------------------------------\nFor s = 1 To intSht\n'시트 개수만큼 반복\nvarTemp(s) = wkBk.Sheets(s).UsedRange.Offset(1)\nNext s\n'각 시트의 제목제외한 데이터를 배열에 넣음\nwkBk.\nClose\nFalse\n'열려진 파일을 닫음\n'-------------------------------------------\n' 배열내의 각 시트데이터 통합시트에 뿌림\n'-------------------------------------------\nFor s = 1 To intSht\n'시트 개수만큼 반복\nWith Sheets(s)\n.Cells(.Rows.Count, \"A\").End(3)(2).Resize(\nUBound\n(\nvarTemp(s), 1\n), _\nUBound(\nvarTemp(s), 2\n)) = varTemp(s)\n'배열내 값을 각 시트에 뿌림\nEnd With\nNext s\nErase\nvarTemp\n'배열의 초기화\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nSet wkBk = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "폴더내에 여러 파일이 있고, 이 파일들은 모두 동일한 순서와 동일한 개수의 시트들이 있다(시트 이름은 상관 없으며, 시트의 개수 및 위치에 따라 합쳐진다.). 아래의 매크로를 돌리면 각 시트의 데이터를 통합파일로 가져와 합치는 기능.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1290) 폴더내 모든파일 동일 시트끼리 합치기 (엑셀 VBA 매크로)\n재생\n5,189\n재생 (space/k)\n재생\n00:45\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:45\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 ..."}
{"instruction": "Excel VBA code for: (1294) 문자합쳐 메일주소 링크로 만들기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_And_Add_Hyperlinks()\nDim rngC As Range\n'각 셀을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Range(\"A1:A10\")\n'A1:A10 영역의 각 셀을 순환\nActiveSheet.\nHyperlinks.Add\nrngC.Offset(, 3), _\nrngC & rngC(1, 2) & rngC(1, 3)\n'A:C열을 합쳐서 하이퍼링크 추가\nNext rngC\nColumns(\"D\").AutoFit\n'열너비 자동맞춤\nEnd Sub", "context": "A:C 열에 있는 문자를 합쳐서 메일주소를 D열에 넣기\n매크로 실행 전                                       매크로 실행 후 결과\nOption Explicit\nSub combine_And_Add_Hyperlinks()\nDim rngC As Range\n'각 셀을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Range(\"A1:A10\")\n'A1:A10 영역의 각 셀을 순환\nActiveSheet.\nHyperlinks.Add\nrngC.Offset(, 3), _\nrngC & rngC(1, 2) & rngC(1, 3)\n'A:C열을 합쳐서 하이퍼링크 추가\nNext rngC\nColumns(\"D\").AutoFit\n'열너비 자동맞춤\nEnd Sub..."}
{"instruction": "Excel VBA code for: (1295) 월별 판매량 구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub monthly_Sales_Sum()\n'-----------------------------------------------------------\n'  VBE 도구(Tools) => 참조(References)에\n'  Microsoft ActiveX Data Object Library 2.8 또는 6.0 참조후\n'-----------------------------------------------------------\nDim strSQL As String\n'SQL 조건을 넣을 변수\nDim strConn As String\n'Connection 넣을 변수\nDim adoRS As ADODB.Recordset\n'ADO Recordset 넣을 변수\nDim i As Integer\n'반복 구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nstrSQL = \"\nTRANSFORM\nSUM(판매금액)  \" & _\n\"SELECT 제품명  \" & _\n\"FROM [Data$]  \" & _\n\"WHERE 일자\nBETWEEN\n#\n2011\n-\n01\n-\n01\n#\nAND\n#\n2011\n-\n12\n-\n31\n# \" & _\n\"\nGROUP BY\n제품명  \" & _\n\"\nPIVOT\nFORMAT(일자,'mm') & '월' ;\"\n'SQL 및 Pivot 조건을 지정\nstrConn = \"Provider=                     Microsoft.ACE.OLEDB.12.0;\" & _\n\"Data Source=               \" & ThisWorkbook.FullName & \";\" & _\n\"Extended Properties=    Excel 12.0;\"\n'연결 조건을 변수에 넣음\nSet adoRS = New ADODB.Recordset\n'recordset을 변수에\nadoRS.\nOpen\nstrSQL, strConn, adOpenForwardOnly, adLockReadOnly, adCmdText\n'SQL 조건에 따라 연결하여 파일을 열기\nWith Sheets(\"Query\")\n'Query라는 시트에서\n.Range(\"A1\").CurrentRegion.Clear\n'기존 데이터 삭제\nIf\nNot adoRS.EOF\nThen\n'파일의 마지막이 아니라 데이터가 존재하면\nFor i = 0 To adoRS.\nFields.Count\n- 1\n'recordset의  필드 개수만큼 반복\n.Cells(1, i + 1).Value = adoRS.Fields(i).Name\n'각 필드 이름을 넣음\nNext\n.Range(\"A2\").\nCopyFromRecordset\nadoRS\n'데이터 복사\nSheets(1).Cells(1, 1).Copy\n'서식복사\n.Rows(1).SpecialCells(2).\nPasteSpecial\nPaste:=xlPasteFormats\n'서식 붙여넣기\nApplication.CutCopyMode = False\n'복사모드 해제(클립보드 비우기)\n.UsedRange.\nNumberFormat\n= \"#,##0\n\"         '사용영역 셀 서식 설정\n.Columns.AutoFit\n'열너비 자동맞춤\n.Activate\n'활성화\nElse\n'일치하는 데이터 없을 경우\nMsgBox \"일치하는 데이터가 없습니다\", 64, \"데이터 오류\"\n'메시지 출력\nEnd If\nEnd With\nadoRS.Close\n'recordset 닫음\nSet adoRS = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "(각 년도의) 월별 판매량을 구하는 기능. Data 시트에 2010년 ~ 2013년 까지의 많은 데이터가 있으며, 아래 예제는 2011년의 각 월별 판매금액 합계를 구함.\n매크로 실행 전 (아래로 데이터가 더 있으며, Query 시트는 비어 있음)\n매크로 실행 후 Query 시트의 결과\nOption Explicit\nSub monthly_Sales_Sum()\n'-----------------------------------------------------------\n'  VBE 도구(Tools) => 참조(References)에\n'  Microsoft ActiveX Data Object Library 2.8 또는 6.0 참조후\n'-----------------------------------------------------------\nDim strSQL As String\n'SQL 조건을 넣을 변수\nDim strConn As String\n'Connection 넣을 변수\nDim adoRS..."}
{"instruction": "Excel VBA code for: (1300) 특정값 있는 행만 추출하기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_All_Gap4()\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'Sheet2의 기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Cells(1, 1)\n'현재시트 사용영역 복사\n.Activate\n'활성화\nEnd With\nFor i = Cells(Rows.Count, 1).End(3).\nRow\nTo 2\nStep -1\n'마지막 행에서 2행까지 1씩 빼며 반복\nIf Cells(i, 2) <> \"갑\" Then\n'B열의 값이 \"갑\"이 아니면\nCells(i, 2).\nEntireRow.Delete\n'전체 행을 삭제\nEnd If\nNext i\nEnd Sub", "context": "특정한 값(아래 예제의 경우 \"갑\")이 들어 있는 행들만을 추출하는 기능으로 예제 파일에는 10,000행의 데이터가 있음. 다양한 방법으로 접근이 가능하며 코드마다 속도가 다르다. 필터 후 복사, ADO SQL 또는 배열을 사용하는 것이 속도가 빠르다.\n사용한 코드                                                                                                         소요시간\n1. Union 메서드를 이용 (특정값 있는 행만 추출하기 1 )...........................................     33.60초\n2. Copy 메서드 이용 (특정값 있는 행만 추출하기 2 )    ...........................................     29.12초\n3. 위에서 아래로 내려가며 행 삭제 (특정값 있는 행만 추출하기 3 ) ...................."}
{"instruction": "Excel VBA code for: (1301) 특정값 있는 행만 추출하기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_All_Gap6()\nDim rngAll As Range\n'B열 전체영역을 넣을 변수\nDim strAddr As String\n'처음 검색하여 찾은 셀의 주소 넣을 변수\nDim C As Range\n'검색하여 찾은 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Columns(\"B\").SpecialCells(2)\n'B열 문자영역을 변수에 넣음\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'Sheet2의 기존 데이터 삭제\nRows(1).SpecialCells(2).Copy .Cells(1, 1)\n'제목 복사\nSet C = rngAll.\nFind\n(What:=\"갑\", After:=Cells(1, 2), Lookat:=xlWhole)\n'처음 일치하는 \"갑\"을 찾아 변수 C에 넣고\nIf Not C Is Nothing Then\n'만일 일치하는 데이터가 있으면\nstrAddr = C.\nAddress\n'첫 일치하는 주소를 strAddr에 넣고\nDo\n'다음을 실행\n.Cells(Rows.Count, \"A\").\nEnd(3)(2)\n.Resize(, 4) = _\nC.Offset(, -1).Resize(, 4).Value\n'검색에 일치한 값의 행을 복사\nSet C = rngAll.\nFindNext\n(C)\n'다음 일치하는 데이터를 찾아 변수에 넣고\nIf strAddr = C.Address Then\nExit Do\n'주소가 처음 일치한 셀이면 Do구문종료\nLoop While Not C Is Nothing\n'일치하는 데이터 없을때까지 무한 반복\nEnd If\n.Activate\n'활성화\nSet rngAll = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet C = Nothing\nEnd With\nEnd Sub", "context": "특정한 값(아래 예제의 경우 \"갑\")이 들어 있는 행들만을 추출하는 기능으로 예제 파일에는 10,000행의 데이터가 있음. 다양한 방법으로 접근이 가능하며 코드마다 속도가 다르다. 필터 후 복사, ADO SQL 또는 배열을 사용하는 것이 속도가 빠르다.\n사용한 코드                                                                                                         소요시간\n1. Union 메서드를 이용 (특정값 있는 행만 추출하기 1 )...........................................     33.60초\n2. Copy 메서드 이용 (특정값 있는 행만 추출하기 2 )    ...........................................     29.12초\n3. 위에서 아래로 내려가며 행 삭제 (특정값 있는 행만 추출하기 3 ) ...................."}
{"instruction": "Excel VBA code for: (1302) 특정값 있는 행만 추출하기 6 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_All_Gap6()\nDim rngAll As Range\n'전체영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = ActiveSheet.UsedRange\n'전체 사용영역을 변수에 넣음\nrngAll.FormatConditions.Delete\n'기존 조건부서식 삭제\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'Sheet2의 기존 데이터 삭제\nWith rngAll\n'전체 영역에서\n.\nFormatConditions\n.Add Type:=2, Formula1:=\"=$B1=\"\"갑\"\"\"\n'조건부서식 적용\n.FormatConditions(1\n).Interior.Color\n= 49407\n'조건부서식에 배경색 적용\n.\nAutoFilter\nField:=2, Criteria1:=RGB(255, 192, 0), _\nOperator:=xlFilterCellColor\n'조건부서식의 색깔로 필터\nEnd With\nrngAll.\nSpecialCells(12).Copy\n.Cells(1, 1)\n'전체 보이는 영역을 복사\nrngAll.FormatConditions.Delete\n'(Sheet1) 조건부서식 삭제\n.UsedRange.FormatConditions.Delete\n'(Sheet2) 조건부 서식 삭제\nIf ActiveSheet.\nAutoFilterMode\nThen\n'현재시트에 필터 적용되어 있으면\nrngAll.\nAutoFilter\n'현재시트내의 필터 해제함\nEnd If\n.Activate\n'활성화\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "특정한 값(아래 예제의 경우 \"갑\")이 들어 있는 행들만을 추출하는 기능으로 예제 파일에는 10,000행의 데이터가 있음. 다양한 방법으로 접근이 가능하며 코드마다 속도가 다르다. 필터 후 복사, ADO SQL 또는 배열을 사용하는 것이 속도가 빠르다.\n사용한 코드                                                                                                         소요시간\n1. Union 메서드를 이용 (특정값 있는 행만 추출하기 1 )...........................................     33.60초\n2. Copy 메서드 이용 (특정값 있는 행만 추출하기 2 )    ...........................................     29.12초\n3. 위에서 아래로 내려가며 행 삭제 (특정값 있는 행만 추출하기 3 ) ...................."}
{"instruction": "Excel VBA code for: (1304) 특정값 있는 행만 추출하기 8 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_All_Gap8()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'Sheet2에서 행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'Sheet2의 기존 데이터 삭제\nRows(1).SpecialCells(2).Copy .Cells(1, 1)\n'제목 복사\nr = 1\n'제목행 건너 뛰기 위해 1부터 시작\nFor Each\nrngC\nIn\nColumns(\"B\").\nSpecialCells(2)\n'B열 문자열 각 셀을 순환\nIf rngC = \"갑\" Then\n'B열의 값이 \"갑\"이면\nr = r + 1\n'행을 1씩 늘려감\n.Cells(r, 1).Resize(, 4) = rngC.Offset(, -1).Resize(, 4).Value\n'각 행을 복사\nEnd If\nNext\nrngC\n.Activate\n'활성화\nEnd With\nEnd Sub", "context": "특정한 값(아래 예제의 경우 \"갑\")이 들어 있는 행들만을 추출하는 기능으로 예제 파일에는 10,000행의 데이터가 있음. 다양한 방법으로 접근이 가능하며 코드마다 속도가 다르다. 필터 후 복사, ADO SQL 또는 배열을 사용하는 것이 속도가 빠르다.\n사용한 코드                                                                                                         소요시간\n1. Union 메서드를 이용 (특정값 있는 행만 추출하기 1 )...........................................     33.60초\n2. Copy 메서드 이용 (특정값 있는 행만 추출하기 2 )    ...........................................     29.12초\n3. 위에서 아래로 내려가며 행 삭제 (특정값 있는 행만 추출하기 3 ) ...................."}
{"instruction": "Excel VBA code for: (1305) 특정값 있는 행만 추출하기 9 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_All_Gap9()\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'Sheet2에서 행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'Sheet2의 기존 데이터 삭제\nRows(1).SpecialCells(2).Copy .Cells(1, 1)\n'제목 복사\nr = 1\n'제목행 건너 뛰기 위해 1부터 시작\nFor\ni = 1 To Cells(Rows.Count, 1).End(3).\nRow\n'1 ~ 마지막 행에까지 반복\nIf Cells(i, 2) = \"갑\" Then\n'B열의 값이 \"갑\"이면\nr = r + 1\n'행을 1씩 늘려감\n.Cells(r, 1).Resize(, 4) = Cells(i, 1).Resize(, 4).Value\n'각 행을 복사\nEnd If\nNext\ni\n.Activate\n'활성화\nEnd With\nEnd Sub", "context": "특정한 값(아래 예제의 경우 \"갑\")이 들어 있는 행들만을 추출하는 기능으로 예제 파일에는 10,000행의 데이터가 있음. 다양한 방법으로 접근이 가능하며 코드마다 속도가 다르다. 필터 후 복사, ADO SQL 또는 배열을 사용하는 것이 속도가 빠르다.\n사용한 코드                                                                                                         소요시간\n1. Union 메서드를 이용 (특정값 있는 행만 추출하기 1 )...........................................     33.60초\n2. Copy 메서드 이용 (특정값 있는 행만 추출하기 2 )    ...........................................     29.12초\n3. 위에서 아래로 내려가며 행 삭제 (특정값 있는 행만 추출하기 3 ) ...................."}
{"instruction": "Excel VBA code for: (1306) 특정값 있는 행만 추출하기 10 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_All_Gap10()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'배열크기 늘려갈 변수\nDim varTemp\n()\n'\n동적배열\n로 사용할 변수\nDim c As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'Sheet2의 기존 데이터 삭제\nRows(1).SpecialCells(2).Copy .Cells(1, 1)\n'제목 복사\nFor Each rngC In Columns(\"B\").\nSpecialCells(2)\n'B열 문자열 각 셀을 순환\nIf rngC = \"갑\" Then\n'B열의 값이 \"갑\"이면\nr = r + 1\n'행을 1씩 늘려감\nReDim Preserve\nvarTemp(1 To r)\n'배열크기 재지정\nvarTemp(r) = rngC.Offset(, -1).Resize(, 4)\n'배열에 각 행값을 넣음\nEnd If\nNext rngC\nFor r = 1 To\nUBound\n(varTemp)\n'배열 상한값 까지 반복\n.Cells(.Rows.Count, \"A\").\nEnd(3)(2)\n.Resize(, 4) =\nvarTemp(r)\n'1행씩 배열 값을 셀에 뿌림\nNext r\n.Activate\n'활성화\nEnd With\nEnd Sub", "context": "특정한 값(아래 예제의 경우 \"갑\")이 들어 있는 행들만을 추출하는 기능으로 예제 파일에는 10,000행의 데이터가 있음. 다양한 방법으로 접근이 가능하며 코드마다 속도가 다르다. 필터 후 복사, ADO SQL 또는 배열을 사용하는 것이 속도가 빠르다.\n사용한 코드                                                                                                         소요시간\n1. Union 메서드를 이용 (특정값 있는 행만 추출하기 1 )...........................................     33.60초\n2. Copy 메서드 이용 (특정값 있는 행만 추출하기 2 )    ...........................................     29.12초\n3. 위에서 아래로 내려가며 행 삭제 (특정값 있는 행만 추출하기 3 ) ...................."}
{"instruction": "Excel VBA code for: (1307) 특정값 있는 행만 추출하기 11 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_All_Gap11()\n'------------------------------------------------------------\n'  VBE 도구(Tools) => 참조(References)에\n'  Microsoft ActiveX Data Object Library 2.8 또는 6.0 참조후\n'------------------------------------------------------------\nDim strSQL As String\n'SQL 조건을 넣을 변수\nDim strConn As String\n'Connection 넣을 변수\nDim adoRS As ADODB.Recordset\n'ADO Recordset 넣을 변수\nDim i As Integer\n'반복 구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nstrSQL = \"\nSELECT\n*\n\" & _\n\"\nFROM\n[Sheet1$] \" & _\n\"\nWHERE\n이름 = '갑'  ;\"\n'SQL 조건을 변수에 넣음\nstrConn = \"Provider=                         Microsoft.ACE.OLEDB.12.0;\" & _\n\"Data Source=                   \" & ThisWorkbook.FullName & \";\" & _\n\"Extended Properties=        Excel 12.0;\"\n'연결 조건을 변수에 넣음\nSet adoRS = New ADODB.Recordset\n'Early binding으로 recordset을 변수에\nadoRS.\nOpen\nstrSQL, strConn, adOpenForwardOnly, adLockReadOnly, adCmdText\n'SQL 조건에 따라 연결하여 recordset 열기\nIf Not\nadoRS.EOF\nThen\n'파일의 마지막이 아니라 데이터가 존재하면\nWith Sheets(\"Sheet2\")\n'Sheet2 시트에서\n.Range(\"A1\").CurrentRegion.Clear\n'기존 데이터 삭제\nRows(1).SpecialCells(2).Copy .Cells(1, 1)\n'제목 복사\n.Range(\"A2\").\nCopyFromRecordset\nadoRS\n'데이터 복사\n.Activate\n'활성화\nEnd With\nElse\nMsgBox \"자료가 없습니다\", 64, \"데이터 오류\"\n'메시지 출력\nEnd If\nadoRS.Close\n'recordset 닫음\nSet adoRS = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "특정한 값(아래 예제의 경우 \"갑\")이 들어 있는 행들만을 추출하는 기능으로 예제 파일에는 10,000행의 데이터가 있음. 다양한 방법으로 접근이 가능하며 코드마다 속도가 다르다. 필터 후 복사, ADO SQL 또는 배열을 사용하는 것이 속도가 빠르다.\n사용한 코드                                                                                                         소요시간\n1. Union 메서드를 이용 (특정값 있는 행만 추출하기 1 )...........................................     33.60초\n2. Copy 메서드 이용 (특정값 있는 행만 추출하기 2 )    ...........................................     29.12초\n3. 위에서 아래로 내려가며 행 삭제 (특정값 있는 행만 추출하기 3 ) ...................."}
{"instruction": "Excel VBA code for: (1308) 특정값 있는 행만 추출하기 12 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_All_Gap12()\nDim rngAll As Range\n'전체영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = ActiveSheet.UsedRange\n'전체 사용영역을 변수에 넣음\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'Sheet2의 기존 데이터 삭제\nWith rngAll\n'전체 영역에서\n.\nAutoFilter\n2, \"갑\", , , 1\n'자동필터 적용\nEnd With\nrngAll.Copy .Cells(1, 1)\n'전체 영역을 복사\nIf ActiveSheet.\nAutoFilterMode\nThen\n'현재시트에 필터 적용되어 있으면\nrngAll.\nAutoFilter\n' 현재시트내의 필터 해제함\nEnd If\n.Activate\n'활성화\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "특정한 값(아래 예제의 경우 \"갑\")이 들어 있는 행들만을 추출하는 기능으로 예제 파일에는 10,000행의 데이터가 있음. 다양한 방법으로 접근이 가능하며 코드마다 속도가 다르다. 필터 후 복사, ADO SQL 또는 배열을 사용하는 것이 속도가 빠르다.\n사용한 코드                                                                                                         소요시간\n1. Union 메서드를 이용 (특정값 있는 행만 추출하기 1 )...........................................     33.60초\n2. Copy 메서드 이용 (특정값 있는 행만 추출하기 2 )    ...........................................     29.12초\n3. 위에서 아래로 내려가며 행 삭제 (특정값 있는 행만 추출하기 3 ) ...................."}
{"instruction": "Excel VBA code for: (1309) 특정값 있는 행만 추출하기 13 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_All_Gap13()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'배열크기 늘려갈 변수\nDim varTemp()\n'정적배열로 사용할 변수\nDim c As Integer\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nReDim\nvarTemp(1 To Cells(Rows.Count, 1).End(3).Row, 1 To 4)\n'배열크기 재지정\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'Sheet2의 기존 데이터 삭제\nRows(1).SpecialCells(2).Copy .Cells(1, 1)\n'제목 복사\nFor Each rngC In Columns(\"B\").SpecialCells(2)\n'B열 문자열 각 셀을 순환\nIf rngC = \"갑\" Then\n'B열의 값이 \"갑\"이면\nr = r + 1\n'행을 1씩 늘려감\nFor c = 1 To 4\n'4회 반복\nvarTemp(r, c)\n= Cells(rngC.Row, c)\n'배열에 각 행의 값을 넣음\nNext c\nEnd If\nNext rngC\n.Cells(2, 1).Resize(\nUBound\n(varTemp,\n1\n),\nUBound\n(varTemp,\n2\n)) =\nvarTemp\n'배열값 시트에 뿌림\n.Activate\n'활성화\nEnd With\nEnd Sub", "context": "특정한 값(아래 예제의 경우 \"갑\")이 들어 있는 행들만을 추출하는 기능으로 예제 파일에는 10,000행의 데이터가 있음. 다양한 방법으로 접근이 가능하며 코드마다 속도가 다르다. 필터 후 복사, ADO SQL 또는 배열을 사용하는 것이 속도가 빠르다.\n사용한 코드                                                                                                         소요시간\n1. Union 메서드를 이용 (특정값 있는 행만 추출하기 1 )...........................................     33.60초\n2. Copy 메서드 이용 (특정값 있는 행만 추출하기 2 )    ...........................................     29.12초\n3. 위에서 아래로 내려가며 행 삭제 (특정값 있는 행만 추출하기 3 ) ...................."}
{"instruction": "Excel VBA code for: (1310) 특정값 있는 행만 추출하기 14 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_All_Gap14()\nDim r As Long\n'배열크기 늘려갈 변수\nDim varTemp\n'임시배열로 사용할 변수\nDim c As Integer\n'열 개수만큼 반복할 변수\nDim varR()\n'추출된 값만 넣을 결과배열 변수\nDim y As Long\n'배열위치 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nvarTemp\n=\nActiveSheet.UsedRange\n'전체 사용영역을 배열에 넣음\nReDim\nvarR(1 To Cells(Rows.Count, 1).End(3).Row, 1 To 4)\n'배열크기 재지정\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'Sheet2의 기존 데이터 삭제\nRows(1).SpecialCells(2).Copy .Cells(1, 1)\n'제목 복사\nFor r = 1 To UBound(varTemp, 1)\n'임시배열의 상한값 까지 반복\nIf varTemp(r, 2) = \"갑\" Then\n'값이 \"갑\"이면\ny = y + 1\n'배열위치 1씩 늘려감\nFor c = 1 To 4\n'4회 반복\nvarR(y, c) = varTemp(r, c)\n'결과배열에 임시배열의 각 행 값을 넣음\nNext c\nEnd If\nNext r\n.Cells(2, 1).Resize(\nUBound\n(varTemp,\n1\n),\nUBound\n(varTemp,\n2\n)) =\nvarR\n'결과배열값 시트에 뿌림\n.Activate\n'활성화\nEnd With\nEnd Sub", "context": "특정한 값(아래 예제의 경우 \"갑\")이 들어 있는 행들만을 추출하는 기능으로 예제 파일에는 10,000행의 데이터가 있음. 다양한 방법으로 접근이 가능하며 코드마다 속도가 다르다. 필터 후 복사, ADO SQL 또는 배열을 사용하는 것이 속도가 빠르다.\n사용한 코드                                                                                                         소요시간\n1. Union 메서드를 이용 (특정값 있는 행만 추출하기 1 )...........................................     33.60초\n2. Copy 메서드 이용 (특정값 있는 행만 추출하기 2 )    ...........................................     29.12초\n3. 위에서 아래로 내려가며 행 삭제 (특정값 있는 행만 추출하기 3 ) ...................."}
{"instruction": "Excel VBA code for: (1311) 특정값 있는 행만 추출하기 15 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_All_Gap15()\nDim rngAll As Range\n'전체영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = ActiveSheet.UsedRange\n'전체 사용영역을 변수에 넣음\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'Sheet2의 기존 데이터 삭제\nWith Cells(1, 6)\n'F1셀에서\n.Value = \"이름\"\n'조건식제목을 넣음\n.Offset(1) = \"갑\"\n'F2 셀에 \"갑\"을 넣음\nEnd With\nrngAll.\nAdvancedFilter\n2, Cells(1, 6).Resize(2, 1), .Cells(1, 1)\n'B열이 \"갑\"인 행을 제목포함 sheet2에 추출\nCells(1, 6).Resize(2, 1).ClearContents\n'임시로 사용한 영역의 조건 삭제\n.Activate\n'활성화\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "특정한 값(아래 예제의 경우 \"갑\")이 들어 있는 행들만을 추출하는 기능으로 예제 파일에는 10,000행의 데이터가 있음. 다양한 방법으로 접근이 가능하며 코드마다 속도가 다르다. 필터 후 복사, ADO SQL 또는 배열을 사용하는 것이 속도가 빠르다.\n사용한 코드                                                                                                         소요시간\n1. Union 메서드를 이용 (특정값 있는 행만 추출하기 1 )...........................................     33.60초\n2. Copy 메서드 이용 (특정값 있는 행만 추출하기 2 )    ...........................................     29.12초\n3. 위에서 아래로 내려가며 행 삭제 (특정값 있는 행만 추출하기 3 ) ...................."}
{"instruction": "Excel VBA code for: (1313) 소계(부분합) 구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Subtotal()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'공백까지의 개수 구할 변수\nDim rngA As Range\n'각 구역(area)을 넣을 영역변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim c As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'(제목 제외한) 2행 부터 시작\nDo\n'다음을 실행\nIf Cells(r, 2) <> \"\" Then\n'B열 각 셀이 빈셀이 아니면\ni = i + 1\n'개수를 하나씩 늘려감\nElse\n'빈 셀이면\nSet\nrngA = Cells(r - i, 3).Resize(i, 3)\n'각 구역(area)을 변수에 넣음\nFor Each rngC In Cells(r, 3).Resize(, 3)\n'빈셀 있는 행의 C:E열 각 셀 순환\nc = c + 1\n'열 위치 1씩 늘려감\nrngC =\nApplication.Sum\n(rngA.\nColumns(c)\n)\n'각 셀에 각 구역의 열 합계를 넣음\nNext rngC\ni = 0\n'재사용 위하여 초기화\nc = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nSet rngA = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                                              매크로 실행 후 결과\nOption Explicit\nSub find_Subtotal()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'공백까지의 개수 구할 변수\nDim rngA As Range\n'각 구역(area)을 넣을 영역변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim c As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'(제목 제외한) 2행 부터 시작\nDo\n'다음을 실행\nIf Cells(r, 2) <> \"\" Then\n'B열 각 셀이 빈셀이 아니면\ni = i + 1\n'개수를 하나씩 늘려감\nElse\n'빈 셀이면\nSet\nrngA = Cells(r - i, 3).Resize(i, 3)\n'각 구역(area)을 변수에 ..."}
{"instruction": "Excel VBA code for: (1314) 각 주(週)의 합계 구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub weekly_Sum()\nDim cnt As Integer\n'각 주의 카운터로 사용할 변수\nDim r As Long\n'행을 늘려갈 변수\nDim i As Long\n'날짜 카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"C:D\").SpecialCells(2).Offset(1).\nClear\n'C:D열의 기존 데이터 삭제\nr = 1\n'(제목행 건너 뛰기 위해) 1 부터 시작\nDo\n'다음을 실행\ncnt = cnt + 1\n'몇 주차인지 카운터할 변수 1씩 늘려감\nDo\n'다음을 실행\ni = i + 1\n'날짜 카운터를 하나씩 늘려감\nr = r + 1\n'행번호를 하나씩 늘려감\nLoop Until\nCells(r, 1) = \"\" Or _\nCells(r, 1).\nDisplayFormat\n.Font.ColorIndex\n= 3\n'A열이 빈셀 또는 빨간날짜일 때까지 무한 반복\nWith Cells(Rows.Count, \"C\")\n'C열 마지막 셀에서\n.End(3)(2) = cnt & \" 주차 합계 :\"\n'종단셀 윗방향 바로 아래셀에 몇 주차인지 입력\n.End(3)(1, 2) =\nApplication.Sum\n(Cells(r, 2).Offset(-i + 1).Resize(i))\nEnd With\n'각 주의 합계를 종단셀 윗방향이용 D열에 입력\ni = 0\n'재사용위해 날짜카운터 초기화\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nWith Cells(Rows.Count, \"C\")\n'C열 마지막 셀에서\n.End(3)(2).\nInterior.ColorIndex\n= 6\n'종단셀 윗방향 바로 아래셀을 노란색으로 채움\n.End(3)(2) = \"전체합계 : \"\n'종단셀 윗방향 바로 아래셀에 전체합계 입력\n.End(3)(1, 2) = Application.Sum(Columns(\"D\"))\n'전체합계를 D열 마지막행에 입력\nEnd With\nColumns(\"D\").\nNumberFormat\n= \"#,##0\"\n'D열의 서식을 콤마로 지정\nColumns(\"A:D\").AutoFit\n'A:D열 열너비 자동맞춤\nEnd Sub", "context": "조건부 서식을 이용하여 토요일은 파란색, 일요일은 빨간색으로 표시함.\n파란색에 적용한 조건부서식 : =WEEKDAY($A2) = 7\n빨간색에 적용한 조건부서식 : =WEEKDAY($A2) = 1\n매크로 실행 전                                                   매크로 실행 후 결과\n참고로, DisplayFormat은 2010에서만 지원하므로 2010 이하에서는\nLoop Until Cells(r, 1) = \"\" Or _\nCells(r, 1).DisplayFormat.Font.ColorIndex = 3\n코드를\nLoop Until Cells(r, 1) = \"\" Or _\nWeekday(Cells(r, 1)) = vbSunday\n라고 수정하면 된다.\nOption Explicit\nSub weekly_Sum()\nDim cnt As Integer\n'각 주의 카운터로 사용할 변수\nDim r As Long\n'행을 늘려갈 변수\nDim i As Long\n'날짜 카운..."}
{"instruction": "Excel VBA code for: (1317) 짝수 또는 홀수행만 가져오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub bring_Every_Other_Row()\nDim rngSel As Range\n'선택영역 전체를 넣을 변수\nDim sht As\nWorksheet\n'마우스로 선택한 시트를 넣을 변수\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim colsCnt As Integer\n'전체 열개수 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수 / 2 + 1을 넣을 변수\nDim var\n()\n'정적배열로 사용할 변수\nDim r As Long\n'배열크기 늘려갈 변수\nDim i As Long\n'반복구문에 사용할변수\nDim c As Integer\n'열 개수만큼 반복할 변수\nDim y As Long\n'행 위치 2씩 건너뛰며 늘려갈 변수\n'-----------------------------------------\n' 데이터를 가져올 시트를 선택하는 코드\n'-----------------------------------------\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet\nrngSel =\nApplication.InputBox\n(\"마우스로 영역을 설정하시오!\",\nType:=8\n)\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.Clear\n'기존 데이터 삭제\nWith rngSel.\nParent\n'선택한 셀의 부모\nSet sht = Workbooks(.\nParent.Name\n).Worksheets(.Name)\nEnd With\n'선택한 셀의 시트를 변수에 넣음\nWith sht\n'sht 에서\n.Rows(1).SpecialCells(2).Copy [A1]\n'제목행을 A1셀에 복사\nlastRow = .Cells(.Rows.Count, \"A\").End(3).\nRow\n'마지막 행을 변수에 넣음\ncolsCnt = .UsedRange.Columns.Count\n'전체 열개수를 변수에 넣음\nEnd With\nrowsCnt =\nInt\n((lastRow - Cells(rngSel.Row, 1).Row) / 2 + 1)\n'전체 행개수 / 2 + 1을 변수에넣음\nReDim varT(1 To rowsCnt, 1 To colsCnt)\n'배열크기 재지정\ny = Cells(rngSel.Row, 1).Row\n'마지막 행을 변수에 넣음\n'------------------------------------------\n' 1행씩 건너 뛰며 데이터를 배열에 넣는 코드\n'------------------------------------------\nFor\ni = 1 To rowsCnt\n'rowsCnt 개수만큼 반복\nr = r + 1\n'배열 크기 1씩 늘려감\nFor\nc = 1 To colsCnt\n'열 개수만큼 반복\nvarT(r, c) = sht.Cells(y, c)\n'배열에 각 셀의 값을 넣음\nNext\nc\ny = y + 2\n'행 위치 2씩 늘려감\nNext\ni\nCells(2, 1).Resize(rowsCnt, colsCnt) = varT\n'배열값 시트에 뿌림\nColumns(\"A:D\").\nAutoFit\n'A:D열 열 너비 자동맞춤\nSet rngSel = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet sht = Nothing\nEnd Sub", "context": "매크로를 실행 후 영역 선택창이 나타나면 데이터를 가져오려는 시트를 선택하고, 셀을 선택한다. 마우스로 선택한 셀을 기준으로 아래에 있는 데이터를 한 행씩 건너 뛰면서 마지막 행까지 가져오는 기능. 다른 시트는 물론\n다른 파일에 있는 데이터도 가져올 수 있음\n.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1317) 짝수 또는 홀수행만 가져오기 (엑셀 VBA 매크로)\n재생\n2,240\n재생 (space/k)\n재생\n00:28\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:28\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정..."}
{"instruction": "Excel VBA code for: (1318) 선택한 파일만 세로 정렬하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub selected_Windows_Arrangement()\n'Run Macro 버튼에 연결된 코드\nUserForm1.\nShow\n'사용자폼을 화면에 띄움\nEnd Sub\n\nPrivate Sub CommandButton1_Click()\n'Exit 버튼에 연결된 코드\nUnload Me\n'사용자폼을 닫음\nEnd Sub\n\nPrivate Sub CommandButton2_Click()\n'\"초기화\"버튼에 연결된 코드\nDim i As Integer\n'반복구문에 사용할 변수\nFor i = 0 To ListBox1.\nListCount\n- 1\n'목록의 개수 만큼 반복\nListBox1.\nSelected\n(i) = False\n'선택된 목록의 선택을 해제\nNext i\nEnd Sub\n\nPrivate Sub CommandButton3_Click()\n'\"창정렬\" 버튼에 연결된 코드\nDim i As Integer\n'반복구문에 사용할 변수\nFor i = 0 To ListBox1.ListCount - 1\n'목록의 개수 만큼 반복\nIf ListBox1.Selected(i) = True Then\n'만약 목록이 선택되어 있다면\nWindows(ListBox1.List(i)).\nWindowState\n= xlNormal\n'창을 일반보기로 설정\nElse\n'목록이 선택되어 있지 않다면\nWindows(ListBox1.List(i)).WindowState = xlMinimized\n'창을 최소화\nEnd If\nNext i\nWindows.Arrange\nArrangeStyle:=xlVertical\n'화면에 띄워진 창을 세로보기로 정렬\nEnd Sub\n\nPrivate Sub UserForm_Initialize()\n'사용자폼이 열리면 자동실행될 코드\nDim wkb As Workbook\n'파일을 넣을 변수\nDim r As Integer\n'행 위치 늘려갈 변수\nDim rngAll As Range\n'A열의 전체 문자를 넣을 변수\nDim rngC As Range\n'A열 각 셀을 넣을 변수\nWith ThisWorkbook.Sheets(1)\n'이 매크로 실행파일 Sheet1에서\n.UsedRange.ClearContents\n'사용영역에 입력된 데이터 삭제\nFor Each wkb In Workbooks\n'각 파일을 순환\nIf Windows(wkb.Name).\nVisible\n= True Then\n'만일 파일이 보이기로 설정되었으면\nr = r + 1\n'행 위치 1씩 늘려감\n.Cells(r, 1) = wkb.Name\n'A열에 파일의 이름을 입력\nEnd If\nNext wkb\n.Columns(1).SpecialCells(2).\nSort\n.[A1], 1\n'A열을 오름차순으로 정렬\nSet rngAll = .Range(.Cells(1, 1), .Cells(.Rows.count, 1).End(3))\n'A열 전체를 변수에 넣음\nFor Each rngC In rngAll\n'A열 각 셀을 순환\nListBox1.\nAddItem\nrngC\n'목록에 각 파일이름을 추가\nNext rngC\nWith ListBox1\n'목록에서\n.\nMultiSelect\n= fmMultiSelectMulti\n'복수의 목록을 선택할 수 있도록 설정\n.\nListStyle\n= fmListStyleOption\n'옵션버튼 방식으로 목록 설정\nEnd With\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "아래 코드를 요청한 분은 50개가 넘는 파일이 서로를 참조하고 있어 이를 모두 띄워놓고 작업하는 상황. 띄워진 파일 중 자신이 원하는 두 세개의 창만을 화면에 세로 정렬하려고 하여도 파일이 너무 많아 찾기 힘들어 아래와 같은 코드를 요청하심. 참고로, 아래의 코드는\n\"개인용 매크로 통합문서\"에 저장하고 단축키를 지정\n하여 사용하여야 편리하다. 개인용 매크로 통합문서에 넣으면 동영상에 나타나지 않으므로 동영상에서는 별도의 파일에 넣어서 작동방법을 보여줌.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1318) 선택한 파일만 세로 정렬하기 (엑셀 VBA 매크로)\n재생\n2,126\n재생 (space/k)\n재생\n01:07\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:07\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안..."}
{"instruction": "Excel VBA code for: (1319) 왼쪽 열부터 채우며 내림차순 정렬하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_Overall_Descending()\nDim rngAll As Range\n'전체 사용영역을 넣을 변수\nDim colsCnt As Integer\n'전체 열개수 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim i As Long\n'반복 구문에 사용할 변수\nDim r As Long\n'행 위치 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet\nrngAll = ActiveSheet.UsedRange\n'전체 사용영역을 변수에 넣음\nrowsCnt = rngAll.\nRows.Count\n'전체 행 개수를 변수에 넣음\ncolsCnt = rngAll.\nColumns.Count\n'전체 열개수를 변수에 넣음\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nFor i = 1 To colsCnt\n'전체 열 개수만큼 반복\n.Cells(.Rows.Count, \"A\").\nEnd(3)(2)\n.Resize(rowsCnt) = _\nrngAll.Columns(i).Value\n'각 열을 Sheet2 A열에 복사\nNext i\n.Columns(1).\nSort\n.Range(\"A1\"),\n2\n'값을 내림차순으로 정렬\nr = 1\n'1행부터 시작\nWith Sheets(3)\n.UsedRange.ClearContents\n'기존 데이터 삭제\nSet rngAll = .Range(rngAll.\nAddress\n)\n'Sheet3 영역을 변수에 넣음\nEnd With\nFor i = 1 To colsCnt\n'전체 열 개수만큼 반복\nrngAll.Columns(i) = .Cells(r, 1).Resize(rowsCnt).Value\n'Sheet2를 각 열에 복사\nr = r + rowsCnt\n'행의 위치를 늘려감\nNext i\nEnd With\nSheets(3).Activate\n'Sheet3 활성화\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기\n)\nEnd Sub", "context": "Sheet1 에 있는 아래와 같은 데이터를 A열에서 부터 오른쪽으로 내림차순으로 채워가는 기능. 데이터를 Sheet2에 임시로 복사하여 내림차순으로 정렬하고 이를 다시 Sheet3에 옮기는 방법을 사용함.\n매크로 실행 전(Sheet2 와 Sheet3 은 비어 있음)           매크로 실행 후 Sheet3 의 결과\nOption Explicit\nSub sort_Overall_Descending()\nDim rngAll As Range\n'전체 사용영역을 넣을 변수\nDim colsCnt As Integer\n'전체 열개수 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim i As Long\n'반복 구문에 사용할 변수\nDim r As Long\n'행 위치 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet\nrngAll = ActiveSheet.UsedRange\n'전체 사용영역을 변수에 넣음\nrowsCnt..."}
{"instruction": "Excel VBA code for: (1320) 선택영역 각 행에 빈행 삽입하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Rows_In_Selection()\nDim input_Value As String\n'입력값을 넣을 변수\nDim msg As String\n'메시지 넣을 문자 변수\nConst\nintMin As Integer =\n1\n'최솟값을 넣을 변수\nConst intMax As Integer =\n100\n'최댓값을 넣을 변수\nDim colsCnt As Integer\n'전체 열개수 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim totalRow As Long\n'선택영역 행 x 입력창 값 넣을 변수\nDim varTemp\n()\n'정적배열로 사용할 변수\nDim r As Long\n'행 늘려갈 변수\nDim c As Integer\n'열 늘려갈 변수\nDim y As Long\n'배열위치 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nIf Selection.\nColumns.Count\n<> Columns.Count Then\n'전체행 선택하지 않으면\nMsgBox \"전체행을 선택하고 다시 실행\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\n'----------------------------------------------\n' 입력창으로 삽입할 행의 개수 결정하는 코드\n'----------------------------------------------\nDo\n'다음을 실행\ninput_Value =\nInputBox\n(intMin & \" 과 \" & intMax & \" 사이의 숫자를 입력.\")\n'입력창 값을 변수에 넣음\nIf input_Value = \"\" Then Exit Sub\n'입력값 없으면 매크로 중단\nIf\nIsNumeric\n(input_Value) Then\n'입력값이 숫자이면\nIf input_Value >= intMin And input_Value <= intMax Then\nExit\nDo\n'최솟값보다 크거나 같고, 최댓값보다 작거나 같으면 Do 구문 종료\nEnd If\nEnd If\nmsg = \"번호입력 오류.\" &\nvbCr\n& vbCr\n'메시지창 내용 + 줄바꿈 2번\nmsg = msg & intMin & \" 과 \" & intMax & \" 사이의 숫자를 입력.\"\n'메시지창 내용\nMsgBox msg, 64, \"입력오류\"\nLoop\n'무한 반복\nrowsCnt = Selection.Rows.Count\n'선택영역 행 개수를 변수에 넣음\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'현재시트 사용영역 열개수를 변수에 넣음\ntotalRow = rowsCnt * input_Value + rowsCnt\n'선택영역 행 x 입력창 값을 변수에 넣음\nIf totalRow > 1000000 Then\n'삽입될 행이 1000000 행이 넘을 경우\nMsgBox \"삽입될 행이 1000000행을 넘어갑니다.\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nReDim\nvarTemp(1 To totalRow, 1 To colsCnt)\n'배열크기 재지정\n'----------------------------------------------\n' 선택영역을 배열에 넣었다 셀에 뿌리는 코드\n'----------------------------------------------\ny = 1\n'배열 위치 1부터 시작\nFor r = 1 To rowsCnt\n'행 개수만큼 반복\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nvarTemp(y, c) = Selection.Cells(r, c)\n'배열에 선택영역 값을 넣음\nNext c\ny = y + input_Value + 1\n'배열 값 입력될 위치 늘려감\nNext\nSelection.\nEntireRow.Delete\n'선택 영역 행삭제\nSelection.Cells(1, 1).Resize(totalRow).\nEntireRow.Insert\n'행삽입\nSelection.Cells(1, 1).Resize(totalRow, colsCnt) = varTemp\n'배열값 셀에 뿌림\nEnd Sub", "context": "매크로 실행 전 전체 행을 선택한 모습                         매크로 실행 후 결과\n위 경우 매크로 실행 후 나타나는 입력창에서 3을 넣은 결과임.\n선택영역 각 행마다 입력창에 입력한 숫자만큼 행을 삽입하는 기능. 전체행을 선택하고 매크로를 실행하여야 한다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1320) 선택영역 각 행에 빈행 삽입하기 1 (엑셀 VBA 매크로)\n재생\n1,603\n재생 (space/k)\n재생\n00:37\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:37\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도..."}
{"instruction": "Excel VBA code for: (1321) 컬렉션 이용한 공백행 삭제 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Blank_Rows_Using_Collection()\nDim X As\nNew Collection\n'컬렉션으로 사용할 변수\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor i = 1 To Cells(Rows.Count, 1).End(3).\nRow\n'1행에서 마지막행까지 반복\nIf Cells(i, 1) <> \"\" Then\n'A열이 빈셀이 아니라면\nX.Add\nCells(i, 1).Resize(, 4)\n'각 행을 컬렉션에 넣음\nEnd If\nNext i\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nFor i = 1 To X.Count\n'컬렉션의 개수만큼 반복\n.Cells(i, 1).Resize(, 4) = X.\nItem(i).Value\n'셀에 각 컬렉션의 아이템 값을 뿌림\nNext i\n.Activate\n'활성화\nEnd With\nEnd Sub", "context": "마치 배열(array)과 마찬가지로 컬렉션에도 영역을 넣을 수 있다. 배열보다 빠른 것도 아니고 값을 시트에 뿌릴 때에도 배열이 더 유리하지만 \"컬렉션을 이런 용도로도 사용할 수 있구나\" 정도로 생각하고 넘어가면 될 듯.\n매크로 실행 전 (Sheet2 는 비어 있음)                               매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub delete_Blank_Rows_Using_Collection()\nDim X As\nNew Collection\n'컬렉션으로 사용할 변수\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor i = 1 To Cells(Rows.Count, 1).End(3).\nRow\n'1행에서 마지막행까지 반복\nIf Cells(i, 1) <> \"\" Then\n'A열이 빈셀이 아니라면\nX.Add\nCells(i, 1).Re..."}
{"instruction": "Excel VBA code for: (1322) 이름 일치하는 파일만 폴더에서 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_Files_In_Folder()\nDim strPath As String\n'파일 가져올 폴더 경로를 넣을 변수\nDim strTarget As String\n'파일이 복사될 폴더 경로를 넣을 변수\nDim i As Integer\n'반복구문에 사용될 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strExt As String\n'파일 확장자를 넣을 변수\nDim rngC As Range\n'A열 각 셀을 넣을 변수\nDim msgYN As String\n'메시지 박스 선택결과 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n'--------------------------------------\n' 파일 가져올 폴더 선택하는 코드\n'--------------------------------------\nWith Application.\nFileDialog(msoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Title = \"파일을 복사해올 폴더 선택\"\n'폴더창 타이틀\n.Show\n'폴더 선택창 띄우기\nIf .\nSelectedItems\n.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 종료\nElse\n'폴더 선택시\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'--------------------------------------\n' 파일 복사될 폴더 선택하는 코드\n'--------------------------------------\nWith Application.FileDialog(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Title = \"파일이 복사될 폴더 선택\"\n'폴더창 타이틀\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 종료\nElse\n'폴더 선택시\nstrTarget = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nFor i = 1 To 2\n'2회 반복\nstrExt =\nChoose\n(i, \"*.xls*\", \"*.jpg\")\n'파일 확장자를 선택\nfileName =\nDir\n(strPath & strExt)\n'(폴더내)파일을 변수에 넣음\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nFor Each rngC In Range(\"A1\", Cells(Rows.Count, \"A\").End(3))\n'A열 각 셀을 순환\nIf fileName = rngC Then\n'파일이름과 셀의 이름이 일치하면\nOn Error\nResume Next\n'에러 발생해도 다음코드 진행\nIf\nFileLen\n(strTarget & fileName) > 0 Then\n'복사될 폴더에 동일파일 존재여부 확인\nIf\nErr\n<> 0 Then\n'동일한 파일이 없을 경우(에러가 난 경우)\nFileCopy\nstrPath & fileName, strTarget & fileName\n'파일을 복사\nElse\n'동일한 파일이 존재할 경우\nErr.\nClear\n'발생한 에러 초기화\n'-------------------------------------------------\n' 복사될 폴더에 동일 파일 존재할 경우의 처리코드\n'-------------------------------------------------\nmsgYN =\nMsgBox\n(fileName & \" 파일이 존재. 덮어쓸까요?\", 3, \"파일존재\")\nSelect Case msgYN\n'메시지박스 결과를 선택\nCase vbYes:\n'Yes 선택 시\nKill\nstrTarget & fileName\n'기존파일 삭제\nFileCopy strPath & fileName, strTarget & fileName\n'파일을 복사\nCase vbNo:\n'No 선택 시 덮어쓰지 않음\nCase vbCancel: Exit Sub\n'취소시 메크로 종료\nEnd Select\nEnd If\nOn Error GoTo 0\n'에러 검출기능 복원\nEnd If\nEnd If\nNext rngC\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nNext i\nEnd Sub", "context": "A열에 있는 파일 이름과 일치하는 파일을 Source 폴더에서 찾고, 이름이 일치할 경우 Target 폴더로 파일을\n복사\n하는 기능. 만일 Target 폴더에 이미 동일한 파일이 존재할 경우 사용자에게 덮어쓸지 또는 덮어쓰지 않을지 묻는 기능을 포함.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1322) 이름 일치하는 파일만 폴더에서 복사하기 (엑셀 VBA 매크로)\n재생\n1,718\n재생 (space/k)\n재생\n00:42\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:42\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정..."}
{"instruction": "Excel VBA code for: (1323) 이름 일치하는 파일만 폴더에서 이동하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_Files_In_Folder()\nDim strPath As String\n'파일 가져올 폴더 경로를 넣을 변수\nDim strTarget As String\n'파일이 이동될 폴더 경로를 넣을 변수\nDim i As Integer\n'반복구문에 사용될 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strExt As String\n'파일 확장자를 넣을 변수\nDim rngC As Range\n'A열 각 셀을 넣을 변수\nDim msgYN As String\n'메시지 박스 선택결과 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n'--------------------------------------\n' 파일 가져올 폴더 선택하는 코드\n'--------------------------------------\nWith Application.\nFileDialog(msoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Title = \"파일을 이동해올 폴더 선택\"\n'폴더창 타이틀\n.Show\n'폴더 선택창 띄우기\nIf .\nSelectedItems\n.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 종료\nElse\n'폴더 선택시\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'--------------------------------------\n' 파일 이동될 폴더 선택하는 코드\n'--------------------------------------\nWith Application.FileDialog(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Title = \"파일이 이동될 폴더 선택\"\n'폴더창 타이틀\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 종료\nElse\n'폴더 선택시\nstrTarget = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nFor i = 1 To 2\n'2회 반복\nstrExt =\nChoose\n(i, \"*.xls*\", \"*.jpg\")\n'파일 확장자를 선택\nfileName =\nDir\n(strPath & strExt)\n'(폴더내)파일을 변수에 넣음\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nFor Each rngC In Range(\"A1\", Cells(Rows.Count, \"A\").End(3))\n'A열 각 셀을 순환\nIf fileName = rngC Then\n'파일이름과 셀의 이름이 일치하면\nOn Error\nResume Next\n'에러 발생해도 다음코드 진행\nIf\nFileLen\n(strTarget & fileName) > 0 Then\n'이동될 폴더에 동일파일 존재여부 확인\nIf\nErr\n<> 0 Then\n'동일한 파일이 없을 경우(에러가 난 경우)\nName\nstrPath & fileName\nAs\nstrTarget & fileName\n'파일을 이동\nElse\n'동일한 파일이 존재할 경우\nErr.\nClear\n'발생한 에러 초기화\n'-------------------------------------------------\n' 이동될 폴더에 동일 파일 존재할 경우의 처리코드\n'-------------------------------------------------\nmsgYN =\nMsgBox\n(fileName & \" 파일이 존재. 덮어쓸까요?\", 3, \"파일존재\")\nSelect Case\nmsgYN\n'메시지박스 결과를 선택\nCase vbYes:\n'Yes 선택 시\nKill\nstrTarget & fileName\n'기존파일 삭제\nName strPath & fileName As strTarget & fileName\n'파일을 이동\nCase vbNo:\n'No 선택 시 덮어쓰지 않음\nCase vbCancel: Exit Sub\n'취소시 메크로 종료\nEnd Select\nEnd If\nOn Error GoTo 0\n'에러 검출기능 복원\nEnd If\nEnd If\nNext rngC\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nNext i\nEnd Sub", "context": "A열에 있는 파일 이름과 일치하는 파일을 Source 폴더에서 찾고, 이름이 일치할 경우 Target 폴더로 파일을\n이동\n하는 기능. 만일 Target 폴더에 이미 동일한 파일이 존재할 경우 사용자에게 파일을 이동(Target 폴더의 파일이 삭제되고, Source 폴더의 파일이 이동)할지 묻는 기능을 포함.\n배열에 넣어 작업하면 속도는 더 나겠지만 초보님들은 이해하기 더 어려워질 것이므로 아래와 같이함.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1323) 이름 일치하는 파일만 폴더에서 이동하기 (엑셀 VBA 매크로)\n재생\n985\n재생 (space/k)\n재생\n01:00\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:00\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n..."}
{"instruction": "Excel VBA code for: (1324) 값이 작아지면 열 교차하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub switch_When_Going_Down()\nDim bln As\nBoolean\n'C열 또는 D열 위치를 결정할 변수\nDim colNo As Integer\n'열번호 결정해 넣을 변수\nDim y As Long\n'행위치 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"A\").ClearContents\n'A열의 기존 데이터 삭제\nDo\n'다음을 실행\nIf bln = False Then\n'bln 이 거짓일 경우\ncolNo = 3\n'colNo 에 3를 대입\nElse: colNo = 4\n'참일 경우 4을 대입\nEnd If\nDo\n'다음을 실행\ny = y + 1\n'행위치 1씩 늘려감\nCells(y, 1) = Cells(y, colNo)\n'A열에 C또는 D열의 값을 입력\nLoop Until\nCells(y, colNo) > Cells(y + 1, colNo) Or _\nCells(y, 3) = \"\"\n'아래행이 윗행보다 작거나 빈셀일때까지 무한 반복\nbln = Not bln\n'bln 값을 반전시킴\nLoop Until\nCells(y, 3) = \"\"\n'C열에 빈셀 나올때까지 무한 반복\nEnd Sub", "context": "1. C행부터 시작하며, 아래행이 윗행보다 작아질 때까지 값을 A열에 입력\n2. 아래셀이 윗셀보다 값이 작으면 C열과 D열을 번갈아 가면서 작업\n매크로 실행 전                                                              매크로 실행 후 결과 (화살표는 이해를\n돕기 위해 수작업으로 넣은 것)\nOption Explicit\nSub switch_When_Going_Down()\nDim bln As\nBoolean\n'C열 또는 D열 위치를 결정할 변수\nDim colNo As Integer\n'열번호 결정해 넣을 변수\nDim y As Long\n'행위치 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"A\").ClearContents\n'A열의 기존 데이터 삭제\nDo\n'다음을 실행\nIf bln = False Then\n'bln 이 거짓일 경우\ncolNo = 3\n'colNo 에 3를 대..."}
{"instruction": "Excel VBA code for: (1325) 괄호안의 숫자 더하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub sum_In_Parenthesis()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim strU As String\n'(과 ) 사이의 문자를 합칠변수\nDim lngSum As Long\n'괄호안의 값을 합쳐갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"B\").ClearContents\n'B열의 기존 데이터 삭제\nFor Each\nrngC\nIn\nColumns(1).SpecialCells(2)\n'A열 각 문자셀을 순환\nFor i = 1 To Len(rngC)\n'각 셀의 문자 길이만큼 반복\nIf\nMid\n(rngC, i, 1) = \"(\" Then\n'만약 문자가 ( 라면\nDo\n'다음을 실행\ni = i + 1\n'각 셀의 문자위치를 1씩 늘려감\nstrU = strU + Mid(rngC, i, 1)\n'(와 ) 사이의 문자를 합쳐감\nLoop Until\nMid(rngC, i + 1, 1) = \")\"\n')가 나올때까지 무한 반복\nlngSum = lngSum +\nVal\n(strU)\n'추출한 괄호안의 값을 축적해감\nstrU = \"\"\n'재사용 위하여 초기화\nEnd If\nNext\ni\nrngC.Next = lngSum\n'B열에 합친 값을 입력함\nlngSum = 0\n'재사용 위하여 초기화\nNext rngC\nEnd Sub\n\nFunction 괄호합계(ByVal s As String)\n'사용자정의 함수(셀의 문자를 넣을 변수)\nDim a As Variant, v, i As Byte\n'문자를 쪼개 넣을 변수, 배열 변수, 반복에 사용할 변수\nIf InStr(s, \")\") Then\n'만일 문자내에 ) 존재하면\na = Split(s, \"(\")\n'( 으로 문자를 쪼개에 배열에 넣음\nFor i = 1 To UBound(a)\n'배열 상한값까지 반복\nv = v + Val(a(i))\n'추출한 괄호안의 값을 축적해감\nNext\nEnd If\n괄호합계 = v\n'합친 값을 함수에 되돌려줌\nEnd Function", "context": "매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub sum_In_Parenthesis()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim strU As String\n'(과 ) 사이의 문자를 합칠변수\nDim lngSum As Long\n'괄호안의 값을 합쳐갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"B\").ClearContents\n'B열의 기존 데이터 삭제\nFor Each\nrngC\nIn\nColumns(1).SpecialCells(2)\n'A열 각 문자셀을 순환\nFor i = 1 To Len(rngC)\n'각 셀의 문자 길이만큼 반복\nIf\nMid\n(rngC, i, 1) = \"(\" Then\n'만약 문자가 ( 라면\nDo\n'다음을 실행\ni = i + 1\n'각 셀의 문자위치를 1씩 늘려감\nstrU = strU + Mid(rngC, i, 1..."}
{"instruction": "Excel VBA code for: (1326) 괄호안의 숫자 더하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub sum_In_Parenthesis2()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim strU As String\n'숫자와 + 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"A\").Copy Cells(1, 2)\n'A열을 B열에 복사\nFor Each rngC In Columns(2).SpecialCells(2)\n'B열 각 문자셀을 순환\nrngC.\nReplace\n\"(\", \"+\"\n'모든 ( 를 + 로 변환\nFor i = 1 To Len(rngC)\n'각 셀의 문자 길이만큼 반복\nIf\nMid\n(rngC, i, 1)\nLike\n\"\n[0-9+]\n\" Then\n'만약 문자가 숫자거나 + 이면\nstrU = strU + Mid(rngC, i, 1)\n'숫자와 + 합쳐감\nEnd If\nNext i\nIf\nLen\n(strU) > 0 Then\n'괄호안에 숫자가 있다면\nrngC =\nEvaluate\n(strU)\n'합쳐진 문자를 계산하여 셀에 입력\nElse\n'괄호안에 숫자 없다면\nrngC = vbNullString\n'공백을 넣음\nEnd If\nstrU = \"\"\n'재사용 위하여 초기화\nNext rngC\nColumns(\"B\").NumberFormat = \"#,##0\"\n'B열의 서식 설정\nColumns(\"A:B\").AutoFit\n'A:B열 열너비 자동맞춤\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub sum_In_Parenthesis2()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim strU As String\n'숫자와 + 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"A\").Copy Cells(1, 2)\n'A열을 B열에 복사\nFor Each rngC In Columns(2).SpecialCells(2)\n'B열 각 문자셀을 순환\nrngC.\nReplace\n\"(\", \"+\"\n'모든 ( 를 + 로 변환\nFor i = 1 To Len(rngC)\n'각 셀의 문자 길이만큼 반복\nIf\nMid\n(rngC, i, 1)\nLike\n\"\n[0-9+]\n\" Then\n'만약 문자가 숫자거나 + 이면\nstrU = strU + Mid(rngC, i, 1)\n'숫자와 + 합쳐감\nEnd If\nNext..."}
{"instruction": "Excel VBA code for: (1327) 선택영역과 일치하는 그림파일을 폴더(하위폴더 포함)에서 가져오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Pictures_Matching_Name2()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim rngSel As Range\n'선택 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Application.FileDialog(\nmsoFileDialogFolderPicker\n)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더를 선택한 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nSet rngSel = Selection\n'선택영역을 변수에 넣음\nCall\neachFolder(rngSel, strPath)\n'eachFolder 코드를 호출\nEnd Sub\n\nPrivate Function eachFolder\n(ByVal rngSel As Range, strPath As String)\nDim fSO As Scripting.FileSystemObject\n'FileSystemObject를 넣을 변수\nDim fldName As Scripting.Folder\n'상위폴더 넣을 변수\nDim C As Range\n'검색에 일치한 셀을 넣을 변수\nDim subFolder As Scripting.Folder\n'하위폴더 넣을 변수\nDim fileName As Object\n'각 파일을 넣을 변수\nSet\nfSO = New Scripting.\nFileSystemObject\n'새로운 파일시스템개체를 변수에\nSet fldName = fSO.\nGetFolder\n(strPath)\n'선택한 폴더의 이름을 변수에 넣음\nFor Each fileName In fldName.Files\n'폴더내 각 파일을 순환\nSet C = rngSel.\nFind\n(fileName.Name, , , xlWhole)\n'선택영역에서 이름 일치하는 셀을 찾음\nIf Not C Is Nothing Then\n'그림파일과 동일한 이름이 셀에 존재하면\nActiveSheet.\nPictures.\nInsert\n(fldName.\nPath\n& \"\\\" & fileName.Name).Select\n'그림파일 삽입\nSet C = C.Next.\nMergeArea\n'이름 오른쪽 셀병합된 영역을 C에 넣음\nWith Selection\n'선택된 그림파일\n.Name = \"Temp#\"\n'(임시로) 이름을 \"Temp#\"로 지정\n.ShapeRange.LockAspectRatio = msoFalse\n'그림의 가로/세로크기 고정 해제\n.Height = C.Height - 4\n'그림의 가로크기 지정\n.Width = C.Width - 4\n'그림의 세로크기 지정\n.Copy\n'그림을 복사\nActiveSheet.PasteSpecial\nLink:=False\n'그림 링크깨고 붙여넣기\nActiveSheet.Pictures(\"Temp#\").Delete\n'원본\n그림파일\n삭제\nEnd With\nWith Selection\n'(복사되어)선택된 그림파일\n.Left = C.Left + 2\n'그림의 왼쪽위치 지정\n.Top = C.Top + 2\n'그림의 윗쪽위치 지정\nEnd With\nEnd If\nNext fileName\nFor Each subFolder In fldName.\nSubFolders\n'각 폴더의 하위폴더를 순환\nCall eachFolder(rngSel, subFolder.Path)\n'각 폴더경로로 eachFolder함수호출\nNext subFolder\nSet fSO = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet fldName = Nothing\nSet C = Nothing\nEnd Function", "context": "선택영역에 입력된 그림파일의 이름과 폴더내(하위폴더 포함) 그림파일의 이름이 일치할 경우 이름이 입력된 셀의 오른쪽 셀에 그림을\n영구삽입\n하는 기능. 그러므로, 매크로 실행 전 그림파일 이름이 들어간 영역을 선택하고 매크로 실행.\nSet C =\nC.Next.\nMergeArea\n라고 되어 있는 코드를 ﻿\n﻿\n﻿\n﻿아래처럼 수정하면 다른 위치에 넣을 수 있다.\n﻿\n이름이 들어간 셀에 넣으려면 :               Set C = C.MergeArea\n이름이 들어간 셀의 아래에 넣으려면 :     Set C = C.\nOffset(1)\n.MergeArea\n이름이 들어간 셀의 위에 넣으려면 :        Set C = C.\nOffset(-1)\n.MergeArea\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1327) 선택영역과 일치하는 그림파일을 폴더(하위폴더 포함)에서 가져오기 (엑셀 VBA 매크로)\n재생\n1,780\n재생 (space/k)\n..."}
{"instruction": "Excel VBA code for: (1330) 중복된 행 조건부 제거 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Dupes_Selectively()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim j As Integer\n'열 개수만큼 반복할 변수\nDim i As Long\n'중복행 개수 구할 변수\nDim cnt As Long\n'카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.\nClearContents\n'기존 데이터 삭제\nActiveSheet.\nUsedRange\n.Copy .Cells(1, 1)\n'데이터를 임시로 복사\n.\nActivate\n'활성화\nEnd With\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nFor j = 1 To 4\n'전체 열 개수만큼 반복\nIf Cells(r, j) <> Cells(r + 1, j) Then\n'만약 각 열의 위아래 값이 다르면\nExit For\n'For 구문 종료\nEnd If\nNext j\nIf j = 5 Then\n'각 행이 바로 아래 행과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nIf i = 4 Then\n'i가 4라면\nCells(r - 2, 1).Resize(3, 4).ClearContents\n'중복행을 삭제\ni = 0\n'재사용 위하여 초기화\nEnd If\nElse\n'각 셀이 바로 아래 셀과 다\n르면\nIf i > 0 Then\n'위아래 중복행이 있다면\nCells(r - i + 1, 1).Resize(i, 4).ClearContents\n'중복행을 삭제\ni = 0\n'재사용 위하여 초기화\nEnd If\nEnd If\ncnt = 0\n'재사용 위하여 카운터 초기화\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nActiveSheet.UsedRange.Offset(1).\nSort\n[A2], 1\n'(공백행 없애기 위해)오름차순 정렬\nColumns(\"A:D\").\nAutoFit\n'열너비 자동맞춤\nEnd Sub", "context": "1. 일자, 번호, 번호2, 거래처가 모두 일치하는 중복행을 제거\n2. 단, 중복된 행이 5개 이상일 경우\n네 행\n씩 끊어서\n제일 상단의 행만 남기고 삭제\n(빨간색은 제거되는 행과 구분하려 임의로 표시한 것임)\n매크로 실행 전 (Sheet2는 비어 있음)                             매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub remove_Dupes_Selectively()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim j As Integer\n'열 개수만큼 반복할 변수\nDim i As Long\n'중복행 개수 구할 변수\nDim cnt As Long\n'카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.\nClearContents\n'기존 데이터 삭제\nActiveSheet.\nUsedRange\n.Copy ...."}
{"instruction": "Excel VBA code for: (1331) 기존서식 유지하며 정렬하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_Keeping_Format()\nDim rngAll As Range\n'전체 사용영역 넣을 개체변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).\nUsedRange.Clear\n'기존 데이터 삭제\nSet rngAll = ActiveSheet.UsedRange\n'현재시트 사용영역을 개체변수에 넣음\nrngAll.Copy\n'전체영역을 복사\nSheets(2).Cells(1, 1).\nPasteSpecial\nPaste:=\nxlPasteFormats\n'Sheet2의 A1셀에 서식 복사\nrngAll.\nSort\n[A1], 1\n'A1셀 기준으로 오름차순 정렬\nrngAll.ClearFormats\n'기존 서식을 삭제\nSheets(2).UsedRange.Copy\n'Sheet2의 사용영역 복사\nCells(1, 1).PasteSpecial Paste:=xlPasteFormats\n'A1셀에 서식 복사\nApplication.CutCopyMode = False\n'자르기복사 모드 해제\nCells(1, 1).\nSelect\n'A1셀 선택(영역 선택 해제용도)\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "엑셀의 오른차순 정렬 실행전                          오름차순 정렬 후 결과\n위와 같이 셀에 서식이 적용된 경우 정렬을 하면 오른쪽과 같이 서식도 함께 이동하여 정렬이 된다. 아래의 매크로는 기존서식을 유지하면 정렬하는 기능. 말은 매크로라고 하지만 사실 Sheet1의 서식을 Sheet2에 복사 => 정렬 => Sheet2의 서식 Sheet1에 복사 과정을 코드로 옮긴 것뿐이다.\n매크로 실행 전                                             매크로 실행 후 결과\nOption Explicit\nSub sort_Keeping_Format()\nDim rngAll As Range\n'전체 사용영역 넣을 개체변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).\nUsedRange.Clear\n'기존 데이터 삭제\nSet rngAll = ActiveSheet.UsedRange\n'현재시트 ..."}
{"instruction": "Excel VBA code for: (1333) 반복할 행 상단/하단 동시 설정 (엑셀 VBA 매크로)", "input": "", "output": "Sub repeat_Header_Footer()\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nDim rngFooter As Range\n'꼬리말이 될 영역을 넣을 변수\nDim strPath As String\n'파일 경로를 넣을 변수\nDim cht As\nChartObject\n'차트개체를 넣을 변수\nSet rngFooter = Cells(Rows.Count, \"A\").End(3).Offset(-1).Resize(2, 9)\n'꼬리말 영역을 개체변수에 넣음\nstrPath = ActiveWorkbook.\nPath\n& \"\\\"\n'현재 활성화된 파일이 저장된 폴더의 경로 + \\\nrngFooter.\nCopyPicture\n'꼬리말 영역을 복사해 Clipboard에 넣음\nSet cht = ActiveSheet.\nChartObjects.Add\n(0, 0, rngFooter.Width, rngFooter.Height)\n'새로운 차트개체를 각 셀크기로 생성\ncht.Chart.Paste\n'꼬리말 영역을 복사해서 차트에 붙여 넣음\ncht.Chart.\nExport\nstrPath & \"Temp_Pic.gif\"\n'그림을 내보냄\ncht.Delete\n'삽입했던 차트개체를 삭제\nWith\nActiveSheet.PageSetup\n'현재시트 페이지 셋업\n.\nPrintTitleRows\n= \"$1:$1\"\n'머리말(반복될 행)로 1행을 설정\n.\nPrintArea\n= \"$A$1:\" & Cells(Rows.Count, \"I\").End(3).Offset(-2).Address\n'마지막 2행 제외한 영역을 인쇄영역으로 설정\n.\nCenterFooterPicture\n.Filename = strPath & \"Temp_Pic.gif\"\n'꼬리말 가운데에 그림파일 삽입\n.\nCenterFooter\n= \"&G\"\n'꼬리말 가운데 그림이 나타나도록 설정\nEnd With\nKill\nstrPath & \"Temp_Pic.gif\"\n'임시로 저장한 그림파일 삭제\nActiveSheet.\nPrintPreview\n'현재시트 인쇄 미리보기\n'ActiveSheet.\nPrintOut\n'실제 인쇄(윗행 삭제한 뒤 주석처리 제거후 사용)\nSet rngFooter = Nothing\n'개체변수(들) 초기화\nSet cht = Nothing\nEnd Sub\n\nSub delete_Footer()\n'\"머리/꼬리말 삭제\" 버튼에 연결된 코드\nWith ActiveSheet.PageSetup\n'현재시트 페이지 셋업\n.PrintTitleRows = \"\"\n'머리말(반복될 행) 표시 삭제\n.CenterFooter = \"\"\n'꼬리말 가운데 그림이 나타나지 않도록 설정\nEnd With\nEnd Sub", "context": "엑셀에서 반복할 행의 설정은 연속된 행이나 열 전체이어야 한다. 그러므로 엑셀의 기본 기능을 이용하여 반복할 행을 상단과 하단으로 구분하여 넣을 수 없다.\n약간의 트릭으로 상단은 반복할 행기능을 사용하고, 하단 반복할 행은 그림파일로 만들어 꼬리말 중앙에 그림으로 삽입할 수 있지만, 하단 부분의 값이 입력된 수치에 따라 값이 변하는 경우 인쇄 시마다 그림파일을 만들어 넣어야 하는 불편함이 있다.\n아래의 매크로는 반복할 행을 상단과 하단에 동시에 넣는 것으로 코드도 약간 길고 사용도 복잡하지만 반드시 이 기능이 필요한 분들의 경우 유용할 수도 있겠다는 생각이 든다. 엑셀의 기본기능에서 지원하지 않으므로 이를 구현하기 위해서는 여러가지 제약이 따른다. 그러므로 이런 코드는 에러가 날 확률이 높아진다. 아래 설명을 잘 참조하시기를....\n첨부한 파일에 있는 예제는 1~106행까지 총 3 페이지의 데이터가 있으며, 이를 페이지 미리보기 한 것. 한가지 주의할 것은 페이지가 윗 그림과 같이 ..."}
{"instruction": "Excel VBA code for: (1335) 모든 차트에 Template 적용하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub applying_Chart_Template()\nDim cht As\nChartObject\n'차트개체를 넣을 변수\nDim wkSht As Worksheet\n'각 시트를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each wkSht In ActiveWorkbook.Worksheets\n'현재 선택된 엑셀파일의 각 시트를 순환\nFor Each cht In wkSht.ChartObjects\n'각 시트의 차트를 순환\ncht.Chart\n.\nApplyChartTemplate\n( _\n\"C:\\users\\\" & Environ(\"username\") & _\n\"\\Desktop\\Chart_Template.crtx\")\n'바탕화면에 있는 차트 template를 각 차트에 적용\nNext cht\nNext wkSht\nMsgBox \"매크로가 종료 되었습니다.\"\nEnd Sub", "context": "많은 차트를 생성한 이후 동일한 차트모양을 적용해주어야 할 때가 있다. 이 때 차트 하나 하나를 마우스로 클릭하여 차트의 종류를 변경하는 것은 매우 번거로운 작업이다. 아래와 같은 방법을 사용하면\n\"현재 활성화된 엑셀파일\"\n의 모든 시트에 있는 차트를 지정한 template와 동일한 차트의 모양으로 한 번에 바꾸어준다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1335) 모든 차트에 Template 적용하기 (엑셀 VBA 매크로)\n재생\n1,648\n재생 (space/k)\n재생\n01:03\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:03\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 ..."}
{"instruction": "Excel VBA code for: (1336) 선택영역을 가로(또는 세로)로 숫자 채우기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_Numbers_with_Increment2()\nDim strInput As String\n'메시지박스 선택결과 넣을 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 영역변수\nDim rngA As Range\n'선택영역 각 (A)rea넣을 영역변수\nDim i As Long\n'숫자 더해갈 변수\nDim r As Long\n'각 area의 행만큼 반복할 변수\nDim c As Integer\n'각 area의 열만큼 반복할 변수\nDim cCnt As Integer\n'각 area의 열 개수 넣을 변수\nDim rCnt As Long\n'각 area의 행 개수 넣을 변수\nDim varAll As Variant\n'(2차원 정적)배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 일시 정지\ni = 0\n'i값 초기화(\n시작값\n결정)\n'-----------------------------\n' 셀병합 영역이 있는지 확인\n'-----------------------------\nFor Each rngC In Selection\n'선택 영역 각 셀을 순환\nIf rngC.\nMergeCells\nThen\n'각 셀중 셀병합 영역 있을경우\nMsgBox \"셀병합 영역 해지 후 재실행.\", 64, \"셀병합 에러\"\n' 에러 출력\nExit Sub\n'매크로 종료\nEnd If\nNext rngC\n'-------------------------------\n' 메시지박스의 선택결과 결정\n'-------------------------------\nOn Error Resume Next\n'에러 발생해도 다음코드 진행\nstrInput = MsgBox(\"가로채우기는 Yes, 세로채우기는 No 선택\", 3, \"가로 or 세로 채우기\")\n'메시지박스 선택결과를 strInput에 넣음\nOn Error GoTo 0\n'에러 초기화\nSelect Case\nstrInput\n'------------------------\n' Yes 선택 시 결과처리\n'------------------------\nCase vbYes\n'Yes 선택 시 (각 가로행부터 숫자채움)\nFor Each rngA In Selection.\nAreas\n'선택영역의 각 area를 순환\nrCnt = rngA.\nRows.Count\n'각 area의 행 개수를 변수에 넣음\ncCnt = rngA.\nColumns.Count\n'각 area의 열 개수를 변수에 넣음\nReDim\nvarAll(1 To rCnt, 1 To cCnt)\n'배열을 각 area크기로 재지정\nFor r = 1 To rCnt\n'각 area 행 숫자만큼 반복\nFor c = 1 To cCnt\n'각 area 열 숫자만큼 반복\ni = i + 1\n'숫자를 1씩 늘려감\nvarAll(r, c) = i\n'배열에 순차적으로 값을 넣음\nNext c\nNext r\nrngA = varAll\n'배열 값을 각 area에 뿌림\nNext rngA\n'----------------------\n' No 선택 시 결과처리\n'----------------------\nCase vbNo\n'No 선택 시 (각 세로열부터 숫자채움)\nFor Each rngA In Selection.Areas\n'선택영역의 각 area를 순환\nrCnt = rngA.Rows.Count\n'각 area의 행 개수를 변수에 넣음\ncCnt = rngA.Columns.Count\n'각 area의 열 개수를 변수에 넣음\nReDim varAll(1 To rCnt, 1 To cCnt)\n'배열을 각 area크기로 재지정\nFor c = 1 To cCnt\n'각 area 열 숫자만큼 반복\nFor r = 1 To rCnt\n'각 area 행 숫자만큼 반복\ni = i + 1\n'숫자를 1씩 늘려감\nvarAll(r, c) = i\n'배열에 순차적으로 값을 넣음\nNext r\nNext c\nrngA = varAll\n'배열 값을 각 area에 뿌림\nNext rngA\nCase vbCancel\n'Cancel 선택 시\nExit Sub\n'매크로 종료\nEnd Select\nEnd Sub", "context": "기존 \"(103) 선택영역을 가로(또는 세로)로 숫자 채우기 (\nhttp://rosa0189.blog.me/60133629917\n)\"의 속도를 개선한 코드이다. 기존에는 각 셀에 숫자를 하나씩 입력하였지만 이 코드는 숫자를 배열에 넣은 후 각 area 마다 한 번에 뿌리도록 하였다.\n1. 먼저 영역을 선택하고 매크로를 실행\n2. 선택영역에 셀병합 셀이 있을 경우 에러 메시지 출력\n3. 1개 또는 복수 영역을 선택하고 매크로를 실행\n4. 메시지 박스에서 Yes 선택시 가로로 숫자가 채워지고, No 선택 시 세로로 숫자가 채워짐\n5.\ni = 0\n으로 설정되어\n1부터\n숫자가 채워지며, i = 100 으로 설정 시 101부터 숫자가 채워짐.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1336) 선택영역을 가로(또는 세로)로 숫자 채우기 2 (엑셀 VBA 매크로)\n재생\n706\n재생 (space/k)\n재생\n00:40\n0:00:00\n재생 (space/..."}
{"instruction": "Excel VBA code for: (1337) 선택영역의 행 또는 열을 서로 뒤집기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub switch_All_Rows_Columns3()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngA As Range\n'각 area를 넣을 영역변수\nDim rCnt As Long\n'각 area의 행 개수 넣을 변수\nDim cCnt As Integer\n'각 area의 열 개수 넣을 변수\nDim varTemp As Variant\n'선택영역 넣을 배열변수\nDim r As Long\n'행 늘려갈 숫자에 사용할 변수\nDim c As Long\n'열 늘려갈 숫자에 사용할 변수\nDim i As Long\n'행 1씩 늘려갈 변수\nDim j As Integer\n'열 1씩 늘려갈 변수\nDim vbYNAs String\n'메시지박스 입력받은 변수\nDim varAll As Variant\n'뒤섞은 값을 넣을 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nRandomize\n'랜덤값 발생기 초기화\n'(계속 새로운 랜덤 기준값 생성)\nIf Selection.\nCount\n= 1 Then\n'만일 한 셀만 선택하였을 경우\nMsgBox \"한 셀만 선택함. 뒤집을 행, 또는 열이 없음.\", 64, \"영역선택 오류\"\nExit Sub\n'매크로 종료\nEnd If\nFor Each rngC In Selection\n'선택 영역 각 셀을 순환\nIf rngC.\nMergeCells\nThen\n'각 셀중 셀병합 영역 있을경우\nMsgBox \"셀병합 영역 해지 후 재실행.\", 64, \"셀병합 에러\"\n' 에러 출력\nExit Sub\n'매크로 종료\nEnd If\nNext rngC\nvbYN = MsgBox(\"행(좌우)을 뒤집으려면  Yes,\" & _\nChr(10)\n& Chr(10) & _\n\"열(상하)을 뒤집으려면  No를 선택\", vbYesNoCancel, \"방향 선택\")\n'메시지창 출력\nSelect Case\nvbYN\n'Yes, No, Cancel 중에서\nCase vbYes\n'Yes를 선택 시\n'-----------------------------\n' 행(좌에서 우)을 섞는 코드\n'-----------------------------\nFor Each rngA In Selection.Areas\n'선택영역 각 area를 순환\nIf rngA.Count <> 1 Then\n'area가 1개의 셀이 아닌 경우\nvarTemp = rngA\n'각 area를 배열변수 varTemp에 넣음\nrCnt = rngA.Rows.Count\n'각 area의 행 개수를 변수에 넣음\ncCnt = rngA.Columns.Count\n'각 area의 열 개수를 변수에 넣음\nReDim\nvarAll(1 To rCnt, 1 To cCnt)\n'배열크기 재지정\nFor r = 1 To rCnt\n'varTemp 행을 늘려감\ni = i + 1\n'varAll의 행을 늘려감\nFor c = cCnt To 1 Step -1\n'VarTemp의 열을 늘려감\nj = j + 1\n'varAll의 열을 늘려감\nvarAll(i, j) = varTemp(r, c)\n'varAll에 varTemp의 값을 넣음\nNext c\nj = 0\n'재사용 위하여 열 초기화\nNext r\ni = 0\n'재 사용 위하여 행 초기화\nrngA = varAll\n'각 area에 배열값을 뿌림\nEnd If\nNext rngA\nCase vbNo\n'No를 선택 시\n'-------------------------------\n' 열(위에서 아래)을 섞는 코드\n'-------------------------------\nFor Each rngA In Selection.Areas\n'선택영역 각 area를 순환\nIf rngA.Count <> 1 Then\n'area가 1개의 셀이 아닌 경우\nvarTemp = rngA\n'각 area를 배열변수 varTemp에 넣음\nrCnt = rngA.Rows.Count\n'각 area의 행 개수를 변수에 넣음\ncCnt = rngA.Columns.Count\n'각 area의 열 개수를 변수에 넣음\nReDim varAll(1 To rCnt, 1 To cCnt)\n'배열크기 재지정\nFor c = 1 To cCnt\n'varTemp 열을 늘려감\nj = j + 1\n'varAll의 열을 늘려감\nFor r = rCnt To 1 Step -1\n'VarTemp의 행을 늘려감\ni = i + 1\n'varAll의 행을 늘려감\nvarAll(i, j) = varTemp(r, c)\n'varAll에 varTemp의 값을 넣음\nNext r\ni = 0\n'재사용 위하여 행 초기화\nNext c\nj = 0\n'재 사용 위하여 열 초기화\nrngA = varAll\n'각 area에 배열값을 뿌림\nEnd If\nNext rngA\nCase vbCancel\n: Exit Sub\n'Cancel선택시 취소\nEnd Select\nEnd Sub", "context": "기존 \"(1282) 선택영역의 행 또는 열을 서로 뒤집기 2 (\nhttp://rosa0189.blog.me/60167699092\n)\" 코드의 단점들을 보완하고 속도를 개선한 코드이다. 배열에 넣어 처리하므로 속도도 훨씬 더 빨라졌다.\n1. 1개의 셀만을 선택하였을 경우 뒤집는 의미가 없으므로 에러 출력\n2. 선택 영역에 셀병합된 셀이 있을 경우 에러 출력\n3. 복수의 영역을 선택하여 아무 방향으로나 뒤집어도 된다.\n4. Yes 선택 시 행(좌우)방향, No 선택 시 열(상하) 방향으로 데이터를 뒤집어 준다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1337) 선택영역의 행 또는 열을 서로 뒤집기 3 (엑셀 VBA 매크로)\n재생\n1,339\n공유하기\n재생 (space/k)\n재생\n00:42\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:42\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재..."}
{"instruction": "Excel VBA code for: (1338) 여러시트의 데이터를 한 통합시트로 모으기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_All_Sheets2()\nDim intCol As Integer\n'시트이름 넣을 열번호\nDim wkSht As Worksheet\n'각 시트를 넣을 변수\nDim rowsCnt As Long\n'각 시트 전체행을 넣을 변수\nDim colsCnt As Integer\n'각 시트 전체열을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.Offset(1).Clear\n'기존 데이터 삭제\n'----------------------------------------------\n' 필드명(제목) 제일 오른쪽이 \"시트명\"인지 확인\n'----------------------------------------------\nWith Cells(1, Columns.Count)\n'1행 왼쪽 종단셀에서\nIf .End(1)(1, 1) <> \"시트명\" Then\n'제일 오른쪽이 \"시트명\" 아니면\nintCol = .End(1)(1, 2\n).Column\n'시트이름 위치할 열번호 추출\n.End(1)(1, 2) = \"시트명\"\n'제일 오른쪽열에 \"시트명\"입력\nElse\nintCol = .End(1)(1, 1).Column\n'시트이름 위치할 열번호 추출\nEnd If\nEnd With\n'-----------------------------------------------\n' 각 시트를 순환하며 제목행 제외한 데이터 가져옴\n'-----------------------------------------------\nFor Each wkSht In ActiveWorkbook.\nWorksheets\n'활성화된 파일의 각 시트를 순환\nIf wkSht\n.Name\n<> ActiveSheet.Name Then\n'시트명이 현재시트 아니라면\nWith wkSht.\nUsedRange\n'각 시트의 데이터 영역에서\nrowsCnt = .Rows.Count\n'각 시트의 행 개수를 변수에 넣음\ncolsCnt = .Columns.Count\n'각 시트의 열 개수를 변수에 넣음\nCells(Rows.Count, \"A\").End(3)(2).Resize _\n(rowsCnt, colsCnt) =\n.Offset\n(1).Value\n'제목행 제외한 각 시트의 내용을 통합시트(Main)로 복사\nIf rowsCnt > 1 Then\n'(데이터 없을 경우 에러방지용)\nCells(Rows.Count, intCol).End(3)(2). _\nResize(rowsCnt - 1) = wkSht.Name\n'시트의 이름을 마지막 열에 복사\nEnd If\nEnd With\nEnd If\nNext wkSht\nEnd Sub", "context": "1. 현재 열려진 파일의 각 시트에 있는 데이터를\n현재시트\n로 통합하는 코드\n2. 제일 마지막 열에는 각 시트의 이름을 추가함(어느 시트의 데이터인지 확인하기 위함)\n3. 모든 시트의 필드명(제목)은 1행에 있고 동일해야 함. 각 시트는 2행 부터 데이터가 있어야 함.\n4. 데이터의 행 또는 열 개수 제한 없음\n5. 매크로 실행 시 기존 \"Main\"시트의 데이터는 삭제된 이후 다른 시트의 데이터를 통합.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1338) 여러시트의 데이터를 한 통합시트로 모으기 3 (엑셀 VBA 매크로)\n재생\n5,660\n재생 (space/k)\n재생\n00:54\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:54\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재..."}
{"instruction": "Excel VBA code for: (1339) 다른 시트에 있는 일치하는 데이터 찾기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_And_Relocation()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nDim C As Range\n'검색하여 찾은 영역을 넣을 변수\nDim strAddr As String\n'검색한 셀의 주소를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(3).UsedRange.Offset(2).\nClear\n'Sheet3의 기존 데이터 삭제\nSet rngAll = Range(\"A2\", Cells(Rows.Count, 1).End(3)(1))\n'첫 번째 시트 A열의 데이터 영역을 개체변수 rngAll 에 넣음\nFor Each\nrngC\nIn\nrngAll\n'전체영역(rngAll)의 각셀(rngC)을 순환\nWith Sheets(2).Columns(1)\n'Sheet2 A열에서\nSet C = .\nFind\n(What:=rngC, After:=.Cells(Rows.Count, \"A\").End(3)(1), Lookat:=xlWhole)\nEnd With\n'처음 일치하는 데이터(나이)를 찾아 C에 넣고\nIf Not C Is Nothing Then\n'만일 일치하는 데이터가 있으면\n'--------------------------------------\n' 첫번째 일치한 셀의 값을 처리할 코드\n'--------------------------------------\nstrAddr = C.\nAddress\n'첫 일치하는 주소를 strAddr에 넣고\nWith Sheets(3).Cells(Rows.Count, 2)\n'Sheet3의 B열 마지막 행에서\n.End(3)(2).\nPrevious\n.Resize(, 2) = rngC.Resize(, 2).Value\n'종단셀 윗방향 바로 아래 왼쪽셀에 \"나이, 이름\"을 입력\n.End(3)(2).Resize(, 2) = C.Resize(, 2).Value\n'종단셀 윗방향 바로 아래셀에 \"나이, 성격\"을 입력\n'-----------------------------------------\n' 두 번째 부터 일치한 셀의 값을 처리할 코드\n'-----------------------------------------\nDo\n'다음을 실행\nSet C = Sheets(2).Columns(1).\nFindNext\n(C)\n'다음 일치하는 데이터를 변수에 넣고\nIf strAddr = C.Address Then Exit Do\n'주소가 처음 찾은 주소와 일치 시 Do구문종료\n.End(3)(2).Resize(, 2) = C.Resize(, 2).Value\n'다음 일치한 데이터를 Sheet3에 입력\nLoop While Not C Is Nothing\n'일치하는 데이터 없을때까지 무한 반복\nEnd With\nEnd If\nNext\nrngC\nSheets(\"Sheet3\").\nActivate\n'Sheet3을 활성화\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nSet C = Nothing\n'개체변수 초기화\nEnd Sub", "context": "Sheet1의 데이터                                                 Sheet2의 데이터\nSheet1의 1열에 있는 나이와 일치하는 나이를 Sheet2 1열에서 모두 찾고, 일치하는 나이가 있을 경우 이를 아래와 같이 Sheet3에 옮겨주는 기능. 매크로 실행 전 Sheet3은 비어 있는 상태.\n매크로 실행 후 Sheet3에 얻은 결과.\nOption Explicit\nSub combine_And_Relocation()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nDim C As Range\n'검색하여 찾은 영역을 넣을 변수\nDim strAddr As String\n'검색한 셀의 주소를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(3).UsedRange.Offset(2).\nClear\n'Sheet..."}
{"instruction": "Excel VBA code for: (1340) 링크로 삽입된 그림(사진) 영구 삽입하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_A_Pic()\nDim myPic As Variant\nmyPic = Application.GetOpenFilename(filefilter:=\"Picture Files,*.jpg;*.bmp;*.tif;*.gif\")\nIf myPic = False Then\nExit Sub\nEnd If\nWith ActiveSheet.Pictures.Insert(myPic).ShapeRange\n.LockAspectRatio = msoFalse\n.Height = Selection.Height\n.Width = Selection.Width\n.Left = Selection.Left\n.Top = Selection.Top\nEnd With\nEnd Sub\n\nSub embed_Pics_Permanently()\nDim rngSel As Range\n'선택된 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngShp As Range\n'각 그림의 왼쪽위가 속한 영역을 넣을 변수\nDim shpC As Shape\n'각각의 도형(shape)을 넣을 변수\nDim picLeft As Single\n'각 그림(사진)의 왼쪽 위치 넣을 변수\nDim picTop As Single\n'각 그림의 윗쪽 위치 넣을 변수\nIf Not TypeOf Selection Is Range Then\n'셀 영역아닌 그림, 차트 등을 선택하였을 경우\nMsgBox \"영역이 선택되지 않음\", 64, \"영역선택 오류\"\n'경고 메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel = Application.InputBox(\"마우스로 영역을 선택하시오!\", Type:=8)\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each\nrngC\nIn\nrngSel\n'선택영역내 각 셀을 순환\nFor Each\nshpC\nIn\nActiveSheet.Shapes\n'시트내의 각 도형을 순환\nIf shpC.Type = 11 Then\n'만일 각 도형이 링크된 그림이라면\nSet rngShp = shpC.\nTopLeftCell\n'각 도형의 왼쪽위 영역을 변수에 넣음\nIf Not Intersect(rngC, rngShp) Is Nothing Then\n'각 도형이 각셀영역에 포함되면\npicLeft = shpC.\nLeft\n'링크된 그림의 왼쪽 위치를 변수에\npicTop = shpC.\nTop\n'링크된 그림의 윗쪽 위치를 변수에\nshpC.Copy\n'링크된 그림을 복사\nActiveSheet.\nPasteSpecial Link:=False\n'그림 링크깨고 붙여넣기\nshpC.Delete\n'링크된 그림을 삭제\nSelection.Left = picLeft\n'복사된 그림 왼쪽 위치를 링크된 그림 왼쪽위치에\nSelection.Top = picTop\n'복사된 그림 윗쪽 위치를 링크된 그림 왼쪽위치에\nEnd If\nEnd If\nNext\nshpC\nNext\nrngC\nMsgBox \"매크로가 종료되었습니다.\"\nSet rngSel = Nothing\n'개체변수들 초기화(메모리 비우기)\nSet rngShp = Nothing\nEnd Sub", "context": "Sub insert_A_Pic()\nDim myPic As Variant\nmyPic = Application.GetOpenFilename(filefilter:=\"Picture Files,*.jpg;*.bmp;*.tif;*.gif\")\nIf myPic = False Then\nExit Sub\nEnd If\nWith ActiveSheet.Pictures.Insert(myPic).ShapeRange\n.LockAspectRatio = msoFalse\n.Height = Selection.Height\n.Width = Selection.Width\n.Left = Selection.Left\n.Top = Selection.Top\nEnd With\nEnd Sub\n링크로 그림(사진)파일 삽입 또는 기존의\nGetOpenFilename\n을 이용한 위와 같은 코드로 (\nA컴퓨터\n에서) 그림을 삽입하면 그림이 링크로 삽입되어 파일을 다른 컴퓨터(\nB컴퓨터\n)로 가져갈 경우 동일 경로에 그림파일이 없므로 그림이 아래와 같..."}
{"instruction": "Excel VBA code for: (1341) 링크로 삽입된 그림(사진) 영구 삽입하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub embed_Pics_Permanently1()\nDim shtNo As Integer\n'현재 시트의 번호 넣을 변수\nDim i As Integer\n'전체 시트 개수 넣을 변수\nDim wks As\nWorksheet\n'각 시트를 넣을 변수\nDim shpC As Shape\n'각각의 도형(shape)을 넣을 변수\nDim picLeft As Single\n'각 그림(사진)의 왼쪽 위치 넣을 변수\nDim picTop As Single\n'각 그림의 윗쪽 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nshtNo = ActiveSheet.\nIndex\n'활성화된 시트의 번호를 변수에 넣음\nFor i = 1 To Sheets.Count\n'전체 시트를 순환\nSheets(i).\nActivate\n'시트를 순차적으로 활성화\nFor Each shpC In Sheets(i).\nShapes\n'시트내의 각 도형을 순환\nIf shpC.Type = 11 Then\n'만일 각 도형이 링크된 그림이라면\npicLeft = shpC.Left\n'링크된 그림의 왼쪽 위치를 변수에\npicTop = shpC.Top\n'링크된 그림의 윗쪽 위치를 변수에\nshpC.Copy\n'링크된 그림을 복사\nActiveSheet.\nPasteSpecial Link:=False\n'그림 링크깨고 붙여넣기\nshpC.Delete\n'링크된 그림을 삭제\nSelection.Left = picLeft\n'복사된 그림 왼쪽 위치를 링크된 그림 왼쪽위치에\nSelection.Top = picTop\n'복사된 그림 윗쪽 위치를 링크된 그림 왼쪽위치에\nEnd If\nNext shpC\nNext i\nMsgBox \"매크로가 종료되었습니다.\"\nSheets(shtNo).Activate\n'처음 매크로 실행된 시트를 활성화\nEnd Sub", "context": "링크로 파일삽입(\nInsert\n이용)\n하여 (\nA컴퓨터\n에서) 그림(사진)을 삽입하면 그림이 링크로 삽입되어 파일을 다른 컴퓨터(\nB컴퓨터\n)로 가져갈 경우 또는 이메일로 첨부하여 보낼 경우 동일 경로에 그림파일이 없으므로 그림이 아래와 같이 깨지게 된다.\n아래의 매크로를 실행 시\n화면에 활성화된 시트의\n모든\n링크된 그림\n을 링크를 깨어 복사 후 원본을 삭제하고 원본의 자리에 복사된 그림을 넣어서 그림 파일들이\n영구삽입\n되도록 하였다.\n(첨부된 파일을 열면 아래 동영상처럼 처음에 링크로 그림이 삽입 되었음에도 불구하고 파일을 여시면 링크가 깨졌기 때문에 그림 파일이 깨지지 않고 정상적으로 나올 것입니다.)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1341) 링크로 삽입된 그림(사진) 영구 삽입하기 2 (엑셀 VBA 매크로)\n재생\n8,314\n공유하기\n재생 (space/k)\n재생\n01:09\n0:00:00\n재생 (space/k)\n재생\n음소거 ..."}
{"instruction": "Excel VBA code for: (1343) Cells, Offset, Set, End 코드들의 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub using_Cells()\nDim tmr As Single\nDim i As Long\ntmr = Timer\nFor i = 1 To 100000\nCells(i, 1) = i\n'셀에 바로 입력\n﻿\nNext i\ntmr = Timer - tmr\nMsgBox \"총 \" & Format(Timer - tmr, \"#0.00\") & \" : 초 소요.\"\nEnd Sub\n\nSub using_Offset()\nDim tmr As Single\nDim i As Long\ntmr = Timer\nFor i = 1 To 100000\nCells(1, 2).Offset(i) = i\n'1행씩 offset시키며 입력\nNext i\ntmr = Timer - tmr\nMsgBox \"총 \" & Format(Timer - tmr, \"#0.00\") & \" : 초 소요.\"\nEnd Sub\n\nSub using_Set()\nDim tmr As Single\nDim i As Long\nDim rngT As Range\ntmr = Timer\nSet rngT = Cells(1, 3)\nFor i = 1 To 100000\nSet rngT = rngT.Offset(1)\n'Set 이용 1행씩 offset\nrngT = i\n'셀에 값을 입력\nNext i\ntmr = Timer - tmr\nMsgBox \"총 \" & Format(Timer - tmr, \"#0.00\") & \" : 초 소요.\"\nEnd Sub\n\nSub using_End()\nDim tmr As Single\nDim i As Long\ntmr = Timer\nFor i = 1 To 100000\nCells(i + 1, \"D\").End(xlUp)(2) = i\n'종단셀 윗방향 이용. End(3)(2)와 동일\nNext i\ntmr = Timer - tmr\nMsgBox \"총 \" & Format(Timer - tmr, \"#0.00\") & \" : 초 소요.\"\nEnd Sub", "context": "느림의 미학을 강조하는 사람들이 있다. \"빨리빨리\"만 외치는 대한민국 사람들에게 꼭 필요한 덕목 중의 하나가 아닐까 하는 생각도 든다. 하지만, 온가족이 기다리고 있는데 혼자서 엑셀을 붙들고 소위 \"복붙\", 즉 복사와 붙여넣기만 반목하며 퇴근을 안하거나 못하는 것은 옳지 않다는 생각이다.\n동일한 기능을 하는데 코드가 다르면 문득 \"도대체 뭔 차이가 있을까\" 하는 의문점이 들어야 더 좋은 코드를 찾아낼 수 있다. 아래의 코드들은 1부터 순차적으로 100,000까지 입력하는 동일한 기능을 하는데\n소요시간도 거의 동일\n하게 걸린다. 그러므로, 본인들이 선호하는 방식을 사용하면 될 것 같다.\n각 매크로 실행 후 결과\nSub using_Cells()\nDim tmr As Single\nDim i As Long\ntmr = Timer\nFor i = 1 To 100000\nCells(i, 1) = i\n'셀에 바로 입력\n﻿\nNext i\ntmr = Timer - tmr\nMsgBox \"총 \" & Format..."}
{"instruction": "Excel VBA code for: (1344) 복수의 시트 원하는 이름으로 한 번에 삽입하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub add_Sheets_Before_And_After1()\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim wkSht As Worksheet\n'각 시트 넣을 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim msg As String\n'메시지창의 메시지 넣을 변수\nDim rowsCnt As Long\n'선택영역 행 개수 넣을 변수\nDim varTemp\n'(시트 이름넣을)배열로 사용할 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim shtCnt As Integer\n'Main 시트의 index 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Selection\n'선택 영역에서\ncolsCnt = .\nColumns.Count\n'선택영역의 열 개수를 변수에 넣음\n'--------------------------\n'선택한 area 의 개수 확인\n'--------------------------\nIf colsCnt > 1 Or .\nAreas.Count\n> 1 Then\n'선택영역의 열 개수가 1보다 크면\nMsgBox \"1개의 area에, 1열만 선택하세요.\", 64, \"영역설정 에러\"\n'메시지출력\nExit Sub\n'매크로 종료\nEnd If\n'-------------------------------------------\n'빈셀 선택유무와 시트이름 중복되는지 확인\n'-------------------------------------------\nFor Each\nwkSht\nIn\nActiveWorkbook.Worksheets\n'전체 시트의 각 시트를 순환\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nIf rngC = vbNullString Then\n'셀 중에 빈셀이 있으면\nMsgBox \"선택영역에 빈셀이 있습니다.\", 64, \"셀의 문자입력 오류\"\nExit Sub\n'매크로 종료\nEnd If\nIf rngC.Value = wkSht.Name Then\n'만약 중복되는 이름 있으면 중단\nMsgBox \"시트이름[ \" & wkSht.Name & \" ]이 중복\", 64, \"시트이름 중복오류\"\nExit Sub\n'매크로 종료\nEnd If\nNext rngC\nNext\nwkSht\nshtCnt = ActiveSheet.\nIndex\n'현재시트의 시트번호를 변수에 넣음\nvarTemp = .Value\n'선택영역을 배열에 넣음\nrowsCnt = .\nRows.Count\n'선택영역의 행 갯수 추출\nEnd With\nmsg = MsgBox(\"시트를 앞에 삽입시 Yes, 뒤에 삽입시 No 선택\", vbYesNoCancel, \"위치 선택\")\nSelect Case\nmsg\n'메시지 창의 버튼 선택\n'-----------------------------------------------\n'사용자의 선택에 따라 앞 또는 뒤에 시트 추가\n'-----------------------------------------------\nCase\nvbYes\n'Yes선택시\nFor i = rowsCnt To 1 Step -1\n'선택영역의 셀 갯수만큼\nWorksheets.\nAdd\nbefore\n:=Sheets(1)\n'선택영역 아래쪽부터 앞쪽에 시트 삽입\nIf rowsCnt = 1 Then\n'선택영역이 1개의 행이면\nActiveSheet.Name = varTemp\n'배열 값을 그대로 넣음\nElse\n'2개 이상의 행이라면\nActiveSheet.Name = varTemp(i, 1)\n'시트 이름에 배열에 넣은 이름 순차적으로 넣음\nEnd If\nNext i\nSheets(shtCnt + rowsCnt).\nActivate\n'Main 파일 활성화\nCase\nvbNo\n'No 선택 시\nFor i = 1 To rowsCnt\n'선택영역 셀 갯수만큼\nWorksheets.Add\nAfter\n:=Sheets(Sheets.Count)\n'선택영역 윘쪽부터 뒷쪽에 시트 삽입\nIf rowsCnt = 1 Then\n'선택영역이 1개의 행이면\nActiveSheet.Name = varTemp\n'배열 값을 그대로 넣음\nElse\n'2개 이상의 행이라면\nActiveSheet.Name = varTemp(i, 1)\n'시트 이름에 배열에 넣은 이름 순차적으로 넣음\nEnd If\nNext i\nSheets(shtCnt).Activate\n'Main 파일 활성화\nEnd Select\nEnd Sub", "context": "기존 \" (238) 복수의 시트 원하는 이름으로 한 번에 삽입하기 1\n(\nhttp://rosa0189.blog.me/60135279544\n)\" 코드의 여러 가지 에러를 없앤 코드이다. 기존코드는 한 셀만 선택하거나 선택영역에 빈 셀이 있거나 하면 에러가 발생했었다. 여러 에러를 없애려다 보니 코드가 조금 길어졌다. 당연한 얘기지만,\n:     콜론\n/    슬래시\n\\   백 슬래시\n[ ]  대괄호\n?     물음표\n* 별표\n등은 금칙어 이므로 시트의 이름으로 사용될 수 없다. 선택영역의 셀에 이런 문자가 포함된 경우 에러 메시지를 출력할 수 있지만 코드만 길어지므로 생략함.\n아래 동영상처럼 파일의 제일 앞과 뒤가 아닌 자신이 원하는 위치에 시트를 추가하고 싶을 경우 아래 시트의 삽입 위치를 조정하면 됨. 즉,\n시트 앞쪽 위치: Worksheets.Add before:=\nSheets(\n2\n﻿\n)\n으로 수정 시 2번째 시트 앞에 삽입\n시트 윗쪽 위치 : Worksheets.Add Aft..."}
{"instruction": "Excel VBA code for: (1346) 데이터를 신청과목별로 각 시트에 내보내기 (엑셀 VBA 매크로)", "input": "", "output": "Sub distribute_As_Per_Subject()\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim strName As String\n'신청과목을 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nColumns(\"E\").Replace \" \", \"\"\n'E열의 공백 모두 제거\nFor i = 2 To Sheets.Count\n'Sheet1 제외한 2번째 시트부터\nSheets(i).UsedRange.Offset(1).\nClearContents\n'각 시트의 기존 데이터 삭제\nNext i\nr = 2\n'2행부터 시작\ncolsCnt = ActiveSheet.\nUsedRange\n.Columns.Count\n'전체 열개수를 변수에 넣음\nOn Error GoTo\nerrHandler\n'신청과목 입력오류로 에러 시 에러처리\nDo Until\nCells(r, 1) = vbNullString\n'A열에 빈셀 나올때까지\nstrName = Cells(r, 5)\n'신청과목을 문자변수에 넣음\nIf\nLen\n(strName) > 0 Then\n'신청과목이 빈셀 아니면\nIf strName = \"종합\" Then\n'신청과목이 종합일 경우\nstrName = \"국영수사과\"\n'전과목을 변수에 넣음\nFor i = 1 To 5\n'신청과목 길이만큼 반복\nCall\nmove_Each_Row((\nMid\n(strName, i, 1)), colsCnt, _\nCells(r, 1).Resize(, colsCnt))\n'각 행을 옮겨주는 코드 호출\nNext i\nElse\nFor i = 1 To Len(strName)\n'신청과목 길이만큼 반복\nCall move_Each_Row((Mid(strName, i, 1)), colsCnt, _\nCells(r, 1).Resize(, colsCnt))\n'각 행을 옮겨주는 코드 호출\nNext i\nEnd If\nIf Err > 0 Then\n'에러가 발생했을 경우\nGoTo errHandler\n'에러 처리 구문으로 이동\nEnd If\nEnd If\nr = r + 1\nLoop\n'무한 반복\nMsgBox \"매크로가 종료되었습니다.\"\n'매크로 종료 메시지 출력\nExit Sub\n'매크로 종료\nerrHandler:\nMsgBox \"에러 발생. 데이터를 확인하고 재실행\", 64, \"에러 발생\"\n'--------------------------------------------------------------\n' 과목이름에 \"국영수\"대신 \"군영수\" 같은 오타있거나\n' 사용자가 \"국, 영, 수, 사, 과\" 시트를 미리 만들지 않은 경우 등\n'--------------------------------------------------------------\nEnd Sub\n\nSub move_Each_Row\n(strEach As String, colsCnt As Integer, rngR As Range)\nSheets(strEach).Cells(Rows.Count, 1).End(3)(2).\nResize\n(, colsCnt) = _\nrngR.Value\n'각 행의 데이터를 해당 시트에 복사\nEnd Sub", "context": "Sheet1에 데이터가 있고 \"국\", \"영\", \"수\", \"사\", \"과\" 시트는 제목행만 있고 비어 있는 상태에서\n1) (E열을 기준으로) 2번 행 김하나는 신청과목이\"종합\"이므로 \"국영수사과\" 전 시트에\n2) 3행의 나영철은 \"국\", \"영\", \"수\" 시트에\n3) 5행의 김영희는 \"영\", \"수\" 시트에 각 행의 데이터를 복사해 옮기는 기능.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1346) 데이터를 신청과목별로 각 시트에 내보내기 (엑셀 VBA 매크로)\n재생\n740\n재생 (space/k)\n재생\n00:33\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:33\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 ..."}
{"instruction": "Excel VBA code for: (1348) 각 시트의 데이터를 신청과목별으로 합치기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_As_Per_Subject()\nDim s As Integer\n'2번 시트부터 반복할 변수\nDim rngAll As Range\n'복사한 전체 데이터 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수를 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngA As Range\n'이름이 중복된 행 영역 넣을 변수\nDim j As Long\n'배열크기 늘려갈 변수\nDim y As Integer\n'신청과목 문자만큼 반복할 변수\nDim varTemp()\n'동적배열로 사용할 변수\nDim strName As String\n'신청과목 문자를 합쳐넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.Offset(1).\nClearContents\n'기존 데이터 삭제\nFor s = 2 To Sheets.Count\n'2번 시트부터 마지막까지 반복\n'------------------------------------------------\n' Sheet1 으로 각 시트의 데이터를 불러오는 코드\n'------------------------------------------------\nWith Sheets(s).\nUsedRange\n'각 시트 사용영역에서\nrowsCnt = .Rows.Count\n'행 개수를 변수에 넣음\ncolsCnt = .Columns.Count\n'열 개수를 변수에 넣음\nCells(Rows.Count, \"A\").End(3)(2).Resize(rowsCnt, _\ncolsCnt) = .\nOffset(1)\n.Value\n'각 시트의 데이터를 Sheet1에 복사\nEnd With\nNext s\nSet\nrngAll = ActiveSheet.UsedRange.Offset(1)\nrngAll.\nSort\n[A2], 1\n'A열 No를 기준으로 오름차순 정렬\nOn Error GoTo errHandler\n'신청과목 입력오류로 에러 시 에러처리\n'-----------------------------------------------------------------\n' C열의 이름 중복 판단하여 동적으로 배열크기 늘려가며 넣는 코드\n'-----------------------------------------------------------------\nr = 2\n'제목 제외한 2행부터 시작\nDo\nIf Cells(r, 3) = Cells(r + 1, 3) Then\n'\"이름\"이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'\n\"이름\"이\n바로 아래 셀과 다르면\nSet rngA = Cells(r - i, 1).Resize(i + 1, colsCnt)\n'중복 구역을 변수에 넣음\nIf rngA.Rows.Count > 5 Then\n'중복행이 5보다 크면\nGoTo\nerrHandler\n'에러 처림\nElseIf rngA.Rows.Count = 5 Then\n'중복행이 5이면\nj = j + 1\n'배열크기 1씩 늘려감\nReDim Preserve\nvarTemp(1 To j)\n'배열크기 재지정\nvarTemp(j) = Cells(r, 1).Resize(, colsCnt)\n'배열에 행 데이터를 넣음\nvarTemp(j)(1, 5) = \"종합\"\n'신청과목은 \"종합\"\nElse\n'중복행이 5행보다 작으면\nj = j + 1\n'배열크기 1씩 늘려감\nReDim Preserve varTemp(1 To j)\n'배열크기 재지정\nFor y = i To 0 Step -1\n'중복행 만큼 반복\nstrName = strName & Cells(r - y, 5)\n'각 신청과목을 합쳐감\nNext y\nvarTemp(j) = Cells(r, 1).Resize(, colsCnt)\n'배열에 행 데이터를 넣음\nvarTemp(j)(1, 5) = strName\n'신청과목에 합쳐진 문자 넣음\nEnd If\nstrName = \"\"\n'재사용 위하여 초기화\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nrngAll.ClearContents\n'임시로 복사한 데이터 삭제\n'-------------------------------------------------------------\n' 각 행에 동적배열에 입력한 데이터를 행단위로 뿌려주는 코드\n'-------------------------------------------------------------\nFor r = 2 To\nUBound\n(varTemp, 1) + 1\n'배열 개수만큼 반복\nCells(r, 1).Resize(, colsCnt) = varTemp(r - 1)\n'각 행에 배열의 데이터를 뿌림\nNext r\nMsgBox \"매크로가 종료되었습니다.\"\n'매크로 종료 메시지 출력\nExit Sub\n'매크로 종료\nerrHandler:\nMsgBox Cells(r, 3) & \" 학생 에러 발생. 데이터를 확인하고 재실행\", 64, \"데이터 입력 에러\"\nrngAll.ClearContents\n'임시로 복사한 데이터 삭제\nEnd Sub", "context": "앞서 \" (1346) 데이터를 신청과목별로 각 시트에 내보내기 (\nhttp://rosa0189.blog.me/60204442172\n) 기능을 이번에는 역으로 구현한 것. 즉, 각 시트에 있는 데이터를 신청과목으로 통합하는 내용.\n1. 각 시트에는 시트이름과 일치하는 이름으로 E열에 신청과목이 입력되어 있음\n2. \"국\", \"영\", \"수\", \"사\", \"과\"를 모두 신청하였을 경우 신청과목을 \"종합\"으로 표기\n3. \"국\" 시트, \"수\" 시트, \"사\"시트에 동일한 이름으로 과목을 신청한 학생은 \"국수사\"로 신청과목 표기\n4. 중복신청하여 5과목이 초과되는 학생은 에러 메시지 출력\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1348) 각 시트의 데이터를 신청과목별으로 합치기 (엑셀 VBA 매크로)\n재생\n3,273\n재생 (space/k)\n재생\n00:42\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:42\n실시간\n..."}
{"instruction": "Excel VBA code for: (1349) 특정 영역에 순차적으로 값 채우기 연습 12 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_19()\nDim rngCol As Range\n'선택영역의 세로 열을 넣을 변수\nDim rngC As Range\n'각 열내의 각 셀을 넣을 변수\nDim cnt As Long\n'카운터로 사용할 변수\nDim upDown As\nBoolean\n'상하 방향을 결정할 변수\nDim i As Long\n'값을 내려오면 서 채울때 사용할 변수\nupDown =\nFalse\n'upDown을 false로(Boolean은 초기 값이 false임)\nFor Each\nrngCol\nIn\nSelection.\nColumns\n'선택영역의 각 열을 (왼쪽 열부터)순환\nFor Each rngC In rngCol.\nCells\n'각 열의 각 셀을 순환\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nIf upDown = False Then\n'upDown 방향이 false (아래방향)이면\nrngC = cnt\n'각 셀에 카운터의 값을 넣음\nElse\n'upDown 방향이 true (윗방향)이면\ni = i + 2\n'뺄 값을 2씩 더해감\nrngC = cnt + rngCol.Rows.Count + 1 - i\n'윗 행부터 값을 채워줌\nEnd If\nNext rngC\ni = 0\n'재사용 위하여 초기화\nupDown = Not upDown\n'upDown의 값을 반전시킴\nNext\nrngCol\nEnd Sub\n\nSub range_Fill_20()\nDim upDown As\nBoolean\n'상하 방향을 결정할 변수\nDim rngCol As Range\n'선택영역의 세로 열을 넣을 변수\nDim cnt As Long\n'카운터로 사용할 변수\nDim i As Long\n'값을 내려오면 서 채울때 사용할 변수\nupDown = False\n'upDown을 false로(Boolean은 초기 값이 false임)\nFor Each rngCol In Selection.Columns\n'선택영역의 각 열을 (왼쪽 열부터)순환\nIf upDown = False Then\n'upDown 방향이 false (아래방향)이면\nFor i = 1 To rngCol.\nCells.Count\n'열 개수만큼 반복\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nrngCol.\nCells(i)\n= cnt\n'각 셀에 값을 채워감\nNext i\nElse\n'upDown 방향이 true (윗방향)이면\nFor i = rngCol.Cells.Count To 1\nStep -1\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nrngCol.Cells(i) = cnt\n'각 셀에 값을 채워감\nNext i\nEnd If\nupDown = Not upDown\n'upDown의 값을 반전시킴\nNext rngCol\nEnd Sub", "context": "초보자님들을 위한 코너로, 윗그림 처럼 마우스로 선택한 영역에 순차적으로 값을 채우는 연습.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1349) 특정 영역에 순차적으로 값 채우기 연습 12 (엑셀 VBA 매크로)\n재생\n267\n재생 (space/k)\n재생\n00:26\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:26\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n이번 동영상은 설명이 필요 없는 것 같음.\n한 가지 참고..."}
{"instruction": "Excel VBA code for: (1350) 특정 영역에 순차적으로 값 채우기 연습 13 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_21()\nDim rngC As Range\n'선택영역내 각 셀을 넣을 변수\nDim cnt As Long\n'카운터로 사용할 변수\nFor Each\nrngC\nIn\nSelection\n'선택영역의 각 셀을순환\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nIf Selection.Cells(1).\nRow\nMod\n2 = 0 And _\nrngC.Row Mod\n2 = 0 Then\n'선택영역 첫셀의 행을 2로 나눈 나머지가 0이고\n'각 셀의 행을 2로 나눈 나머지가 0이면\nrngC = cnt\n'각셀에 카운터의 값을 채워감\nElseIf Selection.Cells(1).Row Mod 2 = 1 And _\nrngC.Row Mod 2 = 1 Then\n'선택영역 첫셀의 행을 2로 나눈 나머지가 0이고\n'각 셀의 행을 2로 나눈 나머지가 1이면\nrngC = cnt\nEnd If\nNext\nrngC\nEnd Sub", "context": "다시 초보님들을 위한 코너. 위와 같이 선택영역 위치와 크기 상관없이 홀수행은 숫자를 채우고 짝수 행은 한 행씩 건너 뛰면서, 숫자도 빈 셀의 개수만큼 건너뛰면서 순차적으로 값을 채우는 코드이다. 가끔 쉬울듯 보여도 본인이 직접 해보면 까다로운 경우도 많다. 아래의 코드를 보기전 나라면 어떻게 할까 한 번 생각해보자.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1350) 특정 영역에 순차적으로 값 채우기 연습 13 (엑셀 VBA 매크로)\n재생\n232\n재생 (space/k)\n재생\n00:21\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:21\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시..."}
{"instruction": "Excel VBA code for: (1351) 특정 영역에 순차적으로 값 채우기 연습 14 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_22()\nDim rngC As Range\n'선택영역내 각 셀을 넣을 변수\nDim cnt As Long\n'카운터로 사용할 변수\nFor Each\nrngC\nIn\nSelection\n'선택영역의 각 셀을순환\nIf Selection.Cells(1).\nRow Mod\n2 = 0 And _\nrngC.Row Mod 2 = 0 Then\n'선택영역 첫셀의 행을 2로 나눈 나머지가 0이고\n'각 셀의 행을 2로 나눈 나머지가 0이면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nrngC = cnt\n'각셀에 카운터의 값을 채워감\nElseIf Selection.Cells(1).Row Mod 2 = 1 And _\nrngC.Row Mod 2 = 1 Then\n'선택영역 첫셀의 행을 2로 나눈 나머지가 0이고\n'각 셀의 행을 2로 나눈 나머지가 1이면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nrngC = cnt\nEnd If\nNext\nrngC\nEnd Sub", "context": "초보님들을 위한 영역에 순차적으로 숫자를 채우는 코드. 앞서  연습한 것과 조금 다르게 이번에는 선택영역의 짝수행을 공백으로 건너 뛰면서 숫자는 공백을 무시하고 계속하여 순차적을 채워가는 코드. 배열을 사용하면 속도도 빠르고 좋지만 초보님들을 위한 코너이므로 Mod 연산자 하나로 해결해보자.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1351) 특정 영역에 순차적으로 값 채우기 연습 14 (엑셀 VBA 매크로)\n재생\n291\n재생 (space/k)\n재생\n00:15\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:15\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음..."}
{"instruction": "Excel VBA code for: (1352) 행삽입 삭제 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Blank_Rows()\nDim lastRow As Long\n'마지막 행 - 1 을 넣을 변수\nDim lngNo As Long\n'삽입할 행의 개수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, \"A\").End(3).Row - 1\n'마지막 행 -1 을 변수에 넣음\nlngNo =\n1\n'삽입할 행의 개수를 변수에 넣음\nColumns(\"A\").Insert\n'A열에 열을 삽입\nFor i = 1 To lngNo + 1\n'lngNo + 1 회만큼 반복\nCells(Rows.Count, \"A\").End(3)(2).Resize(lastRow) = _\nApplication.\nEvaluate\n(\"row(1:\" & lastRow & \")\")\n'행 개수의 만큼 연속숫자 입력\nNext i\nActiveSheet.UsedRange.Sort [A1], 1, Header:=True\n'현재시트 사용영역을 오름차순 정렬\nColumns(\"A\").Delete\n'임시로 사용한 열 삭제\nEnd Sub\n\nSub delete_Blank_Rows()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim lngNo As Integer\n'삽입할 행의 개수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'번호를 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, \"A\").End(3).Row\n'마지막 행을 변수에 넣음\nlngNo =\n1\n'삭제할 행의 개수를 변수에 넣음\nColumns(\"A\").Insert\n'A열에 임시 열을 삽입\nFor i = 2 To lastRow Step lngNo + 1\n'마지막행까지 lngNo + 1 만큼 건너 뛰며 반복\nr = r + 1\n'번호를 1씩 늘려감\nCells(i, 1) = r\n'A열에 정렬 기준으로 사용할 번호를 뿌려줌\nNext i\nActiveSheet.UsedRange.Sort [A1], 1, Header:=True\n'현재시트 사용영역을 오름차순 정렬\nColumns(\"A\").Delete\n'임시로 사용한 열 삭제\nEnd Sub\n\nSub delete_Blank_Rows_Using_Array()\nDim colNo As Integer\n'전체 열 개수 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim rngAll As Range\n'전체 사용 영역을 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim x As Long\n'동적배열의 크기 늘려갈 변수\nDim varR()\n'동적배열로 사용할 변수\nDim c As Integer\n'열(c)olumn 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\ncolNo = 1\n'1열에 빈 셀이 있는 것을 기준으로 행 삭제\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\ncolsCnt = .Columns.Count\n'전체 열 개수를 변수에 넣음\nSet rngAll = .Offset(1).Resize(.Rows.Count - 1)\n'colNo열의\nEnd With\nFor r = 1 To rngAll.Rows.Count\n'1~ varAll 배열의 행 개수만큼 반복\nIf rngAll(r, colNo) <> Empty Then\n'각 행의 값이 빈셀이 아니라면\nx = x + 1\n'배열크기 1씩 늘려감\nReDim Preserve\nvarR(1 To colsCnt, 1 To x)\n'동적배열 크기 재지정\nFor c = 1 To colsCnt\n'1 ~ varAll 배열의 열 개수만큼 반복\nvarR(c, x) = rngAll(r, c)\n'값을 배열에 넣음\nNext c\nEnd If\nNext r\nrngAll.ClearContents\n'기존 데이터 영역의 데이터를 삭제\nCells(2, 1).Resize(UBound(varR, 2), colsCnt) = _\nApplication.\nTranspose\n(varR)\n' 행/열 변환하여 배열의 값을 셀에 뿌림\nEnd Sub", "context": "(규칙적 또는)불규칙적\n으로 빈 행이 있는 데이터의 빈 행을 없애주는 코드로 앞으로 빈행 삭제 시 이용하기 위해 미리 정리하여 기본코드에 넣어둠. 빈 행의 데이터 삭제시 실제로 행을 삭제하는 것은 엄청나게 느리다. 그래서 아래와 같이 정렬 또는 배열등을 이용하여서 빈행을 삭제하는게 좋다.\ndelete_Rows_Using_Sort 매크로 실행 전                  매크로 실행 후 결과\nOption Explicit\nSub\ndelete_Rows_Using\n_Sort\n()\nDim rngAll As Range\n'A열 문자있는 셀 전체를 넣을 변수\nDim rngC As Range\n'전체영역 각셀을 넣을 변수\nDim cnt As Long\n'카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\nSet rngAll = .Columns(.Columns.Cou..."}
{"instruction": "Excel VBA code for: (1354) 그룹별 데이터 각 시트로 분류하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub move_Each_Group_To_Sheets()\nDim colName As String\n'필터링 조건이 되는 열이름 넣을 변수\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim colsCnt As Integer\n'전체 열개수 넣을 변수\nDim varTemp\n'임시열 전체를 넣을 변수\nDim strName As String\n'각 시트이름 넣을 변수\nDim s As Long\n'시트 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\ncolName = \"\nB\n\"\n'필터링(시트이름) 조건이 되는 열의 이름\nSet rngAll = ActiveSheet.UsedRange\n'전체 영역을 변수에 넣음\nIf rngAll.Rows.Count < 2 Then\n'데이터 없이 제목행만 있는 경우\nMsgBox \"옮길 데이터가 없습니다.\", 64, \"데이터 오류\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\ncolsCnt = rngAll.Columns.Count\n'전체 사용영역의 열 개수를 변수에 넣음\nrngAll.Columns(colName).\nAdvancedFilter\nAction:=2, _\nCopyToRange:=Cells(1, colsCnt + 1), Unique:=1\n'유일한 이름 목록을 추출\nColumns(colsCnt + 1).\nSpecialCells(2\n).Offset(1).Sort Cells(2, colsCnt + 1), 1\n'오름차순 정렬\nvarTemp = Range(Cells(2, colsCnt + 1), Cells(Rows.Count, colsCnt + 1).End(3))\n'배열에 유일한 이름 목록을 넣음\nIf rngAll.Rows.Count = 2 Then\n'1개의 데이터 옮기는 특수상황 처리\nstrName = varTemp\n'배열내의 값을 변수에 넣음\nCall\nmove_data(colsCnt, rngAll, strName)\n'시트이름 확인 후 데이터 이동하는 코드 호출\nElse\nFor s = 1 To UBound(varTemp, 1)\n'배열내 유일한 이름 개수만큼 반복\nstrName = varTemp(s, 1)\n'각 시트 이름을 변수에 넣음\nCall\nmove_data(colsCnt, rngAll, strName)\n'시트이름 확인 후 데이터 이동하는 코드 호출\nNext s\nEnd If\nColumns(colsCnt + 1).\nDelete\n'임시로 사용한 열 삭제\nsorting_Sheets\n'시트 오름차순 정렬 코드 호출\nSet rngAll = Nothing\n'개체변수 초기화 (메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\n'메시지 출력\nEnd Sub\n\nSub move_data\n(colsCnt As Integer, rngAll As Range, strName As String)\nDim rngT As Range\n'데이터 복사될 (T)arget 지점\nDim sht As Worksheet\n'시트를 넣을 변수\nOn Error Resume Next\n'에러가 발생해도 중단없이 다음코드 진행\nSet sht = Sheets(strName)\n'시트를 개체변수 sht에 넣음\nIf\nErr <> 0\nThen\n'시트가 존재하지 않아 에러 발생 시\nSheets.\nAdd\nafter:=Sheets(Sheets.Count)\n'시트를 제일 뒤에 추가\nSheets(Sheets.Count).\nName\n= strName\n'시트의 이름을 변경\nSheets(1).Activate\n'Data 시트 활성화\nWorksheets.\nFillAcrossSheets\nRange(\"A1\", _\nCells(1, Columns.Count).End(1)(1, 0))\n'전체 시트에 제목행 복사\nEnd If\nWith Sheets(strName)\nSet rngT = .Cells(Rows.Count, \"A\").End(3)(2)\n'복사될 위치 설정\nCells(2, colsCnt + 1) = strName\n'필터 조건(유일한 \"이름\")을 지정\nCells(2, colsCnt + 1) = \"'=\" & strName\n'  '=추가로 전체일치 데이터만 가져오도록 함.\nrngAll.AdvancedFilter Action:=2, CriteriaRange:=Cells(1, colsCnt + 1).Resize(2), _\nCopyToRange:=rngT, Unique:=0\n'각 이름별 데이터 시트에 복사\nrngT.\nEntireRow.Delete\n'중복 복사된 제목행 삭제\n.Columns.AutoFit\n'각 시트의 열너비 자동 맞춤\n.UsedRange.\nSort\n.Range(\"A2\"), 1, Header:=True\n'각 시트 오름차순 정렬\nEnd With\nSet sht = Nothing\n'개체변수 초기화\nSet rngT = Nothing\n'개체변수 초기화\nEnd Sub\n\nSub sorting_Sheets()\nDim i As Long\n'앞 시트 위치 넣을 변수\nDim j As Long\n'뒷 시트 위치 넣을 변수\nFor i = 2 To Sheets.Count\n'2번 시트부터 반복\nFor j = i + 1 To Sheets.Count\n'i + 1 만큼 반복\nIf\nUCase\n(Sheets(j).Name) < UCase(Sheets(i).Name) Then\n'두 sheet의 이름을 비교하여\nSheets(j).\nMove\nBefore:=Sheets(i)\n'오름차순으로 시트를 이동\nEnd If\nNext j\nNext i\nEnd Sub", "context": "기존의 \"(764) 그룹별 데이터 각 시트로 분류하기 (\nhttp://rosa0189.blog.me/60150909122\n) 코드의 경우 Main 시트만 남기고 모든 시트를 삭제한 뒤 사용자가 지정한 열의 데이터를 기준으로 새로이 시트를 생성하고 데이터를 분류하였다.\n아래의 코드는 기존의 시트들을 삭제하지 않고 Main 시트에 있는 데이터를 각 시트로 분류하는 코드이다. 단, 옮기려는 데이터와 동일한 시트가 존재하지 않을 경우 새로운 시트를 생성하여 준다. 생성된 시트는 오름차순으로 정렬된다.\n아래 동영상처럼 매크로 버튼 클릭 시 기존 시트에 있는 데이터를 그대로 놔두고 계속하여 Data 시트의 데이터를 각 시트에 복사하는 코드. 즉, 기존 시트에 계속하여 append 시킴. 매크로 버튼 연속 클릭 시 중복데이터 생성됨.\n50,000 행의 데이터\n를 가지고 시험해 봤을 때 내 컴퓨터에서 대략\n1.0초 정도 소요\n되었다.\n고\n급필터를 사용하여 데이터를 옮기므로 상당히 속도가 빠르다.\n..."}
{"instruction": "Excel VBA code for: (1355) 그룹별 데이터 각 시트로 분류하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub move_Each_Group_To_Sheets_Everytime()\nDim colName As String\n'필터링 조건이 되는 열이름 넣을 변수\nDim i As Integer\n'시트 개수만큼 반복할 변수\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim colsCnt As Integer\n'전체 열개수 넣을 변수\nDim varTemp\n'임시열 전체를 넣을 변수\nDim strName As String\n'각 시트이름 넣을 변수\nDim s As Long\n'시트 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\ncolName = \"\nB\n\"\n'필터링 조건이 되는 열의 이름\nFor i = 2 To Sheets.Count\n'2번 시트부터 마지막 시트까지 반복\nSheets(i).UsedRange.Offset(1).Clear\n'제목 제외한 모든 데이터 삭제\nNext i\nSet rngAll = ActiveSheet.UsedRange\n'전체 영역을 변수에 넣음\nIf rngAll.Rows.Count < 2 Then\n'데이터 없이 제목행만 있는 경우\nMsgBox \"옮길 데이터가 없습니다.\", 64, \"데이터 오류\"   '메시지 출력\nExit Sub\n'매크로 종료\nEnd If\ncolsCnt = rngAll.Columns.Count\n'전체 사용영역의 열 개수를 변수에 넣음\nrngAll.Columns(colName).\nAdvancedFilter\nAction:=2, _\nCopyToRange:=Cells(1, colsCnt + 1), Unique:=1\n'유일한 이름 목록을 추출\nColumns(colsCnt + 1).\nSpecialCells(2)\n.Offset(1).Sort Cells(2, colsCnt + 1), 1\n'오름차순 정렬\nvarTemp = Range(Cells(2, colsCnt + 1), Cells(Rows.Count, colsCnt + 1).End(3))\n'배열에 유일한 이름 목록을 넣음\nIf rngAll.Rows.Count = 2 Then\n'1개의 데이터 옮기는 특수상황 처리\nstrName = varTemp\n'배열내의 값을 변수에 넣음\nCall\nmove_data(colsCnt, rngAll, strName)\n'시트이름 확인 후 데이터 이동하는 코드 호출\nElse\nFor s = 1 To UBound(varTemp, 1)\n'배열내 유일한 이름 개수만큼 반복\nstrName = varTemp(s, 1)\n'각 시트 이름을 변수에 넣음\nCall\nmove_data(colsCnt, rngAll, strName)\n'시트이름 확인 후 데이터 이동하는 코드 호출\nNext s\nEnd If\nColumns(colsCnt + 1).\nDelete\n'임시로 사용한 열 삭제\nsorting_Sheets\n'시트 오름차순 정렬 코드 호출\nSet rngAll = Nothing\n'개체변수 초기화 (메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\nEnd Sub\n\nSub move_data\n(colsCnt As Integer, rngAll As Range, strName As String)\n'---------------------------------------------------------------\n' 필요시 시트를 추가하고 고급필터 이용하여 데이터 이동하는 코드\n'---------------------------------------------------------------\nDim rngT As Range\n'데이터 복사될 (T)arget 지점\nDim sht As Worksheet\n'시트를 넣을 변수\nOn Error Resume Next\n'에러가 발생해도 중단없이 다음코드 진행\nSet sht = Sheets(strName)\n'시트를 개체변수 sht에 넣음\nIf\nErr <> 0\nThen\n'시트가 존재하지 않아 에러 발생 시\nSheets.Add after:=Sheets(Sheets.Count)\n'시트를 제일 뒤에 추가\nSheets(Sheets.Count).\nName\n= strName\n'시트의 이름을 변경\nSheets(1).Activate\n'Data 시트 활성화\nWorksheets.\nFillAcrossSheets\nRange(\"A1\", _\nCells(1, Columns.Count).End(1)(1, 0))\n'전체 시트에 제목행 복사\nEnd If\nWith Sheets(strName)\nSet rngT = .Cells(Rows.Count, \"A\").End(3)(2)\n'복사될 위치 설정\nCells(2, colsCnt + 1) = strName\n'필터 조건(유일한 \"이름\")을 지정\nCells(2, colsCnt + 1) = \"'=\" & strName\n' '=추가로 전체일치 데이터만 가져오도록 함.\nrngAll.AdvancedFilter Action:=2, CriteriaRange:=Cells(1, colsCnt + 1).Resize(2), _\nCopyToRange:=rngT, Unique:=0\n'각 이름별 데이터 시트에 복사\nrngT.\nEntireRow.Delete\n'중복 복사된 제목행 삭제\n.Columns.AutoFit\n'각 시트의 열너비 자동 맞춤\n.UsedRange.\nSort\n.Range(\"A2\"), 1, Header:=True\n'각 시트 오름차순 정렬\nEnd With\nSet sht = Nothing\n'개체변수 초기화\nSet rngT = Nothing\n'개체변수 초기화\nEnd Sub\n\nSub sorting_Sheets()\n'----------------------------------------------------------\n' Data 시트를 제외하고 2번 시트부터 오름차순 정렬하는 코드\n'----------------------------------------------------------\nDim i As Long\n'앞 시트 위치 넣을 변수\nDim j As Long\n'뒷 시트 위치 넣을 변수\nFor i = 2 To Sheets.Count\n'2번 시트부터 반복\nFor j = i + 1 To Sheets.Count\n'i + 1 만큼 반복\nIf\nUCase\n(Sheets(j).Name) < UCase(Sheets(i).Name) Then\n'두 sheet의 이름을 비교하여\nSheets(j).\nMove\nBefore:=Sheets(i)\n'오름차순으로 시트를 이동\nEnd If\nNext j\nNext i\nEnd Sub", "context": "기존의 \"(764) 그룹별 데이터 각 시트로 분류하기 (\nhttp://rosa0189.blog.me/60150909122\n) 는 기존시트를 모두 삭제 후 새로운 시트 생성하여 각 시트로 그룹별 분류를 하여주었고, \"(1354) 그룹별 데이터 각 시트로 분류하기 1 (\nhttp://rosa0189.blog.me/60150909122\n)\" 은 기존 시트에 계속하여 중복을 허용하며 그룹별 데이터를 각 시트로 분류하여 주었다.\n아래의 코드는 매크로 실행 시\n기존 시트는 삭제하지 않고 데이터만 삭제하고, Data 시트에 있는 모든 데이터를 그룹별로 각 시트로 재 분류하는 코드\n이다. 매크로 버튼을 연속으로 클릭하여도 데이터가 중복으로 복사되지 않는다.\ncolName = \"B\" 의 의미는 B열을 기준으로 분류한다는 뜻. 다른 열, 예를 들면 C열을 기준으로 데이터를 분류하고 싶을 경우 colName = \"C\"라고만 수정하면 나머지는 코드가 다 알아서 한다.\n0초\n0초\n100%\n광고 후 계속됩니..."}
{"instruction": "Excel VBA code for: (1356) 그룹별 데이터 각 시트로 분류하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub move_Each_Group_To_Sheets_RemoveDuplicates()\nDim colName As String\n'필터링 조건이 되는 열이름 넣을 변수\nDim rngAll As Range\n'전체영역을 넣을 변수\nDim colsCnt As Integer\n'전체 열개수 넣을 변수\nDim varTemp\n'임시열 전체를 넣을 변수\nDim strName As String\n'각 시트이름 넣을 변수\nDim s As Long\n'시트 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\ncolName = \"\nB\n\"\n'필터링(시트생성) 조건이 되는 열의 이름\n'-----------------------------------------\n' 각종 사용자 에러 검출하여 걸러내는 코드\n'-----------------------------------------\nSet rngAll = ActiveSheet.UsedRange\n'전체 영역을 변수에 넣음\nIf ActiveSheet.\nUsedRange\n.Cells.Count =\n1\nOr _\nrngAll.Rows.Count < 2 Then\n'시트가 비었거나 제목행만 있는 경우\nMsgBox \"옮길 데이터가 없습니다.\", 64, \"데이터 오류\"   '메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nOn Error\nResume Next\n'에러 발생해도 다음 코드 진행\nIf Columns(colName).SpecialCells(2).Areas.Count > 1 Then\n'지정한 열에 데이터가 아예 없거나 중간에 빈 셀이 있어 영역이 2개 이상이면\nMsgBox \"데이터가 없거나 지정한 열에 빈셀 있음.\", 64, \"데이터 입력 에러\"\nExit Sub\n'매크로 종료\nEnd If\nOn Error GoTo 0\n'에러 검출기능 초기화\ncolsCnt = rngAll.Columns.Count\n'전체 사용영역의 열 개수를 변수에 넣음\n'--------------------------------------------\n' 지정한 열에서 유일한 목록을 추출하는 코드\n'--------------------------------------------\nrngAll.Columns(colName).\nAdvancedFilter\nAction:=2, _\nCopyToRange:=Cells(1, colsCnt + 1), Unique:=1\n'유일한 이름 목록을 추출\nColumns(colsCnt + 1).\nSpecialCells(2)\n.Offset(1).\nSort\nCells(2, colsCnt + 1), 1\n'오름차순 정렬\nvarTemp = Range(Cells(2, colsCnt + 1), Cells(Rows.Count, colsCnt + 1).End(3))\n'배열에 유일한 이름 목록을 넣음\nIf rngAll.Rows.Count = 2 Then\n'1개의 데이터 옮기는 특수상황 처리\nstrName = varTemp\n'배열내의 값을 변수에 넣음\nCall\nmove_data(colsCnt, rngAll, strName)\n'시트이름 확인 후 데이터 이동하는 코드 호출\nElse\nFor s = 1 To UBound(varTemp, 1)\n'배열내 유일한 이름 개수만큼 반복\nstrName = varTemp(s, 1)\n'각 시트 이름을 변수에 넣음\nCall\nmove_data(colsCnt, rngAll, strName)\n'시트이름 확인 후 데이터 이동하는 코드 호출\nNext s\nEnd If\nColumns(colsCnt + 1).\nDelete\n'임시로 사용한 열 삭제\nsorting_Sheets\n'시트 오름차순 정렬 코드 호출\nSet rngAll = Nothing\n'개체변수 초기화 (메모리 비우기)\nSheets(1).Activate\n'Data 시트 활성화\nFor s = 2 To Sheets.Count\n'각 시트의 중복 제거\nSheets(s).UsedRange.RemoveDuplicates _\nArray(1, 2, 3, 4)\n, xlYes\n'1 ~ 4열 모두 같아야 중복으로 처리함\nNext s\nMsgBox \"매크로가 종료되었습니다.\"\nEnd Sub\n\nSub move_data\n(colsCnt As Integer, rngAll As Range, strName As String)\n'--------------------------------------------------------------\n' 필요시 시트를 추가하고 고급필터 이용하여 데이터 이동하는 코드\n'--------------------------------------------------------------\nDim rngT As Range\n'데이터 복사될 (T)arget 지점\nDim sht As Worksheet\n'시트를 넣을 변수\nOn Error Resume Next\n'에러가 발생해도 중단없이 다음코드 진행\nSet sht = Sheets(strName)\n'시트를 개체변수 sht에 넣음\nIf\nErr <> 0\nThen\n'시트가 존재하지 않아 에러 발생 시\nOn Error\nGoTo 0\n'에러 검출기능 초기화\nSheets.Add after:=Sheets(Sheets.Count)\n'시트를 제일 뒤에 추가\nSheets(Sheets.Count).\nName\n= strName\n'시트의 이름을 변경\nSheets(1).Activate\n'Main 시트 활성화\nWorksheets.\nFillAcrossSheets\nRange(\"A1\", _\nCells(1, Columns.Count).End(1)(1, 0))\n'전체 시트에 제목행 복사\nEnd If\nWith Sheets(strName)\nSet rngT = .Cells(Rows.Count, \"A\").End(3)(2)\n'복사될 위치 설정\nCells(2, colsCnt + 1) = strName\n'필터 조건(유일한 \"이름\")을 지정\nCells(2, colsCnt + 1) = \"'=\" & strName\n' '=추가로 전체일치 데이터만 가져오도록 함.\nrngAll.AdvancedFilter Action:=2, CriteriaRange:=Cells(1, colsCnt + 1).Resize(2), _\nCopyToRange:=rngT, Unique:=0\n'각 이름별 데이터 시트에 복사\nrngT.\nEntireRow.Delete\n.Columns.AutoFit\n'각 시트의 열너비 자동 맞춤\n.UsedRange.Sort .Range(\"A2\"), 1, Header:=True\n'각 시트 오름차순 정렬\nEnd With\nSet sht = Nothing\n'개체변수 초기화\nSet rngT = Nothing\n'개체변수 초기화\nEnd Sub\n\nSub sorting_Sheets()\n'---------------------------------------------------------\n' Data 시트를 제외하고 2번 시트부터 오름차순 정렬하는 코드\n'---------------------------------------------------------\nDim i As Long\n'앞 시트 위치 넣을 변수\nDim j As Long\n'뒷 시트 위치 넣을 변수\nFor i = 2 To Sheets.Count\n'2번 시트부터 반복\nFor j = i + 1 To Sheets.Count\n'i + 1 만큼 반복\nIf\nUCase\n(Sheets(j).Name) < UCase(Sheets(i).Name) Then\n'두 sheet의 이름을 비교하여\nSheets(j).\nMove\nBefore:=Sheets(i)\n'오름차순으로 시트를 이동\nEnd If\nNext j\nNext i\nEnd Sub", "context": "﻿\n기존의\n\"(764) 그룹별 데이터 각 시트로 분류하기 (\nhttp://rosa0189.blog.me/60150909122\n) 는 기존시트를 모두 삭제 후 새로운 시트 생성하여 각 시트로 그룹별 분류를 하여주었고,\n\"(1354) 그룹별 데이터 각 시트로 분류하기 1 (\nhttp://rosa0189.blog.me/60204593072\n)\" 은 기존 시트에 계속하여 중복을 허용하며 그룹별 데이터를 각 시트로 분류하여 주었으며,\n\"(1355) 그룹별 데이터 각 시트로 분류하기 2 (\nhttp://rosa0189.blog.me/60204636892\n)\" 은 기존 시트는 삭제하지 않고 데이터만 삭제하고, 데이터를 그룹별로 각 시트에 분류하여 주었다.\n아래의 코드는 매크로 실행 시\n기존 시트을 삭제하지 않고, 기존의 데이터도 그대로 유지하며, Data 시트에 있는 모든 데이터를 중복 없이 그룹별로 각 시트로 재 분류하는 코드\n이다. 즉, 매크로 버튼을 연속으로 클릭하여도 이미 기존 시트에 있..."}
{"instruction": "Excel VBA code for: (1357) 메모창에 그림 삽입하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Pictures_Into_Comments_1()\nDim rngSel As Range\n'선택영역 전체를 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim strPath As String\n'그림폴더 저장경로 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet\nrngSel = Application.\nInputBox\n(\"마우스로 영역을 설정하시오!\", Type:=8)\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nstrPath =\n\"C:\\Users\\Public\\Pictures\\Sample Pictures\"\n'파일 경로를 변수에 넣음\nFor Each rngC In rngSel\n'선택영역 각 셀을 순환\nfileName = strPath & \"\\\" & rngC.Value & \".jpg\"\n'각 파일의 전체 경로를 변수에 넣음\nIf\nDir\n$\n(fileName) <> \"\" Then\n'경로내 .jpg 파일을 찾기\nWith rngC\n'각 셀에서\n.ClearComments\n'기존 메모 삭제(삭제 시 기존 메모 있으면 에러)\n.AddComment (\"\")\n'메모삽입\n.Comment.Shape.Fill.UserPicture (fileName)\n'메모에 그림을 넣음\n.Comment.Shape.LockAspectRatio = msoFalse\n'그림 좌우비율 고정 해제\n.Comment.Shape.\nWidth\n=\n200\n'그림의 폭\n.Comment.Shape.\nHeight\n=\n150\n'그림의 높이\n.Comment.Shape.LockAspectRatio = msoTrue\n'그림 좌우비율 고정\nEnd With\nEnd If\nNext rngC\nMsgBox \"매크로가 종료되었습니다.\"\nEnd Sub", "context": "선택한 영역의 파일 이름과 경로내의 그림 이름이 일치 시 각 셀의 메모에 그림을 삽입하는 기능.\n아래 코드에서\n\"C:\\Users\\Public\\Pictures\\Sample Pictures\"\n라고 되어 있는 경로를 자신의 그림파일 경로와 일치시키면 된다. 물론 .jpg 파일이 아닌 다른 파일을 삽입하고 싶을 경우에는 .jpg 라는 코드를 .gif 또는 .bmp 와 같이 바꿔주면 된다. (이 코드의 단점은 기존 메모가 삭제된다는 것이다. 업데이트가 필요할 듯.)\n표시되는 그림 크기는 아래 코드내의 200, 150을 자신이 원하는 크기로 변경하면 된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1357) 메모창에 그림 삽입하기 1 (엑셀 VBA 매크로)\n재생\n1,713\n재생 (space/k)\n재생\n00:19\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:19\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자..."}
{"instruction": "Excel VBA code for: (1358) 메모있는 셀에만 그림 삽입하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Pictures_Into_Comments_2()\nDim rngSel As Range\n'선택영역 전체를 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim strPath As String\n'그림폴더 저장경로 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strMemo As String\n'메모 넣을 변수\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel = Application.\nInputBox\n(\"마우스로 영역을 설정하시오!\", Type:=8)\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nstrPath =\n\"C:\\Users\\Public\\Pictures\\Sample Pictures\"\n'파일 경로를 변수에 넣음\nFor Each rngC In rngSel\n'선택영역 각 셀을 순환\nfileName = strPath & \"\\\" & rngC.Value & \".jpg\"\n'각 파일의 전체 경로를 변수에 넣음\nIf\nDir$\n(fileName) <> \"\" Then\n'경로내 .jpg 파일을 찾기\nWith rngC\n'각 셀에서\nOn Error\nResume Next\n'에러 발생해도 다음코드 진행\nstrMemo = .Comment.Text\n'기존 메모를 변수에 넣음\nOn Error\nGoTo 0\n'(메모 없어 에러시)에러 검출기능 초기화\nIf strMemo <> \"\" Then\n'메모가 존재할 경우\n.ClearComments\n'기존 메모 삭제(삭제 시 기존 메모 있으면 에러)\n.AddComment (strMemo)\n'기존 메모 복원\n.Comment.Shape.Fill.UserPicture (fileName)\n'메모에 그림을 넣음\n.Comment.Shape.LockAspectRatio = msoFalse\n'그림 좌우비율 고정 해제\n.Comment.Shape.\nWidth\n=\n200\n'그림의 폭\n.Comment.Shape.\nHeight\n=\n150\n'그림의 높이\n.Comment.Shape.LockAspectRatio = msoTrue\n'그림 좌우비율 고정\nEnd If\nEnd With\nEnd If\nstrMemo = \"\"\n'재사용 위하여 초기화\nNext rngC\nMsgBox \"매크로가 종료되었습니다.\"\nEnd Sub", "context": "앞서 해본 \"(1357) 메모창에 그림 삽입하기 1 (\nhttp://rosa0189.blog.me/60204696281\n)\" 은 선택영역내의 기존 메모가 모두 삭제되며 그림을 삽입하였다. 이번 코드는 메모가 삽입된 셀에만 그림을 삽입하는 기능이다. 메모가 없으면 그림 파일과 이름이 일치해도 그림이 메모에 삽입되지 않는다.\n아래 코드에서\n\"C:\\Users\\Public\\Pictures\\Sample Pictures\"\n라고 되어 있는 경로를 자신의 그림파일 경로와 일치시키면 된다. 물론 .jpg 파일이 아닌 다른 파일을 삽입하고 싶을 경우에는 .jpg 라는 코드를 .gif 또는 .bmp 와 같이 바꿔주면 된다.\n표시되는 그림 크기는 아래 코드내의 200, 150을 자신이 원하는 크기로 변경하면 된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1358) 메모있는 셀에만 그림 삽입하기 (엑셀 VBA 매크로)\n재생\n1,488\n재생 (space/k)\n..."}
{"instruction": "Excel VBA code for: (1359) 메모창에 그림 삽입하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Pictures_Into_Comments_3()\nDim rngSel As Range\n'선택영역 전체를 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim strPath As String\n'그림폴더 저장경로 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strMemo As String\n'메모 넣을 변수\nOn Error\nResume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel = Application.InputBox(\"마우스로 영역을 설정하시오!\", Type:=8)\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error\nGoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nstrPath = \"C:\\Users\\Public\\Pictures\\Sample Pictures\"\n'파일 경로를 변수에 넣음\nFor Each rngC In rngSel\n'선택영역 각 셀을 순환\nfileName = strPath & \"\\\" & rngC.Value & \".jpg\"\n'각 파일의 전체 경로를 변수에 넣음\nIf\nDir$\n(fileName) <> \"\" Then\n'경로내 .jpg 파일을 찾기\nWith rngC\n'각 셀에서\nOn Error\nResume Next\n'(빈셀 또는 이름 달라) 다음코드 진행\nstrMemo = .Comment.Text\n'기존 메모를 변수에 넣음\nOn Error\nGoTo 0\n'에러 발생 시 에러 검출기능 초기화\nIf\nLen\n(strMemo) = 0 Then strMemo = \"\"\n'메모가 없을 경우 공백삽입\n.\nClearComments\n'기존 메모 삭제(삭제 시 기존 메모 있으면 에러)\n.\nAddComment\n(strMemo)\n'기존 메모 복원\n.Comment.Shape.Fill.UserPicture (fileName)\n'메모에 그림을 넣음\n.Comment.Shape.LockAspectRatio = msoFalse\n'그림 좌우비율 고정 해제\n.Comment.Shape.\nWidth\n=\n200\n'그림의 폭\n.Comment.Shape.\nHeight\n=\n150\n'그림의 높이\n.Comment.Shape.LockAspectRatio = msoTrue\n'그림 좌우비율 고정\nEnd With\nstrMemo = \"\"\n'재사용 위하여 초기화\nEnd If\nNext rngC\nMsgBox \"매크로가 종료되었습니다.\"\nEnd Sub", "context": "선택한 영역의 파일 이름과 경로내의 그림 이름이 일치 시 각 셀의 메모에 그림을 삽입하는 기능. 기존 메모는 그대로 유지된다.\n아래 코드에서\n\"C:\\Users\\Public\\Pictures\\Sample Pictures\"\n라고 되어 있는 경로를 자신의 그림파일 경로와 일치시키면 된다. 물론 .jpg 파일이 아닌 다른 파일을 삽입하고 싶을 경우에는 .jpg 라는 코드를 .gif 또는 .bmp 와 같이 바꿔주면 된다.\n표시되는 그림 크기는 아래 코드내의 200, 150을 자신이 원하는 크기로 변경하면 된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1359) 메모창에 그림 삽입하기 2 (엑셀 VBA 매크로)\n재생\n581\n재생 (space/k)\n재생\n00:23\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:23\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구..."}
{"instruction": "Excel VBA code for: (1360) 메모창에 그림 삽입하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Pictures_Into_Comments_4()\nDim rngSel As Range\n'선택영역 전체를 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim strPath As String\n'그림폴더 저장경로 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strMemo As String\n'메모 넣을 변수\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel = Application.InputBox(\"마우스로 영역을 설정하시오!\", Type:=8)\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .\nSelectedItems\n.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 종료\nElse\n'폴더 선택시\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName =\nDir\n﻿\n(strPath & \"*.jpg*\")\n'각 파일 경로를 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nFor Each rngC In rngSel\n'선택영역 각 셀을 순환\nIf rngC.Value & \".jpg\" = fileName Then\n'셀 이름과 그림파일이 일치하면\nWith rngC\n'각 셀에서\nOn Error\nResume Next\n'(빈셀 또는 이름 달라) 다음코드 진행\nstrMemo = .Comment.Text\n'기존 메모를 변수에 넣음\nOn Error\nGoTo 0\n'에러 발생 시 에러 검출기능 초기화\nIf Len(strMemo) = 0 Then strMemo = \"\"\n'메모가 없을 경우 공백삽입\n.ClearComments\n'기존 메모 삭제(삭제 시 기존 메모 있으면 에러)\n.AddComment (strMemo)\n'기존 메모 복원\n.Comment.Shape.Fill.UserPicture (strPath & fileName)\n'메모에 그림을 넣음\n.Comment.Shape.LockAspectRatio = msoFalse\n'그림 좌우비율 고정 해제\n.Comment.Shape.\nWidth\n=\n200\n'그림의 폭\n.Comment.Shape.\nHeight\n=\n150\n'그림의 높이\n.Comment.Shape.LockAspectRatio = msoTrue\n'그림 좌우비율 고정\nEnd With\nEnd If\nstrMemo = \"\"\n'재사용 위하여 초기화\nNext rngC\nfileName =\nDir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한반복\nMsgBox \"매크로가 종료되었습니다.\"\nEnd Sub", "context": "선택한 영역의 파일 이름과 경로내의 그림 이름이 일치 시 각 셀의 메모에 그림을 삽입하는 기능. 기존 메모는 그대로 유지된다.\n기존 \"(1357) 메모창에 그림 삽입하기 1 (\nhttp://rosa0189.blog.me/60204696281\n)\" 및 \"(1359) 메모창에 그림 삽입하기 2 (\nhttp://rosa0189.blog.me/60204703974\n)\" 는 그림파일의 경로를 코드내에 미리 입력하여 주었는데 이 코드는 매크로 실행 후 폴더 선택창이 나타나서 그림 파일이 저장된 폴더를 선택하도록 하였다. 이런 코드를 사용할 분들이 별로 많지는 않을 것이라 생각되지만 이것이 더 편리한 것 같다.\n표시되는 그림 크기는 아래 코드내의 200, 150을 자신이 원하는 크기로 변경하면 된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1360) 메모창에 그림 삽입하기 3 (엑셀 VBA 매크로)\n재생\n970\n재생 (space/k)\n재생\n00:2..."}
{"instruction": "Excel VBA code for: (1361) 테이블 작업 기본코드 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub working_With_Table()\nDim tblName As String\nDim fldName As String\ntblName = \"Table2\"\nfldName = \"갑\"\nWith ActiveSheet.\nListObjects\n(tblName).\nSort\n.SortFields.Clear\n.SortFields.Add _\nKey:=Range(tblName & \"[[#All],[\" & fldName & \"]]\"), _\nSortOn:=xlSortOnValues, Order:= _\nxlAscending, DataOption:=xlSortNormal\n.Header = xlYes\n.MatchCase = False\n.Orientation = xlTopToBottom\n.SortMethod = xlPinYin\n.Apply\nEnd With\nEnd Sub", "context": "테이블을 가지고 작업하는 경우는 많지 않지만 뒤적거리다 공부한 김에 나중에 사용할 것을 대비하여 기본 코드를 정리해서 미리 올려 놓음.\n테이블의 생성\nActiveSheet.ListObjects.\nAdd\n(xlSrcRange, _\nRange(\"$A$1:$D$10\"), , xlYes).Name = \"Table1\"\n또는\nActiveSheet.ListObjects.Add(1, [A1:D10]).Name = \"Table1\"\n스타일 적용\nActiveSheet.ListObjects(1).TableStyle = \"TableStyleLight10\"\n테이블의 삭제\nActiveSheet.ListObjects(1).Unlist    'Index 1 번인 테이블의 해제\n[A1:D10].Style = \"Normal\"               '테이블에 적용된 스타일 제거\n테이블의 필터링\nActiveSheet.ListObjects(\"Table1\").Range.\nAutoFilter\n, _\nField:=2, Cr..."}
{"instruction": "Excel VBA code for: (1363) 행/열 변환하여 복사 후 빈행삭제 (엑셀 VBA 매크로)", "input": "", "output": "Sub transpose_And_Delete_Blanks()\nDim rngC As Range\n'C열 각 셀을 넣을 변수\nDim rngA As Range\n'D열 공백 area를 넣을 변수\nDim rngAll As Range\n'전체 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nIf ActiveSheet.UsedRange.Columns.Count > 3 Then\n'열이 3개 이상이면\nMsgBox \"이미 옮겨진 데이터입니다.\", 64, \"데이터 에러\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\n'---------------------------------------------\n' No 있는 행만 C열을 D열에 복사하는 코드\n'---------------------------------------------\nFor Each rngC In Columns(\"C\").\nSpecialCells(2)\n'C열의 문자셀 순환\nIf rngC.\nPrevious\n<> \"\" Then\n'각 셀의 앞셀이 공백이 아니면\nrngC.\nNext\n= rngC\n'각 셀 오른쪽에 셀값을 입력\nEnd If\nNext rngC\n'--------------------------------------------\n' No 없는 C열의 값을 각 행에 복사하는 코드\n'--------------------------------------------\nFor Each rngA In Columns(\"D\").\nSpecialCells(4)\n.Areas\n'D열의 공백 area를 순환\nSet rngT = rngA.Offset(-1, 1)(1)\n'공백 area의 오른쪽 윗셀기준\nFor Each rngC In rngA.Offset(, -1)\n'D열 공백셀 왼쪽의 데이터 각셀\nCells(rngT.Row, Columns.Count).End(1)(1, 2) = rngC\n'값을 복사\nNext rngC\nNext rngA\n'-------------------------------------------------------\n' 빈셀로 필터링 하고 빈셀을 삭제 후 필터 제거하는 코드\n'-------------------------------------------------------\nSet rngAll = Range(\"A1\").CurrentRegion\n'A1셀의 인접셀 영역을 변수에 넣음\nrngAll.\nAutoFilter\nField:=1, Criteria1:=\"\"\n'A열을 빈셀 기준으로 필터링\nWith rngAll\n'전체 영역에서\nSet rngAll = .Offset(1).Resize(.Rows.Count - 1, .Columns.Count)\nEnd With\n'제목행 제외한 전체영역\nrngAll.Delete Shift:=xlUp\n'필터영역 삭제\nWith Range(\"A1\").CurrentRegion\n'A1셀에서\n.\nAutoFilter\n'필터 제거\n.Borders.\nLineStyle = 1\n'데이터 영역 전체에 외곽선 처리\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. No 있는 행의 C열 값을 D열에 복사\n2. No 없는 C열의 값을 행/열 변환하여 복사\n3. 빈행을 삭제\n매크로 실행 전                             매크로 실행 후 결과\nOption Explicit\nSub transpose_And_Delete_Blanks()\nDim rngC As Range\n'C열 각 셀을 넣을 변수\nDim rngA As Range\n'D열 공백 area를 넣을 변수\nDim rngAll As Range\n'전체 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nIf ActiveSheet.UsedRange.Columns.Count > 3 Then\n'열이 3개 이상이면\nMsgBox \"이미 옮겨진 데이터입니다.\", 64, \"데이터 에러\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\n'---------------------------------------------\n' No 있..."}
{"instruction": "Excel VBA code for: (1364) 메모창에 그림 삽입하기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Pictures_Into_Comments_5()\nDim rngSel As Range\n'선택영역 전체를 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim strPath As String\n'그림폴더 저장경로 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strMemo As String\n'메모 넣을 변수\nDim picW As Single\n'그림의 가로 크기 넣을 변수\nDim picH As Single\n'그림의 세로 크기 넣을 변수\nDim intW As Single\n'메모의 가로 크기 넣을 변수\nOn Error Resume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel = Application.\nInputBox\n(\"마우스로 영역을 설정하시오!\", Type:=8)\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nintW =\n100\n'메모창의 가로 크기\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 종료\nElse\n'폴더 선택시\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName =\nDir\n(strPath & \"*.jpg*\")\n'각 파일 경로를 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nFor Each\nrngC\nIn\nrngSel\n'선택영역 각 셀을 순환\nIf rngC.Value & \".jpg\" = fileName Then\nWith rngC\n'각 셀에서\nOn Error\nResume Next\n'(빈셀 또는 이름 달라) 다음코드 진행\nstrMemo = .Comment.Text\n'기존 메모를 변수에 넣음\nOn Error\nGoTo 0\n'에러 발생 시 에러 검출기능 초기화\nIf\nLen\n(strMemo) = 0 Then strMemo = \"\"\n'메모가 없을 경우 공백삽입\n.ClearComments\n'기존 메모 삭제(삭제 시 기존 메모 있으면 에러)\n.\nAddComment\n(strMemo)\n'기존 메모 복원\n.Comment.Shape.Fill.UserPicture (strPath & fileName)\n'메모에 그림을 넣음\nActiveSheet.\nPictures.Insert\n(strPath & fileName).Select\n'각 그림을 열기\npicW = Selection.Width\n'열린 그림의 가로 크기를 변수에\npicH = Selection.Height\n'열린 그림의 세로 크기를 변수에\nSelection.Delete\n'열린 그림 삭제\n.Comment.Shape.LockAspectRatio = msoFalse\n'그림 좌우비율 고정 해제\n.Comment.Shape.Width = intW\n'그림의 폭\n.Comment.Shape.Height = (picH * intW) / picW\n'그림의 높이\n.Comment.Shape.LockAspectRatio = msoTrue\n'그림 좌우비율 고정\nEnd With\nEnd If\nstrMemo = \"\"\n'재사용 위하여 초기화\nNext\nrngC\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한반복\nMsgBox \"매크로가 종료되었습니다.\"\nEnd Sub", "context": "선택한 영역의 파일 이름과 경로내의 그림 이름이 일치 시 각 셀의 메모에 그림을 삽입하는 기능. 기존 메모 및 그림의 가로/세로 비율은 그대로 유지된다.\n기존 \"(1357) 메모창에 그림 삽입하기 1 (\nhttp://rosa0189.blog.me/60204696281\n)\" 및 \"(1359) 메모창에 그림 삽입하기 2 (\nhttp://rosa0189.blog.me/60204703974\n)\"  그리고 (1360) 메모창에 그림 삽입하기 3 (\nhttp://rosa0189.blog.me/60204706201\n)는 그림파일의 가로/세로 비율을 무시한 채 코드에서 지정한 크기 (200 x 150) 으로 메모창에 그림을 삽입하였다. 아래의 코드는\n그림의 가로/세로 비율을 그대로 유지\n하면서 그림을 삽입한다.\n표시되는 그림 크기는 아래 코드내의\nintW =\n100\n를 자신이 원하는 크기로 변경하면 된다. 그림의 비율이 고정되어 있으므로 그림의 가로 크기만 지정하면 된다.\n0초\n0초\n100%\n광고..."}
{"instruction": "Excel VBA code for: (1366) 두 열에서 일치하는 날짜 찾아 나열하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Matching_Date()\nDim varLeft\n'왼쪽 Date 영역 넣을 배열변수\nDim varRight\n'오른쪽 Date 영역 넣을 배열변수\nDim i As Long\n'왼쪽 Date 반복구문에 사용할 변수\nDim j As Long\n'오른쪽 Date 반복구문에 사용할 변수\nDim r As Long\n'동적배열 늘려갈 변수\nDim varR()\n'동적배열로 사용할 배열변수\nDim y As Long\n'열 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 일시 정지\nSheets(2).UsedRange.ClearContents\n'Sheet2 의 기존 데이터 삭제\nIf ActiveSheet.\nUsedRange\n.Rows.Count < 3 Then\n'데이터가 없을 경우\nMsgBox \"이동할 데이터가 없습니다.\"\n'메시지 출력\nExit Sub\n'메크로 종료\nEnd If\nvarLeft = Range(\"A1\").CurrentRegion\n'A~D열을 배열에\nvarRight = Range(\"F1\").CurrentRegion\n'F~J열을 배열에\nFor i = 1 To\nUBound\n(varLeft, 1)\n'varLeft 배열 상한값 만큼 반복\nFor j = 1 To UBound(varRight, 1)\n'varRight 배열 상한값 만큼 반복\nIf varLeft(i, 1) = varRight(j, 1) Then\n'날짜가 일치하면\nr = r + 1\n'배열 개수 1씩 늘려감\nReDim Preserve\nvarR(1 To 9, 1 To r)\n'배열크기 기존값 유지하며 재지정\nFor y = 1 To 4\n'왼쪽 Date 열 개수만큼 반복\nvarR(y, r) = varLeft(i, y)\n'배열에 값을 넣음\nNext y\nFor y = 1 To 5\n'오른쪽 Date 열 개수만큼 반복\nvarR(y + 4, r) = varRight(j, y)\n'배열에 값을 넣음\nNext y\nExit\nFor\n'For (j) 구문 빠져나감.\nEnd If\nNext j\nNext i\nWith Sheets(\"Sheet2\")\n'Sheet2 에서\n.Cells(1, 1).Resize(UBound(varR, 2), 9) = _\nApplication.\nTranspose\n(varR)\n'행/열 변환하여 배열값 셀에 뿌림\n.Columns.AutoFit\n'열너비 자동맞춤\n.Columns(\"A\").SpecialCells(2).Interior.ColorIndex = 15\n'A열에 색채우기\n.Columns(\"E\").SpecialCells(2).Interior.ColorIndex = 37\n'E열에 색채우기\n.\nActivate\n'활성화\n.UsedRange.\nSort\n[A1], 1, Header:=True\n'오름차순으로 정렬\nEnd With\nEnd Sub", "context": "매크로 실행 전 (A 열과 F 열에 날짜들이 있음. 일치하는 날짜들을 찾아 아래처럼 나열하는 기능. Sheet2는 비어 있는 상태)\n매크로 실행 후 Sheet 2의 결과\nSub find_Matching_Date()\nDim varLeft\n'왼쪽 Date 영역 넣을 배열변수\nDim varRight\n'오른쪽 Date 영역 넣을 배열변수\nDim i As Long\n'왼쪽 Date 반복구문에 사용할 변수\nDim j As Long\n'오른쪽 Date 반복구문에 사용할 변수\nDim r As Long\n'동적배열 늘려갈 변수\nDim varR()\n'동적배열로 사용할 배열변수\nDim y As Long\n'열 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 일시 정지\nSheets(2).UsedRange.ClearContents\n'Sheet2 의 기존 데이터 삭제\nIf ActiveSheet.\nUsedRange\n.Rows.Count < 3 Then\n'데이터가 없을 경우\n..."}
{"instruction": "Excel VBA code for: (1367) 상대좌표 이용한 자동매크로 기록 활용 8 (엑셀 VBA 매크로)", "input": "", "output": "Sub Macro1()\nDim i As Long\nFor i = 1 to\n데이터행의 개수(숫자)\n매크로가 자동 저장한 코드\nNext i\nEnd Sub", "context": "왕 초보님들을 위한 자동매크로 기록을 오랫만에 한 번 해본다. 매크로란게 별거 아니다. 저렇게 자동 저장한 내용에 If 구문, For 구문, For Each 구문, Do Loo 구문, Select 구문 등을 이용하여 반복하게 만드는 것이다. 모르는 코드의 대부분은 매크로 자동 저장으로 알아낼 수 있다. 그래도 모르면 검색하면 98% 나온다. 좀 짜게 말해서 2%만 노하우다.\n2행을 삽입\nA열과 B열에 있는 두 행은 셀병합\nE:F 열과 G:H 열의 데이터를 복사하여 C:D 열의 아래에 복사하여 1행을 3행 데이터로 만듬.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1367) 상대좌표 이용한 자동매크로 기록 활용 8 (엑셀 VBA 매크로)\n재생\n1,960\n공유하기\n재생 (space/k)\n재생\n01:54\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:54\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n..."}
{"instruction": "Excel VBA code for: (1369) 시트내 데이터를 폴더(하위폴더 포함)내 각 파일로 내보내기 (엑셀 VBA 매크로)", "input": "", "output": "Sub loop_Through_All_Folders2()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n'--------------------------------------------------------------\n' 2행 A2:B2 공백일 경우 데이터 없는 것으로 판단 매크로 종료\n'--------------------------------------------------------------\nIf Range(\"A2\") =\nvbNullString\nOr Range(\"B2\") = vbNullString Then\nMsgBox \"업데이트할 데이터가 없습니다.\", 64, \"데이터 입력오류\"\nExit Sub\n'A2:A3 영역에 데이터 없으면 중단\nEnd If\n'--------------------\n' 폴더 선택창 출력\n'--------------------\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\neachFolder strPath\n'eachFolder 코드를 호출\nEnd Sub\n\nPrivate Function eachFolder\n(mainFolder As String)\nDim fSO As Scripting.\nFileSystemObject\n'파일 시스템을 넣을 변수\nDim fldName As\nScripting.Folder\n'상위폴더 넣을 변수\nDim subFolder As Scripting.Folder\n'하위폴더 넣을 변수\nDim rngT As Range\n'복사될 위치 넣을 변수\nDim wkBk As Workbook\n'각 파일을 넣을 변수\nDim fileName As Object\n'각 파일 경로를 넣을 변수\nDim strFolder As String\n'폴더 경로에서 제일 마지막 폴더를 넣을 변수\nDim fName As String\n'fileName에서 확장자 제거한 파일이름\nDim rngAll As Range\n'O:P 열을넣을 변수\nDim rngC As Range\n'rngAll의 각 셀을 넣을 변수\nDim var()\n'동적배열로 사용할 변수\nDim r As Long\n'배열 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nSet fSO =\nNew\nScripting.FileSystemObject\n'새로운 파일시스템개체를 변수에\nSet fldName = fSO.\nGetFolder\n(mainFolder)\n'선택한 폴더의 이름을 변수에 넣음\n'---------------------------------------\n'파일명과 폴더명을 추출해내는 코드\n'---------------------------------------\nstrFolder =\nMid\n(fldName,\nInStrRev\n(fldName, \"\\\") + 1, _\nLen\n(fldName) - InStrRev(fldName, \"\\\") + 1)\n'전체 폴더 경로에서 마지막 폴더만 추출\nFor Each\nfileName\nIn\nfldName.Files\n'폴더내 각 파일을 순환\nIf\nInStr\n(fileName, \".xlsx\") Then\n'파일이 엑셀 파일이면\nfName = Left(fileName.Name, Len(fileName.Name) - _\n(Len(fileName.Name) - InStrRev(fileName.Name, \".\")) - 1)\n'확장자 포함한 파일이름에서 파일이름만 추출\nSet rngAll = Range(\"O2\", Cells(Rows.Count, \"O\").End(3))\n'O:P열의 데이터 영역을 변수에 넣음\n'---------------------------------------------\n'조건에 맞는 데이터를 동적배열에 넣는 코드\n'---------------------------------------------\nFor Each rngC In rngAll\n'전체 영역 각 셀을 순환\nIf rngC = fName And _\nrngC.Next = strFolder Then\n'O열(파일이름)과 P열(폴더)이 일치 시\nr = r + 1\n'배열크기 늘려감\nReDim Preserve\nvar(1 To 14, 1 To r)\n'배열 크기 재지정\nFor i = 1 To 14\n'14개의 열만큼 반복\nvar(i, r) = Cells(rngC.Row, i)\n'배열에 각 값을 넣음\nNext i\nEnd If\nNext rngC\n'---------------------------------------------------------\n' 각 파일에 배열내의 데이터를 뿌리고 중복 제거하는 코드\n'---------------------------------------------------------\nSet\nwkBk = Workbooks.\nOpen\n(fileName)\n'파일을 열고 변수에 넣음\nwkBk.Sheets(1).Activate\n'1번 시트인 데이터 시트 활성화\nIf r > 0 Then\nCells(Rows.Count, 1).End(3)(2).Resize(\nUBound\n(var, 2), 14) = _\nApplication.\nTranspose\n(var)\n'배열값 각 파일의 첫 시트에 뿌림\nActiveSheet.UsedRange.\nRemoveDuplicates\n_\nArray(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14), xlYes\n'중복제거\n'1~14열 모두 같아야 중복으로 처리함\nwkBk.Save\n'열린 파일 저장\nEnd If\nr = 0\n'재사용 위하여 초기화\nErase\nvar\n'재사용 위하여 배열 초기화\nwkBk.\nClose\nFalse\n'열린 파일 저장 없이 닫음\nEnd If\nNext\nfileName\n'-----------------------------\n' 재귀 호출로 하위 폴더 순환\n'-----------------------------\nFor Each subFolder In fldName.SubFolders\n'각 폴더의 하위폴더를 순환\neachFolder subFolder.Path\n'각 폴더경로로 eachFolder함수호출\nNext subFolder\nSet fSO = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet fldName = Nothing\nSet rngT = Nothing\nSet wkBk = Nothing\nSet rngAll = Nothing\nEnd Function", "context": "O열의 시트이름과 P열의 폴더이름이 일치 시 폴더내의 시트로 내보내는 기능\n폴더는 선택한 폴더의\n하위 폴더를 포함\n폴더내의 각 시트에는 중복 데이터가 없어야 함. 즉, 매크로 버튼을 실수로 2번을 클릭하여도 데이터 시트에는 중복 데이터가 발생하지 않아야 함.\n주의\n할 것은, 동일한 파일이름은 사용하여도 되지만, 동일한 폴더 이름은 사용하지 않아야 함. 또는 동일한 이름의 폴더가 여러개일 경우 파일명은 모두 달라야 함.\n매크로 실행 전 엑셀창에서 Alt + F11 클릭하고 매크로 창으로 들어간 뒤 윗 그림과 같이\nMicrosoft Scripting Runtime\n이 활성화된 것을 확인.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1369) 시트내 데이터를 폴더(하위폴더 포함)내 각 파일로 내보내기 (엑셀 VBA 매크로)\n재생\n1,670\n재생 (space/k)\n재생\n01:07\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n0..."}
{"instruction": "Excel VBA code for: (1370) 행 데이터를 5열씩 끊어서 이동하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub transpose_In_5_Columns_1()\nDim r As Long\n'행 늘려갈 변수\nDim c As Integer\n'열 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nRows(\"1:2\").Copy Sheets(2).Cells(1, 1)\n'제목행 Sheet2에 복사\nr = 3\n'3행부터 시작\nc = 0\n'0 부터 시작\nWith Sheets(2)\n'Sheet 2에서\n.UsedRange.Offset(2).\nClearContents\n'기존 데이터 삭제\nDo Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지\nDo\n'실행\nIf c = 0 Then\n'c가 0이면\n.Cells(Rows.Count, 4).\nEnd(3)(2, -2)\n.Resize(, 3) = _\nCells(r, 1).\nResize\n(, 3).Value\n'A열부터 이름/성명/사번 복사\nElse\n'c가 0이 아니면\n.Cells(Rows.Count, 4).End(3)(2).Resize(, 5) = _\nCells(r, c - 1).Resize(, 5).Value\n'D열부터 출석자 5열씩 복사\nEnd If\nc = c + 5\n'열 5씩 늘려감\nLoop Until\nCells(r, c - 1) = \"\"\n'행1, 열 5씩 더하며 빈셀까지 무한\nr = r + 1\n'행 1씩 늘려감\nc = 0\n'재사용 위하여 c값 초기화\nLoop\n'무한 반복\n.Columns.\nAutoFit\n'열너비 자동 맞춤\n.Activate\n'활성화\nEnd With\nEnd Sub", "context": "가로로 길게 늘어진 데이터를 세로로 아래와 같이 5열씩 끊어서 이동하는 기능. 아래 데이터는 Z열에서 끝났지만 실제로는 오른쪽으로 데이터의 길이는 제한이 없음. 배열에 넣어 뿌리는 것이 제일 빠르지만 초보님들에게는 더 어려우므로 우선은 배열을 사용하지 않고 옮기는 것을 해봄. 아래와 같이 데이터가 행 또는 열 방향으로 정해진 크기가 없을 때에는\nDo ... Loop\n문을 사용하는 것이 정답니다.\n매크로 실행 전 (Sheet 2는 비어 있는 상태)\n매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub transpose_In_5_Columns_1()\nDim r As Long\n'행 늘려갈 변수\nDim c As Integer\n'열 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nRows(\"1:2\").Copy Sheets(2).Cells(1, 1)\n'제목행 Sheet2에 복사\nr = 3\n'3행부터 시작\nc = 0\n'..."}
{"instruction": "Excel VBA code for: (1372) 중첩 For Each 와 중첩 For 구문의 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub array_With_\nFor_Each\n()                                  Sub array_\nWith_For\n()\nDim i As Long                                                     Dim i As Long\nDim varA                                                            Dim varA\nDim varB                                                            Dim varB\nDim\na\nDim\nb\nDim cnt As Long                                                 Dim cnt As Long\nDim j As Long                                                    Dim j As Long\nFor i = 1 To 5000                                                 For i = 1 To 5000\nCells(i, 1) = i                                                     Cells(i, 1) = i\nNext i                                                                Next i\nvarA = Range(\"A1:A5000\")                                   varA = Range(\"A1:A5000\")\nvarB = varA                                                       varB = varA\nFor Each\na\nIn\nvarA\nFor\ni = 1 To 5000\nFor Each\nb\nIn\nvarB\nFor\nj = 1 To 5000\nIf a = b Then                                                     If varA(i, 1) = varB(j, 1) Then\ncnt = cnt + 1                                                     cnt = cnt + 1\nEnd If                                                              End If\nNext\nb\nNext\nj\nj = j + 1\nCells(j, 2) = cnt                                                Cells(i, 2) = cnt\ncnt = 0                                                             cnt = 0\nNext\na\nNext\ni\nEnd Sub", "context": "아래의 두 코드는 A:A5000 까지 1 ~ 5000 까지 순차적으로 채우고 이를 배열 varA에 넣고, varA를 varB에 복사한 뒤 양쪽의 중복개수를 B열에 구하는 동일한 기능을 하는 코드이다(복사한 뒤 비교하므로 당연히 중복 개수는 모두 1개). 여러 책에서 For 반복구문 보다는 For Each 구문이 더 빠르다고 하였는데 아직까지 별로 실감을 못하였다. 하지만, 아래의 코드에서는 확실히 차이가 난다.\nCells 속성을 사용하여 작업 시 행과 열의 구분이 간편한 For 구문(오른쪽 코드)의 사용이 더 편리하겠지만, 단지 중복 횟수나 비교 등의 목적이라면 For Each(왼쪽 코드)를 사용하는 것이 훨 유리하겠다. 생각보다 큰 속도차이가 난다.\n행방향으로 A1:GJH1 까지 넣고 비교하나, A1:A5000 까지 열로 넣고 비교하나 비슷한 시간이 소요됨.\n반복횟수\nFor Each\n구문 사용한 코드\nFor 구문\n사용한 코드\n5,000행 x 5,000회\n1.45초\n3.65\n초\nSu..."}
{"instruction": "Excel VBA code for: (1373) 두 열에서 일치하는 날짜 찾아 나열하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Matching_Date_1()\nDim vL As\nVariant\n'A열 데이터 넣을 변수\nDim vR As\nVariant\n'F열 데이터 넣을 변수\nDim varLeft As\nVariant\n'왼쪽 Date 영역(A:D열) 넣을 배열변수\nDim varRight As\nVariant\n'오른쪽 Date 영역(F:J열) 넣을 배열변수\nDim i As Long\n'왼쪽 Date 반복구문에 사용할 변수\nDim j As Long\n'오른쪽 Date 반복구문에 사용할 변수\nDim r As Long\n'동적배열 늘려갈 변수\nDim\nvarOut()\n'동적배열로 사용할 배열변수\nDim y As Long\n'열 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 일시 정지\nSheets(2).UsedRange.ClearContents\n'Sheet2 의 기존 데이터 삭제\nIf ActiveSheet.UsedRange.Rows.Count < 3 Then\n'데이터가 없을 경우\nMsgBox \"이동할 데이터가 없습니다.\"\n'메시지 출력\nExit Sub\n'메크로 종료\nEnd If\nvarL = Columns(\"A\").SpecialCells(2)\n'A열을 배열에 넣음\nvarR = Columns(\"F\").SpecialCells(2)\n'F열을 배열에 넣음\nvarLeft = Range(\"A1\").CurrentRegion\n'A~D열을 배열에\nvarRight = Range(\"F1\").CurrentRegion\n'F~J열을 배열에\nFor Each\nvL In varL\n'A열 각 셀을 순환\ni = i + 1\n'A열 행을 늘려감\nFor Each\nvR In varR\n'F열 각 셀을 순환\nj = j + 1\n'F열 행을 늘려감\nIf vL = vR Then\n'날짜가 일치하면\nr = r + 1\n'동적배열 개수 1씩 늘려감\nReDim Preserve\nvarOut(1 To 9, 1 To r)\n'동적배열크기 재지정\nFor y = 1 To 4\n'왼쪽 Date 열 개수만큼 반복\nvarOut(y, r) = varLeft(i, y)\n'결과배열에 왼쪽 date영역 값을 넣음\nNext y\nFor y = 1 To 5\n'오른쪽 Date 열 개수만큼 반복\nvarOut(y + 4, r) = varRight(j, y)\n'결과배열에 오른쪽 date영역 값을 넣음\nNext y\nExit\nFor\n'For each(varR) 구문 빠져나감.\nEnd If\nNext\nvR\nj = 0\nNext\nvL\nWith Sheets(\"Sheet2\")\n'Sheet2 에서\n.Cells(1, 1).Resize(UBound(varOut, 2), 9) = _\nWorksheetFunction.Transpose\n(varOut)\n'행열 변환하여 배열값 셀에 뿌림\n.Columns.AutoFit\n'열너비 자동맞춤\n.Columns(\"A\").SpecialCells(2).Interior.ColorIndex = 15\n'A열에 색채우기\n.Columns(\"E\").SpecialCells(2).Interior.ColorIndex = 37\n'E열에 색채우기\n.Activate\n'활성화\n.UsedRange.\nSort\n[A1], 1, Header:=True\n'오름차순으로 정렬\nEnd With\nEnd Sub", "context": "앞서 중첩 For Each와 중첩 For 구문의 속도비교를 하다가 불현듯 머리를 스치는 생각이 있었다. 이를 잘 활용하면 두 데이터를 비교하여 중첩된 데이터를 추출하거나, 중복을 삭제하거나 등의 여러 작업을 기존코드보다 훨씬 바르게 할 수 있겠다 싶었는데 아래의 코드로 해보니 내가 지금까지 해오던 방식보다 엄청나게 빠르다. 참고로 첨부 데이터는\n왼쪽 10,000행, 오른쪽 10,000 행의 데이터를 서로 비교하는 것으로 결과도출에 내 컴퓨터로 딱 3초가 소요\n되었다.\n여러개의 배열을 사용하여 구조는 꽤 복잡하지만, 아래 코드진행 방식을 이해하고 자신의 데이터에 적용하면 상당한 속도개선 효과를 보실것으로 확신한다.\n매크로 실행 전 (A 열과 F 열에 날짜들이 있음. 일치하는 날짜들을 찾아 아래처럼 나열하는 기능. Sheet2는 비어 있는 상태\n매크로 실행 후 Sheet 2의 결과\nSub find_Matching_Date_1()\nDim vL As\nVariant\n'A열 데이터 넣을 변수\n..."}
{"instruction": "Excel VBA code for: (1374) Old 와 New 두 시트의 유일한 데이터, 중복데이터 및 중복 없는 통합데이터 추출 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Duplicated_Data2()\nDim varCol As Variant\n'중복삭제 열 개수 array 넣을 배열변수\nDim v As Integer\n'중복삭제 array 반복할 변수\nDim s As Integer\n'시트(s)heet 개수 늘려갈 변수\nDim vO As Variant\n'varO 내 각 값을 넣을 배열변수\nDim vN As Variant\n'varN 내 각 값을 넣을 배열변수\nDim varO As Variant\n'Old 시트내 A열 넣을 배열변수\nDim varN As Variant\n'New 시트내 A열 넣을 변수\nDim varOld As Variant\n'Old 시트 전체자료 넣기위한 배열변수\nDim varNew As Variant\n'New 시트 전체자료 넣기 위한 배열변수\nDim r As Integer\n'동적배열 크기 늘려갈 변수\nDim varBoth()\n'양쪽(B)oth에 중복된 자료 넣을 동적배열\nDim colsCnt As Integer\n'전체 열 개수 넣기 위한 변수\nDim i As Long\n'Old 배열내 행을 늘려나갈 변수\nDim j As Long\n'New 배열내 행을 늘려갈 변수\nDim cnt As Integer\n'카운터로 사용할 변수\nDim x As Integer\n'열 개수 늘려갈 변수\nIf\nWorksheetFunction.CountA\n(Range(\"A2:A3\")) < 2 Or _\nWorksheetFunction.CountA(Sheets(2).Range(\"A2:A3\")) < 2 Then\n'1번 또는 2번시트 A2:A3셀이 빈 경우\nMsgBox \"작업할 데이터가 부족합니다.\", 64, \"데이터 입력 오류\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n.Calculation =\nxlCalculationManual\n'셀계산 수동으로 전환\nEnd With\nWorksheets.\nFillAcrossSheets\nRange(\"1:1\")\n'전체 시트에 제목행 복사\nFor s = 3 To 6\n'3 ~ 6번 시트에서 반복\nSheets(s).UsedRange.Offset(1).\nClear\n'기존 데이터 삭제\nNext s\n'---------------------------------------------------\n'열 개수 추출하고 Old / New 시트의 중복을 제거\n'---------------------------------------------------\ncolsCnt = Sheets(1).UsedRange.Columns.Count\n'전체 열 개수를 변수에 넣음\nReDim\nvarCol(0 To colsCnt - 1)\n'배열크기 재지정\nFor v = 0 To colsCnt - 1\n'전체 열 개수만큼 반복\nvarCol(v) = v + 1\n'배열에 열 개수를 넣음\nNext v\nFor s = 1 To 2\n'Old와 New 시트의 중복 제거\nSheets(s).UsedRange.\nRemoveDuplicates\n_\nColumns:=\n(varCol),\nHeader:=xlYes\n'전체열 모두 일치 시 중복제거\nNext s\n'-------------------------------------------------------\n'각 배열에 제목 제외한 Old / New 시트의 데이터를 넣음\n'-------------------------------------------------------\nWith Sheets(1)\n'1번 시트 사용영역에서\nvarO = Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'제목 제외한 A열을 배열에 넣음\nvarOld = .UsedRange.Offset(1).\nResize\n(.UsedRange.Rows.Count - 1)\nEnd With\n'제목빼고 배열에 넣음\nWith Sheets(2)\n'2번 시트\nvarN = Range(.Range(\"A2\"), .Cells(Rows.Count, \"A\").End(3))\n'A열을 배열에 넣음\nvarNew = .UsedRange.Offset(1).Resize(.UsedRange.Rows.Count - 1)\nEnd With\n'제목빼고 배열에 넣음\n'-----------------------------------------------------\n' 먼저 \"이름\"이 일치하는지 검색 후 나머지 열들을 검사\n'-----------------------------------------------------\nFor Each vO In varO\n'Old A열 각 셀을 순환\ni = i + 1\n'Old A열 행을 늘려감\nFor Each vN In varN\n'New A열 각 셀을 순환\nj = j + 1\n'New A열 행을 늘려감\nIf vO = vN Then\n'이름이 일치하면\nFor x = 2 To colsCnt\n'2 ~ 마지막 열까지 반복\nIf varOld(i, x) = varNew(j, x) Then\n'값이 같다면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nElse: cnt = 0\n'카운터 값을 초기화\nExit\nFor\n'값이 다르면 for 구문 종료\nEnd If\nNext x\n'-----------------------------------------------------------\n' 중복 데이터를 varBoth에 넣고 varOld / varNew에서는 삭제\n'-----------------------------------------------------------\nIf cnt = colsCnt - 1 Then\n'2 ~ 마지막 열까지 같다면\ncnt = 0\n'재사용 위하여 초기화\nr = r + 1\n'동적배열 개수 1씩 늘려감\nReDim Preserve\nvarBoth(1 To colsCnt, 1 To r)\n'동적배열크기 재지정\nFor x = 1 To colsCnt\n'전체 열 개수만큼 반복\nvarBoth(x, r) = varOld(i, x)\n'중복데이터를 varBoth에 넣음\nvarOld(i, x) =\nEmpty\n'varOld 내의 중복데이터 삭제\nvarNew(j, x) = Empty\n'varNew 내의 중복데이터 삭제\nNext x\nEnd If\nEnd If\nNext vN\nj = 0\n'재사용 위하여 초기화\nNext vO\n'----------------------------------------------------\n' 각 배열에 넣은 값들을 해당 시트에 뿌려주는 코드\n'----------------------------------------------------\nSheets(3).Cells(2, 1).Resize(\nUBound\n(varOld, 1), colsCnt) = varOld\n'varOld 배열값을 OldOnly에 뿌림\nIf r > 0 Then\n'배열이 비어 있지 않으면\nSheets(4).Cells(2, 1).Resize(UBound(varBoth, 2), colsCnt) = _\nWorksheetFunction.Transpose\n(varBoth)\n'varBoth 배열값을 Both에 뿌림\nEnd If\nSheets(5).Cells(2, 1).Resize(UBound(varNew, 1), colsCnt) = varNew\n'varNew 배열값을 NewOnly에 뿌림\n'-------------------------------------------------------------\n' varOld, varNew, varBoth 배열에 추출한 값을 All 시트에 통합\n'-------------------------------------------------------------\nWith Sheets(6).Cells(Rows.Count, \"A\")\n.End(3)(2).Resize(UBound(varOld, 1), colsCnt) = varOld\n'varOld 배열값을 All에 뿌림\nIf r > 0 Then\n'배열이 비어 있지 않으면\n.End(3)(2).Resize(UBound(varBoth, 2), colsCnt) = _\nWorksheetFunction.Transpose(varBoth)\n'varBoth 배열값을 All에 뿌림\nEnd If\n.End(3)(2).Resize(UBound(varNew, 1), colsCnt) = varNew\n'varNew 배열값을 All에 뿌림\nEnd With\nFor s = 3 To 6\n'3 ~ 6번 시트에서 반복\nWith Sheets(s)\n'각 시트에서\n.Columns(\"E\").\nNumberFormat\n= \"yyyy-mm-dd\"\n'E열의 서식을 날짜로 설정\n.UsedRange.Sort .[A1], 1, Header:=True\n'각 시트를 이름순으로 오름차순 정렬\n.Columns.AutoFit\n'열너비 자동 맞춤\nEnd With\nNext s\nWith Application\n.Calculation =\nxlCalculationAutomatic\n'셀계산 자동으로 돌려놓음\n.ScreenUpdating = True\n'화면업데이트 재 실행\nEnd With\nMsgBox \"데이터 추출이 완료되었습니다.\"\n'완료 메시지 출력\nEnd Sub", "context": "'제목에서 보는 것처럼 앞서 이와 같은 코드를 2번 해보았으며 이번이 3번째이다.\n기존에 Old에 1만행, New에 1만행\n을 넣고 돌렸을 때\n47초 정도 소요\n되던 코드인데\n아래의 코드로는\n6 ~ 12초 정도 소요\n된다. 상당한 발전이다. 소요시간은 데이터의 위치, 열의 개수, 엑셀버전, 엑셀 32 비트/64 비트, 자신의 컴퓨터 속도 등에 따라 큰 차이가 날 수 있다.\n'Old 시트와 New 시트에 여러 데이터가 있음. Old에만 있는 데이터, 양쪽에 중복되어 있는 데이터, New 시트에만 있는 데이터, Old와 New 시트를 합친 중복없는 데이터를 추출하는 기능. 최소 2행 이상의 데이터가 있어야 하며, 데이터의 열 개수 제한이 없지만 All 시트의 통합데이터가 65536행을 넘어가면 에러발생함. 데이터가 65536보다 클 경우 동적배열이 아닌 정적배열로 수정하면 됨.\n본인의 파일에 아래의 코드를 복사하여 쓸 수도 있지만, 간단히 여기에 첨부된 파일을 다운받고 자신의 데이터를 ..."}
{"instruction": "Excel VBA code for: (1376) 콤마(,)로 구분된 데이터의 특정구간 추출 및 가공 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Japanese()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim varTemp\n'A열 전체를 넣을 변수\nDim varR()\n'결과 배열 넣을 변수\nDim x\n'A열 및 Hex값 넣을 배열변수\nDim strC As String\n'(문자분리 후)3번째 열만 넣을 변수\nDim r As Long\n'동적배열 크기 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n'------------------------------\n'폴더 선택창을 출력하는 코드\n'------------------------------\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName =\nDir\n(strPath & \"*.txt\")                       '\n(폴더내)각 텍스트파일 이름을 변수에 넣음\nIf fileName = \"\" Then                                      '폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nWorkbooks.\nOpen\n(strPath & fileName)\n'각 파일을 열기\n'--------------------------------------------------\ndelete_Blank_Rows\n'빈행을 삭제해주는 코드 호출\n'--------------------------------------------------\nIf\nWorksheetFunction.CountA\n(\"A\") > 0 Then\n'A열에 데이터가 1개 이상이면\nvarTemp = Columns(\"A\").SpecialCells(2)\n'A열 전체 문자를 배열에 넣음\nElse\nMsgBox \"데이터가 없어서 종료합니다.\", 64, \"데이터 에러\"\nExit Sub\n'매크로 종료\nEnd If\n'---------------------------------------------\n'동적배열에 문자 넣고 시트에 뿌리는 코드\n'---------------------------------------------\nFor Each x In varTemp\n'배열내 각 값을 순환\nstrC =\nTrim\n(\nSplit\n(x, \",\")\n(2)\n)\n'콤마로 분리 후 3번째 그룹만 앞뒤 공백 제거 후 변수에\nr = r + 1\n'배열 값 1씩 늘려감\nReDim Preserve\nvarR(1 To 3, 1 To r)\n'배열크기 재지정\nvarR(1, r) = strC\n'추출한 값을 배열에 순차적으로 넣음\nvarR(3, r) =\nWorksheetFunction.Dec2Hex\n(LenB(strC))\n'Hex값 추출하여 배열의 3열에 넣음\nNext x\nCells(1, 2).Resize(UBound(varR, 2), 3) = _\nWorksheetFunction.Transpose\n(varR)\n'배열내 추출한 내용 B열부터 뿌리기\n'------------------------------\n'불필요한 문자 제거하는 코드\n'------------------------------\nWith Columns(\"B\")\n.\nReplace\n\"{*}\", \"\"\n'{ } 포함 { } 내의 문자 삭제\n.Replace \"#*C\", \"\"\n'#과 C(포함) 사이의 문자 삭제\n.Replace \"#*F\", \"\"\n'#과 F(포함) 사이의 문자 삭제\n.Replace \"#*S\", \"\"\n'#과 S(포함) 사이의 문자 삭제\n.Replace \"#*W\", \"\"\n'#과 W(포함) 사이의 문자 삭제\nEnd With\n'-------------------------------\n' 서식 및 제목 지정하는 코드\n'-------------------------------\nWith Range(Cells(1, 4), Cells(UBound(varR, 2), 1))\n.\nNumberFormatLocal\n= \"0#\"\n'D열을 2자리수로 설정\n.HorizontalAlignment = xlLeft\n'D열 왼쪽 정렬\nEnd With\nRows(\"1:1\").Insert\n'1행 추가\nCells(1, 1).Resize(, 4) =\nArray\n(\"추출\", \"문장\", \"번역문\", \"문장 길이(16진수)\")\n'제목행 입력\nColumns.AutoFit\n'열너비 자동 맞춤\n'----------------------------------------------------------------\n'파일 존재여부 확인 후 동일 이름 없으면 엑셀파일로 저장 후 닫음\n'----------------------------------------------------------------\nstrC = Trim(Split(fileName, \".\")(0))\n'앞뒤 공백 제거하여 텍스트 파일의 파일이름 추출\nOn Error\nResume Next\n'에러 발생해도 다음코드 진행\nIf FileLen(strPath & strC & \".xlsx\") > 0 Then\n'이동될 폴더에 동일파일 존재여부 확인\nIf\nErr <> 0\nThen\n'에러가 난 경우(동일한 파일이 없을 경우)\nActiveWorkbook.SaveAs fileName:=strPath & strC & \".xlsx\", _\nFileFormat:=xlOpenXMLWorkbook\n'텍스트 파일 폴더에 저장\nElse\n'동일한 파일이 존재할 경우\nActiveWorkbook.Close False\n'각 파일을 저장하지 않고 닫음\nMsgBox \"동일한 파일이 존재함 종료함\", 64, \"파일 저장 오류\"\nExit Sub\n'매크로 종료\nEnd If\nActiveWorkbook.Close False\n'각 파일을 저장하지 않고 닫음\nEnd If\nOn Error\nGoTo 0\n'에러 검출 초기화\nr = 0\n'재사용 위하여 초기화\nErase\nvarR\n'재사용 위하여 배열 초기화\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nMsgBox \"매크로 실행이 종료되었습니다.\"\nEnd Sub\n\nSub delete_Blank_Rows()\n'-------------------------------\n'공백행을 모두 제거하는 코드\n'-------------------------------\nDim rngAll As Range\n'전체 사용 영역을 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim v As Long\n'동적배열의 크기 늘려갈 변수\nDim varR()\n'동적배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range([A1], Cells(Rows.Count, \"A\").End(3))\n'A열 전체영역을 변수에 넣음\nFor r = 1 To rngAll.Rows.Count\n'전체 행 개수만큼 반복\nIf Cells(r, 1) <> \"\" Then\n'각 행의 값이 빈셀이 아니라면\nv = v + 1\n'배열크기 1씩 늘려감\nReDim Preserve varR(1 To v)\n'동적배열 크기 재지정\nvarR(v) = Cells(r, 1)\n'값을 배열에 넣음\nEnd If\nNext r\nrngAll.ClearContents\n'기존 데이터 영역의 데이터를 삭제\nCells(1, 1).Resize(UBound(varR, 1)) = _\nWorksheetFunction.Transpose(varR)\n'행/열 변환하여 배열의 값을 셀에 뿌림\nEnd Sub", "context": "네이버 지식인에 올라온 질문이었는데 나름 공부할 것들이 많겠다 싶어서 코드를 만들었더니 잠시 후 삭제되어 버렸다. 이 질문을 요청한 사람이 아래의 코드를 보았으면 상당히 기뻐하였을 것이 확실한데 좀 아쉽다.\n한 폴더안에 다수의 텍스트 파일이 있음.\n각 텍스트 파일의 각 행은 윗 그림과 같이 2 개의 콤마로 구분된 3개의 열로 구성.\n\"추출\", \"문장\", \"번역문\", \"문장 길이(16진수)\" 이란 제목을 A1:D1에 입력\n텍스트파일 각 행을 엑셀의 A열로 가져옴.\n공백행 모두 삭제\n텍스트 파일 3번째의 열(두 번째 콤마 뒷 문자들)을 엑셀의 B열에 분리.\n{ }, #과 F사이 문자삭제, #과 C사이 문자삭제, #과 S사이 문자삭제, #과 W사이 문자삭제\nB열의 문자길이를 16진수로 엑셀 D열에 두 자리수 문자로 표시\n위와 같이 가공한 파일을 텍스트 파일과 동일한 이름으로 텍스트 파일이 있는 폴더에 저장\n동일한 이름의 파일이 폴더내에 있을 경우 경고 표시\n0초\n0초\n100%\n광고 후 계..."}
{"instruction": "Excel VBA code for: (1377) 문자 중 한문만 추출하기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Hanmun4()\nDim rngC As Range\n'선택영역의 각 셀을 넣을 변수\nDim i As Integer\n'셀의 문자길이만큼 반복할 변수\nDim str As String\n'추출한 각 문자 넣을 변수\nDim strU As String\n'문자를 합쳐 넣을 변수\nDim strHanja As String\n'한자만 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nFor i = 1 To Len(rngC)\n'각셀의 문자 길이 만큼 반복\nstr =\nMid\n(rngC, i, 1)\n'셀의 각 문자를 변수에 넣음\nIf str\nLike \"[ㄱ-힣]\n\" Then\n'한글/한문만 추출\nstrU = strU & Mid(rngC, i, 1)\n'추출한 문자를 합쳐감\nEnd If\nNext i\nFor i = 1 To Len(strU)\n'strU의 문자 길이 만큼 반복\nstr = Mid(strU, i, 1)\n'strU의 각 문자를 변수에 넣음\nIf\nNot\nstr\nLike \"[가-힣]\"\nThen\n'각 문자가 한글이 아니라면\nstrHanja = strHanja & Mid(strU, i, 1)\n'추출한 문자를 합쳐감\nEnd If\nNext i\nrngC.Next = strHanja\n'각셀의 오른쪽에 한문을 뿌림\nstrU = \"\"\n'재사용 위하여 초기화\nstrHanja = \"\"\n'재사용 위하여 초기화\nNext rngC\nColumns(\"B\").AutoFit\n'B열 열너비 자동맞춤\nEnd Sub", "context": "제목에서 보듯 많은 문자가 섞여 있는 조건하에서 한문(漢文)만 추출하는 것으로 이번이 4번째이다. 지금 이 코드를 올리는 것은 기존의 코드들에 약간의 문제점들이 있어서 조금더 완성된 코드를 올리는 것이다.\n문자 추출은 쉬울 수도, 어려울 수도 있다. Unicode가 나오기전 1문자를 1바이트로 표현하는 ASCII 코드는 겨우 256문자 였으므로 문자의 추출은 식은죽 먹기였다. 하지만 한국/중국/일본 때문에 생겨난 Unicode는 1문자를 2바이트로 표현하며 문자의 개수도 많아 원하는 문자만 추출하는 것이 가끔 어려울 때가 있다. 그 한 예가 한문(漢文)만 추출하는 경우이다. 나의 기존 코드는 물론 다른 사람들의 코드도 몇 개 보았지만 모두 문제가 있었다. 외국사람들은 Unicode를 잘 쓰지 않아서 이런 내용은 구글을 검색하여도 비슷한 코드조차 나오지 않는다.\n아래 코드는\n한글/\n한문만을 한 번에 추출한 후 한글을 제외하는 단순한 방법을 사용함.\n아래 예제 그림에서 보듯 내가 가지고..."}
{"instruction": "Excel VBA code for: (1380) 부분검색 일치시 모든 행 가져오기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub multiple_Search1()\nDim wks As Worksheet\n'각 시트 넣을 변수\nDim i As Integer\n'2번 반복할 변수\nDim fileName As String\n'선택한 파일들을 넣을 변수\nDim wkb As Workbook\n'workbook을 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim varCol As Variant\n'중복제거 column으로 사용할 배열변수\nDim v As Integer\n'반복구문에 사용할 변수\nDim rng1 As Range\n'1.xlsx 파일 A열 넣을 변수\nDim rng2 As Range\n'2.xlsx 파일 A열 넣을 변수\nDim C As Range\n'찾은 셀을 넣을 변수\nDim strAddr As String\n'처음 찾은 셀의 주소 넣을 변수\nDim rngC As Range\n'1.xlsx A열 각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.ClearContents\n'기존 데이터 삭제\n'----------------------------------------------------\n'경고 없이 Main 시트 남기고 다른 모든 시트 삭제\n'----------------------------------------------------\nApplication.DisplayAlerts = False\n'엑셀 화면 경고표시 중단\nFor Each wks In ThisWorkbook.Worksheets\n'매크로 파일의 각 시트 순환\nIf wks.Name <> \"Main\" Then\n'파일이름이 Main이 아니면\nwks.Delete\n'파일 삭제\nEnd If\nNext wks\nApplication.DisplayAlerts = True\n'화면 경고표시 복원\nChDir\nThisWorkbook.Path\n'폴더는 매크로파일과 동일한 위치에서 시작\n'------------------------------------\n'파일 선택창을 2번 띄우는 코드\n'------------------------------------\nFor i = 1 To 2\n'2회 반복\nfileName = Application.\nGetOpenFilename\n(\"Excel Files (*.xls*),*.xls\", , _\n\"엑셀 파일을 선택\",\nMultiSelect:=False\n)\n'엑셀 파일을 선택\nIf fileName = \"False\" Then Exit Sub\n'취소 선택 시 매크로 종료\nSet\nwkb = Workbooks.Open(fileName)\n'파일을 열고 개체변수에 넣음\n'-------------------------------------\n' 혹시 모를 중복 데이터 삭제 코드\n'-------------------------------------\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열개수를 변수에\nReDim\nvarCol(0 To colsCnt - 1)\n'배열크기 재지정\nFor v = 0 To colsCnt - 1\n'열 개수만큼 반복\nvarCol(v) = v + 1\n'배열에 숫자 채워감\nNext v\nActiveSheet.UsedRange.\nRemoveDuplicates\n_\nColumns:=(varCol), Header:=xlNo\n'전체열이 같은 경우 중복으로제거\nErase varCol\n'재사용 위하여 배열 초기화\n'-------------------------------------\n' 데이터 시트들을 통합 시트에 복사\n'-------------------------------------\nWith ThisWorkbook\nIf i = 1 Then\n'i가 1일 경우\nSheets(1).\nCopy after\n:=.Sheets(i)\n'2번째 시트추가하면 복사\nwkb.Close\n'1.xlsx 파일 닫음\nElse\n'i가 2일 경우\nSheets(1).Copy after:=.Sheets(i)\n'3번째 시트추가하면 복사\nwkb.Close\n'2.xlsx 파일 닫음\nEnd If\nEnd With\nNext i\nSheets(\"Main\").Activate\n'Main시트 활성화\nSet rng1 = Sheets(2).Columns.SpecialCells(2)\n'두 번째시트의 A열을 변수에\nSet rng2 = Sheets(3).Columns.SpecialCells(2)\n'세 번째 시트의 A열을 변수에\n'---------------------------------------------\n'검색에 일치하는 모든 데이터를 찾아서 추출함\n'---------------------------------------------\nFor Each rngC In rng1\n'두 번째 시트 A열 각 셀을 순환\nSet C = rng2.\nFind\n(What:=rngC, Lookat:=\nxlPart\n)\n'세번째 시트 A열을 검색해서 변수에\nIf\nNot C Is Nothing\nThen\n'일치하는 데이터 있으면\nstrAddr = C.Address\n'찾은 셀의 주소를 변수에 넣음\nDo\n'실행\nSet C = rng2.\nFindNext\n(C)\n'다음 찾은 데이터를 변수에\nCells(Rows.Count, \"A\").End(3)(2).Resize(, 4) = C.Resize(, 4).Value\n'찾은 값을 시트에 뿌림\nLoop While Not C Is Nothing And C.Address <> strAddr\n'검색 일치하지 않거나 처음 찾은 셀이 아닐때까지 무한 반복\nEnd If\nNext rngC\nSet wkb = Nothing\n'개체변수들 초기화\nSet rng1 = Nothing\nSet rng2 = Nothing\nSet C = Nothing\nMsgBox \"매크로가 종료되었습니다.\"\nEnd Sub", "context": "1.xlsx 파일 Sheet1의 A열                                  2.xlsx 파일 Sheet1의 데이터\n1.xlsx A열에는 검색할 단어가 있으며, 2.xlsx 파일에 데이터가 있음.\n1.xlsx 파일의 A열에 있는 검색 단어들을 2.xlsx 파일의 A열에서 검색하고 부분만 일치해도 2.xlsx파일에 있는 모든 행의 데이터를 통합시트로 가져오는 기능\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1380) 부분검색 일치시 모든 행 가져오기 1 (엑셀 VBA 매크로)\n재생\n5,143\n재생 (space/k)\n재생\n00:43\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:43\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기..."}
{"instruction": "Excel VBA code for: (1381) 부분검색 일치시 모든 행 가져오기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub multiple_Search2()\nDim col_1 As String\n'첫 번째 파일 열 이름 넣을 번수\nDim col_2 As String\n'두 번째 파일 열 이름 넣을 번수\nDim fileName As String\n'선택한 파일을 넣을 변수\nDim wkb As Workbook\n'workbook을 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim varCol As Variant\n'중복제거 column으로 사용할 배열변수\nDim v As Integer\n'반복구문에 사용할 변수\nDim var1\n'첫 번째 파일 A열 넣을 배열변수\nDim var2\n'두 번째 파일 A열 넣을 배열변수\nDim varTemp\n'두 번째 파일 모든 데이터영역 넣을 배열변수\nDim varR\n'결과값을 넣을 배열변수\nDim vX\n'var1 배열 각 값을 순환할 배열변수\nDim vY\n'var2 배열 각 값을 순환할 배열변수\nDim r As Long\n'var2의 행 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim x As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nChDir\nThisWorkbook.Path\n'폴더는 매크로파일과 동일한 위치에서 시작\ncol_1 = \"A\"\n'첫 번째 파일 검색할 열\ncol_2 = \"A\"\n'두 번째 파일 검색할 열\nActiveSheet.UsedRange.ClearContents\n'기존 데이터 삭제\n'----------------------------------\n'파일 선택창을 2번 띄우는 코드\n'----------------------------------\nFor i = 1 To 2\n'2회 반복\nfileName = Application.\nGetOpenFilename\n(\"Excel Files (*.xls*),*.xls\", , _\n\"엑셀 파일을 선택\", MultiSelect:=False)\n'엑셀 파일을 선택\nIf fileName = \"False\" Then Exit Sub\n'취소 선택 시 매크로 종료\nSet wkb = Workbooks.Open(fileName)\n'파일을 열고 개체변수에 넣음\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열개수를 변수에\nReDim\nvarCol(0 To colsCnt - 1)\n'배열크기 재지정\nFor v = 0 To colsCnt - 1\n'열 개수만큼 반복\nvarCol(v) = v + 1\n'배열에 숫자 채워감\nNext v\n'---------------------------------\n' 혹시 모를 중복 데이터 삭제 코드\n'---------------------------------\nActiveSheet.UsedRange.\nRemoveDuplicates\n_\nColumns:=(varCol), Header:=xlNo\n'전체열이 같은 경우 중복으로제거\nErase varCol\n'재사용 위하여 배열 초기화\n'---------------------------------\n' 두 시트의 데이터를 배열에 넣음\n'---------------------------------\nIf i = 1 Then\n'i가 1일 경우\nvar1 = Columns(col_1).\nSpecialCells(2)\n'(첫 번째 파일)A열을 배열 var1에 넣음\nElse                                                          'i가 2일 경우\nvar2 = Sheets(1).Columns(col_2).SpecialCells(2)\n'(두 번째 파일)A열을 배열 var1에 넣음\nvarTemp = ActiveSheet.UsedRange\n'(두 번째 파일) 전체 데이터 영역을 변수에\nEnd If\nwkb.\nClose False\n'열은 파일을 저장없이 닫음\nNext i\nReDim varR(1 To\nUBound\n(varTemp, 1) * 5, _\n1 To UBound(varTemp, 2))\n'중복 많을 경우 에러 방지 위해 배열 크기 5배 크게 지정지정\n'---------------------------------------------\n'검색에 일치한 데이터를 배열에 넣는 코드\n'---------------------------------------------\nFor Each\nvX In var1\n'var1 의 각 값을 순환\nFor Each\nvY In var2\n'var2 의 각 값을 순환\nr = r + 1\n'행을 1씩 늘려감\nIf\nInStr\n(vY, vX) Then\n'만일 문자를 포함하고 있다면\nx = x + 1\nFor i = 1 To UBound(varTemp, 2)\n'열 개수만큼 반복\nvarR(x, i) = varTemp(r, i)\n'결과 배열에 임시배열의 값을 옮김\nNext i\nEnd If\nNext\nvY\nr = 0\n'열 반복 재사용 위하여 초기화\nNext\nvX\n'------------------------------------------------------\n' 배열에 일치하는 데이터가 하나라도 있으면 시트에 뿌림\n'------------------------------------------------------\nIf x > 0 Then\n'배열이 비어 있지 않다면\nCells(1, 1).Resize(UBound(varR, 1), UBound(varR, 2)) = varR\n'배열값 시트에 뿌림\nEnd If\nSet wkb = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\n'매크로 종료 메시지 출력\nEnd Sub", "context": "앞서 \"(1381) 부분검색 일치시 모든행 가져오기 1 (\nhttp://rosa0189.blog.me/60205167166\n) 에서는\nFind 속성을 가지고 해보았다. 이번에는 동일한 내용을 몽땅\n배열\n에 넣어서 해본다. 배열이라 속도는 더 빠르지만 부분 검색이므로 중복이 많을 경우 overflow 될 수 있다. (예, 1.xlsx에 \"우리\"와 \"나라\"가 있고, 2.xlsx에 \"우리나라\"가 있는 경우 2번 데이터를 가져오게 된다. 그래서 배열 크기를 넉넉하게 5배 큰 크기로 설정함)\n1.xlsx 파일 Sheet1의 A열                                  2.xlsx 파일 Sheet1의 데이터\n1.xlsx A열에는 검색할 단어가 있으며, 2.xlsx 파일에 데이터가 있음.\n1.xlsx 파일의 A열에 있는 검색 단어들을 2.xlsx 파일의 A열에서 검색하고 부분만 일치해도 2.xlsx파일에 있는 모든 행의 데이터를 통합시트로 가져오는 기능\n0초\n0초\n100%\n광..."}
{"instruction": "Excel VBA code for: (1382) 부분검색 일치시 모든 행 가져오기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub multiple_Search_3()\nDim wks As Worksheet\n'각 시트 넣을 변수\nDim i As Integer\n'2~3까지 반복할 변수\nDim fileName As String\n'선택한 파일들을 넣을 변수\nDim wkb As Workbook\n'workbook을 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim varCol As Variant\n'중복제거 column으로 사용할 배열변수\nDim v As Integer\n'반복구문에 사용할 변수\nDim rngA As Range\n'2번시트 A열 넣을 변수\nDim rngC As Range\n'A열 각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.ClearContents\n'기존 데이터 삭제\n'--------------------------------------------------\n'경고 없이 Main 시트 남기고 다른 모든 시트 삭제\n'--------------------------------------------------\nApplication.\nDisplayAlerts\n= False\n'엑셀 화면 경고표시 중단\nFor Each wks In ThisWorkbook.Worksheets\n'매크로 파일의 각 시트 순환\nIf wks.Name <> \"Main\" Then\n'파일이름이 Main이 아니면\nwks.Delete\n'파일 삭제\nEnd If\nNext wks\nApplication.DisplayAlerts = True\n'화면 경고표시 복원\nChDir\nThisWorkbook.Path\n'폴더는 매크로파일과 동일한 위치에서 시작\n'---------------------------------\n'파일 선택창을 2번 띄우는 코드\n'---------------------------------\nFor i = 1 To 2\n'2회 반복\nfileName = Application.\nGetOpenFilename\n(\"Excel Files (*.xls*),*.xls\", , _\n\"엑셀 파일을 선택\", MultiSelect:=False)\n'엑셀 파일을 선택\nIf fileName = \"False\" Then Exit Sub\n'취소 선택 시 매크로 종료\nSet wkb = Workbooks.Open(fileName)\n'파일을 열고 개체변수에 넣음\n'------------------------------------\n' 혹시 모를 중복 데이터 삭제 코드\n'------------------------------------\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열개수를 변수에\nReDim\nvarCol(0 To colsCnt - 1)\n'배열크기 재지정\nFor v = 0 To colsCnt - 1\n'열 개수만큼 반복\nvarCol(v) = v + 1\n'배열에 숫자 채워감\nNext v\nActiveSheet.UsedRange.\nRemoveDuplicates\n_\nColumns:=(varCol), Header:=xlNo\n'전체열이 같은 경우 중복으로제거\nErase\nvarCol\n'재사용 위하여 배열 초기화\n'-------------------------------------\n' 데이터 시트들을 통합 시트에 복사\n'-------------------------------------\nWith ThisWorkbook\n'이 매크로 실행파일\nIf i = 1 Then\n'i가 1일 경우\nSheets(1).\nCopy after\n:=.Sheets(i)\n'2번째 시트추가하면 복사\nwkb.Close\nFalse\n'1.xlsx 파일 닫음\nElse\n'i가 2일 경우\nSheets(1).Copy after:=.Sheets(i)\n'3번째 시트추가하면 복사\nwkb.Close False\n'2.xlsx 파일 닫음\nEnd If\nEnd With\nNext i\nSheets(\"Main\").Activate\n'Main시트 활성화\n'--------------------------------------------------\n'고급필터는 제목행이 필요하므로 임시 제목행 복사\n'--------------------------------------------------\nFor i = 2 To 3\n'2 ~ 3 까지 반복\nWith Sheets(i)\n'2, 3번째 시트에서\n.Rows(1).Insert\n'2, 3번째 시트에 1행 추가\n.Cells(1, 1).Resize(1, 4) = Array(\"제1\", \"제2\", \"제3\", \"제4\")\nEnd With\n'임시 제목 삽입\nNext i\nWith Sheets(2)\nSet\nrngA = .Range(.[A2], .Cells(Rows.Count, \"A\").End(3)) '고급필터 Criteria 영역\n'-------------------------------------------------------------------------\n'부분 일치하는 데이터 가져오는 조건 만들기 위해 각 검색 조건 앞에 * 추가\n'-------------------------------------------------------------------------\nFor Each rngC In rngA\n'A열 각 셀을 순환\nrngC = \"\n*\n\" & rngC & \"\n*\n\"\n'각 셀 앞뒤에 * 추가\nNext rngC\nEnd With\nSheets(3).UsedRange.\nAdvancedFilter\nAction:=2, _\nCriteriaRange:=Sheets(2).Cells(1, 1).Resize(rngA.Rows.Count + 1), _\nCopyToRange:=[A1], Unique:=0\n'고급필터 이용 데이터 복사 이동\nRows(1).Delete\n'임시 제목행 삭제\nSet wkb = Nothing\n'개체변수(들) 초기화\nSet rngA = Nothing\nMsgBox \"매크로가 종료되었습니다.\"\nEnd Sub", "context": "앞서 \"(1381) 부분검색 일치시 모든행 가져오기 1 (\nhttp://rosa0189.blog.me/60205167166\n) 에서는\nFind 기능을 가지고 해보았으며, (1381) 부분검색 일치시 모든행 가져오기 2 (\nhttp://rosa0189.blog.me/60205167880\n) 에서는 배열에 넣었다. 이번에는 \"\n고급필터\n\" 기능을 이용해서 동일한 기능을 구현해본다. VBA이용하여 고급필터의 조건을 만들기가 조금 까다로워서 그렇지 소요시간을 측적해보지 않아도 이 코드가 가장 빠를 것으로 생각된다. )\n1.xlsx 파일 Sheet1의 A열                                   2.xlsx 파일 Sheet1의 데이터\n1.xlsx A열에는 검색할 단어가 있으며, 2.xlsx 파일에 데이터가 있음.\n1.xlsx 파일의 A열에 있는 검색 단어들을 2.xlsx 파일의 A열에서 검색하고 부분만 일치해도 2.xlsx파일에 있는 모든 행의 데이터를 통합시트로 가져오..."}
{"instruction": "Excel VBA code for: (1384) 일본어만 추출하는 코드 만들기 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Japanese()\nDim rngC As Range\n'선택영역의 각 셀을 넣을 변수\nDim r As Integer\n'셀의 문자길이만큼 반복할 변수\nDim str As String\n'추출한 각 문자 넣을 변수\nDim strU As String\n'문자를 합쳐 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nFor r = 1 To Len(rngC)\n'각셀의 문자 길이 만큼 반복\nstr =\nAsc\n(Mid(rngC, r, 1))\n'셀의 각 문자를 변수에 넣음\nIf str <= -21514 And str >= -21855 Then\n'각 문자가 일본어면 문이면\nstrU = strU & Mid(rngC, r, 1)\n'문자를 합쳐간다\nEnd If\nNext r\nrngC.Next = strU\n'각셀의 오른쪽에 한문을 뿌림\nstrU = \"\"\n'재사용 위하여 초기화\nNext rngC\nEnd Sub", "context": "\"일본어만 추출하는 코드 만들기\"라고 하니까 조금 거창하게 들리지만 알고 보면 정말 뭣도 아니다. 아래 내용을 잘 익혀 두었다가 특별한 문자 그룹을 추출해야 하는 경우 응용해서 사용하시기 바란다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1384) 일본어만 추출하는 코드 만들기 (엑셀 VBA 매크로)\n재생\n662\n재생 (space/k)\n재생\n01:35\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n01:35\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경..."}
{"instruction": "Excel VBA code for: (1386) 다중조건으로 고급필터 적용하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub advanced_Filter_Multiple_Conditions1()\nDim i As Integer\n'반복 코드에 사용할 변수\nDim rngData As Range\n'전체 데이터 영역을 넣을 변수\nDim rngCri As Range\n'필터링 조건 영역을 넣을 변수\nDim rngT As Range\n'필터된 결과 복사될 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nCells(10, 1).CurrentRegion.Offset(1).\nClear\n'기존 데이터 삭제\nWith Sheets(\"필터기준\")\n'필터기준 시트에서\n.Cells(1, 1).CurrentRegion.Copy .Cells(1, Columns.Count).End(1)(1, 3)\n'필터기준 영역을 복사하여 종단셀 이용 오른쪽에 복사\nFor i = 5 To 1 Step -1\n'1씩 줄여가면서 5회 반복\nIf Len(.Cells(2, i)) < 1 Then\n'만일 셀값의 길이가\n1\n보다 작으면\n.Cells(2, i).\nEntireColumn.Delete\n'전체 열을 삭제\nEnd If\nNext i\nSet\nrngCri = .Cells(1, 1).CurrentRegion\n'추출된 필터조건 영역을 변수에 넣음\nEnd With\nWith Sheets(\"원본자료\")\n'원본자료 시트에서\n.Activate\n'활성화\nSet rngData = .UsedRange\n'사용영역을 변수에 넣음\nSet rngT = Sheets(\"Main\").Cells(10, 1).Resize(, 9)\n'복사가 될 지점을 변수에 넣음\nEnd With\nrngData.\nAdvancedFilter\n_\nAction:=xlFilterCopy, _\nCriteriaRange:=rngCri, _\nCopyToRange:=rngT, _\nUnique:=False\n'각 조건에 따라 고급필터 적용\nWith rngCri\n'rngCri 영역에서\n.Resize(, .Columns.Count + 1).EntireColumn.Delete\n'열을 1개 늘려서 삭제\nEnd With\nSheets(\"필터기준\").Columns.\nAutoFit\n'전체열 열너비 자동맞춤\nSheets(\"Main\").Activate\n'Main 시트 활성화\nSet rngData = Nothing\n'개체변수(들) 초기화\nSet rngT = Nothing\nEnd Sub", "context": "고급필터는 엑셀의 강력한 필터기능이며 속도도 빠르다. 그런데, A(결과), B(데이터), C 시트가 있을때, A시트에서 고급필터를 이용 B시트의 필터링 데이터를 한 번에 가져올 수 없다. 또한 복수의 조건으로 고급필터를 저장할 때 필터링 조건의 적용이 조금은 까탈스럽다. 하지만 아래에 적용한 것처럼 하니까 이제 VBA(매크로) 이용한 고급필터의 적용도 상당히 손쉬울 것 같다. 많이 애용하여야 할듯.\nADO SQL 과 속도비교는 안해봤지만 엑셀의 필터링 엔진도 대단한 속도감을 자랑한다. 몇 만행의 데이터도 순식간에 처리한다.\n매크로 실행 후 결과 데이터가 출력될 \"Main\" 시트\n데이터가 저장된 \"원본자료\"시트\n\"필터기준\" 시트에 약간의 수식을 적용하여 Main 시트를 참조하도록. \"Main\"시트가 아닌 이 \"필터기준\" 시트의 필터조건을 기준으로 필터링 된다. \"필터기준\" 시트내 2행에 적용된 수식을 참조.\n\"필터기준\" 시트 A2 에 입력된 수식 : =\">=\" & TEXT(Main!$..."}
{"instruction": "Excel VBA code for: (1389) 엑셀 2010과 2013의 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub select_Case()                                                Sub mutiple_ElseIf()\nDim i As Long                                                        Dim i As Long\nDim r As Long                                                        Dim r As Long\nApplication.ScreenUpdating = False                          Application.ScreenUpdating = False\nFor i = 1 To 10000000                                               For i = 1 To 10000000\nr = Int(Rnd\n* 5) + 1                                                  r = Int(Rnd\n* 5) + 1\nSelect Case\nr\nIf\nr = 1 Then\nCase\n1: r = 1                                                         r = 1\nCase 2: r = 1\nElseIf\nr = 2 Then\nCase 3: r = 1                                                         r = 1\nCase 4: r = 1                                                     ElseIf r = 3 Then\nCase Else : r =1                                                    r = 1\nEnd Select\nElseIf r = r Then\nNext i                                                                           r = 1\nEnd Sub", "context": "갑자기 엑셀 2010 과 2013의 속도차이는 얼마나 날까 궁금하여 예전에 시간을 측정하였던 몇 개의 코드를 동일한 컴퓨터에서 돌려봤다. 단지, 1년 6개월 전과의 차이라면 엑셀 2010과 2013의 버전 차이뿐. 약간씩 차이는 있지만 결과는 대개 10%를 상회하는 정도의 속도가 향상된 것 같다.\n그런데, 조건문 하나만 본다면 훨씬 빨라졌다. 아래의 동일한 코드를 1년 반전에 속도 측정한 적이 있다(\nhttp://rosa0189.blog.me/60162594959\n). 2013에서 매크로 버튼을 누르고 뭔가 잘못된지 알았다. 2010에서 2.50초 걸리던 것이 2013에서는 0.82초 걸리다니 .... (100,000,000 번으로 해보니 딱 8초 걸린다). 여러번 해봐도 마찬가지다. 아래의 내용이 정확하다면, 조건문을 많이 사용한 특정 매크로는 기존 엑셀 2010 보다 두 배이상 빨라진 것이다. 마이크로소프트 녀석들 도대체 엑셀 내부 엔진에 무슨 짓을 한것인지......... 무서..."}
{"instruction": "Excel VBA code for: (1390) 차트를 선택영역 크기로 맞춰 옮기기 (엑셀 VBA 매크로)", "input": "", "output": "Sub fit_A_Chart_In_Selection()\nDim rngSel As Range                              '선택영역 전체를 넣을 변수\nIf\nTypeOf\nSelection Is Range Then            '선택한 것이 영영이라면\nMsgBox \"차트가 선택되지 않음\", 64, \"영역선택 오류\"  '경고 메시지 출력\nExit Sub\nEnd If\nOn Error Resume Next                             '에러 발생해도 다음 코드 진행\nSet rngSel = Application.InputBox(\"마우스로 복사될 위치를 선택하시오!\", Type:=8)\nIf rngSel Is Nothing Then Exit Sub            '취소 선택시 매크로 중단\nOn Error GoTo 0                                     '에러검출기능 복원\nIf rngSel.MergeCells Then                       'rngShp가 셀병합된 셀이라면\nSet rngSel = rngSel.\nMergeArea\n'영역을 셀병합 영역으로 확장\nEnd If\nWith Selection                                        '선택영역\n.Left = rngSel.Left                               '차트의 왼쪽 위치를 선택영역 왼쪽 위치에\n.Top = rngSel.Top                               '차트의 윗쪽 위치를  선택영역 윗쪽 위치에\n.Height = rngSel.Height - 5                   '차트 높이를 선택영역 크기 - 5로\n.Width = rngSel.Width - 5                     '차트 폭을 선택영역 크기 - 5로\nEnd With\nSet rngSel = Nothing                               '개체변수들 초기화(메모리 비우기)\nActiveWindow.\nRangeSelection\n.Select       '영역을 선택\nEnd Sub", "context": "차트 생성 시 차트의 크기를 특정 크기로 맞출 수 없다. 아래의 매크로를 사용하면 생성한 차트를 자신이 선택한 영역의 크기에 딱 맞추어 옮길 수 있다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1390) 차트를 선택영역 크기로 맞춰 옮기기 (엑셀 VBA 매크로)\n재생\n2,016\n재생 (space/k)\n재생\n00:13\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:13\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동..."}
{"instruction": "Excel VBA code for: (1391) 행(좌우) 또는 열(상하) 방향 무작위로 섞기 (엑셀 VBA 매크로)", "input": "", "output": "Sub random_Reshuffle_Rows_Columns()\nDim msg As String\n'메시지 출력에 사용할 변수\nDim rngA As Range\n'각 (A)rea를 넣을 변수\nDim varA\n'각 (A)rea를 넣을 배열\nDim rowsCnt As Long\n'각 area의 행 개수 넣을 변수\nDim colsCnt As Integer\n'각 area의 열 개수 넣을 변수\nDim varR\n'뒤섞은 결과 값을 넣을 배열\nDim varCnt() As Long\n'행 또는 열의 숫자만큼 카운터로 쓰일 배열\nDim varNo() As Long\n'행 또는 열 개수만큼 순차적으로 숫자 넣을 배열\nDim i As Long\n'행 또는 열 개수만큼 반복할 변수\nDim y As Long\n'행 또는 열 개수만큼 반복할 변수\nDim j As Long\n'랜덤 값을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nmsg = MsgBox(\"행(좌우)으로 섞는건 Yes, 열(상하)로\" & _\n\"섞는건 No 선택\", vbYesNoCancel, \"행열 선택\")\nFor Each\nrngA\nIn\nSelection.\nAreas\n'선택영역 각 area를 순환\nRandomize\n'랜덤값 발생기 초기화\n'(계속 새로운 랜덤 기준값 생성)\nIf rngA.Cells.\nCount\n> 1 Then\n'(1개 셀만 선택했을 때 에러방지용)\nWith rngA\n'각 area 에서\nvarA = .\nValue\n'varA에 각 area값을 넣음\nrowsCnt = .Rows.Count\n'각 area의 행 개수를 변수에 넣음\ncolsCnt = .Columns.Count\n'각 area의 열 개수를 변수에 넣음\nSelect Case\nmsg\n'메시지 선택에 따라서\nCase\nvbYes\n'메시지창에서 Yes 선택시\nReDim\nvarR(1 To rowsCnt, 1 To colsCnt)\n'결과배열 크기 재지정\nReDim varCnt(1 To colsCnt)\n'카운터로 사용될 배열 크기 재지정\nFor i = 1 To colsCnt\n'열 개수만큼 반복\nvarCnt(i) = i\n'카운터 배열에 순차적 값을 넣음\nNext i\nFor y = 1 To rowsCnt\n'행 개수만큼 반복\nvarNo = varCnt\n'varNo 배열에 varCnt값을 넣음\nFor i = colsCnt To 1 Step -1\n'제일 큰 열에서 부터 1씩 빼며 반복\nj = Int(\nRnd\n* i) + 1\n'무작위 값을 추출\nvarR(y, i) = varA(y, varNo(j))\n'무작위로 추출한 위치의 배열 값을 varR에 순차적으로 넣음\nvarNo(j) = varNo(i)\n'제일 뒤에 있는 배열 값을 추출한 곳에 채워 넣음\nNext i\nNext y\n.Value = varR\n'결과배열에 추출한 값을 각 area에 뿌림\nCase\nvbNo\nReDim varR(1 To rowsCnt, 1 To colsCnt)\nReDim varCnt(1 To rowsCnt)\nFor i = 1 To rowsCnt\nvarCnt(i) = i\nNext i\nFor y = 1 To colsCnt\nvarNo = varCnt\nFor i = rowsCnt To 1 Step -1\nj = Int(Rnd * i) + 1\nvarR(i, y) = varA(varNo(j), y)\nvarNo(j) = varNo(i)\nNext i\nNext y\n.Value = varR\nEnd Select\nEnd With\nEnd If\nNext rngA\nEnd Sub", "context": "한 영역의 행(좌우) 방향 또는 열(상하) 방향으로 데이터를 무작위로 섞는 것은 몇 번 해보았다. 이 코드는\n선택된 area 개수에 상관 없이\n, 메시지창에서 Yes 또는 No를 선택함에 따라 선택된 영역의 입력된 값을 행(좌우) 또는 열(상하) 방향으로 무작위로 섞어주는 기능을 한다.\nA1:J100000 , 즉\n1,000,000 셀정도 뒤섞으니 내 컴퓨터로는\n1\n.05\n초 정도 소요\n된다. 무지 빠르다. 행 또는 열방향으로 섞는 것은 거의 이 코드가 마지막이 될 것 같다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1391) 행(좌우) 또는 열(상하) 방향 무작위로 섞기 (엑셀 VBA 매크로)\n재생\n2,678\n공유하기\n재생 (space/k)\n재생\n00:45\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:45\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인..."}
{"instruction": "Excel VBA code for: (1392) 행제목 일치 시 파일내 데이터 가져오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_Language_Files()\nDim fileNames As\nVariant\n'모든 파일 넣을 배열 변수\nDim fileName As Variant\n'각 파일을 넣을 변수\nDim wkb As Workbook\n'workbook을 넣을 변수\nDim rngRow As Range\n'통합파일 첫 행의 문자를 넣을 변수\nDim R As Range\n'통합파일 첫 행 각 셀을 넣을 변수\nDim rngNew As Range\n'데이터 파일 첫 행의 문자를 넣을 변수\nDim N As Range\n'데이터 파일 첫 행 각 셀을 넣을 변수\nDim rngData As Range\n'데이터 파일내 문자영역 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.Offset(1).ClearContents\n'기존 데이터 삭제\nChDir ThisWorkbook.Path\n'매크로 실행파일과 동일한 경로 기준\nfileNames = Application.\nGetOpenFilename\n(\"Excel Files (*.xls*),*.xls*\", , _\n\"엑셀 파일(들)을 선택\", MultiSelect:=True)\n'엑셀 파일(들)을 선택\nSet rngRow = Rows(1).SpecialCells(2)\n'통합파일 첫 행의 문자를 변수에 넣음\nIf\nTypeName\n(fileNames) = \"\nBoolean\n\" Then Exit Sub\n'취소 선택 시 매크로 종료\nFor Each fileName In fileNames\n'선택한 각 엑셀 파일을 순환\nSet wkb = Workbooks.Open(fileName)\n'파일을 열고 개체변수에 넣음\nSet rngNew = Rows(1).SpecialCells(2)\n'데이터 파일 첫 행의 문자를 변수에 넣음\nDo\n'다음을 실행\nFor Each R In rngRow.Cells\n'통합파일 첫 행 각 셀을 순환\nFor Each N In rngNew.Cells\n'데이터 파일 첫 행 각 셀을 순환\nIf R = N Then\n'두 데이터가 일치하면\nIf Cells(2, N.Column) <> \"\" Then\n'2 행이 비어 있지 않으면(데이터 확인)\nSet rngData = Range(Cells(2, N.Column), _\nCells(Rows.Count, N.Column).End(3))\n'데이터 영역을 변수에 넣음\nR.Offset(1).Resize(rngData.Rows.Count) = rngData.Value\n'데이터를 통합시트에 복사\nExit Do\n'중첩 For 구문 탈출\nEnd If\nEnd If\nNext N\nNext R\nLoop Until\nTrue\n'1회만 실행 하고 종료\nwkb.Close False\n'열은 파일을 저장없이 닫음\nNext fileName\nSet rngRow = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet wkb = Nothing\nSet rngNew = Nothing\nSet rngData = Nothing\nEnd Sub", "context": "(요청하셨던 내용)\n1. 통합파일의 행제목과 총 30개 정도 되는 각 언어별 파일의 행 제목에서 일치하는 언어명을 찾음\n(아래 예제에서는 3개의 파일만으로 진행)\n2. 각 파일에서 일치하는 언어명 있을 경우 그 밑의 내용들을 통합파일의 언어명 밑으로 불러오기\n3. 각 파일에 있는 불러오는 행의 수는 불규칙\n매크로 실행 전                                             데이터 파일 내의 데이터가 입력된 모양\n매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1392) 행제목 일치 시 파일내 데이터 가져오기 (엑셀 VBA 매크로)\n재생\n1,518\n재생 (space/k)\n재생\n00:41\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:41\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자..."}
{"instruction": "Excel VBA code for: (1394) 화폐 종류별 정렬 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_By_Currenty()\nDim rngData As Range\n'A열 전체 문자영역을 넣을 변수\nDim D As Range\n'A열 각 셀을 넣을 변수\nDim rngCur As Range\n'E열 화폐 정렬순서 넣을 변수\nDim C As Range\n'E열 각 셀을 넣을 변수\nDim colsCnt As Integer\n'전체데이터 영역 열 개수 넣을 변수\nDim rngT As Range\n'각 화폐별 첫 데이터가 복사될 위치\nDim rngArea As Range\n'각 화폐 그룹별 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nSet rngData = Range(\n[A2]\n, Cells(Rows.Count, \"A\").End(3))\n'A열 전체를 개체변수에\nSet rngCur = Range(\"E2:E6\")\n'화폐 정렬순서를 개체변수에\ncolsCnt = [A1].\nCurrentRegion\n.Columns.Count\n'A1 연결영역 열 개수를 변수에\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.\nClear\n'기존 데이터 삭제\nCells(1, 1).Resize(, colsCnt).Copy .Cells(1, 1)\n'제목행 복사\nFor Each C In rngCur\n'화폐 정렬순서 각 셀을 순환\nSet rngT = .Cells(Rows.Count, \"A\").End(3)(2)\n'화폐 그룹별 첫데이터 복사될위치 변수에 넣음\nFor Each D In rngData\n'A열 각 셀을 순환\nIf\nMid\n(C.\nNumberFormat\n, 5, 1) = _\nMid(D.NumberFormat, 5, 1) Then\n'화폐 서식이 일치하면\n.Cells(Rows.Count, \"A\").End(3)(2).Resize(1, colsCnt) = _\nD.Resize(1, colsCnt).Value\n'각 행의 데이터를 Sheet2 에 복사\nEnd If\nNext D\nSet rngArea = Range(rngT, Sheets(2).Cells(Rows.Count, \"A\").End(3))\n'각 화폐 그룹별 영역을 개체변수에 넣음\nrngArea.NumberFormat = C.NumberFormat\n'화폐서식을 복사\nrngArea.\nSort\nrngT, 1, Header:=False\n'오름차순으로 정렬\nNext C\n.Activate\n'활성화\nEnd With\nSet rngData = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngCur = Nothing\nSet rngT = Nothing\nEnd Sub", "context": "화폐 종류별 정렬하는 기능은 엑셀에 있지 않다. VBA(매크로) 사용하면 그리 어렵지 않으려니 생각했는데 막상 코딩을 해보니 이것 저것 걸리는게 꽤 많다. 그럭 저럭 아래처럼 하긴 했지만 이런 기능이 필요하고 데이터가 많은 사람들은 머리가 꽤 아플거 같다. 더군다나, 일본의 엔화와 중국의 위안화는 심볼마저\n¥\n로 동일해서 두 가지 화폐를 구분하는 것은 방법이 없는 것처럼 보인다.\n매크로 실행 전 Sheet2는 비어 있음.                                 매크로 실행 후 Sheet2 의 결과\n(A열의 화폐가 그룹별로 오름차순 정렬)\nOption Explicit\nSub sort_By_Currenty()\nDim rngData As Range\n'A열 전체 문자영역을 넣을 변수\nDim D As Range\n'A열 각 셀을 넣을 변수\nDim rngCur As Range\n'E열 화폐 정렬순서 넣을 변수\nDim C As Range\n'E열 각 셀을 넣을 변수\nDim colsC..."}
{"instruction": "Excel VBA code for: (1395) 중복없는 숫자로 선택영역 채우기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub random_Fill_Final()\nDim rngA As Range\n'각 area를 넣을 변수\nDim rowsCnt As Long\n'전체 행의 개수 넣을 변수\nDim colsCnt As Integer\n'전체 열의 개수 넣을 변수\nDim maxNo As Long\n'선택영역 셀 개수 넣을 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim varTemp()\n'임시배열로 사용할 배열변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nDim y As Long\n'행 방향 늘려갈 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim x As Integer\n'열 방향 늘려갈 변수\nDim varR()\n'결과 값을 넣을 배열 변수\nDim cnt As Long\n'카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngA In Selection.\nAreas\n'선택영역 각 area를 순환\nRandomize\n'랜덤값 발생기 초기화\n'(계속 새로운 랜덤 기준값 생성)\nWith rngA\n'각 area에서\nrowsCnt = .Rows.Count\n'전체 행 개수를 변수에 넣음\ncolsCnt = .Columns.Count\n'전체 열 개수를 변수에 넣음\nmaxNo = .Count\n'선택영역 셀 개수를 변수에 넣음\nEnd With\nReDim\nvarTemp(1 To maxNo)\n'임시배열의 크기 재지정\nReDim varR(1 To rowsCnt, 1 To colsCnt)\n'결과 열의 크기 재지정\nFor Each rngC In rngA\n'각 area의 각 셀을 순환\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = r\n'각 셀을 배열에 넣음\nNext rngC\ny = 1\nFor i = maxNo To 1 Step -1\n'최댓값 부터 1씩 줄여가며 반복\nr =\nInt\n(\nRnd\n() * i) + 1\n'무작위 값을 추출\ncnt = cnt + 1\n'카운터를 늘려감\nIf cnt = colsCnt + 1 Then\n'카운터가 열개수에 도달하면\ny = y + 1\n'행을 1씩 늘려감\ncnt = 1\n'카운터 초기화\nx = 0\n'재사용 위하여 초기화\nEnd If\nx = x + 1\n'열방향 값을 1씩 늘려감\nvarR(y, x) = varTemp(r)\n'배열에 랜덤값을 채워감\nvarTemp(r) = varTemp(i)\n'배열 윗값을 추출된 위치에 채움\nNext i\nrngA = varR\n'결과배열 값을 선택영역에 뿌림\nr = 0\n'재사용 위하여 초기화\nx = 0\n'재사용 위하여 초기화\ny = 0\n'재사용 위하여 초기화\ncnt = 0\n'재사용 위하여 초기화\nNext rngA\nEnd Sub", "context": "하나 또는 복수의 영역을 선택하고 매크로 실행 시\n각 area마다\n중복없는 숫자로 선택영역을 채워주는 기능으로 기존의 단점들을 보완한 코드. 기존에는 한 개의 영역만을 선택하고 매크로 실행해야 했지만, 이제 ctrl + 마우스 이용하여 여러 영역을 선택하여도 상관 없으며 속도 또한 빠르다.\nA1:J100000 영역을 1 ~ 1,000,000의 숫자로 채워주는데 내 컴퓨터로\n1.2초\n정도 소요.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1395) 중복없는 숫자로 선택영역 채우기 3 (엑셀 VBA 매크로)\n재생\n629\n공유하기\n재생 (space/k)\n재생\n00:08\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:08\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5..."}
{"instruction": "Excel VBA code for: (1396) 선택영역을 랜덤(random)하게 뒤섞기 10 (엑셀 VBA 매크로)", "input": "", "output": "Sub random_Reshuffle_5()\nDim rngA As Range\n'각 area를 넣을 변수\nDim rowsCnt As Long\n'전체 행의 개수 넣을 변수\nDim colsCnt As Integer\n'전체 열의 개수 넣을 변수\nDim maxNo As Long\n'선택영역 셀 개수 넣을 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim varTemp()\n'임시배열로 사용할 배열변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nDim y As Long\n'행 방향 늘려갈 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim x As Integer\n'열 방향 늘려갈 변수\nDim varR()\n'결과 값을 넣을 배열 변수\nDim cnt As Long\n'카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngA In Selection.\nAreas\n'선택영역 각 area를 순환\nRandomize\n'랜덤 초기화\nWith rngA\n'각 area에서\nrowsCnt = .Rows.Count\n'전체 행 개수를 변수에 넣음\ncolsCnt = .Columns.Count\n'전체 열 개수를 변수에 넣음\nmaxNo = .\nCount\n'선택영역 셀 개수를 변수에 넣음\nEnd With\nReDim\nvarTemp(1 To maxNo)\n'임시배열의 크기 재지정\nReDim varR(1 To rowsCnt, 1 To colsCnt)\n'결과 열의 크기 재지정\nFor Each rngC In rngA\n'가 area의 각 셀을 순환\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = rngC\n'각 셀을 배열에 넣음\nNext rngC\ny = 1\nFor i = maxNo To 1 Step -1\n'최댓값 부터 1씩 줄여가며 반복\nr =\nInt\n(\nRnd\n() * i) + 1\n'무작위 값을 추출\ncnt = cnt + 1\n'카운터를 늘려감\nIf cnt = colsCnt + 1 Then\n'카운터가 열개수에 도달하면\ny = y + 1\n'행을 1씩 늘려감\ncnt = 1\n'카운터 초기화\nx = 0\n'재사용 위하여 초기화\nEnd If\nx = x + 1\n'열방향 값을 1씩 늘려감\nvarR(y, x) = varTemp(r)\n'배열에 랜덤값을 채워감\nvarTemp(r) = varTemp(i)\n'배열 윗값을 추출된 위치에 채움\nNext i\nrngA = varR\n'결과배열 값을 각 area에 뿌림\nr = 0\n'재사용 위하여 초기화\nx = 0\n'재사용 위하여 초기화\ny = 0\n'재사용 위하여 초기화\ncnt = 0\n'재사용 위하여 초기화\nNext rngA\nEnd Sub\n\nSub random_Reshuffle_6()\nDim rngA As Range\n'각 area를 넣을 변수\nDim rowsCnt As Long\n'전체 행의 개수 넣을 변수\nDim colsCnt As Integer\n'전체 열의 개수 넣을 변수\nDim maxNo As Long\n'선택영역 셀 개수 넣을 변수\nDim varTemp()\n'임시배열로 사용할 배열변수\nDim varR()\n'결과 값을 넣을 배열 변수\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim r As Long\n'배열위치 늘리거나 랜덤값 추출에 사용할 변수\nDim x As Integer\n'열 방향 늘려갈 변수\nDim y As Long\n'행 방향 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nFor Each rngA In Selection.Areas\n'선택영역 각 area를 순환\nRandomize\n'랜덤값 발생기 초기화\n'(계속 새로운 랜덤 기준값 생성)\nWith rngA\n'각 area에서\nrowsCnt = .Rows.Count\n'전체 행 개수를 변수에 넣음\ncolsCnt = .Columns.Count\n'전체 열 개수를 변수에 넣음\nmaxNo = .Count\n'선택영역 셀 개수를 변수에 넣음\nEnd With\nReDim varTemp(1 To maxNo)\n'임시배열의 크기 재지정\nReDim varR(1 To rowsCnt, 1 To colsCnt)\n'결과 열의 크기 재지정\nFor Each rngC In rngA\n'가 area의 각 셀을 순환\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = rngC\n'각 셀을 배열에 넣음\nNext rngC\nFor y = 1 To rowsCnt\n'area 의 행 개수 만큼 반복\nFor x = 1 To colsCnt\n'area의 열 개수 만큼 반복\nr = Int(Rnd() * maxNo) + 1\n'무작위 값을 추출\nvarR(y, x) = varTemp(r)\n'배열에 랜덤값을 채워감\nvarTemp(r) = varTemp(maxNo)\n'배열 윗값을 추출된 위치에 채움\nmaxNo = maxNo - 1\n'전체 셀 개수 1개씩 줄여감\nNext x\nNext y\nrngA = varR\n'결과배열 값을 각 area에 뿌림\nr = 0\nNext rngA\nEnd Sub", "context": "아래 동영상에서 보듯 선택된 영역을 무작위로 뒤 섞어 주는 기능. 기존에는 1개의 area만 선택할 수 있었지만 이제는 ctrl + 마우스로 여러개의 영역을 선택하여도 된다. A1:J100000 셀까지 즉,\n1,000,000 개의 셀\n을 선택하고 무작위로 섞었을 때 내 컴퓨터로\n2.2초 정도 소요\n.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1396) 선택영역을 랜덤(random)하게 뒤섞기 10 (엑셀 VBA 매크로)\n재생\n1,880\n공유하기\n재생 (space/k)\n재생\n00:09\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:09\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시..."}
{"instruction": "Excel VBA code for: (1398) 선택영역을 가로(또는 세로)로 숫자 채우기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_Numbers_With_Increment3()\nDim msg As String\n'메시지 출력에 사용할 변수\nDim rngA As Range\n'각 area를 넣을 변수\nDim rngC As Range\n'각 area의 첫행 또는 첫열 각 셀을 넣을 변수\nDim i As Long\n'카운터로 사용할 변수\nDim colsCnt As Integer\n'각 area의 열 개수 넣을 변수\nDim rowsCnt As Long\n'각 area의 행 개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nmsg =\nMsgBox\n(\"가로채우기 Yes, 세로채우기는 No 선택\", 3, \"가로 or 세로 채우기\")\n'메시지박스 선택결과를 msg에 넣음\ni = 0\n'0일 경우 1부터 채워짐. 100일 경우 101부터\nSelect Case msg\n'메시지창 선택 결과에 따라서\nCase vbYes\n'Yes 선택 시\nFor Each rngA In Selection.\nAreas\n'선택영역 각 area를 순환\nWith rngA\n'각 area에서\ncolsCnt = .Columns.Count\n'열 개수를 변수에 넣음\nFor Each rngC In rngA.Resize(1)\n'각 area의 첫 행 각셀을 순환\ni = i + 1\n'카운터를 1씩 늘려감\nrngC = i\n'첫 행에 값을 채움\nNext rngC\ni = i + .Cells.Count - colsCnt\n'area 전체 셀 개수 - 열개수를 축척해감\n.\nDataSeries\nxlColumns, step:=colsCnt\n'열방향으로 열 개수만큼 늘리며 채워감\nEnd With\nNext rngA\nCase vbNo\n'Yes 선택 시\nFor Each rngA In Selection.Areas\nWith rngA\n'각 area에서\nrowsCnt = .Rows.Count\n'행 개수를 변수에 넣음\nFor Each rngC In rngA.Resize(, 1)\n'각 area의 첫 열 각셀을 순환\ni = i + 1\n'카운터를 1씩 늘려감\nrngC = i\n'첫 열에 값을 채움\nNext rngC\ni = i + .Cells.Count - rowsCnt\n'area 전체 셀 개수 - 행개수를 축척해감\n.DataSeries xlRows, step:=rowsCnt\n'행방향으로 행 개수만큼 늘리며 채워감\nEnd With\nNext rngA\nEnd Select\nEnd Sub", "context": "기존 \"(103) 선택영역을 가로(또는 세로)로 숫자 채우기 (\nhttp://rosa0189.blog.me/60203970736)\n의 속도를 엄청나게 개선한 코드이다. 기존에는 배열에 넣어 뿌렸지만, 이번에는 엑셀의 기본기능인 채우기를 응용하여 각 area를 채워가므로 수 백만개의 셀도 순식간에 연속된 숫자로 채워간다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1398) 선택영역을 가로(또는 세로)로 숫자 채우기 3 (엑셀 VBA 매크로)\n재생\n855\n재생 (space/k)\n재생\n00:39\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:39\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. ..."}
{"instruction": "Excel VBA code for: (1399) 양식 복사 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub repeat_Format_With_Number()\n'Run Macro 버튼에 연결된 매크로\nDim startRow As Long\n'양식의 첫행 시작위치\nDim rowNo As Long\n'양식 1개의 행 개수\nDim howMany As Long\n'복사할 양식의 개수\nDim startNo As Long\n'연번의 시작 숫자\nDim i As Long\n'반복구문에 사용할 변수\nDim str As String\n'반복 문자를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nstartRow = Range(\"\nA2\n\")\n'\n양식의 시작행\n을 변수에 넣음\nrowNo = Range(\"\nC2\n\")\n'\n양식 1개의 행 개수\n변수에 넣음\nhowMany = Range(\"\nE2\n\")\n'\n복사할 양식의 개수\n변수에 넣음\nstartNo = Range(\"\nF2\n\")\n'연번의\n시작 번호\n를 변수에 넣음\nstr = Range(\"\nG2\n\").Value                               '\n반복문자\n를 변수에 넣음\nCells(startRow, 1).Resize(rowNo).\nEntireRow.Copy\n'양식을 복사\nCells(startRow + rowNo, 1).Resize(rowNo _\n* howMany).EntireRow.\nPasteSpecial\nPaste:=\nxlPasteFormats\n'지정한 개수만큼 양식을 복사\nFor i = 1 To howMany\n'양식 개수만큼 반복\nCells(startRow + i * rowNo, 1) = startNo + i - 1\n'연번을 입력함\nCells(startRow + i * rowNo, 5) = str\n'반복문자를 입력함\nNext i\nApplication.CutCopyMode = False\n'복사모드 해제\nRange(\"A1\").Select\n'A1셀 활성황\nMsgBox \"양식복사가 종료되었습니다.\"\n'메시지 출력\nEnd Sub\n\nSub delete_Format()\n'\"양식 삭제\" 버튼에 연결된 매크로\nDim startRow As Long\n'양식의 첫행 시작위치\nDim rowNo As Long\n'양식 1개의 행 개수\nDim howMany As Long\n'복사할 양식의 개수\nstartRow = Range(\"A2\")\n'양식의 시작행을 변수에 넣음\nrowNo = Range(\"C2\")\n'양식 1개의 행 개수 변수에 넣음\nhowMany = Range(\"E2\")\n'복사할 양식의 개수 변수에 넣음\nCells(startRow + rowNo, 1).Resize(rowNo _\n* howMany).\nEntireRow\n.\nDelete\n'기존 데이터 삭제\nEnd Sub", "context": "동일한 양식에 연번과 모델명 같은 반복 문자를 넣으면서 복사할 때 이를 수작업 하는 사람들을 많이 보았다. 아래의 코드를 잘 응용하면 원하는 양식을 자신이 원하는 개수만큼 반복할 문자와 함께 생성할 수 있습니다. 그렇죠?\n매크로 실행 전 (복사할 양식이 생성되어 있음)\n매크로 실행 후 양식이 복사된 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1399) 양식 복사 1 (엑셀 VBA 매크로)\n재생\n1,384\n재생 (space/k)\n재생\n00:54\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:54\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다..."}
{"instruction": "Excel VBA code for: (1401) 이름과 함께 사진위치 행/열 변환하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub relocate_Data_With_Pictures()\nDim intNo As Integer                                  '그림을 몇 행씩 끊어 옮길지 정할 변수\nDim rngArea As Range                              '5행씩 끊어서 영역에 넣을 변수\nDim rngC As Range                                  '각 셀을 순환할 변수\nDim c As Integer                                       '열(C)olumn 방향 늘려갈 변수\nDim r As Long                                          '행(R)ow 방향 늘려갈 변수\nDim i As Long                                          '반복구문에 사용할 변수\nApplication.ScreenUpdating = False            '화면 업데이트 (일시)정지\nintNo = 5\n'5행씩 끊어서 옮김\nSet rngArea = Cells(1, 1).Resize(intNo, 2)    '첫 5행을 변수에 넣음\nFor i = 1 To Cells(Rows.Count, \"A\").End(3).\nRow\n+ intNo Step intNo\n'전체 행 + 5행까지 5씩 건너 뛰며 반복\nr = r + 1                                                '행을 1씩 늘려감\nFor Each rngC In rngArea                      '영역의 각 셀을 순환\nc = c + 1                                          '열을 1씩 늘려감\nrngC.\nCopy\nCells(r + 1, c + 3)              '각 영역을 행/열 늘려가며 복사\nNext rngC\nc = 0                                                   '재사용 위하여 초기화\nSet rngArea = rngArea.\nOffset\n(intNo)       '작업 영역을 5행 건너뛴 곳으로 설정\nNext i\nSet rngArea = Nothing                               '개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "아래와 같이 작동하려면 모든 사진은 B열의 각 셀크기 보다 작아야 한다. 셀크기 보다 더 크면 셀과 함께 복사되지 않는다. 셀크기 보다 클 경우, F5 => 옵션 => 개체를 클릭하여 모든 그림을 한 번에 선택한 이후에 왼쪽 모서리가 B열의 각 셀에 포함되도록 하고 여기(\nhttp://rosa0189.blog.me/60147277109\n) 있는 코드를 돌리면 모든 사진을 셀보다 약간 작세 셀에 넣을 수 있다.\nA열의 이름과 사진이 일치하면 다른 코드를 사용하여 위와 같이 옮길 수도 있다. 아래 코드는 A:B 열의 각 셀을 복사하므로 속도는 좀 떨어진다. 사진 때문에 어쩔 수 없다.\nintNo = 5\n로 되어 있어 5행씩 옮기며, 원하는 숫자로 조절하면 된다.\n매크로 실행 전 과일 이름과 사진이 열방향으로 입력된 모습\n매크로 실행 후 결과\nOption Explicit\nSub relocate_Data_With_Pictures()\nDim intNo As Integer            ..."}
{"instruction": "Excel VBA code for: (1402) 폴더(하위폴더 포함)명과 만든 날짜/마지막 수정일 추출 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Folder_Path_And_Date()\nDim strPath As String                                  '폴더의 경로를 넣을 변수\nApplication.ScreenUpdating = False              '화면 업데이트 (일시) 정지\n'------------------------------\n' 폴더 선택창 출력\n'------------------------------\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)  '폴더선택 창에서\n.Show                                                   '폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then               '취소 선택 시\nExit Sub                                             '매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"          '폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'----------------------\n' 제목행 입력\n'----------------------\nWith ActiveSheet                                          '활성화된 시트에서\n.UsedRange.Clear                                   '기존 데이터 삭제\n.Range(\"A1:C1\") =\nArray\n(\"Path\", \"Date Created\", \"Last Modified Date\")\nEnd With                                                     '필드제목 입력\neachFolder strPath\n'eachFolder 코드를 호출\nColumns.AutoFit                                          '열너비 자동맞춤\nMsgBox \"매크로가 종료되었습니다.\"               '메시지 출력\nEnd Sub\n\nPrivate Function eachFolder(mainFolder As String)\nDim fSO As Scripting.\nFileSystemObject\n'FileSystemObject를 넣을 변수\nDim fldName As Scripting.\nFolder\n'상위폴더 전체경로(마지막이 \"\\\")를 넣을 변수\nDim subFolder As Scripting.Folder                 '하위폴더 넣을 변수\nDim rngT As Range                                      '복사될 위치 넣을 변수\nSet fSO = New Scripting.FileSystemObject      '새로운 파일시스템개체를 변수에\nSet fldName = fSO.\nGetFolder\n(mainFolder)       '선택한 폴더의 이름을 변수에 넣음\nSet rngT = Cells(Rows.Count, \"A\").End(3)(2)  '복사될 지점을 변수에 넣음\nWith fldName                                               '각 폴더에서\nrngT = .Path                                            '폴더 경로를 입력\nrngT(1, 2) = .DateCreated                          '처음 만든 날짜\nrngT(1, 3) = .DateLastModified                   '마지막 수정된 날짜\nEnd With\n'---------------------------------------\n' 재귀 호출로 하위 폴더 순환\n'---------------------------------------\nFor Each subFolder In fldName.\nSubFolders\n'각 폴더의 하위폴더를 순환\neachFolder subFolder.Path                       '하위폴더 재귀호출\nNext subFolder\nSet fSO = Nothing                                         '개체변수들 초기화(메모리 비우기)\nSet fldName = Nothing\nSet rngT = Nothing\nEnd Function", "context": "지정한 폴더와 그 폴더의 모든 하위폴더 정보를 가져오는 기능.\n매크로 실행 전\n매크로 실행 후 결과.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1402) 폴더(하위폴더 포함)명과 만든 날짜/마지막 수정일 추출 (엑셀 VBA 매크로)\n재생\n826\n재생 (space/k)\n재생\n00:11\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:11\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n매크로를 실..."}
{"instruction": "Excel VBA code for: (1403) 폴더(하위폴더 포함)내 엑셀파일 특정 시트의 데이터 통합 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_From_All_Folders()\nDim strPath As String                                   '폴더의 경로를 넣을 변수\nApplication.ScreenUpdating = False              '화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Offset(1).Clear         '기존 데이터 삭제\n'----------------------\n' 폴더 선택창 출력\n'----------------------\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)  '폴더선택 창에서\n.Show                                                  '폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then             '취소 선택 시\nExit Sub                                           '매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"        '폴더 경로를 변수에 넣음\nEnd If\nEnd With\neachFolder strPath\n'eachFolder 코드를 호출\nActiveSheet.UsedRange.\nSort\n[A1], 1, Header:=True        '오름차순 정렬\nMsgBox \"매크로가 종료되었습니다.\"             '메시지 출력\nEnd Sub\n\nPrivate Function eachFolder(mainFolder As String)\nDim strSht As String                                     '시트이름을 넣을 변수\nDim wks As Worksheet                                 '시트를 넣을 변수\nDim fSO As Scripting.FileSystemObject           '파일 시스템을 넣을 변수\nDim fldName As Scripting.Folder                    '상위폴더 넣을 변수\nDim fileName As Object                                '파일이름 넣을 변수\nDim subFolder As Scripting.Folder                 '하위폴더 넣을 변수\nDim rngT As Range                                      '복사될 위치 넣을 변수\nDim wkBk As Workbook                                '각 파일을 넣을 변수\nDim rngAll As Range                                     '전체 데이터 넣을 변수\nDim rowsCnt As Long                                   '전체 데이터의 행 개수 넣을 변수\nDim colsCnt As Integer                                  '전체 데이터의 열 개수 넣을 변수\nstrSht = \"\nSheet3\n\"                                          '데이터를 가져오려는 시트의 이름\nSet fSO = New Scripting.\nFileSystemObject\n'새로운 파일시스템개체를 변수에\nSet fldName = fSO.\nGetFolder\n(mainFolder)        '선택한 폴더의 이름을 변수에 넣음\nFor Each fileName In fldName.Files                 '폴더내 각 파일을 순환\nIf\nInStr\n(fileName, \".xlsx\") Then                    '파일이 엑셀 파일이면\n'-------------------------------------------------\n' 각 파일을 열고 시트의 존재여부 확인하는 코드\n'-------------------------------------------------\nSet rngT = Cells(Rows.Count, \"A\").End(3)(2)  '데이터가 복사될 기준위치를 변수에\nSet wkBk = Workbooks.Open(fileName)    '파일을 열고 변수에 넣음\nOn Error\nResume Next                           '에러 발생해도 다음코드 진행\nSet wks = Worksheets(strSht)                 '데이터 시트를 개체변수에 넣음\nIf\nErr\n= 0\nThen                                       '에러가 발생하지 않았다면\n'----------------------------------------------\n' 데이터 존재여부 확인 후 데이터 복사하는 코드\n'----------------------------------------------\nWith Worksheets(strSht).UsedRange    '각 시트의 사용영역에서\nIf .Rows.Count > 1 Then                '데이터가 입력되어 있으면\nSet rngAll = .Offset(1).Resize(.Rows.Count - 1)\nEnd If                                          '제목행 제외한 전체 데이터를 변수에 넣음\nrowsCnt = rngAll.Rows.Count        '전체 데이터의 행 개수를 변수에 넣음\ncolsCnt = rngAll.Columns.Count     '전체 데이터의 열 개수를 변수에 넣음\nrngT.Resize(rowsCnt, colsCnt) = rngAll.Value  '복사될 크기 조절해 데이터 복사\nEnd With\nEnd If\nOn Error\nGoTo 0\n'에러 검출기능 초기화\nwkBk.Close False                                '열린 파일 저장 없이 닫음\nEnd If\nNext fileName\n'-------------------------------\n' 재귀 호출로 하위 폴더 순환\n'-------------------------------\nFor Each subFolder In fldName.\nSubFolders\n'각 폴더의 하위폴더를 순환\neachFolder subFolder.Path\n'각 폴더경로로 eachFolder함수호출\nNext subFolder\nSet fSO = Nothing                                         '개체변수들 초기화(메모리 비우기)\nSet fldName = Nothing\nSet rngT = Nothing\nSet wkBk = Nothing\nSet wks = Nothing\nSet rngAll = Nothing\nEnd Function", "context": "폴더(하위폴더 포함) 내의 모든 특정 시트(아래 예제에서는 Sheet3 라는 이름의 시트)내 데이터를 모두 통합파일로 가져오는 기능. 필요 시 strSht = \"\nSheet3\n\" 를 자신의 데이터 시트 이름으로 변경하여 사용하면 된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1403) 폴더(하위폴더 포함)내 엑셀파일 특정 시트의 데이터 통합 1 (엑셀 VBA 매크로)\n재생\n1,384\n재생 (space/k)\n재생\n00:57\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:57\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버..."}
{"instruction": "Excel VBA code for: (1404) 지그재그로 순차적 숫자 채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub clear_All()\n'\"삭제\" 버튼에 연결된 코드\nRange(\"A1:C10\").ClearContents\n'A1:C10 영역의 데이터 삭제\nEnd Sub\n\nSub fill_In_ZigZag_1()\n'Macro 1 코드에 연결된 코드\nDim rngC As\nRange\n'각 셀을 넣을 변수\nDim i As Integer\n'10회 반복할 변수\nSet rngC = Cells(1, 1)\n'시작 셀을 A1 셀로 지정\nFor i = 1 To 10\n'1부터 10회 반복\nrngC = i\n'셀에 값을 입력\nIf\nrngC.Column = 1 Then\n'셀의 열이 1이면\nSet\nrngC = rngC.\nOffset\n(1, 1)\n'아래 오른쪽 셀로 셀지정\nElseIf\nrngC.Column = 2 And _\nrngC.Offset(-1, -1) <> \"\" Then\n'셀의 열이 2이고 왼쪽윗셀이 빈셀 아니면\nSet rngC = rngC.Offset(1, 1)\n'아래 오른쪽 셀로 셀지정\nElseIf\nrngC.Column = 2 And _\nrngC.Offset(-1, 1) <> \"\" Then\n'셀의 열이 2이고 오른쪽 윗셀이 빈셀 아니면\nSet rngC = rngC.Offset(1, -1)\n'왼쪽 아래 셀로 셀지정\nElseIf\nrngC.Column = 3 Then\n'셀의 열이 3일 경우\nSet rngC = rngC.Offset(1, -1)\n'왼쪽 아래 셀로 셀지정\nEnd If\nNext i\nEnd Sub\n\nSub fill_In_ZigZag_2()\n'Macro 2에 연결된 코드\nDim rngC As Range\nDim i As Integer\nSet rngC = Cells(1, 1)\nFor i = 1 To 10\nrngC = i\nSelect Case\nrngC.Column\nCase\n1: Set rngC = rngC.Offset(1, 1)\nCase\n2 And rngC.Offset(-1, -1) <> \"\"\nSet rngC = rngC.Offset(1, 1)\nCase\n2 And rngC.Offset(-1, 1) <> \"\"\nSet rngC = rngC.Offset(1, -1)\nCase\n3: Set rngC = rngC.Offset(1, -1)\nEnd Select\nNext i\nEnd Sub\n\nSub fill_In_ZigZag_3()\nDim i As Integer\nDim c As Integer\nDim bln As\nBoolean\nCells(1, 1) = 1\nc = 1\nFor i = 2 To 10\nIf c = 1 Then\nc = c + 1\nElseIf c = 3 Then\nc = c - 1\nElseIf c = 2 Then\nIf bln = True Then\nbln = Not bln\nc = c - 1\nElse\nbln = Not bln\nc = c + 1\nEnd If\nEnd If\nCells(i, c) = i\nNext i\nEnd Sub\n\nSub fill_In_ZigZag_4()\nDim r As Integer\nDim c As Integer\nDo\nIf c < 3 Then\nDo\nr = r + 1\nc = c + 1\nCells(r, c) = r\nIf r = 10 Then Exit Sub\nLoop Until\nc = 3\nElse\nDo\nr = r + 1\nc = c - 1\nCells(r, c) = r\nIf r = 10 Then Exit Sub\nLoop Until\nc = 1\nEnd If\nLoop\nEnd Sub\n\nSub fill_In_ZigZag_5()\nDim i As Integer\nDim c As Integer\nDim r As Integer\nFor i = 1 To 10\nr = r + 1\nc =\nChoose\n(r\nMod\n5, 1, 2, 3, 2)\nIf r = 4 Then r = 0\nCells(i, c) = i\nNext i\nEnd Sub\n\nSub fill_In_ZigZag_6()\nDim i As Integer\nDim j As Integer\nDim cnt As Integer\nFor i = 1 To 10\nStep 4\nFor j = 0 To 3\nIf j = 3 Then\nj = j - 2\ncnt = cnt + 1\nCells(cnt, j + 1) = cnt\nExit For\nEnd If\ncnt = cnt + 1\nCells(cnt, j + 1) = cnt\nIf cnt = 10 Then Exit Sub\nNext j\nNext i\nEnd Sub\n\nSub fill_In_ZigZag_7()\nDim i As Integer\nDim cnt As Integer\nFor i = 1 To 10 Step 4\nCells(i, 1) = i\ncnt = cnt + 1\nIf cnt = 10 Then Exit For\nCells(i + 1, 2) = i + 1\ncnt = cnt + 1\nIf cnt = 10 Then Exit For\nCells(i + 2, 3) = i + 2\ncnt = cnt + 1\nIf cnt = 10 Then Exit For\nCells(i + 3, 2) = i + 3\ncnt = cnt + 1\nIf cnt = 10 Then Exit For\nNext i\nEnd Sub\n\nSub fill_In_ZigZag_8()\nDim rngC As Range\nDim r As Integer\nFor Each\nrngC\nIn\nRange(\"A1:C10\")\nIf rngC.\nInterior.ColorIndex\n<> -4142 Then\nr = r + 1\nrngC = r\nEnd If\nNext\nrngC\nEnd Sub", "context": "(\nRange 선택\n메뉴는 초보님들을 위한 코너) 아래 지그재그 모양의 셀에 순서대로 숫자를 1 ~ 10까지 채우는 기능. 아래 코드를 보지 말고 나라면 어떻게 할까 먼저 생각해보자. 쉬울 것 같아도 은근히 이런 문제가 까다로울 때도 많다.\n그 아래의 코드들은 보너스 ~~~  이런 쓸데 없는 코드들을 어디에 사용하냐고 반문할 수 있겠지만, 영역을 마음대로 옮겨다닐 수 있어야 데이터를 이동하거나 특정 위치에 값을 복사하는 등의 작업을 할 때 자신이 의도하는 대로 손쉽게 작업을 할 수 있다.\n(아래 방식들 말고 다른 방법으로 동일기능 할 수 있는 분 코드와 함께 덧글 달아주세요. ^^)\n매크로 실행 전                                                                 매크로 실행 후 결과\nOption Explicit\nSub clear_All()\n'\"삭제\" 버튼에 연결된 코드\nRange(\"A1:C10\").ClearContents\n'A1:C1..."}
{"instruction": "Excel VBA code for: (1405) 조견표와 다르게 입력된 데이터 표시 (엑셀 VBA 매크로)", "input": "", "output": "Sub input_Error_Check()\nDim vO As Variant\n'varO 내 각 값을 넣을 배열변수\nDim vN As Variant\n'varN 내 각 값을 넣을 배열변수\nDim varO As Variant\n'Old 시트내 A열 넣을 배열변수\nDim varN As Variant\n'New 시트내 A열 넣을 변수\nDim i As Long\n'Old 배열내 행을 늘려나갈 변수\nDim j As Long\n'New 배열내 행을 늘려갈 변수\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n.Calculation =\nxlCalculationManual\n'셀계산 수동으로 전환\nEnd With\n'-------------------------------------------\n'각 배열에 제목 제외한 제품 이름을 넣음\n'-------------------------------------------\nvarO = Columns(\"E\").\nSpecialCells\n(2)\n'E열을 배열에 넣음\nvarN = Sheets(2).Columns(\"B\").SpecialCells(2)\n'Sheet2 B열을 배열에 넣음\n'-----------------------------------------------------\n' 먼저 \"제품명\"이 일치하는지 검색 후 제조사를 검사\n'-----------------------------------------------------\nFor Each vO In varO\n'Sheet1 A열 각 셀을 순환\ni = i + 1\n'Sheet1 A열 행을 늘려감\nFor Each vN In varN\n'Sheet2 A열 각 셀을 순환\nj = j + 1\n'Sheet2 A열 행을 늘려감\nIf vO = vN Then\n'제품명이 일치하면\n'--------------------------------\n' 제품명 일치 시 제조사를 확인\n'--------------------------------\nIf Cells(i, 2) <> Sheets(2).Cells(j, 1) Then\n'제조사가 다를 경우\nCells(i, 5).Interior.\nColor\n= 65535\n'제품명 노란 색으로 표시\nExit For\n'for 구문 종료\nEnd If\nEnd If\nNext vN\nj = 0\n'Sheet2 행값 초기화\nNext vO\nWith Application\n.Calculation = xlCalculationAutomatic\n'셀계산 자동으로 돌려놓음\n.ScreenUpdating = True\n'화면업데이트 재 실행\nEnd With\nMsgBox \"데이터 검색이 완료되었습니다.\"\n'완료 메시지 출력\nEnd Sub", "context": "데이터를 입력하다 보면 조견표와 다르게 입력되는 경우가 허다하다. 아래의 코드는 Sheet2 에 있는 조견표와 다르게 입력된 품목을 Sheet1 에서 찾는 기능. 즉, Sheet1에 있는 품목 중 제품명과 제조사가 Sheet2와 모두 일치하지 않는 품목에 표시를 하는 것.\n코드의 속도를 높이기 위해 배열의 값을 비교하며, 이러한 데이터는 개수도 많을 것이므로 코드가 진행되는 동안 자동계산도 잠시 비활성화 시킴.\n매크로 실행전 Sheet 1                                                  매크로 실행 전 Sheet2\n매크로 실행 후 Sheet1의 결과\nOption Explicit\nSub input_Error_Check()\nDim vO As Variant\n'varO 내 각 값을 넣을 배열변수\nDim vN As Variant\n'varN 내 각 값을 넣을 배열변수\nDim varO As Variant\n'Old 시트내 A열 넣을 배열변수\nDim varN ..."}
{"instruction": "Excel VBA code for: (1409) 알파벳 마다 끊어서 이동하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub transpose_Based_On_Alphabet()\nDim y As Long\n'Sheet2 행을 늘려갈 변수\nDim r As Long\n'Sheet1 행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'2번 시트에서\n.UsedRange.Clear\n'기존 데이터 삭제\nDo\n'다음을 실행\ny = y + 1\n'(Sheet2) 행을 1씩 늘려감\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\n.Cells(y, Columns.Count).End\n(1)(1, 2)\n= Cells(r, 1)\n'종단셀 왼쪽방향 기능으로 데이터 복사\nIf Cells(r + 1, 1) = \"\" Then\n'만약 A열에 빈셀이 나오면\n.Columns(\"A\").Delete\n'(Sheet2)의 A열 삭제\n.Columns.AutoFit\n'열너비 자동맞춤\n.Activate\n'활성화\nMsgBox \"매크로가 종료되었습니다.\"\nExit Sub\n'매크로 종료\nEnd If\nLoop Until\nNot\nIsNumeric\n(Cells(r + 1, 1))\n'다음행이 숫자가 아닐때까지 무한반복\nLoop\n'무한반복\nEnd With\nEnd Sub", "context": "세로로 입력된 데이터에서 각 알파벳이 나올 때마다 행열변환을 하여서 데이터를 옮겨주는 기능.\n매크로 실행 전 (Sheet2 는 비어 있는 상태)                매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub transpose_Based_On_Alphabet()\nDim y As Long\n'Sheet2 행을 늘려갈 변수\nDim r As Long\n'Sheet1 행을 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'2번 시트에서\n.UsedRange.Clear\n'기존 데이터 삭제\nDo\n'다음을 실행\ny = y + 1\n'(Sheet2) 행을 1씩 늘려감\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\n.Cells(y, Columns.Count).End\n(1)(1, 2)\n= Cells(r, 1)\n'종단셀 왼쪽방향 기능으로 데이터 복사\nIf Cells(r + 1, 1)..."}
{"instruction": "Excel VBA code for: (1410) 문자 가공하여 x 기준으로 분리하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub process_Text_And_Split()\nDim rngC As Range\n'영역(range) 셀(C)ell 넣을 변수\nDim i As Integer\n'셀의 문자 개수만큼 반복할 변수\nDim strEach As String\n'각(Each) 문자를 넣을 변수\nDim strU As String\n'각 문자를 합쳐(U)nion갈 변수\nDim varR\n'문자를 쪼개어 넣을 배열 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\nActiveSheet.UsedRange.Copy .Range(\"A1\")\n'전체 데이터 Sheet2에 복사\n.Activate\n'Sheet2 활성화\nEnd With\nWith ActiveSheet.UsedRange\n'활성화된 시트의 사용영역에서\n.Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 1).ClearContents\nEnd With\n'기존데이터 삭제\nColumns(\"B\").\nNumberFormatLocal\n= \"\n0.000\n\"\n'B열 소수점 3자리로 표시\nFor Each rngC In Range([A2], Cells(Rows.Count, \"A\").End(3))\n'제목 제외한 A열 데이터 각셀을 순환\nrngC = Left(rngC, Len(rngC) - (Len(rngC) -\nInStrRev\n(rngC, \"-\") + 1))\nrngC =\nReplace\n(\nReplace\n(rngC, \"(\", \"x\"), \")\", \"\")\n'하이픈 이하는 삭제,  (는 x 로 교체, )는 삭제\nFor i = 1 To Len(rngC)\n'정리작업 마친 전체 문자 길이 만큼 반복\nstrEach = Mid(rngC, i, 1)\n'각 문자를 변수에 넣음\nIf strEach\nLike \"[0-9]\"\nOr strEach = \".\" Or _\nstrEach = \"x\" Then\n'숫자, 점(.) 또는 x 일경우\nstrU = strU & strEach\n'문자를 합쳐감\nEnd If\nNext i\nvarR =\nSplit\n(strU, \"x\")\n'구분자 x 로 쪼개어 배열에 넣음\nFor i =\nLBound\n(varR) To\nUBound\n(varR) - 1\n'마지막 배열 빼고 반복\nrngC.Offset(, i + 1) = varR(i)\n'배열 값을 셀에 뿌려감\nNext i\nrngC.Offset(, 5) = varR(UBound(varR))\n'배열의 마지막 값은 F열에 입력\nstrU = \"\"\n'재사용 위하여 초기화\nNext rngC\nColumns.AutoFit\n'열너비 자동 맞춤\nSet rngC = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "하이픈(-) 이하는 삭제\n알파벳 문자들 삭제하고 숫자만 추출\n( 는 x 로 교체하고, ) 는 삭제\nB열 부터 채워가고 제일 마지막 데이터는 F열에 넣음\n매크로 실행 전 Sheet1 (Sheet2 는 비어 있음)\n매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub process_Text_And_Split()\nDim rngC As Range\n'영역(range) 셀(C)ell 넣을 변수\nDim i As Integer\n'셀의 문자 개수만큼 반복할 변수\nDim strEach As String\n'각(Each) 문자를 넣을 변수\nDim strU As String\n'각 문자를 합쳐(U)nion갈 변수\nDim varR\n'문자를 쪼개어 넣을 배열 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\nActiveSheet.UsedRange.Copy .Range(\"A1\")\n'전체 데이터 Sheet2에 복사\n.Ac..."}
{"instruction": "Excel VBA code for: (1413) 셀내의 중복단어 삭제 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Duplicate_Word_Each_Cell_1()\nDim varLeft\n'셀의 단어를 구분자로 나누어 넣을 배열\nDim varRight\n'셀의 단어를 구분자로 나누어 넣을 배열\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 순환할 변수\nDim strU As String\n'문자를 합쳐갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim j As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중단\nColumns(1).Copy Cells(1, 2)\n'1열을 2열에 복사\nSet rngAll = Range(\"B1\", Cells(Rows.Count, \"B\").End(3))\n'전체 영역을 변수에 넣음\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nvarLeft =\nSplit\n(rngC, \" \")\n'각 셀을 구분자(공백)로 나누어 배열에\nvarRight = varLeft\n'배열을 복사하여 두 배열이 같도록 함\nFor i =\nLBound\n(varLeft) To\nUBound\n(varLeft)\n'배열 크기 만큼 반복\nFor j = LBound(varRight) +\ni + 1\nTo UBound(varRight)\n'배열 하한값 + i  + 1 부터 반복\nIf varLeft(i) = varRight(j) Then\n'배열 값이 일치 시\nvarRight(j) =\nEmpty\n'varRight의 중복단어 삭제\nEnd If\nNext j\nNext i\nstrU = Join(varRight, \" \")\n'varRight 를 합친다.\nrngC =\nWorksheetFunction\n.\nTrim\n(strU)\n'공백 제거 후 셀에 뿌림.\nNext rngC\nSet rngAll = Nothing\n'개체 변수 초기화\nEnd Sub", "context": "As far as \"Macro\" is concerned, 모로 가도 서울만 가면 된다. 뭐 꼭 폼나게 코드를 작성해야만 되는건 아니다. 자신의 목적만 달성하면 되는거다. 단, 폼까지 나게 코드를 작성하면 더 좋겠지만. ^^\n각 셀 내에서 중복단어가 있을 경우 처음 나온 단어를 제외하고 뒤에 나오는 중복되는 모든 단어를 삭제하는 기능으로\nhttp://rosa0189.blog.me/60205735104\n여기에서 해본 것을 다른 방법으로 해봤다. 알아보기 쉽도록 중복되어 삭제될 단어는 빨간색으로 표시하였다.\n매크로 실행 전                                                매크로 실행 후 결과\nOption Explicit\nSub remove_Duplicate_Word_Each_Cell_1()\nDim varLeft\n'셀의 단어를 구분자로 나누어 넣을 배열\nDim varRight\n'셀의 단어를 구분자로 나누어 넣을 배열\nDim rngAll As Range\n'..."}
{"instruction": "Excel VBA code for: (1415) 각 행을 5회씩 복사하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_Five_Times_1()\n'32.50초\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'전체 행 만큼 반복할 변수\nDim i As Integer\n'5회 반복에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, \"A\").End(3).\nRow\n'마지막 행을 변수에 넣음\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'기존 데이터 삭제\nFor r = 1 To lastRow\n'1 ~ 마지막 행까지 반복\nFor i = 1 To 5\n'1 ~ 5 까지 1씩 올라가며 반복\nCells(r, 1).Resize(, 3).\nCopy\n_\nDestination:=.Cells(.Rows.Count, \"A\").End(3)(2)\n'각 행을 3열로 크기 조절 후 1행씩 복사\nNext i\nNext r\nEnd With\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "10회에 걸쳐서 아래와 동일한 기능을 하는 10개의 코드를 올리도록 한다. 5,000 개의 행을 5회씩 복사하여 총 25,000 행의 데이터가 생성된다. 이 코드는\n첫 번째\n코드로 10개 중에서 가장 느린 코드이며\n각 행을 .copy 메서드를 이용하여 복사\n한다. 각 행을 복사하는 것은 언제나 최고 느린 코드 중의 하나.\n참고로, 이 코드는 내 컴퓨터로\n약\n32.50 초\n정도 소요\n.\n매크로 실행 전 Sheet1 (Sheet2는 비어 있음)              매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub copy_Five_Times_1()\n'32.50초\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'전체 행 만큼 반복할 변수\nDim i As Integer\n'5회 반복에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.C..."}
{"instruction": "Excel VBA code for: (1417) 각 행을 5회씩 복사하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_Five_Times_3()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'전체 행 만큼 반복할 변수\nDim i As Integer\n'5회 반복에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, \"A\").End(3).\nRow\n'마지막 행을 변수에 넣음\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'기존 데이터 삭제\nFor r = 1 To lastRow\n'1 ~ 마지막 행까지 반복\nFor i = 1 To 5\n'1 ~ 5 까지 1씩 올라가며 반복\n.Cells(.Rows.Count, \"A\").End(3)(2).Resize(1, 3) = _\nCells(r, 1).Resize(, 3)\n.Value\n'value 속성을 이용하여 각행을 복사\nNext i\nNext r\nEnd With\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "10회에 걸쳐서 아래와 동일한 기능을 하는 10개의 코드를 올리도록 한다. 5,000 개의 행을 5회씩 복사하여 총 25,000 행의 데이터가 생성된다. 이 코드는\n세\n번째 코드\n로 10개 중에서 상당히 느린 코드이며\n각 행을 .value 속성을 이용하여 복사\n한다. Copy 메서드를 사용하지 않고 .value 속성을 사용하여 더 빨라졌지만 각 행을 복사하므로 여전히 속도가 느리다.\n참고로, 이 코드는 내 컴퓨터로\n약\n5.95 초\n정도 소요\n.\n매크로 실행 전 Sheet1 (Sheet2는 비어 있음)              매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub copy_Five_Times_3()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'전체 행 만큼 반복할 변수\nDim i As Integer\n'5회 반복에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시..."}
{"instruction": "Excel VBA code for: (1419) 각 행을 5회씩 복사하기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_Five_Times_5()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'전체 행 만큼 반복할 변수\nDim rngT As Range\n'복사될 타겟 지점을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSheets(2).UsedRange.Clear\n'기존 데이터 삭제\nlastRow = Cells(Rows.Count, \"A\").End(3).\nRow\n'마지막 행을 변수에 넣음\nFor r = 1 To lastRow\n'1 ~ 마지막 행까지 반복\nWith Sheets(2)\n'Sheet2 에서\nSet\nrngT = .Cells(.Rows.Count, \"A\").End(3)(2)\n'복사될 지점을 변수에 넣음\nEnd With\nWith rngT\n'복사될 지점에서\n.Resize(1, 3) = Cells(r, 1).Resize(, 3)\n.Value\n'1행의 데이터를 복사한 뒤\n.Resize(5, 3).\nFillDown\n'아래로 4행을 채우기\nEnd With\nNext r\nSet rngT = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "10회에 걸쳐서 아래와 동일한 기능을 하는 10개의 코드를 올리도록 한다. 5,000 개의 행을 5회씩 복사하여 총 25,000 행의 데이터가 생성된다. 이 코드는\n다섯\n번째\n코드\n로 드디어 느린 코드를 벗어났으며 10개의 코드 중 중간 정도의 속도이다.\n각 행을 .value 속성을 이용해 타겟 지점에 복사한 뒤 이를 아래로 채워 복사\n하는 방법을 사용.\n참고로, 이 코드는 내 컴퓨터로\n약\n1.80 초\n정도 소요\n.\n매크로 실행 전 Sheet1 (Sheet2는 비어 있음)                 매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub copy_Five_Times_5()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'전체 행 만큼 반복할 변수\nDim rngT As Range\n'복사될 타겟 지점을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSheet..."}
{"instruction": "Excel VBA code for: (1420) 각 행을 5회씩 복사하기 6 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_Five_Times_6()\nDim r As Long\n'행을 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'기존 데이터 삭제\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\n.Cells(.Rows.Count, \"A\").End(3)(2).\nResize(5, 3)\n= _\nCells(r, 1).Resize(, 3)\n.Value\n'종단셀 윗방향이용 5행씩 한 번에 복사\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nEnd With\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "10회에 걸쳐서 아래와 동일한 기능을 하는 10개의 코드를 올리도록 한다. 5,000 개의 행을 5회씩 복사하여 총 25,000 행의 데이터가 생성된다. 이 코드는\n여섯\n번째\n코드\n로 중간 정도의 속도이다.\n각 행을 .value 속성을 이용해 복사한 뒤 이를 아래로 채워 복사\n하는 방법을 사용.\n참고로, 이 코드는 내 컴퓨터로\n약\n1.45 초\n정도 소요\n.\n매크로 실행 전 Sheet1 (Sheet2는 비어 있음)                 매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub copy_Five_Times_6()\nDim r As Long\n'행을 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'기존 데이터 삭제\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\n.Cells(.Rows.Count, \"A\")...."}
{"instruction": "Excel VBA code for: (1421) 각 행을 5회씩 복사하기 7 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_Five_Times_7()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'전체 행 만큼 반복할 변수\nDim y As Long\n'5행씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, \"A\").End(3).\nRow\n'마지막 행을 변수에 넣음\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'기존 데이터 삭제\ny = 1\n'1부터 시작\nFor r = 1 To lastRow\n'1 ~ 마지막 행까지 반복\n.Cells(y, 1).Resize(5, 3) = _\nCells(r, 1).Resize(, 3)\n.Value\n'5행씩 한 번에 복사\ny = y + 5\n'행을 5씩 늘려감\nNext r\nEnd With\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "10회에 걸쳐서 아래와 동일한 기능을 하는 10개의 코드를 올리도록 한다. 5,000 개의 행을 5회씩 복사하여 총 25,000 행의 데이터가 생성된다. 이 코드는\n일곱\n번째\n코드\n로 10개의 코드 중 빠른 코드들 중의 하나이다.\n각 행을 .value 속성을 5행씩 복사\n하는 단순한 방법으로 중급자들이 사용하기 가장 무난한 코드.\n참고로, 이 코드는 내 컴퓨터로\n약\n0.5 초\n정도 소요\n.\n매크로 실행 전 Sheet1 (Sheet2는 비어 있음)            매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub copy_Five_Times_7()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'전체 행 만큼 반복할 변수\nDim y As Long\n'5행씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, \"A\").En..."}
{"instruction": "Excel VBA code for: (1422) 각 행을 5회씩 복사하기 8 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_Five_Times_8()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim varTemp As\nVariant\n'임시 배열로 사용할 변수\nDim r As Long\n'전체 행 개수만큼 반복할 변수\nDim c As Integer\n'5회 반복할 변수\nDim y As Long\n'전체 데이터 행 개수 x 5배 반복할 변수\nDim i As Integer\n'행 개수인 3회 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSheets(2).UsedRange.Clear\n'기존 데이터 삭제\nSet rngAll = ActiveSheet.UsedRange\n'전체 사용영역을 개체변수에 넣음\nrowsCnt = rngAll.\nRows.Count\n'전체 행 개수를 변수에 넣음\nReDim\nvarTemp(1 To\nrowsCnt * 5\n, 1 To 3)\n'배열크기 전체행 x 5배 크기로 재지정\nFor r = 1 To rowsCnt\n'전체 행 개수만큼 반복\nFor c = 1 To 5\n'5회 복사를 위해 반복\ny = y + 1\n'복사될 행 열을 1씩 늘려감\nFor i = 1 To 3\n'열 개수인 3회 반복\nvarTemp(y, i) = Cells(r, i)\n'배열에 값을 넣음\nNext i\nNext c\nNext r\nSheets(2).Cells(1, 1).Resize(rowsCnt * 5, 3) = varTemp\n'배열값 시트에 뿌림\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "10회에 걸쳐서 아래와 동일한 기능을 하는 10개의 코드를 올리도록 한다. 5,000 개의 행을 5회씩 복사하여 총 25,000 행의 데이터가 생성된다. 이 코드는\n여덟\n번째\n코드\n로 10개의 코드 중 가장 빠른 코드들 중의 하나이다.\n전체 데이터를  배열에 넣었다가  시트에 뿌리는\n방법으로 역시 배열이라 속도는 빠르다.\n참고로, 이 코드는 내 컴퓨터로\n약\n0.4 초\n정도 소요\n.\n매크로 실행 전 Sheet1 (Sheet2는 비어 있음)                매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub copy_Five_Times_8()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim varTemp As\nVariant\n'임시 배열로 사용할 변수\nDim r As Long\n'전체 행 개수만큼 반복할 변수\nDim c As Integer\n'5회 반복할 변수\nDim y As L..."}
{"instruction": "Excel VBA code for: (1423) 각 행을 5회씩 복사하기 9 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_Five_Times_9()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim varTemp As\nVariant\n'임시 배열로 사용할 변수\nDim varR As\nVariant\n'결과 배열로 사용할 변수\nDim r As Long\n'전체 행 개수만큼 반복할 변수\nDim c As Integer\n'5회 반복할 변수\nDim y As Long\n'전체 데이터 행 개수 x 5배 반복할 변수\nDim i As Integer\n'행 개수인 3회 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'기존 데이터 삭제\nSet rngAll = ActiveSheet.UsedRange\n'전체 사용영역을 개체변수에 넣음\nvarTemp = rngAll\n'전체 사용영역을 임시배열에 넣음\nrowsCnt = rngAll.Rows.Count\n'전체 행 개수를 변수에 넣음\nReDim\nvarR(1 To\nrowsCnt * 5\n, 1 To 3)\n'결과배열 크기 전체행 x 5배로 재지정\nFor r = 1 To\nUBound\n(varTemp, 1)\n'전체 행 개수만큼 반복\nFor c = 1 To 5\n'5회 복사를 위해 반복\ny = y + 1\n'복사될 행 열을 1씩 늘려감\nFor i = 1 To 3\n'열 개수인 3회 반복\nvarR(y, i) = varTemp(r, i)\n'임시배열에서 결과배열로 복사\nNext i\nNext c\nNext r\n.Cells(1, 1).Resize(rowsCnt * 5, 3) = varR\n'결과배열 값을 시트에 뿌림\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "10회에 걸쳐서 아래와 동일한 기능을 하는 10개의 코드를 올리도록 한다. 5,000 개의 행을 5회씩 복사하여 총 25,000 행의 데이터가 생성된다. 이 코드는\n아홉\n번째\n코드\n로 10개의 코드 중 가장 빠른 코드들 중의 하나이다.\n전체 데이터를 임시배열에 넣었다가 이를 다시 결과배열에 5회씩 반복하여 복사한 뒤 결과배열의 값을 시트에 뿌리는\n방법으로 역시 대부분 이 방법이 최고의 속도를 자랑한다.\n참고로, 이 코드는 내 컴퓨터로\n약\n0.20 초\n정도 소요\n.\n매크로 실행 전 Sheet1 (Sheet2는 비어 있음)                매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub copy_Five_Times_9()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim varTemp As\nVariant\n'임시 배열로 사용할 변수\nDim varR As\nVariant\n'결과..."}
{"instruction": "Excel VBA code for: (1424) 각 행을 5회씩 복사하기 10 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_Five_Times_10()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim r As Long\n'5회 복사에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nlastRow = Cells(Rows.Count, \"A\").End(3).\nRow\n'마지막 행을 변수에 넣음\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Clear\n'기존 데이터 삭제\nFor r = 1 To 5\n'5회 반복\nActiveSheet.UsedRange.\nCopy\n.Cells(.Rows.Count, \"A\").End(3)(2)\n'전체 데이터를 5회 복사\nNext r\n.UsedRange.\nSort\n.Cells(1, 1), 1, Header:=xlNo\n'데이터를 A열 기준으로 오름차순 정렬\nEnd With\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "10회에 걸쳐서 아래와 동일한 기능을 하는 10개의 코드를 올리도록 한다. 5,000 개의 행을 5회씩 복사하여 총 25,000 행의 데이터가 생성된다. 이 코드는\n마지막 열\n번째\n코드\n로 10개의 코드 중 가장 빠른 코드이다.\n전체 데이터를 5회 복사했다가 정렬\n하는 아주 단순한 방법을 사용하였다.\n참고로, 이 코드는 내 컴퓨터로\n약\n0.10 초\n정도 소요\n.\n10개의 코드를 만들어본 결과 다시 한 번 아래의 사실이 재 확인됨.\n적용한 방법\n코드의 속도\n1\n데이터를 복사(.copy) 하거나 행삽입\n항상 제일 느림\n2\n.value 를 이용하여 데이터를 직접 복사\n중간 정도의 속도\n3\n배열을 사용한 코드\n제일 빠른 코드 중의 하나\n4\n엑셀의 기본 기능 응용\n매크로 최고수가 만든 코드보다 빠르며 안정적\n매크로 실행 전 Sheet1 (Sheet2는 비어 있음)              매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub copy_Five_Times_10..."}
{"instruction": "Excel VBA code for: (1425) .Copy 와 .Paste 의 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub direct_Copy()                                 Sub through_Paste()\nDim rngC As Range                               Dim rngC As Range\nApplication.ScreenUpdating = False        Application.ScreenUpdating = False\nFor Each rngC In [A1:B100]                   For Each rngC In [A1:B100]\nrngC.\nCopy\nrngC.Offset(, 3)                    rngC.\nCopy\nActiveSheet.\nPaste\nrngC.Offset(, 3)\nNext rngC                                            Next rngC\nEnd Sub", "context": "빈번하진 않지만 값과 함께 서식을 복사할 경우 VBA(매크로) 코드내에서 .Copy 메서드를 종종 사용한다. 그런데, 한 행의 코드가 조금 길어져서, 예를 들면,\nCells(r, 1).Resize(, 3).\nCopy\nSheets(\"Sheet2\").Cells(.Rows.Count, \"A\").End(3)(2)\n와 같은 코드를 행바꿔서,\n.Cells(r, 1).Resize(, 3).Copy _\nActiveSheet.\nPaste\nSheets(\"Sheet2\").Cells(.Rows.Count, \"A\").End(3)(2)\n와 같이 사용할 수 있는데 이럴 경우 속도가 상당히 저하된다.\n반복횟수 : 200번\n.Copy\n를 사용한 코드\n.Paste\n를 사용한 코드\n소요시간\n1.00초                                              1\n.60 초\n﻿\nSub direct_Copy()                                 Sub through_Paste..."}
{"instruction": "Excel VBA code for: (1427) 셀병합된 셀에 연번 입력하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub numbering_Of_Merged_Cells_1()\nDim strAddr As String\n'셀병합 주소를 넣을 변수\nDim r As Long\n'번호 1씩 늘려갈 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nWith Selection\n'선택 영역에서\nIf .Columns.\nCount\n> 1 Or .Cells.Count = 1 Then\nMsgBox \"1셀 이상, 1개의 열만 선택하세요\", 64, \"열선택 오류\"\n'1열이상 또는 1셀 선택시 메시지 출력\nExit Sub\n'매크로 종료\nEnd If\n.HorizontalAlignment = xlCenter\n'수평 중앙정렬\n.VerticalAlignment = xlCenter\n'수직 중앙정렬\nstrAddr = .Cells(1).\nMergeArea\n.\nAddress\n'첫 셀의 주소를 변수에 넣음\nr = 1\n'처음 시작 번호\n.Cells(1).Value = r\n'시작 번호를 첫 셀에 넣음\nEnd With\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nIf rngC.MergeArea.Address <> strAddr Then\n'셀주소가 strAddr 아니면\nr = r + 1\n'번호를 1씩 늘려감\nrngC = r\n'셀에 값을 입력함\nstrAddr = rngC.MergeArea.Address\n'새로운 셀병합 주소를 변수에 넣음\nEnd If\nNext rngC\nEnd Sub", "context": "셀병합을 피해야 한다고 매일 주장하므로 이런 코드는 안올리는게 좋을것 같다는 생각도 들지만 ... 아무튼 아래의 코드는 불규칙한 개수로\n셀병합된 영역을 선택하고\n매크로 실행 시 연속된 번호를 입력해주는 코드이다. 아래 코드에서\nr = 1\n이라고 하면 1부터, r = 15 라고 하면 15부터 숫자가 입력된다. 1개 이상의 셀, 1열만 선택하고 매크로 실행하여야 한다.\n매크로 실행 전 영영을 선택한 모습                             매크로 실행 후 결과\nOption Explicit\nSub numbering_Of_Merged_Cells_1()\nDim strAddr As String\n'셀병합 주소를 넣을 변수\nDim r As Long\n'번호 1씩 늘려갈 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nWith Selection\n'선택 영역에서\nIf .Columns.\nCount\n> 1 Or .Cells.Count = 1 Then\nMsgBox \"1셀 이상, 1개..."}
{"instruction": "Excel VBA code for: (1429) byRef 와 byVal 의 속도 비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub pass_byRef()                                        Sub run_byVal()\nDim varTemp As Variant                                 Dim varTemp As Variant\nDim i As Long                                               Dim i As Long\nApplication.ScreenUpdating = False                 Application.ScreenUpdating = False\nvarTemp = Range(\"A1:E2000\")                         varTemp = Range(\"A1:E2000\")\nFor i = 1 To 100000                                         For i = 1 To 100000\nsub_\nbyRef\nvarTemp\nsub_byVal\nvarTemp\nNext i                                                           Next i\nEnd Sub\n\nSub sub_byRef(\nByRef\nvar As Variant)               Sub sub_byVal(\nByVal\nvar As Variant)\nEnd Sub", "context": "아래의 두 코드는 동일한 기능을 한다. varTemp에 A1:J2000 까지의 영역을 넣고 이를 100,000번 하위 프로시저에 넘겨주는 코드이다. 다른 점이라면 매개변수(parameter)인 varTemp를 byRef로 넘겨주느냐, byVal로 넘겨주느냐 차이뿐이다. 그런데 두 코드의 속도차이는 비교가 되지 않을 정도로 byRef가 빠르다. (byRef와 byVal의 차이를 모르시면 여기 참조 :\nhttp://rosa0189.blog.me/60167474721\n)\n문자(string)나 배열(array)을 하위 프로시저에 넘겨줄 때\nbyVal\n를 사용할 경우 VBA는\n전체 문자나 배열을 복사\n하여 넘겨주는데 이로 인해 문자나 배열이 크면 클수록 많은 시간이 소요된다. 반면,\nbyRef\n는 문자나 배열이 참조하고 있는\n주소(address) 즉 pointer\n만을 하위 프로시저에 넘겨주므로 byVal와는 비교가 되지 않을 정도로 빠르다.\n물론 그렇다고 해서 항상 byRef를 사용할 수 ..."}
{"instruction": "Excel VBA code for: (1430) 다중조건으로 고급필터 적용하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub advanced_Filter_Multiple_Conditions_2()\nDim i As Integer\n'반복 코드에 사용할 변수\nDim rngData As Range\n'전체 데이터 영역을 넣을 변수\nDim rngCri As Range\n'필터링 조건 영역을 넣을 변수\nDim wks As Worksheet\n'각 시트를 넣을 변수\nDim rngT As Range\n'필터된 결과 복사될 위치 넣을 변수\nDim colsCnt As Integer\n'필터된 결과들의 열 개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nIf WorksheetFunction.\nCountA\n(Range(\"B1:B5\")) < 1 Then\n'B1:B5가 비어 있으면\nMsgBox \"필터링 조건이 없습니다. 종료합니다.\", 64, \"데이터입력 오류\"\nExit Sub\n'매크로 종료\nEnd If\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열개수를 변수에 넣음\nCells(7, 1).CurrentRegion.\nOffset\n(1).Clear\n'기존 데이터 삭제\nWith Sheets(\"filter\")\n'필터기준 시트에서\n.Cells(1, 1).CurrentRegion.Copy .Cells(1, Columns.Count).\nEnd(1)(1, 3)\n'필터기준 영역을 복사하여 종단셀 이용 오른쪽에 복사\n'----------------------------------------------------------\n' filter 시트의 rngCri 셀에 입력 값이 없는 셀을 삭제하는 코드\n'----------------------------------------------------------\nFor i = 5 To 1 Step -1\n'1씩 줄여가면서 5회 반복\nIf Len(.Cells(2, i)) < 1 Then\n'만일 셀값의 길이가 1보다 작으면\n.Cells(2, i).EntireColumn.Delete\n'전체 열을 삭제\nEnd If\nNext i\nSet rngCri = .Cells(1, 1).CurrentRegion\n'추출된 필터조건 영역을 변수에 넣음\nEnd With\nFor Each wks In ActiveWorkbook.\nWorksheets\n'각 시트를 순환\n'-------------------------------------------------------------------\n' Main과 filter시트가 아닌 시트를 순환하며 조건에 따라 복사하는 코드\n'-------------------------------------------------------------------\nIf wks.Name <> \"Main\" And wks.Name <> \"filter\" Then\n'시트이름이 Main이 아니고 filter도 아닌 경우\nIf wks.Range(\"A2\") <> \"\" Then\n'데이터가 하나라도 있으면\nwks.Activate\n'활성화\nSet rngData = wks.UsedRange\n'사용영역을 변수에 넣음\nSet rngT = Sheets(\"Main\").Cells(Rows.Count, \"A\").End(3)(2).Resize(, colsCnt)\n'복사가 될 타겟 지점을 변수에 넣음\nrngData.\nAdvancedFilter\n_\nAction:=xlFilterCopy, _\nCriteriaRange:=rngCri, _\nCopyToRange:=rngT, _\nUnique:=False\n'각 조건에 따라 고급필터 적용\nrngT.EntireRow.Delete\n'제목행 전체 삭제\nEnd If\nEnd If\nNext wks\n'----------------------------------------------\n' filter 시트에서 임시로 복사한 조건열을 삭제\n'----------------------------------------------\nWith rngCri\n'rngCri 영역에서\n.Resize(, .Columns.Count + 1).EntireColumn.Delete\n'열을 1개 늘려서 삭제\nEnd With\nSheets(\"filter\").Columns.AutoFit\n'전체열 열너비 자동맞춤\nWith Sheets(\"Main\")\n.Activate\n'Main 시트 활성화\nRange(\"A7\").CurrentRegion.\nSort\n[A7], xlAscending, Header:=xlYes\n'오름차순 정렬\nEnd With\nSet rngCri = Nothing\nSet rngData = Nothing\n'개체변수(들) 초기화\nSet rngT = Nothing\nEnd Sub\n\nSub clear_Data()\nCells(7, 1).CurrentRegion.Offset(1).Clear\n'기존 데이터 삭제\nEnd Sub", "context": "B1:B5 셀에 입력한 조건으로 S1 ~ S12 까지 12개의 시트에서\n부분일치하\n는 데이터를 가져오는 기능. 특정인이 아닌 다수의 사람들이 이 매크로를 사용할 수 있도록 최대한 배려를 하였다.\n열 개수에 제한이 없으므로 첨부된 파일을 내려받은 뒤 자신의 데이터를 복사하여 붙여넣고 사용하면 된다(단 2열 이상이어야 함).\n시트개수에 제한이 없으므로 시트개수를 늘리거나 삭제하여 줄여도 된다.\n시트이름에 제한이 없으므로 원하는 이름으로 S1 ~ S12 시트의 이름을 바꾸어도 된다.\n시트위치에 제한이 없으므로 원하는 아무 위치에나 뒤죽박죽 시트를 위치하여도 된다.\nB1:B5의 조건은 입력하고 싶은 것만 입력하면 됨. 즉, B4셀에 \"거래처명\" 하나만 입력하거나\nB1:B5 모두 조건을 입력하여도 된다.\n행제목이 한 자라도 틀리면 에러나므로, S1 ~ S12 시트의 행제목을 복사하여\nMain 시트에 붙여 넣고, filter 시트의 제목은 Main 시트의 제목을 복사하여 붙여 넣는게 오류 방지..."}
{"instruction": "Excel VBA code for: (1431) 목록상자(DropDown List) 생성 기본코드 (엑셀 VBA 매크로)", "input": "", "output": "Sub drop_Downs()\nDim rngList As Range\nDim rngV As Range\nSet rngList = Range(\"\nA1:A10\n\")\n'목록이 입력된 셀 영역\nSet rngV = rngList.\nOffset(, 2)\n'목록상자 만들 셀 영역\nWith rngV.Validation\n.Delete\n.Add Type:=xlValidateList, _\nAlertStyle:=xlValidAlertStop, _\nOperator:=xlBetween, _\nFormula1:=\"=\" & rngList.Address(1, 1, xlA1)\n.IgnoreBlank = True\n.InCellDropdown = True\n.InputTitle = \"\"\n.ErrorTitle = \"\"\n.InputMessage = \"\"\n.ErrorMessage = \"\"\n.IMEMode = xlIMEModeNoControl\n.ShowInput = True\n.ShowError = True\nEnd With\nrngV.Interior.Color = vbCyan\nrngV = \"Click\"\nSet rngList = Nothing\nSet rngV = Nothing\nEnd Sub", "context": "자주는 아니지만 VBA(매크로) 이용하여 목록상자(DropDown List)를 생성한다. 후일 사용을 위하여 기본 코드를 정리하여 둔다. 노란색으로 표시한 목록이 있는 주소와 목록상자 만들어질 위치만 수정하여 사용하면됨.\nOption Explicit\nSub drop_Downs()\nDim rngList As Range\nDim rngV As Range\nSet rngList = Range(\"\nA1:A10\n\")\n'목록이 입력된 셀 영역\nSet rngV = rngList.\nOffset(, 2)\n'목록상자 만들 셀 영역\nWith rngV.Validation\n.Delete\n.Add Type:=xlValidateList, _\nAlertStyle:=xlValidAlertStop, _\nOperator:=xlBetween, _\nFormula1:=\"=\" & rngList.Address(1, 1, xlA1)\n.IgnoreBlank = True\n.InCellDropdown = True\n.InputTitle ..."}
{"instruction": "Excel VBA code for: (1434) 중복데이터의 가장 최근 데이터 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub improved_Data_Consolidate_1()\nDim wks As Worksheet\n'각 시트를 넣을 변수\nDim s As Integer\n'시트 위치 늘려갈 변수\nWith Application\n.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n.\nDisplayAlerts\n= False\n'화면경고 기능 중단\n'-------------------------------\n' sht로 시작하는 시트의 삭제 코드\n'-------------------------------\nFor Each wks In ActiveWorkbook.\nSheets\n'각 시트를 순환\nIf Left(wks.Name, 3) = \"sht\" Then\n'시트가 sht로 시작하면\nwks.Delete\n'시트를 (경고 없이)삭제\nEnd If\nNext wks\n.DisplayAlerts = True\n'화면 경고 복원\nEnd With\n'-------------------------------------\n' sht로 시작하는 새로운 시트의 삽입코드\n'-------------------------------------\nFor s = Sheets.Count To 1 Step -1\n'시트를 뒤에서 부터 카운팅\nSheets.\nAdd\nafter\n:=Sheets(s)\n'데이터 시트 바로 뒤에 시트추가\nWith ActiveSheet\n'활성화된 시트에서\n.Name = \"sht\" & s\n'시트이름을 설정\n.\nTab\n.Color = vbCyan\n'탭 색을 cyan 으로\nEnd With\nNext s\nFor s = 1 To Sheets.Count Step 2\n'2씩 건너 뛰며 총 개수 까지\nSheets(s).Activate\n'1번 시트 활성화\nRange(\"A5\").CurrentRegion.Copy Sheets(s + 1).Cells(1, 1)\n'현재 사용영역 다음시트에 복사\nSheets(s + 1).Activate\n'뒷 시트 활성화\nmanipulate_Data s\n'데이터 처리하는 코드 시트번호와 함께 호출\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\n.Offset(1, 6).\nNumberFormatLocal\n= \"#.0\"\n'G열부터 소수점 이하는 버린다.\"\n.Borders.LineStyle = 1\n'전체에 외곽선을 넣음\nEnd With\nRows(1).NumberFormatLocal = \"m\"\"월\"\" d\"\"일\"\";@\"\n'1행 서식을 날짜로 지정\nColumns.AutoFit\n'전체 열너비 자동 맞춤\nNext s\nSheets(1).Activate\n'1번 시트 활성화\nMsgBox \"매크로가 종료되었습니다.\"\n'메시지 출력\nEnd Sub\n\nSub manipulate_Data(ByVal shtNo As Integer)\nDim colNo As Integer\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim varTemp\n'배열로 사용할 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'중복개수 구할 변수\nDim j As Integer\n'반복구문에 사용할 변수\nDim v As Long\n'배열 위치 1씩 늘려갈 변수\nDim rngLastCol As Range\n'중복데이터의 가장 최근날짜 넣을 변수\nFor colNo = 6 To 4 Step -2\n'6열과 4열을 1번씩\n'---------------------------------\n' 전체 데이터 크기와 배열크기 설정\n'---------------------------------\nSet rngAll = ActiveSheet.UsedRange\n'전체 데이터 사용영역 넣을 변수\nrowsCnt = rngAll.Rows.Count\n'전체 행개수를 변수에 넣음\ncolsCnt = rngAll.Columns.Count\n'전체 열개수를 변수에 넣음\nr = 1\n'1행부터 시작\nReDim\nvarTemp(1 To rowsCnt, 1 To colsCnt)\n'배열크기 재지정\nActiveSheet.UsedRange.\nSort\nCells(1, colNo), 1, Header:=True\n'현재시트 사용영역을 첫 번째는 F열, 두 번째는 D열 기준 오름차순 정렬\nDo\n'다음을 실행\nIf Cells(r, colNo) = Cells(r + 1, colNo) Then\n'위아래 셀값이 같다면\ni = i + 1\n'중복개수를 1씩 늘려감\nElse\n'위아래 셀값이 다르면\nv = v + 1\n'배열 위치 1씩 늘려감\n'-----------------------------\n' 중복이 없는 행의 데이터 처리\n'-----------------------------\nIf i = 0 Then\n'중복 없는 경우\nFor j = 1 To colsCnt\n'1부터 전체 열 개수까지 반복\nvarTemp(v, j) = Cells(r, j)\n'배열에 전체 행을 넣음\nNext j\n'----------------------------\n' 중복이 있는 행의 데이터 처리\n'----------------------------\nElseIf i > 0 Then\n'중복이 있는 경우\nSet rngLastCol = Cells(r - i, Columns.Count).End(1)\n'중복 첫행 날짜셀을 변수에 넣음\nFor j = i To 1 Step -1\n'중복 2행부터 1씩 빼면서 반복\n'------------------------\n' 가장 최근 날짜 찾는 코드\n'------------------------\nWith Cells(r - j + 1, Columns.Count)\n'제일 오른쪽 열에서\nIf .End(1).Column >= rngLastCol.Column Then\n'종단셀 왼쪽으로 가면서 만난 셀이 마지막 날짜셀의 열보다 크면\nSet rngLastCol = .End(1)\n'새로운 셀을 마지막날짜 셀로\nEnd If\nEnd With\nNext j\nFor j = 1 To colsCnt\n'1부터 전체 열 개수까지 반복\nvarTemp(v, j) = Cells(rngLastCol.Row, j)\nNext j\n'배열에 중복된 값을 합쳐감\nEnd If\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀이 나올때까지 무한 반복\nv = 0\n'(배열행)재사용 위하여 초기화\nActiveSheet.UsedRange.Clear\n'현재시트 사용영역 삭제\nCells(1, 1).Resize(\nUBound\n(varTemp, 1), colsCnt) = varTemp\n'배열 값을 셀에 뿌림\nNext colNo\nActiveSheet.UsedRange.Sort Cells(1, 6), 1, Header:=True\n'F열 기준 오름차순 정렬\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "F열에 중복 없는 데이터와, F열에 중복이 있는 데이터 중 가장 최근 날짜에 데이터가 입력된 행만 추출\nD열에도 동일한 기준을 적용\n각 데이터 시트 오른쪽에 새로운 시트를 생성하고 추출한 데이터를 복사\n1행은 날짜, G열 이후는 소수점 1자리까지 표시 등....\n매크로 실행 전.\n(빨간 화살표 : 갑4 가 중복된 상태. 16행의 날짜에 더 최근 날짜 데이터가 있으므로 16행만 추출.\n파란 화살표 : A6 이 중복된 상태. 19행의 날짜에 더 최근 날짜 데이터가 있으므로 19행만 추출.)\n매크로 실행 후 결과 (각 데이터 시트 옆에 결과시트가 삽입됨)\nOption Explicit\nSub improved_Data_Consolidate_1()\nDim wks As Worksheet\n'각 시트를 넣을 변수\nDim s As Integer\n'시트 위치 늘려갈 변수\nWith Application\n.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n.\nDisplayAlerts\n..."}
{"instruction": "Excel VBA code for: (1436) 폴더내 파일을 열지 않고 데이터 통합 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_All_Sheets_In_Folder_5()\n﻿\nDim shtName As String\n'데이터 입력된 시트의 이름넣을 변수\nDim rngData As Range\n'데이터를 가져올 영역을 넣을 변수\nDim rngTarget As Range\n'데이터가 복사될 위치 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim v As Integer\n'배열크기 늘려갈 변수\nDim varFiles()\n'전체 파일 이름 넣을 변수\nDim s As Integer\n'배열개수(파일개수)만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nshtName = \"\nSheet1\n\"\n'데이터가 입력된 시트이름을 변수에 넣음\nSet rngData = Range(\"\nB2:E4\n\")\n'데이터를 가져올 영역을 변수에 넣음\nSet rngTarget = Range(\"B12\")\n'데이터가 복사될 위치\nrowsCnt = rngData.Rows.Count\n'전체 행개수를 변수에 넣음\ncolsCnt = rngData.Columns.Count\n'전체 열개수를 변수에 넣음\nWith rngData\n.ClearContents\n'기존 데이터 삭제\nrngData.Offset(10).ClearContents\n'임시 복사영역 '기존 데이터 삭제\nEnd With\nWith Application.FileDialog(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 종료\nElse\n'폴더 선택시\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While fileName <> \"\"\n'이름이 없지 않다면, 즉, 엑셀파일이 존재하면\nv = v + 1\n'배열크기 1씩 늘려감\nReDim Preserve varFiles(1 To v)\n'배열값 유지하며 크기 재설정\nvarFiles(v) = fileName\n'다음 파일을 파일이름에 넣음\nfileName = Dir\nLoop\n'무한 반복\nFor s = 1 To UBound(varFiles)\n'1 ~ 변수의 상한값까지 반복\nbring_Data\nstrPath & varFiles(s), _\nshtName, _\nrngData.Address(0, 0), _\nrngTarget\n'데이터를 가져오는 하위 함수 호출\nWith rngData.Offset(4, -1).Resize(rowsCnt + 1, colsCnt + 1)\n[A1].Consolidate Sources:=Array(.Address(1, 1, xlR1C1, 1), _\n.Offset(5).Address(1, 1, xlR1C1, 1)), Function:=xlSum, _\nTopRow:=True, LeftColumn:=True\n'데이터 통합기능을 이용해 합쳐간다\nEnd With\nNext s\nSet rngData = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngTarget = Nothing\nEnd Sub\n\nPrivate Sub bring_Data\n(varFile As Variant, _\nstrSht As String, _\nrngD As String, _\nrngT As Range)\n'파일이름, 시트이름, 영역, 복사위치 변수\n'----------------------------------------------------------\n'  에러날 경우 VBE 도구(Tools) => 참조(References)에\n'  Microsoft ActiveX Data Object Library 2.8 또는 6.0 참조\n'----------------------------------------------------------\nDim objCon As Object\n'Connection 개체 넣을 변수\nDim objData As Object\n'RecordSet 데이터 넣을 변수\nDim strConn As String\n'Connection 넣을 변수\nDim strSQL As String\n'SQL 조건을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nIf Val(Application.Version) < 12 Then\n'엑셀 2007 아래버전의 경우\nstrConn = \"Provider=Microsoft.Jet.OLEDB.4.0;\" & _\n\"Data Source=\" & varFile & \";\" & _\n\"Extended Properties=\"\"Excel 8.0;HDR=NO\"\";\"\n'연결 생성\nElse\n'엑셀 2007 버전 이상인 경우\nstrConn = \"Provider=Microsoft.ACE.OLEDB.12.0;\" & _\n\"Data Source=\" & varFile & \";\" & _\n\"Extended Properties=\"\"Excel 12.0;HDR=NO\"\";\"\nEnd If\nstrSQL = \"SELECT * FROM [\" & strSht$ & \"$\" & rngD$ & \"];\"\n'영역내 모든 데이터 가져옴\nSet objCon = CreateObject(\"ADODB.Connection\")\n'생성된 연결 개체변수에 넣음\nSet objData = CreateObject(\"ADODB.Recordset\")\n'연결된 데이터 개체변수에 넣음\nobjCon.Open strConn\n'Connection을 연다\nobjData.Open strSQL, objCon, 0, 1, 1\n'조건에 따라 데이터 연결하여 연다.\nIf Not objData.EOF Then\n'파일의 마지막이 아니라 데이터가 존재하면\nrngT.CopyFromRecordset objData\n'Recordset을 복사될 위치 복사\nElse\nMsgBox varFile & \"에 데이터가 없음\", 16, \"데이터 없음\"\nEnd If\n'데이터 없을 경우 메시지 출력\nobjData.Close\n'Recordset을 닫음\nobjCon.Close\n'연결을 끊음\nSet objData = Nothing\n'개체변수들 초기화\nSet objCon = Nothing\nEnd Sub", "context": "가능하면 모든 것을 엑셀내에서 해결해 보려고 하지만, 파일을 열지 않고 많은 데이터 작업할 경우 역시 ADO는 상당히 유용하다.\n정리하면, 폴더내에 많은 엑셀파일이 있고 이를 통합해야할 경우(첨부된 엑셀 데이터 기준),\nFormulaArray :\nhttp://blog.naver.com/rosa0189/60208407897\n→ 초당\n100\n개 정도 파일작업\n작은 영역의 데이터를 가져올 경우 : ExecuteExcel4Macro 유리    → 초당\n50\n개 정도 파일작업\n넓은 영역의 데이터를 한 번에 가져올 경우 : ADO가 유리             → 초당\n20\n개 정도 파일작업\n넓은 또는 복수의 영역에서 여러 작업을 해야할 경우 :                 → 초당\n3\n개 정도 파일작업\n이 때에는 어쩔 수 없이 파일을 열고, 데이터를 배열에\n넣고, 파일을 닫고, 배열내 데이터를 가공하는 코드를\n사용할 수 밖에 없다.\nABC 폴더내에 60개의 파일이 있음.       Sheet1..."}
{"instruction": "Excel VBA code for: (1437) 열방향 주소 행으로 분리하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub split_Address()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim varTemp\n'추출한 값들을 넣을 배열변수\nDim r As Long\n'행을 늘려갈 변수\nDim v As Long\n'배열 행(1차원) 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim blnTF As Boolean\n'주소 구분자로 사용할 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count, \"A\").End(3).\nRow\n'A열 마지막 행을 변수에\nReDim varTemp(1 To lastRow, 1 To 5)\n'배열크기 재지정\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nv = v + 1\n'배열 행(1차원)을 1씩 늘려감\nvarTemp(v, 1) = Cells(r, 1).Row\n'주소의 행 번호를 배열에 넣음\nDo\n'다음을 실행\nFor i = 2 To 5\n'2 ~ 5까지 1씩 증가하며 반복\nFor Each rngC In Range(\"B1:B10\")\n'B열 문자영역 각 셀을 순환\nIf Cells(r + 2, 1) = \"\" Then\n'현재행보다 2행 뒤가 빈셀(마지막 데이터)이면\nvarTemp(v, i) = Cells(r, 1)\n'배열에 셀주소를 넣음\nvarTemp(v, i + 1) = Cells(r + 1, 1)\n'배열에 번지수 넣음\nGoTo\nfinalData\n'종료위해 마지막 코드로 이동\nElseIf rngC = Split(Cells(r + 2, 1), \" \")\n(0)\nThen\n'2행 아래 첫 단어가 D열 문자일 경우\nvarTemp(v, i) = Cells(r, 1)\n'배열에 주소 넣음\nblnTF =\nTrue\n'주소 구분자 반전\nExit Do\n'Do ... Loop Until True 구문 종료\nEnd If\nNext rngC\nvarTemp(v, i) = Cells(r, 1)\n'배열에 주소를 넣음\nr = r + 1\n'행을 1씩 늘려감\nNext i\nLoop Until\nTrue\n'1회만 실행하고 종료\nblnTF =\nFalse\n'주소 구분자 초기화\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nfinalData:\n'최종 데이터 처리후 이동할 코드\nCells(2, 3).Resize(UBound(varTemp, 1), 5) = varTemp\n'배열값 셀에 뿌림\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지 출력\nEnd Sub", "context": "주소가 A열에 1열로 입력된 상태.\n각 주소는 3행 또는 4행으로 불규칙한 상태.\n각 주소의 시작행 번호와 함께 주소를 C:G 열에 분리하는 기능. (이런 코드는 데이터가 잘못 입력된 경우 에러나기 쉽상이므로 데이터가 반드시 규칙적으로 입력되어 있어야 한다.)\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub split_Address()\nDim lastRow As Long\n'마지막 행을 넣을 변수\nDim varTemp\n'추출한 값들을 넣을 배열변수\nDim r As Long\n'행을 늘려갈 변수\nDim v As Long\n'배열 행(1차원) 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim blnTF As Boolean\n'주소 구분자로 사용할 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nlastRow = Cells(Rows.Count,..."}
{"instruction": "Excel VBA code for: (1439) 숫자들 더하여 특정 합계 만들기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_And_Make_Sum()\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역변수\nDim rngRow As Range\n'각 행(Row)을 넣을 영역변수\nDim i As Long\n'반복구문에 사용할 변수\nDim j As Long\n'무작위로 추출한 숫자 넣을 변수\nDim varTemp()\n'동적배열로 사용할 변수\nDim v As Integer\n'배열크기 늘려갈 변수\nDim y As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Offset(, 13).ClearContents\n'기존 데이터 삭제\nFor Each rngC In Range(\"L1:L10\")\n'L1:L10 영역의 각 셀을 순환\nrngC = WorksheetFunction.\nRandBetween\n(50, 100)\nNext rngC\n'50~100 사이의 무작위 숫자 출력\nFor Each rngRow In Range(\"A1:J10\").\nRows\n'A1:J10 영역의 각 행을 순환\nFor i = 1 To 100\n'100회 반복\nFor y = 1 To 30\n'30회 반복\nj =\nInt\n(\nRnd\n() * 10 + 1)\n'1 ~ 10 사이의 무작위 숫자 추출\nv = v + 1\n'동적배열 크기 1씩 늘려감\nReDim Preserve\nvarTemp(1 To v)\n'배열크기 재지정\nvarTemp(v) = rngRow.Cells(j)\n'배열에 추출한 셀 값을 넣음\nIf WorksheetFunction.\nSum\n(varTemp) = _\nrngRow.Offset(, 11).Cells(1) Then\n'배열의 합계가 L열과 같은 경우\nrngRow.Offset(, 13).Cells(1).Resize(, UBound(varTemp)) = varTemp\n'배열내 값을 시트에 뿌림\nv = 0\n'배열위치 늘려가는 카운터 초기화\nErase\nvarTemp\n'배열 초기화\nExit For\n'For 구문 종료\nEnd If\nNext y\nv = 0\n'배열위치 늘려가는 카운터 초기화\nErase varTemp\n'배열 초기화\nNext i\nNext rngRow\nColumns.AutoFit\n'열너비 자동 맞춤\nEnd Sub", "context": "50 ~ 100 사이의 숫자를 L열에 출력.\nA:J 열에 있는 숫자들을 무작위로 합하여(중복허용) L열의 숫자와 일치하도록 하는 기능.\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub combine_And_Make_Sum()\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역변수\nDim rngRow As Range\n'각 행(Row)을 넣을 영역변수\nDim i As Long\n'반복구문에 사용할 변수\nDim j As Long\n'무작위로 추출한 숫자 넣을 변수\nDim varTemp()\n'동적배열로 사용할 변수\nDim v As Integer\n'배열크기 늘려갈 변수\nDim y As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Offset(, 13).ClearContents\n'기존 데이터 삭제\nFor Each rngC In Ran..."}
{"instruction": "Excel VBA code for: (1440) 데이터 이동하며 합치기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_Two_Data()\nDim rngAll As Range\n'전체(All) 영역을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim r As Long\n:\nr = 1\n'Sheet1의 행(r)ow 1 부터 시작\nDim cnt As Integer\n'카운터(c)ou(nt)er로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(3)\n'Sheet3 에서\n.UsedRange.\nClear\n'기존 데이터 삭제\n.Cells(1, 1).Resize(, 2) =\nArray\n(\"출석번호\", \"전공\")\n'제목행 복사\nColumns(\"B\").Copy .Cells(1, 3)\n' \"취미\" 전체를 sheet3에 복사\nSet rngAll = Range([B2], Cells(Rows.Count, _\n\"B\").End(3)).Offset(, -1).\nSpecialCells(2)\n'A열 전체영역 문자입력된 영역을 변수에 넣음\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nr = r + 1\n'(Sheet1) 행을 1씩 늘려감\nIf rngC.Offset(-1) = \"\" Then\n'위 셀이 빈셀이라면\nDo\n'다음을 실행\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nLoop Until\nrngC.Offset(-cnt - 1) <> \"\"\n'위 셀에 값이 입력된셀 만날때까지 무한반복\n.Cells(.Rows.Count, 1).End(3)(2 + cnt).Resize(, 2) = _\nSheets(1).Cells(r, 1).Resize(, 2).Value\n'cnt + 1 행을 건너 뛰고 2열의 값을 복사\ncnt = 0\n'재사용 위하여 카운터 초기화\nElse\n'위 셀이 빈셀이 아니라면\n.Cells(.Rows.Count, 1).End(3)(2).Resize(, 2) = _\nSheets(1).Cells(r, 1).Resize(, 2).Value\n'2열의 값을 복사\nEnd If\nNext rngC\n.Activate\n'활성화\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\"\nEnd Sub", "context": "매크로 실행 전 Sheet1               매크로 실행 전 Sheet2                 매크로 실행 후 Sheet3의 결과\nOption Explicit\nSub combine_Two_Data()\nDim rngAll As Range\n'전체(All) 영역을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim r As Long\n:\nr = 1\n'Sheet1의 행(r)ow 1 부터 시작\nDim cnt As Integer\n'카운터(c)ou(nt)er로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(3)\n'Sheet3 에서\n.UsedRange.\nClear\n'기존 데이터 삭제\n.Cells(1, 1).Resize(, 2) =\nArray\n(\"출석번호\", \"전공\")\n'제목행 복사\nColumns(\"B\").Copy .Cells(1, 3)\n' \"취미\" 전체를 sheet3에 복사..."}
{"instruction": "Excel VBA code for: (1441) 학년별 반별 과목점수 통합하기 9 (엑셀 VBA 매크로)", "input": "", "output": "Sub consolidate_Same_Group_9()\nDim shp As Shape\n'도형을 넣을 변수\nDim s As Integer\n'반복구문에 사용할 변수\nDim strName As String\n'피벗 테이블 이름 넣을 변수\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim rngT As Range\n'피벗테이블이 생성될 지점\nDim strFld As String\n'원하는 필드 넣을 변수\nDim intPosi As Integer\n'필드 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nActiveSheet.UsedRange.Clear\n'기존 데이터 삭제\nFor Each shp In ActiveSheet.\nShapes\n'시트내 모든 도형 순환\nIf shp.Name <> \"Run Macro\" Then\n'매크로 실행 버튼이 아니면\nshp.\nDelete\n'도형 삭제\nEnd If\nNext shp\nSheets(2).Rows(1).\nCopy\nCells(1, 1)\n'제목행 복사\n'----------------------------------\n' 데이터 시트를 모두 합치는 코드\n'----------------------------------\nFor s = 2 To Sheets.Count\n'2번째 시트부터 마지막 시트까지\nSheets(s).UsedRange.Offset(1).Copy _\nCells(Rows.Count, \"A\").End(xlUp)(2)\n'각 시트 제목행 빼고 복사하여 통합\nNext s\n'-----------------------------------\n' 피벗 테이블 조건을 설정하는 코드\n'-----------------------------------\nstrName = \"PivotTable1\"\n'피벗 테이블 이름을 변수에\nSet\nrngAll = Range(\"A1\").CurrentRegion\n'전체 영역을 개체변수에\ncolsCnt = rngAll.Columns.Count\n'전체 열 개수를 변수에\nSet rngT = Cells(1, Columns.Count).End\n(xlToLeft)(1, 3)\n'피벗테이블 생성 위치를 변수에\n'------------------------------------------\n' 피벗 테이블을 조건에 따라 생성하는 코드\n'------------------------------------------\nActiveWorkbook.\nPivotCaches.Create\n(1, rngAll, 5).\nCreatePivotTable\n_\nTableDestination:=rngT, _\nTableName:=strName, _\nDefaultVersion:=5\n'현재파일에 피벗테이블을 rngT 위치에 strName 이름 엑셀 2013 버전으로 생성\n'----------------------------------\n' 피벗 테이블의 테이블 생성 코드\n'----------------------------------\nWith ActiveSheet.PivotTables(strName)\n'현재시트 피벗테이블\nFor s = 1 To 2\n'1 ~ 2까지 1씩 늘려가며 반복\nstrFld =\nChoose\n(s, \"학년\", \"반\")\n'필드를 선택함\nintPosi = Choose(s, 1, 2)\n'필드 위치 선택함\nWith .\nPivotFields\n(strFld)\n'각 필드\n.Orientation = xlRowField\n'행 방향\n.Position = intPosi\n'각 위치\nEnd With\nNext s\n'--------------------------------\n' 테이블에 데이터 입력하는 코드\n'--------------------------------\nFor s = 1 To 3\n'1 ~ 3까지 1씩 늘려가며 반복\nstrFld = Choose(s, \"국어\", \"영어\", \"수학\")\n'필드를 선택함\n.\nAddDataField\n.PivotFields(strFld), strFld &\n\"합계\", xlSum\nNext s\n'\"각 필드 데이터를 넣음\nEnd With\n'----------------------------\n' 막대차트를 삽입하는 코드\n'----------------------------\nWith ActiveSheet\n'현재 시트에서\n.Shapes.\nAddChart2\n(201, xlColumnClustered).Select\n'차트삽입\nWith .Cells(Rows.Count, \"H\").End(xlUp)(3)\n'마지막 데이터 1행 건너뛴 위치\nSelection.Left = .Left\n'차트 왼쪽을 셀 왼쪽위치로\nSelection.Top = .Top\n'차트 윗쪽을 셀 윗쪽 위치로\nSelection.Width = .Resize(, 4).Width - 5\n'차트의 폭 설정\nSelection.Height = .Resize(10).Height - 5\n'차트의 높이 설정\nEnd With\nActiveChart.\nSetSourceData\nSource:=.UsedRange\n'현재시트 사용영역을 차트영역으로\n.PageSetup.Orientation = xlLandscape\n'페이지를 가로 보기로\nEnd With\nColumns(\"A:F\").AutoFit\n'열너비 자동 맞춤\nColumns(\"H:K\").AutoFit\n'열너비 자동 맞춤\nSet rngAll = Nothing\n'개체변수(들) 초기화\nSet rngT = Nothing\nMsgBox \"매크로가 종료되었습니다.\"\n'메시지창 출력\nEnd Sub", "context": "학년별, 반별, 과목별 점수를 피벗기능을 이용하여 통합하고 차트를 출력하여 이를 보여주는 기능\n매크로 실행 전 Main 시트\n매크로 실행 전 Sheet1                                          매크로 실행 전 Sheet 2\n매크로 실행 전 Sheet3 (비어 있음)                         매크로 실행 전 Sheet4\n매크로 실행 후 Main 시트의 결과(화면 캡춰의 크기 제한으로 차트를 작게 출력하여 잘 보이지 않음.)\nOption Explicit\nSub consolidate_Same_Group_9()\nDim shp As Shape\n'도형을 넣을 변수\nDim s As Integer\n'반복구문에 사용할 변수\nDim strName As String\n'피벗 테이블 이름 넣을 변수\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim rngT As ..."}
{"instruction": "Excel VBA code for: (1443) 복수의 시트 원하는 이름으로 한 번에 삽입하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub add_Sheets_Before_And_After_3()\nDim strAddr As String\n'선택영역 주소를 넣을 변수\nDim wkSht As Worksheet\n'각 시트를 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim shtIdx As Integer\n'활성화된 시트 번호 넣을 변수\nDim varTemp\n'배열로 사용할 변수\nDim rowsCnt As Long\n'열 개수 넣을 변수\nDim msg As String\n'메시지 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim cnt As Integer\n'시트 카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nshtIdx = ActiveSheet.\nIndex\n'현재시트 인덱스(시트번호)를 변수에 넣음\nWith Selection\n'선택영역에서\nstrAddr =\n.Address\n'주소를 변수에 넣음\nrowsCnt = .Rows.Count\n'행 개수 변수에 넣음\nvarTemp =\n.Value\n'각 값을 배열에 넣음\n'-------------------------------\n' 에러 예방을 위해 작성된 코드\n'-------------------------------\nIf .Columns.\nCount\n> 1 Or .Areas.Count > 1 Then\n'열 개수가 1보다 크면\nMsgBox \"1개의 area에, 1열만 선택하세요.\", 64, \"영역설정 에러\"\nExit Sub\n'매크로 종료\nEnd If\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nIf rngC = vbNullString Then\n'빈 셀이 있을 경우\nMsgBox \"선택영역에 빈셀이 있습니다.\", 64, \"셀의 문자입력 오류\"\nExit Sub\n'메시지 출력 후 매크로 종료\nEnd If\nNext rngC\n'-----------------------------------------\n' 이미 동일한 시트 생성된 경우 처리코드\n'-----------------------------------------\nFor Each wkSht In ActiveWorkbook.Worksheets\n'각 시트를 순환\nFor Each rngC In Selection\n'선택영역 각 셀을 순환\nIf rngC.Value = wkSht.\nName\nThen\n'만약 중복되는 이름 있으면\nMsgBox \"시트이름[ \" & wkSht.Name & \" ]이 중복\", 64, \"시트이름 중복오류\"\nExit Sub\n'메시지 출력 후 매크로 종료\nEnd If\nNext rngC\nNext wkSht\nEnd With\nmsg = MsgBox(\"시트를 앞에 삽입시 Yes, 뒤에 삽입시 No 선택\", vbYesNoCancel, \"위치 선택\")\n'메시지 출력\nCells.Copy\nSelect Case\nmsg\n'메시지의 결과에 따라\nCase\nvbYes\n'Yes선택시\n'------------------------------------------------\n' Yes 선택 시 Main 시트 앞에 시트 생성하는 코드\n'------------------------------------------------\nFor i = 1 To rowsCnt\n'1~ 선택영역의 행 개수까지 1씩 증가하며 반복\nSheets.\nAdd\nbefore:=\nSheets(shtIdx + cnt)\n'현재시트 앞쪽에 시트 삽입\nActiveSheet.Paste\n'붙여 넣기\nRange(\"A1\").Select\n'A1셀 선택\nActiveSheet.Range(strAddr) = \"\"\n'현재시트 선택영역과 같은 영역 데이터 삭제\ncnt = cnt + 1\n'시트 카운터를 1씩 늘려감\nIf rowsCnt = 1 Then\n'선택한 셀이 1개일 경우\nActiveSheet.Name = varTemp\n'배열 값을 시트 이름에 넣음\nElse\n'선택한 셀이 2개 이상일 경우\nActiveSheet.Name = varTemp(i, 1)\n'배열내 값을 순차적으로 시트이름에 넣음\nEnd If\nNext i\nSheets(shtIdx + cnt).Activate\n'Main 파일 활성화\nCase\nvbNo\n'No 선택 시\n'-------------------------------------------------\n' No 선택 시 Main 시트 뒤에 시트 생성하는 코드\n'-------------------------------------------------\nFor i = rowsCnt To 1 Step -1\n'선택영역의 행개수까지 1씩 증가하며 반복\nSheets.\nAdd after:=\nSheets(shtIdx)\n'현재시트 뒤쪽에 시트 삽입\nActiveSheet.Paste\n'붙여 넣기\nRange(\"A1\").Select\n'A1셀 선택\nActiveSheet.Range(strAddr) = \"\"\n'현재시트 선택영역과 같은 영역 데이터 삭제\ncnt = cnt + 1\n'시트 카운터를 1씩 늘려감\nIf rowsCnt = 1 Then\n'선택한 셀이 1개일 경우\nActiveSheet.Name = varTemp\n'배열 값을 시트 이름에 넣음\nElse\n'선택한 셀이 2개 이상일 경우\nActiveSheet.Name = varTemp(i, 1)\n'배열내 값을 순차적으로 시트이름에 넣음\nEnd If\nNext i\nSheets(shtIdx).Activate\n'Main 파일 활성화\nEnd Select\nApplication.CutCopyMode = False\n'클립보드 비우기\nEnd Sub", "context": "앞서 복수의 시트를 한 번에 생성하는 두 개의 코드 (\nhttp://blog.naver.com/rosa0189/60135279544\n,\nhttp://blog.naver.com/rosa0189/60204299305\n를 약간 보완한 코드이다.)\n생성할 시트의 이름을 만들고, 시트이름이 적힌 영역을 선택하고 매크로 실행 시, 현재시트의 앞 또는 뒤에 선택한 영역의 이름대로 현재시트(Main)를 복사하여 주는 기능. 에러 발생 예방을 위해서 코드가 조금 길어 졌다.\n매크로 실행 전                                               매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1443) 복수의 시트 원하는 이름으로 한 번에 삽입하기 3 (엑셀 VBA 매크로)\n재생\n1,535\n재생 (space/k)\n재생\n00:34\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:..."}
{"instruction": "Excel VBA code for: (1444) 선택영역의 홀수 또는 짝수행 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Every_Other_Rows()\nDim msg As String\n'메시지(m)e(s)sa(g)e 출력에 사용할 변수\nDim rowsCnt As Long\n'선택영역의 행 개수(C)ou(nt) 넣을 변수\nDim r As Long\n'행(r)ow 반복에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nIf Selection.\nRows\n.\nCount\n= 1 Then\n'선택영이 1행일 경우\nMsgBox \"1행만 선택하여 삭제할 행이 없음\"\n'메시지창 출력\nExit Sub\n'매크로 종료\nEnd If\nIf Selection.\nAreas\n.Count > 1 Then\n'선택 구역이 1개 보다 많을 경우\nMsgBox \"1개의 구역만 선택해야합니다.\"\n'메시지창 출력\nExit Sub\n'매크로 종료\nEnd If\nrowsCnt = Selection.Rows.Count\n'전체 행 개수를 변수에 넣음\nmsg =\nMsgBox\n(\"홀수행 삭제는 Yes, 짝수행 삭제는 No 선택\", _\nvbYesNoCancel, \"홀/짝수행 선택\")\n'메시지창 출력\nSelect Case msg\n'Yes/No 선택에 따라서\nCase vbYes\n'메시지창에서 Yes 선택시\nIf rowsCnt\nMod\n2 = 0 Then rowsCnt = rowsCnt - 1\n'전체행을 2로 나눈 나머지가 0일 경우 전체행을 1 빼줌\nFor r = rowsCnt To 1 Step -2\n'2씩 빼가며 1행까지 반복\nSelection.\nRows(r).Delete\n'전체행 삭제\nNext r\nCase vbNo\n'메시지창에서 No 선택시\nIf rowsCnt Mod 2 = 1 Then rowsCnt = rowsCnt - 1\n'전체행을 2로 나눈 나머지가 1일 경우 전체행을 1 빼줌\nFor r = rowsCnt To 1 Step -2\n'2씩 빼가며 1행까지 반복\nSelection.Rows(r).Delete\n'전체행 삭제\nNext r\nEnd Select\nEnd Sub", "context": "영역을 선택하고 매크로 실행 시 선택창이 나타나며, 홀수/짝수행 선택에 따라 선택영역의 행을 번갈아가면서 삭제해주는 기능\n매크로 실행 전                                                    매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1444) 선택영역의 홀수 또는 짝수행 삭제하기 (엑셀 VBA 매크로)\n재생\n2,047\n재생 (space/k)\n재생\n00:22\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:22\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 ..."}
{"instruction": "Excel VBA code for: (1445) 그룹별로 외곽선 그리기 (엑셀 VBA 매크로)", "input": "", "output": "Sub draw_Lines_As_Grouped()\n'외곽에 테두리 그리는 프로시저\nDim rngC As Range\n'각 셀을 넣을 영역 변수\nDim i As Integer\n'반복구문에 사용할 변수\nFor Each rngC In ActiveSheet.UsedRange\n'현재시트 사용영역 각 셀을 순환\nIf\nLen\n(rngC) > 0 Then\n'각 셀에 아무 값이나 입력되어 있으면\nrngC.\nBorders\n(7).\nLineStyle\n= 1\n'왼쪽에 선그리기\nrngC.Borders(8).LineStyle = 1\n'상\nrngC.Borders(10).LineStyle = 1\n'하\nElseIf Len(rngC) = 0 Then\n'각 셀이 빈셀이면\nrngC.Borders(7).LineStyle = 1\n'좌\nrngC.Borders(10).LineStyle = 1\n'하\nEnd If\nNext rngC\nWith ActiveSheet.UsedRange\n'현재시트 사용 영역에서\nFor i = 7 To 10\n'7부터 1씩 증가하며 반복\n.Borders(i).\nWeight\n= xlMedium\n'상하좌우 외곽에 굵은선\nNext i\nEnd With\nEnd Sub", "context": "조건부 서식을 이용하여서도 빠르게 그릴 수 있지만, 조건부 서식은 테두리가 그려진 영역을 다른 셀 또는 다른 시트에 복사하면 조건부서식이 계속 따라다녀서 상당히 귀찮다.\n매크로 실행 전 영역을 선택한 모습 (영역을 먼저 선택하고 매크로 실행해야 함)\n매크로 실행 후 결과 (외곽에 굵은선 처리하고, 내부는 그룹별로 가는선으로 외곽선을 그려준다.)\nOption Explicit\nSub draw_Lines_As_Grouped()\n'외곽에 테두리 그리는 프로시저\nDim rngC As Range\n'각 셀을 넣을 영역 변수\nDim i As Integer\n'반복구문에 사용할 변수\nFor Each rngC In ActiveSheet.UsedRange\n'현재시트 사용영역 각 셀을 순환\nIf\nLen\n(rngC) > 0 Then\n'각 셀에 아무 값이나 입력되어 있으면\nrngC.\nBorders\n(7).\nLineStyle\n= 1\n'왼쪽에 선그리기\nrngC.Borders(8).LineStyle = 1\n'상\nr..."}
{"instruction": "Excel VBA code for: (1446) 문자 나누기(TextToColumns) 기본코드 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub textToColumns_xlDelimited()\nCall\ninitiate_TextToColumns_xlDelimited\n'문자나누기 옵션들 초기화 코드실행\nSelection.\nTextToColumns\n_\nDestination:=Selection.Cells(1).Offset(, 1), _\nDataType:=\nxlDelimited\n, _\nComma:=True\n'콤마로만 오른쪽 열에 나누고 싶은 경우\nEnd Sub\n\nSub textToColumns_xlFixedWidth()\nDim intCnt As Integer\n'나뉘어질 문자 길이 넣을 변수\nDim varCol\n'나뉘어질 문자 길이 넣을 배열변수\nDim i As Integer\n'반복구문에 사용할 변수\nCall initiate_TextToColumns_xlDelimited\n'문자나누기 옵션들 초기화 코드실행\nintCnt = 5\n'나뉘어질 문자 길이\nReDim varCol(0 To 999)\n'배열크기 재지정 (999는 적당히 넣은것)\nFor i = LBound(varCol) To UBound(varCol)\n'배열 하한값에서 상한값까지 반복\nvarCol(i) =\nArray(i * intCnt, 1\n)\n'나뉘어질 문자길이 배열을 배열에 넣음\nNext i\nSelection.TextToColumns _\nDestination:=Selection.Offset(, 1), _\nDataType:=\nxlFixedWidth\n, _\nFieldInfo:=varCol, _\nTrailingMinusNumbers:=True\n'지정한 문자 길이대로 오른쪽 열에 문자 분리\nColumns.AutoFit\n'열너비 자동 맞춤\nEnd Sub\n\nSub initiate_TextToColumns_xlDelimited()\nWith Cells(Rows.Count, 1)\n.Value = \"temp\"\n.TextToColumns _\nDestination:=Cells(Rows.Count, 2), _\nDataType:=xlDelimited, _\nTextQualifier:=xlDoubleQuote, _\nConsecutiveDelimiter:=False, _\nTab:=False, _\nSemicolon:=False, _\nComma:=False, _\nSpace:=False, _\nOther:=False, _\nOtherChar:=\"\", _\nFieldInfo:=Array(Array(1, 1)), _\nTrailingMinusNumbers:=True\nCells(Rows.Count, 1).EntireRow.Delete\nEnd With\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 결과 (위에는 콤마(,)를 이용하여 구분하고 아래는 5개의 문자씩 끊어서 분리)\nSub textToColumns_xlDelimited()\nCall\ninitiate_TextToColumns_xlDelimited\n'문자나누기 옵션들 초기화 코드실행\nSelection.\nTextToColumns\n_\nDestination:=Selection.Cells(1).Offset(, 1), _\nDataType:=\nxlDelimited\n, _\nComma:=True\n'콤마로만 오른쪽 열에 나누고 싶은 경우\nEnd Sub\n------------------------------------------------------------------------------------------\nSub textToColumns_xlFixedWidth()\nDim intCnt As Integer\n'나뉘어질 문자 길이 넣을 변수\nDim varCol\n'나뉘어질 문자 길이 넣을 배열변수\nDim i ..."}
{"instruction": "Excel VBA code for: (1449) 빈 셀에만 값을 복사하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_To_Blank_Cells_Only_1()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Columns(1).SpecialCells(2)\n'A열 문자입력된 셀을 순환\nFor Each\nrngC\nIn\nrngAll\n'전체영역(rngAll)의 각셀(rngC)을 순환\nIf rngC.Next =\nvbNullString\nThen\n'오른쪽 셀이 빈셀이면\nrngC.\nNext\n= rngC\n'B열에 A열 값을 복사\nEnd If\nNext\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                                      매크로 실행 후 결과\nOption Explicit\nSub copy_To_Blank_Cells_Only_1()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Columns(1).SpecialCells(2)\n'A열 문자입력된 셀을 순환\nFor Each\nrngC\nIn\nrngAll\n'전체영역(rngAll)의 각셀(rngC)을 순환\nIf rngC.Next =\nvbNullString\nThen\n'오른쪽 셀이 빈셀이면\nrngC.\nNext\n= rngC\n'B열에 A열 값을 복사\nEnd If\nNext\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub..."}
{"instruction": "Excel VBA code for: (1450) 빈 셀에만 값을 복사하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_To_Blank_Cells_Only_2()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Columns(2).\nSpecialCells(4)\n'B열 공백 셀을 순환\nFor Each rngC In rngAll\n'전체영역(rngAll)의 각셀(rngC)을 순환\nIf\nLen\n(rngC) =\n0\nThen\n'빈셀이면\nrngC = rngC.\nPrevious\n'B열에 A열 값을 복사\nEnd If\nNext\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                                      매크로 실행 후 결과\nOption Explicit\nSub copy_To_Blank_Cells_Only_2()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Columns(2).\nSpecialCells(4)\n'B열 공백 셀을 순환\nFor Each rngC In rngAll\n'전체영역(rngAll)의 각셀(rngC)을 순환\nIf\nLen\n(rngC) =\n0\nThen\n'빈셀이면\nrngC = rngC.\nPrevious\n'B열에 A열 값을 복사\nEnd If\nNext\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub..."}
{"instruction": "Excel VBA code for: (1451) 빈 셀에만 값을 복사하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_To_Blank_Cells_Only_3()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngArea As Range\n'공백 area를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Columns(2).\nSpecialCells(4)\n'B열 공백 셀을 순환\nFor Each rngArea In rngAll.\nAreas\n'전체영역(rngAll)의 각 area 를 순환\nrngArea = rngArea.Offset(, -1).Value\n'각 공백 area에 A열의 값을 복사\nNext\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                                      매크로 실행 후 결과\nOption Explicit\nSub copy_To_Blank_Cells_Only_3()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngArea As Range\n'공백 area를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Columns(2).\nSpecialCells(4)\n'B열 공백 셀을 순환\nFor Each rngArea In rngAll.\nAreas\n'전체영역(rngAll)의 각 area 를 순환\nrngArea = rngArea.Offset(, -1).Value\n'각 공백 area에 A열의 값을 복사\nNext\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub..."}
{"instruction": "Excel VBA code for: (1452) 빈 셀에만 값을 복사하기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_To_Blank_Cells_Only_4()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Columns(1).SpecialCells(2)\n'A열 문자입력된 셀을 순환\nFor Each rngC In rngAll\n'전체영역(rngAll)의 각셀(rngC)을 순환\nIf rngC.Next = vbNullString Then\n'오른쪽 셀이 빈셀이면\nWith rngC.Next\n'각셀 오른쪽 셀에\n.\nFormula\n= \"=\nINDEX\n($A$1:$A$17,\nROW\n())\"\n'수식을 각 셀에 복사\n.\nValue\n= .\nValue\n'수식을 값으로 변환\nEnd With\nEnd If\nNext\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                                      매크로 실행 후 결과\nOption Explicit\nSub copy_To_Blank_Cells_Only_4()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Columns(1).SpecialCells(2)\n'A열 문자입력된 셀을 순환\nFor Each rngC In rngAll\n'전체영역(rngAll)의 각셀(rngC)을 순환\nIf rngC.Next = vbNullString Then\n'오른쪽 셀이 빈셀이면\nWith rngC.Next\n'각셀 오른쪽 셀에\n.\nFormula\n= \"=\nINDEX\n($A$1:$A$17,\nROW\n())\"\n'수식을 각 셀에 복사\n.\nValue\n= .\nVal..."}
{"instruction": "Excel VBA code for: (1453) 첫 숫자 제외하고 0의 개수 세기 (엑셀 VBA 매크로)", "input": "", "output": "Sub count_Each_One()\nDim i As Integer\n'열방향으로 1 ~ 3 까지 늘려갈 변수\nDim r As Long\n'행 1씩 늘려갈 변수\nDim cnt As Long\n'연속되는 0의 개수 넣을 카운터\nDim blnTF As\nBoolean\n'첫 번째 1인지 아닌지 판단할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"E:G\").\nClear\n'E:F열의 데이터 삭제\nFor i = 1 To 3\n'1 ~ 3까지 1씩 증가하며 반복\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nIf Cells(r, i) = 0 Then\n'셀 값이 0이라면\nCells(r, i).Offset(, 4) = 0\n'오른쪽으로 4열 건너 0 입력\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nElse\n'셀 값이 1이라면\nIf blnTF =\nFalse\nThen\n'첫번째 1이라면\nWith Cells(r, i).Offset(, 4)\n'오른쪽으로 4열 건너 셀\n.\nValue\n= 0\n'0 입력\n.\nInterior.Color\n= Cells(r, i).Interior.Color\n'같은 색으로 색 채우기\nEnd With\ncnt = 0\n'카운터 초기화\nblnTF = True\n'첫 번째 1 지난것 확인\nElse\n'첫 번째 1이 아니라면\nWith Cells(r, i).Offset(, 4)\n'오\n른쪽 4열 건너셀\n.Value = cnt + 1\n'값으로 카운터 + 1 입력\n.Interior.ColorIndex = 6\n'노란 색으로 색 채우기\nEnd With\ncnt = 0\n'카운터 초기화\nEnd If\nEnd If\nLoop Until\nCells(r + 1, i) = \"\"\n'빈 셀이 나올때까지 무한 반복\nr = 0\n'행 초기화\ncnt = 0\n'카운터 초기화\nblnTF = False\n'첫 번째 1 판단기준 초기화\nNext i\nMsgBox \"매크로가 종료되었습니다.\"\n'메시지 출력\nEnd Sub", "context": "1. 각 열의 첫 숫자 1은 예외로 제외한다.\n2. 아래에 있는 1이 앞에 있는 1로 부터 0을 건너 뛴 몇 번째 인지를 기록하는 기능. (결과를 알아보기 쉽게 하기 위하여 노란색으로 결과 값에 색을 칠함)\n매크로 실행 전                                                              매크로 실행 후 결과\nOption Explicit\nSub count_Each_One()\nDim i As Integer\n'열방향으로 1 ~ 3 까지 늘려갈 변수\nDim r As Long\n'행 1씩 늘려갈 변수\nDim cnt As Long\n'연속되는 0의 개수 넣을 카운터\nDim blnTF As\nBoolean\n'첫 번째 1인지 아닌지 판단할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"E:G\").\nClear\n'E:F열의 데이터 삭제\nFor i = 1 To 3\n'1 ~ 3까지 1씩 증가하며 반..."}
{"instruction": "Excel VBA code for: (1454) 두 역간의 KTX 기차 시간표 추출 (엑셀 VBA 매크로)", "input": "", "output": "Private Sub Worksheet_Change(ByVal Target As Range)\n'시트내 셀값이 바뀌면 자동으로 실행되는 매크로(변경셀을 영역변수에 넣음)\nDim rngRow As Range\n'출발/도착역 행(Row) 영역 넣을 영역(개체)변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 영역(개체)변수\nDim rngLeft As Range\n'출발역을 넣을 영역(개체)변수\nDim rngRight As Range\n'도착역을 넣을 영역(개체)변수\nDim r As Long\n'행(r) 늘려갈 변수\nDim rngT As Range\n'데이터 복사 위치(T)arget 넣을 영역(개체)변수\nDim rngData As Range\n'추출한 데이터의 영역을 넣을 영역(개체)변수\nIf Target.\nCount\n> 1 Then Exit Sub\n'1개 셀보다 많이 선택시 매크로 종료\nIf Range(\"B2\") = \"\"\nOr\nRange(\"D2\") = \"\" Then Exit Sub\n'B2 또는 D2셀이 공백일 경우 매크로 종료\nIf Range(\"B2\") = Range(\"D2\") Then\n'B2셀이 D2셀일 경우\nGoTo\nerrHandler\n'에러 처리 구문으로 이동\nEnd If\nSet rngRow = Sheets(2).Range(\"A4:M4\")\n'출발/도착역 데이터 영역을 변수에 넣음\nFor Each rngC In rngRow\n'출발/도착역 영역을\nIf rngC = Range(\"B2\") Then\n'셀값이 B2셀과 일치 시\nSet\nrngLeft = rngC\n'셀값을 rngLeft에 넣음\nEnd If\nIf rngC = Range(\"D2\") Then\n'셀값이 D2셀과 일치 시\nSet rngRight = rngC\n'셀값을 rngRight에 넣음\nEnd If\nNext rngC\nIf rngLeft.\nColumn\n> rngRight.Column Then\n'출발역이 도착역보다 오른쪽에 있을 경우\nGoTo errHandler\n'에러처리 구문으로 이동\nEnd If\nIf Target.\nAddress(0, 0)\n= \"B2\" Or _\nTarget.Address(0, 0) = \"D2\" Then\n'변경된 셀이 B2 또는 D2 셀일 경우\nApplication.\nEnableEvents\n= False\n'이벤트 트리거링 기능을 중단\nActiveSheet.UsedRange.Offset(3).Clear\n'기존 데이터 삭제\nWith Sheets(2)\n'Sheet2 에서\nr = 6\n'6 행부터 시작\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nIf .Cells(r, rngLeft.Column) <> \"\" And _\n.Cells(r, rngRight.Column) <> \"\" Then\n'출발역/도착역 모두 빈셀이 아닐때\nSet rngT = Cells(Rows.Count, 1).End(3)(2)\n'A열 종단셀 윗방향 셀 바로 아래셀을 복사위치로 지정\nrngT = .Cells(r, 1)\n'복사위치에 열차번호 입력\nrngT.Offset(, 1) = .Cells(r, rngLeft.Column)\n'복사위치 오른쪽 열에 출발시각 입력\nrngT.Offset(, 2) = .Cells(r, rngRight.Column)\n'복사위치 2열 오른쪽에 도착시각 입력\nEnd If\nLoop Until\n.Cells(r + 1, 1) = \"\"\n'빈셀이 나올때까지 무한 반복\nEnd With\nIf Range(\"A4\") = \"\" Then\n'A4 셀이 빈셀일 경우\nGoTo errHandler\n'에러처리 구문으로 이동\nEnd If\nSet rngData = Range(\"A4\", Cells(Rows.Count, 1).End(3))\n'데이터 영역을 개체변수에 넣음\nIf Cells(Rows.Count, 1).End(3).Row > 4 Then\n'데이터 최종행이 4보다 크면\nrngData.Offset(, 3).\nFormulaR1C1\n= _\n\"=\nABS\n(RC[-1]-RC[-2])\"\n'D열에 시간계산 수식을 입력\nElse\n'데이터 최종행이 4보다 작거나 같으면\nRange(\"D4\").FormulaR1C1 = \"=ABS(RC[-1]-RC[-2])\"\n'D4셀에 시간계산 수식을 입력\nEnd If\nCells.\nReplace\nWhat:=\"\" & Chr(10) & \"*\", Replacement:=\"\"\n'Alt + Enter로 입력된 데이터를 삭제\nrngData.EntireRow.\nAutoFit\n'열높이 자동 맞춤\nColumns(\"B:E\").\nNumberFormat\n= \"hh:mm\"\n'B:E열 서식을 시간으로 설정\nApplication.EnableEvents = True\n'이벤트 트리거링 기능을 복원\nExit Sub\n'매크로 종료\nElse\n'B2 또는 D2셀이 아닐 경우\nExit Sub\n'매크로 종료\nEnd If\nerrHandler:\nMsgBox \"조건에 맞는 기차가 없습니다.\", 64, \"열차 없음\"\n'에러 메시지창 출력\nApplication.EnableEvents = True\n'이벤트 트리거링 기능을 복원\nEnd Sub", "context": "(아래의 코드는 Module이 아닌 Sheet 에 넣어야 한다.)\n매크로 실행 전\n매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1454) 두 역간의 KTX 기차 시간표 추출 (엑셀 VBA 매크로)\n재생\n574\n재생 (space/k)\n재생\n00:38\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:38\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\nSheet2에는 철도청에서 다..."}
{"instruction": "Excel VBA code for: (1455) 선택영역 첫 열 중복데이터 기준으로 마지막열 셀병합하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub merge_Last_Column()\nDim colsCnt As Integer\n'선택영역 열 개수(C)ou(nt)를 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'중복행 개수를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Selection\n'선택 영역에서\ncolsCnt = .\nColumns.Count\n'열 개수를 변수에 넣음\nIf colsCnt < 2 Then\n'선택영의 열이 1개일 경우\nMsgBox \"복수의 열을 선택하시오\"\n'메시지창 출력\nExit Sub\n'매크로 종료\nEnd If\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nIf .Cells(r, 1) = .Cells(r + 1, 1) Then\n'위 아래 셀 값이 같으면\ni = i + 1\n'중복 카운터를1씩 늘려감\nElse\n'위 아래 셀 값이 다르면\nApplication.\nDisplayAlerts\n=\nFalse\n'화면 경고 중단\n.Cells(r, colsCnt).Offset(-i).Resize(i + 1).Merge\n'중복영역 셀병합\nApplication.DisplayAlerts = True\n'화면 경고 복원\ni = 0\n'재사용 위하여 초기화\nEnd If\nLoop Until\nr = .\nRows.Count\n'선택영역 마지막 행까지 무한 반복\nEnd With\nEnd Sub", "context": "제목과 같이 선택영역 첫 열을 중복된 데이터를 기준으로 마지막 열을 셀병합 해주는 기능이다. 당연히 매크로 실행 전\n먼저 영역을 선택\n해야 한다. 선택하는 영영의 열 크기는 제한이 없다. 자세한 내용은 아래 동영상 참조.\n매크로 실행 전                                                   매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1455) 선택영역 첫 열 중복데이터 기준으로 마지막열 셀병합하기 (엑셀 VBA 매크로)\n재생\n1,482\n재생 (space/k)\n재생\n00:19\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:19\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2...."}
{"instruction": "Excel VBA code for: (1457) 한글, 한자 분리하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Hanmun_2()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rngC As Range\n'선택영역의 각 셀을 넣을 변수\nDim r As Integer\n'셀의 문자길이만큼 반복할 변수\nDim str As String\n'추출한 각 문자 넣을 변수\nDim cnt As Integer\n'첫 한문의 위치 찾을 카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.Offset(, 2).\nClearContents\n'기존 데이터 삭제\nSet rngAll = Columns(\"B\").\nSpecialCells(2)\n'B열 문자입력된셀 전체영역을 변수에 넣음\nFor Each rngC In rngAll\n'B열 문자입력 영역 각 셀을 순환\nFor r = 1 To\nLen\n(rngC)\n'각셀의 문자 길이 만큼 반복\nstr =\nAsc\n(\nMid\n(rngC, r, 1))\n'셀의 각 문자를 변수에 넣음\ncnt = cnt + 1\n'카운터 1씩 늘려감\nIf str >= -13663 And str <= -514 Then\n'각 문자가 한문이면\nrngC.Next =\nLeft\n(rngC, cnt - 1)\n'오른쪽 셀에 한글만 추출\nrngC.Offset(, 2) =\nRight\n(rngC, Len(rngC) - cnt + 1)\n'2열 오른쪽에 한문만 추출\nExit For\n'For 구문 종료\nEnd If\nNext r\ncnt = 0\n'재사용 위하여 초기화\nNext rngC\nFor Each rngC In rngAll.Offset(, 2)\n'D열 각 셀을 순환\nrngC =\nTrim\n(rngC)\n'각 셀의 앞뒤 공백(space) 제거\nrngC =\nReplace\n(rngC, \".\", \",\")\n'각 셀의 점(.)을 콤마(,)로 바꿈\nrngC = Replace(rngC, \" \", \",\")\n'각 셀의 공백(space)를 콤마로 바꿈\nrngC = Replace(rngC, \",,\", \",\")\n'각 셀의 이중 콤마를 단일 콤마로 변경\nNext rngC\nrngAll.Offset(, 2).\nTextToColumns\n_\nDestination:=rngAll.Cells(1).Offset(, 3), _\nDataType:=xlDelimited, _\nComma:=True\n'콤마를 기준으로 E1셀에 문자 분리\nColumns.AutoFit\n'열너비 자동 맞춤\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "1. 한글과 한문을 분리\n2. 분리된 한문을 각 단어로 분리\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub extract_Hanmun_2()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rngC As Range\n'선택영역의 각 셀을 넣을 변수\nDim r As Integer\n'셀의 문자길이만큼 반복할 변수\nDim str As String\n'추출한 각 문자 넣을 변수\nDim cnt As Integer\n'첫 한문의 위치 찾을 카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.Offset(, 2).\nClearContents\n'기존 데이터 삭제\nSet rngAll = Columns(\"B\").\nSpecialCells(2)\n'B열 문자입력된셀 전체영역을 변수에 넣음\nFor Each rngC In rngAll\n'B열 문자입력 영역 각 셀을 순환\nF..."}
{"instruction": "Excel VBA code for: (1458) 공백 셀에 페이지 구분선 추가하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub add_Pagebreak_To_Blanks()\nDim rngC As Range\n'각 셀을 넣을 변수\nWith ActiveSheet\n'현재 시트에서\n.\nResetAllPageBreaks\n'기존 페이지 구분선 삭제\nFor Each rngC In Range(\"B4\", Cells(Rows.Count, \"B\").End(3))\n'B열 전체 데이터 영역의 각 셀을 순환\nIf rngC.Offset(-1) = \"\" Then\n'윗셀이 공백셀이라면\n.\nHPageBreaks.Add\nBefore:=rngC\n'페이지 구분선을 삽입\nEnd If\nNext rngC\nEnd With\nEnd Sub", "context": "B열에 공백셀이 있을 경우 이 공백셀 아래에 페이지 구분선을 추가하는 기능.\n매크로 실행 전                                                   매크로 실행 후 결과 (페이지 구분선이 추가됨)\nOption Explicit\nSub add_Pagebreak_To_Blanks()\nDim rngC As Range\n'각 셀을 넣을 변수\nWith ActiveSheet\n'현재 시트에서\n.\nResetAllPageBreaks\n'기존 페이지 구분선 삭제\nFor Each rngC In Range(\"B4\", Cells(Rows.Count, \"B\").End(3))\n'B열 전체 데이터 영역의 각 셀을 순환\nIf rngC.Offset(-1) = \"\" Then\n'윗셀이 공백셀이라면\n.\nHPageBreaks.Add\nBefore:=rngC\n'페이지 구분선을 삽입\nEnd If\nNext rngC\nEnd With\nEnd Sub..."}
{"instruction": "Excel VBA code for: (1460) 문자 분리후 일치하는 단어 삭제 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_The_Same_Word()\nDim rngAll As Range\n'D열 전체(All) 영역을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim varTemp\n'문자를 분리하여 넣을 배열변수\nDim rngRow As Range\n'각 행(Row)을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.Offset(, 4).ClearContents\n'기존 데이터 삭제\nSet\nrngAll = Range(\"D1\", Cells(Rows.Count, \"D\").End(3))\n'D열 전체 영역을 개체변수에 넣음\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nIf\nInStr\n(rngC, \"<br>\") Then\n'각 셀에 <br> 이 포함된 경우\nvarTemp =\nSplit\n(rngC, \"<br>\")\n'문자를 <br>로 분리하여 배열에 넣음\nFor i =\nLBound\n(varTemp) To\nUBound\n(varTemp)\n'배열 하한값에서 상한값까지 반복\nrngC.Offset(, i + 1) =\nTrim\n(varTemp(i))\n'E열부터 분리한 문자를 셀에 입력\nNext i\nElse\n'<br>이 포함되지 않은 경우\nrngC.Next = Trim(rngC)\n'좌우 공백 제거 후 E열에 입력\nEnd If\nNext rngC\nFor Each rngRow In rngAll.Offset(, -3).Resize(, 3).Rows\n'A:C 열의 각 행을 순환\nFor Each rngC In rngRow.Cells\n'A:C 각 행의 셀들을 순환\nrngC = Trim(rngC)\n'좌우 공백을 제거하여 셀에 넣음\nFor i = 5 To 9\n'5 부터 1씩 증가하며 9까지 반복\nIf rngC = Cells(rngC.Row, i) Then rngC = \"\"\n'분리한 문자와 셀값이 일치시 삭제\nNext i\nNext rngC\nNext rngRow\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. A:C 열에 있는 단어와 D열에 있는 단어가 일치 시 이를 삭제하는 기능\n2. A:C 열에 중복 단어가 있을 수 있으며, D열은 <br>이 단어 사이에 삽입된 상황\n3. 단어의 앞 또는 뒤에, 또는 <br>의 앞 뒤에 공백(space)이 불필요하게 입력된 상황\n4. <br>의 개수 또한 셀마다 일정치 않음.\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub delete_The_Same_Word()\nDim rngAll As Range\n'D열 전체(All) 영역을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim varTemp\n'문자를 분리하여 넣을 배열변수\nDim rngRow As Range\n'각 행(Row)을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nActiveSheet.UsedRange.Offset(, 4)..."}
{"instruction": "Excel VBA code for: (1461) Old 와 New 두 시트의 유일한 데이터, 중복데이터 및 중복 없는 통합데이터 추출 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Duplicated_Data_3()\nDim s As Integer\n'시트(s)heet 개수 늘려갈 변수\nDim colsCnt As Integer\n'전체 열 개수 넣기 위한 변수\nDim varCol As Variant\n'중복삭제 열 개수 array 넣을 배열변수\nDim v As Long\n'중복삭제 array 반복할 변수\nDim varO As Variant\n'Old 시트내 A열 넣을 배열변수\nDim varOld As Variant\n'Old 시트 전체자료 넣기위한 배열변수\nDim varN As Variant\n'New 시트내 A열 넣을 변수\nDim varNew As Variant\n'New 시트 전체자료 넣기 위한 배열변수\nDim rowsCnt As Long\n'Old + New 전체행 넣을 변수\nDim varBoth\n'양쪽(B)oth에 중복된 자료 넣을 배열\nDim vO As Variant\n'varO 내 각 값을 넣을 배열변수\nDim vN As Variant\n'varN 내 각 값을 넣을 배열변수\nDim i As Long\n'Old 배열내 행을 늘려나갈 변수\nDim j As Long\n'New 배열내 행을 늘려갈 변수\nDim x As Integer\n'열 개수 늘려갈 변수\nDim cnt As Long\n'카운터로 사용할 변수\nDim r As Long\n'배열 크기 늘려갈 변수\nWith WorksheetFunction\n'엑셀함수\nIf .CountA(Range(\"A2:A3\")) < 2 Or _\n.CountA(Sheets(2).Range(\"A2:A3\")) < 2 Then\n'1번 또는 2번시트 A2:A3셀이 빈 경우\nMsgBox \"작업할 데이터가 부족합니다.\", 64, \"데이터 입력 오류\"\nExit Sub\n'메시지 출력 후 매크로 종료\nEnd If\nEnd With\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n.Calculation =\nxlCalculationManual\n'셀계산 수동으로 전환\nEnd With\nWorksheets.\nFillAcrossSheets\nRange(\"1:1\")\n'전체 시트에 제목행 복사\nFor s = 3 To 6\n'3 ~ 6번 시트에서 반복\nSheets(s).UsedRange.Offset(1).Clear\n'기존 데이터 삭제\nNext s\n'-------------------------------------------------\n'열 개수 추출하고 Old / New 시트의 중복을 제거\n'-------------------------------------------------\ncolsCnt = Sheets(1).UsedRange.Columns.Count\n'전체 열 개수를 변수에 넣음\nReDim\nvarCol(0 To colsCnt - 1)\n'배열크기 재지정\nFor v = 0 To colsCnt - 1\n'전체 열 개수만큼 반복\nvarCol(v) = v + 1\n'배열에 열 개수를 넣음\nNext v\nFor s = 1 To 2\n'Old와 New 시트의 중복 제거\nSheets(s).UsedRange.\nRemoveDuplicates\n_\nColumns:=(varCol), Header:=xlYes\n'전체열 모두 일치 시 중복제거\nNext s\n'--------------------------------------------------------\n'각 배열에 제목 제외한 Old / New 시트의 데이터를 넣음\n'--------------------------------------------------------\nWith Sheets(1).UsedRange\n'1번 시트 사용영역에서\nvarO = Range(\"A2\", _\nCells(Rows.Count, \"A\").End(3))\n'제목 제외한 A열을 배열에 넣음\nvarOld = .Offset(1).Resize(.Rows.Count - 1)\nEnd With\n'제목빼고 배열에 넣음\nWith Sheets(2)\n'2번 시트\nvarN = Range(.Range(\"A2\"), _\n.Cells(Rows.Count, \"A\").End(3))\n'A열을 배열에 넣음\nWith .UsedRange\nvarNew = .Offset(1).Resize(.Rows.Count - 1)\n'제목빼고 배열에 넣음\nEnd With\nEnd With\n'---------------------------------------\n'varBoth 배열의 크기를 결정하는 코드\n'---------------------------------------\nIf\nUBound\n(varOld, 1) > UBound(varNew, 1) Then\n'Old 행이 더 크면\nrowsCnt = UBound(varOld, 1)\n'Old행을 rowsCnt에 넣고\nElse\n'New 행이 더 크거나 같으면\nrowsCnt = UBound(varNew, 1)\n'New 행을 rowsCnt에 넣음\nEnd If\nReDim varBoth(1 To rowsCnt, 1 To colsCnt)\n'배열크기 재지정\n'------------------------------------------------------\n' 먼저 \"이름\"이 일치하는지 검색 후 나머지 열들을 검사\n'------------------------------------------------------\nFor Each vO In varO\n'Old A열 각 셀을 순환\ni = i + 1\n'Old A열 행을 늘려감\n﻿\n﻿\nDo\n'다음을 실행﻿\nFor Each vN In varN\n'New A열 각 셀을 순환\nj = j + 1\n'New A열 행을 늘려감\nIf vO = vN Then\n'이름이 일치하면\nFor x = 2 To colsCnt\n'2 ~ 마지막 열까지 반복\nIf varOld(i, x) = varNew(j, x) Then\n'값이 같다면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nElse\n:\ncnt = 0\n'카운터 값을 초기화\nExit\nFor\n'값이 다르면 for 구문 종료\nEnd If\nNext x\n'---------------------------------------------------------\n' 중복 데이터를 varBoth에 넣고 varOld / varNew에서는 삭제\n'---------------------------------------------------------\nIf cnt = colsCnt - 1 Then\n'2 ~ 마지막 열까지 같다면\ncnt = 0\n'재사용 위하여 초기화\nr = r + 1\n'배열 개수 1씩 늘려감\nFor x = 1 To colsCnt\n'전체 열 개수만큼 반복\nvarBoth(r, x) = varOld(i, x)\n'중복데이터를 varBoth에 넣음\nvarOld(i, x) =\nEmpty\n'varOld 내의 중복데이터 삭제\nvarNew(j, x) = Empty\n'varNew 내의 중복데이터 삭제\nNext x\nExit Do\n'Do 구문종료\nEnd If\nEnd If\nNext vN\nLoop Until True\n'1회만 실행 후 종료\nj = 0\n'New의 행값 초기화\nNext vO\n'-----------------------------------------------------\n' 각 배열에 넣은 값들을 해당 시트에 뿌려주는 코드\n'-----------------------------------------------------\nSheets(3).Cells(2, 1).Resize(UBound(varOld, 1), _\ncolsCnt) = varOld\n'varOld 배열값을 OldOnly에 뿌림\nIf r > 0 Then\n'배열이 비어 있지 않으면\nSheets(4).Cells(2, 1).Resize(UBound(varBoth, 1), _\ncolsCnt) = varBoth\n'varBoth 배열값을 Both에 뿌림\nEnd If\nSheets(5).Cells(2, 1).Resize(UBound(varNew, 1), _\ncolsCnt) = varNew\n'varNew 배열값을 NewOnly에 뿌림\n'-------------------------------------------------------------\n' varOld, varNew, varBoth 배열에 추출한 값을 All 시트에 통합\n'-------------------------------------------------------------\nWith Sheets(6).Cells(Rows.Count, \"A\")\n.End(3)(2).Resize(UBound(varOld, 1), _\ncolsCnt) = varOld\n'varOld 배열값을 All에 뿌림\nIf r > 0 Then\n'배열이 비어 있지 않으면\n.End(3)(2).Resize(UBound(varBoth, 1), _\ncolsCnt) = varBoth\n'varBoth 배열값을 All에 뿌림\nEnd If\n.End(3)(2).Resize(UBound(varNew, 1), colsCnt) = varNew\n'varNew 배열값을 All에 뿌림\nEnd With\n'-----------------------------------------------------\n' 각 시트의 서식을 설정하고, 정렬한 뒤 열너비 맞춤\n'-----------------------------------------------------\nFor s = 3 To 6\n'3 ~ 6번 시트에서 반복\nWith Sheets(s)\n'각 시트에서\n.Columns(\"E\").\nNumberFormat\n= \"yyyy-mm-dd\"\n'E열의 서식을 날짜로 설정\n.UsedRange.\nSort\n.[A1], 1, Header:=True\n'각 시트를 이름순으로 오름차순 정렬\n.Columns.AutoFit\n'열너비 자동 맞춤\nEnd With\nNext s\nWith Application\n.Calculation =\nxlCalculationAutomatic\n'셀계산 자동으로 돌려놓음\n.ScreenUpdating = True\n'화면업데이트 재 실행\nEnd With\nMsgBox \"데이터 추출이 완료되었습니다.\"\n'완료 메시지 출력\nEnd Sub", "context": "앞서 올린\nhttp://blog.naver.com/rosa0189/60204925163\n코드는 동적배열을 사용하여 데이터의 행 개수가 65536개로 제한이 있었다. 아래의 코드는 변수를 재 정의하여 행 제한을 없앴다.\nOld 시트와 New 시트에 여러 데이터가 있음.\nOld 시트에만 있는 데이터를 OldOnly시트에, 양쪽에 중복되어 있는 데이터를 Both시트에, New 시트에만 있는 데이터를 NewOnly시트에, Old와 New 시트를 통합한 데이터를 ALL시트에 추출하는 기능.\n최소 2행 이상의 데이터가 있어야 하며, 데이터의 행 또는 열 개수 제한이 없음.\n전체 행에서 1자만 틀려도 전체행은 다른 데이터로 취급된다.\n매크로 사용이 익숙치 않으면 첨부된 코드를 다운받고 자신의 데이터를 Old 시트와 New 시트에 복사하여 넣고 매크로 버튼만 클릭하면 된다. 본인의 데이터에 날짜열이 없을 경우 아래 코드에서 Sheets(i).Columns(\"E\").NumberFormat = \"yy..."}
{"instruction": "Excel VBA code for: (1462) 숫자만 추출하여 가로로 뿌리기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Post_Count_1()\nDim r As Long\n'6행씩 늘려갈 변수\nDim rngR As Range\n'각 행의 영역을 넣을 영역변수\nDim j As Long\n'Sheet2 에서 1행씩 늘려갈 변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim y As Long\n'Sheet1에서 1행씩 늘려갈 변수\nDim strEach As String\n'각 문자를 넣을 변수\nDim strU As String\n'합쳐진 숫자를 넣을 변수\nDim x As Integer\n'열방향 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Offset(1).ClearContents\n'기존 데이터 삭제\nr = 1\n'1행부터 시작\nDo\n'다음을 실행\nSet rngR = Worksheets(2).Cells(r, 1).Resize(6)\n'6행씩 묶어서 개체변수에 넣음\nFor Each rngC In rngR\n'rngR 내의 각 셀을 순환\nFor i = 1 To Len(rngC)\n'셀의 문자 길이 개수만큼 반복\nstrEach = Mid(rngC, i, 1)\n'각 문자를 변수에 넣음\nIf strEach\nLike \"[0-9]\"\nThen\n'각 문자가 숫자일 경우\nstrU = strU & strEach\n'숫자를 합쳐감\nEnd If\nNext i\nCells(2 + j, x + 1) =\nVal\n(strU)\n'합쳐진 숫자를 값으로 변환후 셀에 뿌림\nx = x + 1\n'Sheet2 열을 1씩 늘려감\nstrU = \"\"\n'재사용 위하여 초기화\ny = y + 1\n'Sheet1 행을 1씩 늘려감\nNext rngC\nr = r + 6\n'Sheet1 6행씩 건너 뜀\nj = j + 1\n'Sheet2 1행씩 늘려감\nx = 0\n'재사용 위하여 초기화\nLoop Until\nWorksheets(2).Cells(r, 1) = \"\"\n'Sheet1 A열에 빈셀 나올때까지 무한반복\nEnd Sub", "context": "매크로 실행 전 Sheet1                                                  매크로 실행 전 Sheet1\n매크로 실행 후 Sheet1의 결과\nOption Explicit\nSub extract_Post_Count_1()\nDim r As Long\n'6행씩 늘려갈 변수\nDim rngR As Range\n'각 행의 영역을 넣을 영역변수\nDim j As Long\n'Sheet2 에서 1행씩 늘려갈 변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim y As Long\n'Sheet1에서 1행씩 늘려갈 변수\nDim strEach As String\n'각 문자를 넣을 변수\nDim strU As String\n'합쳐진 숫자를 넣을 변수\nDim x As Integer\n'열방향 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveS..."}
{"instruction": "Excel VBA code for: (1463) 숫자만 추출하여 가로로 뿌리기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Post_Count_2()\nDim r As Long\n'Shee2 행을 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim strEach As String\n'각 문자를 넣을 변수\nDim strU As String\n'합쳐진 숫자를 넣을 변수\nDim j As Long\n'Sheet1에서 1행씩 늘려갈 변수\nDim x As Integer\n'열방향 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Offset(1).\nClearContents\n'기존 데이터 삭제\nWith Worksheets(2)\n'Sheet2에서\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nx = x + 1\n'열을 1씩 늘려감\nFor i = 1 To Len(.Cells(r, 1))\n'셀의 문자 길이 개수만큼 반복\nstrEach = Mid(.Cells(r, 1), i, 1)\n'각 문자를 변수에 넣음\nIf strEach\nLike \"[0-9]\"\nThen\n'각 문자가 숫자일 경우\nstrU = strU & strEach\n'숫자를 합쳐감\nEnd If\nNext i\nCells(2 + j, x) =\nVal\n(strU)\n'합쳐진 숫자를 값으로 변환후 셀에 뿌림\nIf x = 6 Then\n'열이 6개 더해지면\nj = j + 1\n'행을 1 늘리고\nx = 0\n'열 값을 초기화\nEnd If\nstrU = \"\"\n'재사용 위하여 초기화\nLoop Until\n.Cells(r + 1, 1) = \"\"\n'A열에 빈셀 나올때까지 무한반복\nEnd With\nEnd Sub", "context": "매크로 실행 전 Sheet1                                                  매크로 실행 전 Sheet1\n매크로 실행 후 Sheet1의 결과\nOption Explicit\nSub extract_Post_Count_2()\nDim r As Long\n'Shee2 행을 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim strEach As String\n'각 문자를 넣을 변수\nDim strU As String\n'합쳐진 숫자를 넣을 변수\nDim j As Long\n'Sheet1에서 1행씩 늘려갈 변수\nDim x As Integer\n'열방향 1씩 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Offset(1).\nClearContents\n'기존 데이터 삭제\nWith Worksheets(2)\n'Sheet2에서\nDo\n'다음을 실행\nr = r + ..."}
{"instruction": "Excel VBA code for: (1464) 특정데이터 전체행 삭제하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_And_Delete_Row()\nDim strF As String\n'검색(F)ind 할 단어 넣을 변수\nDim wks As Worksheet\n'각 시트를 넣을 변수\nDim rowsCnt As Long\n'전체 행의 개수 넣을 변수\nDim colsCnt As Integer\n'전체 열의 개수 넣을 변수\nDim varTemp\n'각 행을 넣을 배열로 사용할 변수\nDim strU As String\n'각 행의 문자를 합칠 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열 1차원(행방향) 1씩 늘려갈 변수\nDim rngR As Range\n'각 행(R)ow 을 넣을 개체변수\nDim varR\n'결과를 넣을 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nstrF = Range(\"F1\").Value\n'행 삭제를 할 문자\nFor Each wks In ActiveWorkbook.Worksheets\n'활성화된 파일의 각 시트를 순환\nr = 1\n'1행 부터 시작\nWith wks\n'각 시트에서\nWith .UsedRange\n'사용영역에서\nrowsCnt = .Rows.Count\n'전체 행개수를 변수에 넣음\ncolsCnt = .Columns.Count\n'전체 열개수를 변수에 넣음\nEnd With\nReDim\nvarR(2 To rowsCnt, 1 To 1)\n'배열크기 재지정\nFor i = 2 To rowsCnt\n'2행부터 마지막 행까지 반복\nSet rngR = .Cells(i, 1).Resize(, colsCnt)\n'각 행을 개체변수에 넣음\nvarTemp = rngR\n'행 전체를 배열에 넣음\nWith\nApplication\n'엑셀에서\nstrU =\nJoin\n(.\nTranspose\n(.\nTranspose\n(varTemp)), \"\")\n'2차원 배열을 2번 행열 변환하여 1차원 배열로 바꿈\nEnd With\nIf\nInStr\n(strU, strF) = 0 Then\n'합쳐진 문자가 strF를 포함하지 않으면\nr = r + 1\n'배열 위치를 1씩 늘려감\nvarR(r, 1) = rngR\n'행 전체를 배열에 넣음\nEnd If\nNext i\nWith .UsedRange\n.Offset(1).Clear\n'기존 데이터 삭제\nFor i = 2 To rowsCnt\n'2행부터 마지막 행까지 반복\n.Cells(i, 1).Resize(, colsCnt) = varR(i, 1)\n'배열내 값을 시트에 뿌림\nNext i\nEnd With\nEnd With\nr = 0\n'재사용 위하여 초기화\nNext wks\nEnd Sub", "context": "1. 파일 전체내에서\nF1셀\n에 있는 문자를 찾아서, 일치할 경우 전체행을 삭제하는 기능.\n2. 제목행은 제외.\n3. 데이터의 위치는 특정 행 또는 특정 열에 한정하지 않음. 즉, 어디에 위치하여도 상관 없음.\n매크로 실행 전 Sheet1 (Sheet2와 Sheet3에도 유사한 데이터가 있음)\n매크로 실행 후 Sheet1의 결과(Sheet2와 Sheet3도 동일한 삭제 결과)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1464) 특정데이터 전체행 삭제하기 1 (엑셀 VBA 매크로)\n재생\n3,881\n공유하기\n재생 (space/k)\n재생\n00:18\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:18\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)..."}
{"instruction": "Excel VBA code for: (1465) 복수의 단어로 조건부 서식적용 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Text_Using_Conditional_Format()\nDim rngAll As Range\n'데이터 전체(A)ll 영역을 넣을 변수\nDim intCol As Integer\n'전체 영역의 열 번호를 넣을 변수\nDim strAddr As String\n'Find 함수의 주소를 넣을 변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim rngFind As Range\n'찾으려는(Find) 영역을 넣을 변수\nSet rngAll = Range(\"A1:D15\")\n'전체 데이터 영역을 개체변수에 넣음\nintCol = 2\n'전체영역의 2번째 열의 데이터 기준\nSet rngFind = Range(\"G1:G3\")\n'찾으려는 조건이 있는 영역을 변수에 넣음\nFor Each rngC In rngFind\n'찾으려는 영역의 각 셀을 순환\nIf\nNot\nIsEmpty\n(rngC) Then\n'각 셀이 빈셀이 아니라면\nstrAddr = rngAll.Columns(2).Cells(1).Address(0, 1)\n'Find 함수에 사용할 주소를 추출\nWith rngAll\n'전체 영역에서\n.\nFormatConditions\n.\nAdd\nType:=xlExpression, _\nFormula1:=\"=FIND(\"\"\" & rngC.Value & \"\"\",\" & strAddr & \")\"\n'Find 함수를 이용한 조건부서식을 추가\n.FormatConditions(.FormatConditions.Count).\nSetFirstPriority\n'조건부서식 우선순위를 최우선으로(이 조건 없으면 한 조건만 색칠해진다.)\nWith .FormatConditions(1).Interior\n'조건부서식의 내부서식\n.PatternColorIndex = xlAutomatic\n'색깔패턴을 자동으로\n.ColorIndex = 36\n'색깔을 옅은 노란색으로\nEnd With\nEnd With\nEnd If\nNext rngC\nSet rngAll = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngFind = Nothing\nEnd Sub\n\nSub delete_Conditional_Format()\nRange(\"A1\").CurrentRegion.FormatConditions.Delete\n'A1 연결셀 영역의 조건부서식 삭제\nEnd Sub", "context": "G열에 있는 단어가 포함된 모든 행을 B열에서 찾아 색으로 표시해주는 기능. DELETE 버튼을 누르면 생성된 색이 모두 삭제된다.\n본인의 위치가 아래 예제와 다른 경우 다음 3가지 조건만 본인의 데이터로 수정하면 된다.\nSet rngAll =\nRange(\"A1:D15\")\n: 전체 데이터 위치\nintCol =\n2\n: 검색할 열의 위치\nSet rngFind =\nRange(\"G1:G3\")\n: 검색할 단어가 들어간 위치\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub find_Text_Using_Conditional_Format()\nDim rngAll As Range\n'데이터 전체(A)ll 영역을 넣을 변수\nDim intCol As Integer\n'전체 영역의 열 번호를 넣을 변수\nDim strAddr As String\n'Find 함수의 주소를 넣을 변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim rngFind As Range\n'찾으..."}
{"instruction": "Excel VBA code for: (1467) 첫 단어와 마지막 단어 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Function first_And_Last(rngC As Range)\n'제일 앞뒤 \"-\"와 단어 합치는 함수(괄호안은 문자 입력된 셀 선택)\nDim var\n'단어를 \"-\" 나누어 넣을 배열변수\nDim strU As String\n'합친 문자를 넣을 변수\nvar =\nSplit\n(rngC, \"-\")\n' \"-\"를 구분자로 셀 값을 분리\nOn Error\nResume Next\n'에러 발생해도 중단 없이 다음코드 진행\nstrU = var(0) & \"-\" & var(UBound(var))\n'제일 앞 뒤 단어를 \"-\"와 함께 합침\nOn Error GoTo 0\n'에러 검출기능 복원\nIf Len(strU) > 0 Then\n'strU 가 비어 있지 않으면\nfirst_And_Last = strU\n'합친 문자를 함수에 돌려줌\nElse\n'strU 가 비어 있으면\nfirst_And_Last = \"\"\n'공백을 함수에 돌려줌\nEnd If\nEnd Function", "context": "사용자 정의 함수 실행 전\n사용자 정의 함수실행 후 결과\nOption Explicit\nFunction first_And_Last(rngC As Range)\n'제일 앞뒤 \"-\"와 단어 합치는 함수(괄호안은 문자 입력된 셀 선택)\nDim var\n'단어를 \"-\" 나누어 넣을 배열변수\nDim strU As String\n'합친 문자를 넣을 변수\nvar =\nSplit\n(rngC, \"-\")\n' \"-\"를 구분자로 셀 값을 분리\nOn Error\nResume Next\n'에러 발생해도 중단 없이 다음코드 진행\nstrU = var(0) & \"-\" & var(UBound(var))\n'제일 앞 뒤 단어를 \"-\"와 함께 합침\nOn Error GoTo 0\n'에러 검출기능 복원\nIf Len(strU) > 0 Then\n'strU 가 비어 있지 않으면\nfirst_And_Last = strU\n'합친 문자를 함수에 돌려줌\nElse\n'strU 가 비어 있으면\nfirst_And_Last = \"\"\n'공백을 함수에 돌려줌\nEn..."}
{"instruction": "Excel VBA code for: (1468) 한글 자모를 영어로 바꾸기 (엑셀 VBA 매크로)", "input": "", "output": "Sub hangul_JaMo_To_English()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Integer\n'전체 문자 길이 만큼 반복할 변수\nDim strEach As String\n'각 문자를 넣을 변수\nDim strU As String\n'합친 문자를 넣을 변수\nDim rngF As Range\n'검색하여 일치한 셀 넣을 변수\nFor Each rngC In Columns(1).SpecialCells(2)\n'A열 문자입력된 각 셀을 순환\nFor i = 1 To Len(rngC)\n'각 셀의 문자 길이 만큼 반복\nstrEach =\nMid$\n(rngC, i, 1)\n'각 문자를 변수에 넣음\nSet rngF = Sheets(2).Columns(1).SpecialCells(2).\nFind\n(what:=strEach)\n'Sheet2 A열 문자에서 일치하는 셀 찾음\nIf\nNo\nt rngF\nIs Nothing\nThen\n'일치하는 셀이 존재하면\nstrU = strU & rngF.Next(, 3)\n'오른쪽 세번째 셀 값을 strU 에 합쳐감\nElse\n'일치하는 셀이 없으면\nstrU = strU & strEach\n'기존 문자를 strU에 합쳐감\nEnd If\nNext i\nrngC.Offset(, 2) = strU\n'합쳐진 문자를 오른쪽 두번째 셀에 출력\nstrU = \"\"\n'재사용 위하여 초기화\nNext rngC\nSet rngF = Nothing\n'개체변수 초기화\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "매크로 실행 전 Sheet1 (바꿀 자모를 알아보기 쉽도록 빨간색으로 표시해 놓았다.)\n매크로 실행 후 Sheet1의 결과\nSheet2에 미리 입력된 비교표\nOption Explicit\nSub hangul_JaMo_To_English()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Integer\n'전체 문자 길이 만큼 반복할 변수\nDim strEach As String\n'각 문자를 넣을 변수\nDim strU As String\n'합친 문자를 넣을 변수\nDim rngF As Range\n'검색하여 일치한 셀 넣을 변수\nFor Each rngC In Columns(1).SpecialCells(2)\n'A열 문자입력된 각 셀을 순환\nFor i = 1 To Len(rngC)\n'각 셀의 문자 길이 만큼 반복\nstrEach =\nMid$\n(rngC, i, 1)\n'각 문자를 변수에 넣음\nSet rngF = Sheets(2).Columns(1).SpecialCells(2).\nFi..."}
{"instruction": "Excel VBA code for: (1469) 두 시트의 다른 데이터 찾아 표시하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Changed_Data_1()\nDim varO As Variant\n'Old 시트내 A열 넣을 배열변수\nDim varOld As Variant\n'Old 시트 전체자료 넣기위한 배열변수\nDim varN As Variant\n'New 시트내 A열 넣을 변수\nDim varNew As Variant\n'New 시트 전체자료 넣기 위한 배열변수\nDim colsCnt As Integer\n'전체 열 개수 넣기 위한 변수\n﻿\nDim vO As Variant\n'varO 내 각 값을 넣을 배열변수\nDim vN As Variant\n'varN 내 각 값을 넣을 배열변수\nDim i As Long\n'Old 배열내 행을 늘려나갈 변수\nDim j As Long\n'New 배열내 행을 늘려갈 변수\nDim x As Integer\n'열 개수 늘려갈 변수\nIf\nWorksheetFunction.CountA\n(Range(\"A2:A3\")) < 2 Or _\nWorksheetFunction.CountA(Sheets(2).Range(\"A2:A3\")) < 2 Then\n'Old 또는 New 시트 A2:A3셀이 빈 경우\nMsgBox \"작업할 데이터가 부족합니다.\", 64, \"데이터 입력 오류\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n.Calculation =\nxlCalculationManual\n'셀계산 수동으로 전환\nEnd With\n'-------------------------------------------------------\n'각 배열에 제목 제외한 Old / New 시트의 데이터를 넣음\n'-------------------------------------------------------\nWith Sheets(1)\n'Old 시트 사용영역에서\nvarO = Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'제목 제외한 A열을 배열에 넣음\nvarOld = .UsedRange.Offset(1).Resize(.UsedRange.\nRows.Count - 1\n)\nEnd With\n'제목빼고 배열에 넣음\nWith Sheets(2)\n'New번 시트\nvarN = Range(.Range(\"A2\"), .Cells(Rows.Count, \"A\").End(3))\n'A열을 배열에 넣음\nvarNew = .UsedRange.Offset(1).Resize(.UsedRange.Rows.Count - 1)\nEnd With\n'제목빼고 배열에 넣음\ncolsCnt = ActiveSheet.UsedRange.\nColumns.Count\n'------------------------------------------------------\n' 먼저 \"이름\"이 일치하는지 검색 후 나머지 열들을 검사\n'------------------------------------------------------\nFor Each vO In varO\n'Old A열 각 셀을 순환\ni = i + 1\n'Old A열 행을 늘려감\nFor Each vN In varN\n'New A열 각 셀을 순환\nj = j + 1\n'New A열 행을 늘려감\nIf vO = vN Then\n'이름이 일치하면\nFor x = 2 To colsCnt\n'2 ~ 마지막 열까지 반복\nIf varOld(i, x) <> varNew(j, x) Then\n'값이 다르다면\nCells(i + 1, x).Interior.\nColorIndex\n= 36\n'셀에 옅은 노란색으로 표시\nEnd If\nNext x\nExit For\n'For 구문 종료\nEnd If\nNext vN\nj = 0\n'New의 행값 초기화\nNext vO\nWith Application\n.Calculation = xlCalculationAutomatic\n'셀계산 자동으로 돌려놓음\n.ScreenUpdating = True\n'화면업데이트 재 실행\nEnd With\nMsgBox \"매크로가 종료되었습니다.\"\n'완료 메시지창 출력\nEnd Sub", "context": "매크로 실행 전 Old 시트 (구분을 위해 미리 New 시트와 다른 데이터들은 테두리를 해두었음)\n매크로 실행 전 New 시트\n매크로 실행 후 Old 시트의 결과 (New 시트와 다른 데이터에 노란색으로 표시하여줌)\nOption Explicit\nSub find_Changed_Data_1()\nDim varO As Variant\n'Old 시트내 A열 넣을 배열변수\nDim varOld As Variant\n'Old 시트 전체자료 넣기위한 배열변수\nDim varN As Variant\n'New 시트내 A열 넣을 변수\nDim varNew As Variant\n'New 시트 전체자료 넣기 위한 배열변수\nDim colsCnt As Integer\n'전체 열 개수 넣기 위한 변수\n﻿\nDim vO As Variant\n'varO 내 각 값을 넣을 배열변수\nDim vN As Variant\n'varN 내 각 값을 넣을 배열변수\nDim i As Long\n'Old 배열내 행을 늘려나갈 변수\nDim j As Long..."}
{"instruction": "Excel VBA code for: (1470) Old 와 New 두 시트의 유일한 데이터, 중복데이터 및 중복 없는 통합데이터 추출 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Duplicated_Data_4()\nDim s As Integer\n'시트(s)heet 개수 늘려갈 변수\nDim colsCnt As Integer\n'전체 열 개수 넣기 위한 변수\nDim varCol As Variant\n'중복삭제 열 개수 array 넣을 배열변수\nDim v As Long\n'중복삭제 array 반복할 변수\nDim varO As Variant\n'Old 시트내 A열 넣을 배열변수\nDim varOld As Variant\n'Old 시트 전체자료 넣기위한 배열변수\nDim varN As Variant\n'New 시트내 A열 넣을 변수\nDim varNew As Variant\n'New 시트 전체자료 넣기 위한 배열변수\nDim rowsCnt As Long\n'Old와 New중 큰 행을 넣을 변수\nDim varBoth\n'양쪽(B)oth에 중복된 자료 넣을 배열\nDim vO As Variant\n'varO 내 각 값을 넣을 배열변수\n﻿\nDim i As Long\n'Old 배열내 행을 늘려나갈 변수\nDim vN As Variant\n'varN 내 각 값을 넣을 배열변수\nDim j As Long\n'New 배열내 행을 늘려갈 변수\nDim r As Long\n'varBoth 배열 위치 늘려갈 변수\nDim x As Integer\n'열 개수 늘려갈 변수\nWith WorksheetFunction\n'엑셀함수\nIf .CountA(Range(\"A2:A3\")) < 2 Or _\n.CountA(Sheets(2).Range(\"A2:A3\")) < 2 Then\n'1번 또는 2번시트 A2:A3셀이 빈 경우\nMsgBox \"작업할 데이터가 부족합니다.\", 64, \"데이터 입력 오류\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nEnd With\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n.Calculation = xlCalculationManual\n'셀계산 수동으로 전환\nEnd With\nWorksheets.\nFillAcrossSheets\nRange(\"1:1\")\n'전체 시트에 제목행 복사\nFor s = 3 To 5\n'3 ~ 5번 시트에서 반복\nSheets(s).UsedRange.Offset(1).Clear\n'기존 데이터 삭제\nNext s\n'--------------------------------------------------\n'열 개수 추출하고 Old / New 시트의 중복을 제거\n'--------------------------------------------------\ncolsCnt = Sheets(1).UsedRange.Columns.Count\n'전체 열 개수를 변수에 넣음\nReDim\nvarCol(0 To colsCnt - 1)\n'배열크기 재지정\nFor v = 0 To colsCnt - 1\n'전체 열 개수만큼 반복\nvarCol(v) = v + 1\n'배열에 열 개수를 넣음\nNext v\nFor s = 1 To 2\n'Old와 New 시트의 중복 제거\nSheets(s).UsedRange.\nRemoveDuplicates\n_\nColumns:=(varCol), Header:=xlYes\n'전체열 모두 일치 시 중복제거\nNext s\n'-------------------------------------------------------\n'각 배열에 제목 제외한 Old / New 시트의 데이터를 넣음\n'-------------------------------------------------------\nWith Sheets(1)\n'1번 시트 사용영역에서\nvarO = Range(\"A2\", _\nCells(Rows.Count, \"A\").End(3))\n'제목 제외한 A열을 배열에 넣음\nvarOld = .UsedRange.Offset(1).Resize(.UsedRange.\nRows.Count - 1\n)\nEnd With\n'제목빼고 배열에 넣음\nWith Sheets(2)\n'2번 시트\nvarN = Range(.Range(\"A2\"), _\n.Cells(Rows.Count, \"A\").End(3))\n'A열을 배열에 넣음\nvarNew = .UsedRange.Offset(1).Resize(.UsedRange.Rows.Count - 1)\nEnd With\n'제목빼고 배열에 넣음\n'-----------------------------------------\n'varBoth 배열의 크기를 결정하는 코드\n'-----------------------------------------\nrowsCnt = UBound(varOld, 1) + UBound(varNew, 1)\n'전체행을 계산하여 변수에 넣음\nReDim varBoth(\n1 To rowsCnt\n, 1 To colsCnt)\n'varBoth배열 크기 재지정\n'-------------------------------------------------------\n' 먼저 \"이름\"이 일치하는지 검색 후 나머지 열들을 검사\n'-------------------------------------------------------\nFor Each vO In varO\n'Old A열 각 셀을 순환\ni = i + 1\n'Old A열 행을 늘려감\nFor Each vN In varN\n'New A열 각 셀을 순환\nj = j + 1\n'New A열 행을 늘려감\nIf vO = vN Then\n'이름이 일치하면\nr = r + 1\n'varBoth배열 행방향 1씩 늘려감\nFor x = 1 To colsCnt\n'전체 열 개수만큼 반복\nvarBoth(r, x) = varOld(i, x)\n'중복데이터를 varBoth에 넣음\nvarOld(i, x) =\nEmpty\n'varOld 내의 중복데이터 삭제\nNext x\nr = r + 1\n'varBoth배열 행방향 1씩 늘려감\nFor x = 1 To colsCnt\n'전체 열 개수만큼 반복\nvarBoth(r, x) = varNew(j, x)\n'중복데이터를 varBoth에 넣음\nvarNew(j, x) = Empty\n'varNew 내의 중복데이터 삭제\nNext x\nEnd If\nNext vN\nj = 0\n'New의 행값 초기화\nNext vO\n'----------------------------------------------------\n' 각 배열에 넣은 값들을 해당 시트에 뿌려주는 코드\n'----------------------------------------------------\nSheets(3).Cells(2, 1).Resize(UBound(varOld, 1), _\ncolsCnt) = varOld\n'varOld 배열값을 OldOnly에 뿌림\nIf r > 0 Then\n'배열이 비어 있지 않으면\nSheets(4).Cells(2, 1).Resize(rowsCnt, _\ncolsCnt) = varBoth\n'varBoth 배열값을 Both에 뿌림\nEnd If\nSheets(5).Cells(2, 1).Resize(UBound(varNew, 1), _\ncolsCnt) = varNew\n'varNew 배열값을 NewOnly에 뿌림\n'---------------------------------------------------\n' 각 시트의 서식을 설정하고, 정렬한 뒤 열너비 맞춤\n'---------------------------------------------------\nFor s = 3 To 5\n'3 ~ 5번 시트에서 반복\nWith Sheets(s)\n'각 시트에서\n.UsedRange.\nSort\n.[A1], 1, Header:=True\n'각 시트를 이름순으로 오름차순 정렬\n.Columns.AutoFit\n'열너비 자동 맞춤\nEnd With\nNext s\nWith Application\n'엑셀에서\n.Calculation =\nxlCalculationAutomatic\n'셀계산 자동으로 복원\n.ScreenUpdating = True\n'화면업데이트 재 실행\nEnd With\nMsgBox \"데이터 추출이 완료되었습니다.\"\n'완료 메시지 출력\nEnd Sub", "context": "앞서 올린 코드(\nhttp://blog.naver.com/rosa0189/60208309318\n)는 전체행에서 1자만 틀려도 전체행을 다른 데이터로 취급하였다.\n이 코드는 Old시트의 A열(이름)과 New 시트의 A열(이름)만 비교.\nOld 시트와 New 시트에 여러 데이터가 있음.\nOld 시트에만 있는 데이터를 OldOnly시트에, 양쪽에 이름이 있는 데이터를 Both시트에, New 시트에만 있는 데이터를 NewOnly시트에 추출하는 기능.\n최소 2행 이상의 데이터가 있어야 하며, 데이터의 행 또는 열 개수 제한이 없음.\n매크로 사용이 익숙치 않으면 첨부된 코드를 다운받고 자신의 데이터를 Old 시트와 New 시트에 복사하여 넣고 매크로 버튼만 클릭하면 된다. 본인의 데이터에 날짜열이 없을 경우 아래 코드에서 Sheets(i).Columns(\"E\").NumberFormat = \"yyyy-mm-dd\" 행을 삭제하면 된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubj..."}
{"instruction": "Excel VBA code for: (1471) 필터된 열 색으로 표시하기 (엑셀 VBA 매크로)", "input": "", "output": "Private Sub Worksheet_Calculate()\nDim auto_Filter As\nAutoFilter\n'자동필터 넣을 변수\nDim flt As\nFilter\n'각 필터를 넣을 변수\nDim i As Integer\n'열 방향 반복해 늘려갈 변수\nApplication.EnableEvents = False\n'이벤트를 비활성화\nSet\nauto_Filter = ActiveSheet.\nAutoFilter\n'현재시트 자동필터를 개체변수에 넣음\nIf ActiveSheet.\nAutoFilterMode\nThen\n'현재시트에 필터 적용된 경우\nFor Each flt In auto_Filter.\nFilters\n'각 필터를 순환\ni = i + 1\n'열 위치 1씩 늘려감\nIf flt.On Then\n'필터가 적용된 경우\nCells(1, i).Interior.ColorIndex = 46\n'셀에 주황석 적용\nElse\n'필터가 적용되지 않을 경우\nCells(1, i).Interior.ColorIndex = 43\n'셀에 초록색 적용\nEnd If\nNext flt\nEnd If\nSet auto_Filter = Nothing\n'개체변수 초기화(메모리 비우기)\nApplication.EnableEvents = True\n'이벤트 기능 활성화\nEnd Sub", "context": "필터(filter)를 적용한 경우 행 번호가 파란색으로 바뀌지만 눈에 잘 띄지 않는다. 필터를 적용하면 아래 코드에 의하여 1행의 제목이 주황 색으로 반전된다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1471) 필터된 열 색으로 표시하기 (엑셀 VBA 매크로)\n재생\n1,279\n재생 (space/k)\n재생\n00:36\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:36\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동..."}
{"instruction": "Excel VBA code for: (1472) A열의 값을 B열의 숫자만큼 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub generate_Data_As_Numbered()\nDim rngAll As Range\n'전체(All) 영역을 넣을 변수\nDim lngSum As Long\n'수량 합계를 넣을 변수\nDim varTemp As Variant\n'배열로 사용할 변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역 변수\nDim i As Long\n'각 수량 만큼 반복할 변수\nDim r As Long\n'배열 행(r)ow 방향 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).Columns(\"D\").\nClearContents\n'기존 데이터 삭제\nSet\nrngAll = Range(\"B2\", Cells(Rows.Count, \"B\").End(3))\n'제목 제외한 B\n﻿\n열 전체를 변수에 넣음\nlngSum =\nApplication.Sum\n(rngAll)\n'전체 데이터 행개수 추출하여 변수에 넣음\nReDim varTemp(1 To lngSum, 1 To 1)\n'배열 2차원으로 크기 재지정\nFor Each rngC In rngAll\n'전체 영역의 각 셀을 순환\nFor i = 1 To rngC.Value\n'셀의 숫자만큼 반복\nr = r + 1\n'배열 행방향(1차원) 1씩 늘려감\nvarTemp(r, 1) = rngC.\nPrevious\n'배열에 BIN No. 를 넣음\nNext i\nNext rngC\nRange(\"D1\").Resize(lngSum, 1) = varTemp\n'배열 셀에 뿌림\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "매크로 실행 전                                             매크로 실행 후 결과\nOption Explicit\nSub generate_Data_As_Numbered()\nDim rngAll As Range\n'전체(All) 영역을 넣을 변수\nDim lngSum As Long\n'수량 합계를 넣을 변수\nDim varTemp As Variant\n'배열로 사용할 변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역 변수\nDim i As Long\n'각 수량 만큼 반복할 변수\nDim r As Long\n'배열 행(r)ow 방향 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).Columns(\"D\").\nClearContents\n'기존 데이터 삭제\nSet\nrngAll = Range(\"B2\", Cells(Rows.Count, \"B\").End(3))\n'제목 제외한 B\n﻿\n열 전체를 ..."}
{"instruction": "Excel VBA code for: (1473) 선택영역의 빈 행을 숨기거나 나타내기 (엑셀 VBA 매크로)", "input": "", "output": "Sub hide_Blank_Rows()\nDim rngU As Range\n'합친(U)nion 영역을 넣을 영역(개체)변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역(개체)변수\nWith Selection\n'선택영역에서\nFor Each rngC In .Columns(1).Cells\n'첫 번째열 각 셀을 순환\nIf\nWorksheetFunction.CountA\n(rngC.Resize(, .Columns.Count)) = 0 Then\n'전체행이 비어 있을 경우\nIf rngU Is Nothing Then\n'rngU 가 비어 있을 경우\nSet rngU = rngC\n'일치한 셀을 넣음\nElse\n'rngU 가 비어 있지 않을 경우\nSet rngU =\nUnion\n(rngU, rngC)\n'기존 rngU 와 영역을 합쳐감\nEnd If\nEnd If\nNext rngC\nEnd With\nIf Not rngU Is Nothing Then\n'빈 행이 하나라도 있을 경우\nrngU.\nEntireRow.Hidden\n= True\n'빈행 전체를 숨기기\nEnd If\nEnd Sub\n\nSub unhide_Rows()\nSelection.EntireRow.Hidden = False\n'선택영역내 숨겨진행 전체를 보이기\nEnd Sub", "context": "제목과 같이 선택한 영역에서 빈행을 숨기거나 나타내는 기능으로, 선택되는 행 또는 열의 개수 제한이 없다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1473) 선택영역의 빈 행을 숨기거나 나타내기 (엑셀 VBA 매크로)\n재생\n939\n재생 (space/k)\n재생\n00:21\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:21\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\nOption Explicit\nSub hide_Bl..."}
{"instruction": "Excel VBA code for: (1474) 각 문자의 행 일치시키기 (엑셀 VBA 매크로)", "input": "", "output": "Sub match_Row_Of_Each_Character()\nDim i As Integer\n'열 2회 반복할 변수\nDim rngAll As Range\n'전체(All) 영역을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim rngLeft As Range\n'C열 문자 입력된 영역을 넣을 변수\nDim rngRight As Range\n'D열 문자 입력된 영역을 넣을 변수\nDim a As Integer\n'(a)rea의 카운터로 사용할 변수\nDim intL As Integer\n'왼쪽(L)elf 열을 넣을 변수\nDim intR As Integer\n'오른쪽(R)ight 열을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"C:D\").ClearContents\n'기존 데이터 삭제\nCells(1, 1).Resize(, 2).\nInsert\nshift:=xlDown\n'임시셀을 삽입\nFor i = 1 To 2\nSet rngAll = Range(Cells(2, i), _\nCells(Rows.Count, i).End(3))\n'A / B열 전체 데이터를 개체변수에 넣음\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nIf rngC = rngC.Offset(-1) Then\n'위 아래 값이 같으면\nCells(Rows.Count, i + 2).End(3)(2) = rngC\n'마지막 값의 바로 아래 셀에 값을 복사\nElse\n'위 아래 값이 다르면\nCells(Rows.Count, i + 2).End(3)(3) = rngC\n'마지막 값에서 한 행 건너 뛰고 복사\nEnd If\nNext rngC\nNext i\nRows(1).Delete\n'임시행 삭제\nCells(1, 3).Resize(, 2).\nDelete\nshift:=xlUp\n'임시셀을 삭제\nSet rngLeft = Range(Cells(1, 3), _\nCells(Rows.Count, 3).End(3)).\nSpecialCells(2)\nSet rngRight = Range(Cells(1, 4), _\nCells(Rows.Count, 4).End(3)).SpecialCells(2)\n'C열과 D열의 문자 입력된 영역을 개체변수에 넣음\nDo\n'다음을 실행\na = a + 1\n'area 개수를 1씩 늘려감\nintL = rngLeft.\nAreas\n(a).Cells.Count\n'C열 area의 셀 개수를 변수에\nintR = rngRight.Areas(a).Cells.Count\n'D열 area의 셀 개수를 변수에\nIf intL > intR Then\n'왼쪽 area의 셀 개수가 많을 경우\nrngRight.Areas(a).Offset(intR).Resize(intL - intR).Insert shift:=xlDown\n'오른쪽 area의 아래에 행을 삽입\nElseIf intL < intR Then\n'오른쪽 area의 셀 개수가 많을 경우\nrngLeft.Areas(a).Offset(intL).Resize(intR - intL).Insert shift:=xlDown\n'왼쪽 area의 아래에 행을 삽입\nEnd If\nLoop Until\na = rngLeft.Areas.Count\n'area 개수만큼 무한 반복\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "A열과 B열에 있는 문자들의 행 위치를 일치시키는 기능.\n매크로 실행 전                                              매크로 실행 후 결과\nOption Explicit\nSub match_Row_Of_Each_Character()\nDim i As Integer\n'열 2회 반복할 변수\nDim rngAll As Range\n'전체(All) 영역을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim rngLeft As Range\n'C열 문자 입력된 영역을 넣을 변수\nDim rngRight As Range\n'D열 문자 입력된 영역을 넣을 변수\nDim a As Integer\n'(a)rea의 카운터로 사용할 변수\nDim intL As Integer\n'왼쪽(L)elf 열을 넣을 변수\nDim intR As Integer\n'오른쪽(R)ight 열을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 ..."}
{"instruction": "Excel VBA code for: (1475) 각 그룹별 최대값 찾기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub max_Of_Each_3_Rows_1()\nDim rngArea As Range\n'3행씩 넣을 영역(Area)변수\nDim lastRow As Long\n'마지막 행(Row)을 넣을 변수\nDim r As Long\n'행(r)ow을 3씩 늘려갈 변수\nDim intMax As Integer\n'최댓값(Max)을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim rngMax As Range\n'최댓값(Max) 영역을 넣을 변수\nDim v As Long\n'배열(v)ariant 위치(1차워) 1씩 늘려갈변수\nDim varTemp\n'추출한 각 행을 넣을 배열변수\nDim x As Integer\n'열(x 축) 방향 위치 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet\nrngArea = Range(\"A2:C4\")\n'첫 area를 변수에 넣음\nlastRow = Cells(Rows.Count, \"A\").End(3).Row\n'마지막 행을 추출하여 변수에 넣음\nReDim\nvarTemp(1 To lastRow, 1 To 3)\n'배열크기 재지정\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nintMax = 0\n'최대값 초기화\nFor Each rngC In rngArea.Offset(, 1).Resize(, 1)\n'B열 각 셀을 순환\nIf rngC > intMax Then\n'셀값이 intMax보다 크면\nintMax = rngC\n'intMax 에 셀값을 넣음\nSet rngMax = rngC.Offset(, -1)\n'A열을 rngMax로 설정\nEnd If\nNext rngC\nv = v + 1\n'배열크기 1씩 늘려감\nFor x = 1 To 3\n'1부터 1씩 늘려가며 3회 반복\nvarTemp(v, x) = rngMax.Offset(, x - 1)\n'배열에 각 행의 값을 넣음\nNext x\nr = r + 3\n'행을 3씩 늘려감\nSet rngArea = rngArea.Offset(3)\n'아래로 3행 건너뛴 영역을 rngArea에 넣음\nLoop Until\nCells(r, 1) = \"\"\n'빈셀 나올때까지 무한 반복\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.\nClear\n'기존 데이터 삭제\nRows(1).\nCopy\n'1행 복사\n.Activate\n'활성화\nActiveSheet.\nPaste\nCells(1, 1)\n'A1셀에 붙여 넣기\nCells(2, 1).Resize(lastRow, 3) = varTemp\n'배열값 시트에 뿌림\nEnd With\nApplication.\nCutCopyMode\n= xlCopy\n'클립보드 비우기\nSet rngArea = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngMax = Nothing\nEnd Sub", "context": "C열에 있는 각 중복된 그룹의 최대값이 있는 데이터만 추출하는 기능. 추출될 데이터의 구분을 위해 색으로 칠해두었다.\n매크로 실행 전 Sheet1                                            매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub max_Of_Each_3_Rows_1()\nDim rngArea As Range\n'3행씩 넣을 영역(Area)변수\nDim lastRow As Long\n'마지막 행(Row)을 넣을 변수\nDim r As Long\n'행(r)ow을 3씩 늘려갈 변수\nDim intMax As Integer\n'최댓값(Max)을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim rngMax As Range\n'최댓값(Max) 영역을 넣을 변수\nDim v As Long\n'배열(v)ariant 위치(1차워) 1씩 늘려갈변수\nDim varTemp\n'추출한 각 행을 넣을 배열변수\nDim x As In..."}
{"instruction": "Excel VBA code for: (1477) 괄호와 함께 셀병합하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub merge_With_Parenthesis()\nDim colsCnt As Integer\n'선택영역 열 개수 넣을 변수\nDim strU As String\n'윗쪽(U)p 값을 넣을 변수\nDim strD As String\n'아래쪽(U)p 값을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nWith Selection\n'선택영역에서\n.\nCopy\n.Offset(3)\n'선택영역 3행 내려 복사\ncolsCnt = .Columns.Count\n'전체 열 개수를 추출\nFor i = 1 To colsCnt\n'1 부터 열 개수까지 1씩 증가하며 반복\nstrU = Cells(4, i)\n'위셀 값을 변수에 넣음\nstrD = Cells(5, i)\n'아래 셀 값을 변수에 넣음\nWith Cells(4, i).Resize(2)\n'상하 두 셀에서\n.ClearContents\n'기존값 삭제\n.Merge\n'상하 두 셀을 셀병합\nEnd With\nCells(4, i) = strU &\nChr(10)\n& \"(\" & strD & \")\"\n'값을 가로와 합쳐 셀에 넣음\nNext i\nEnd With\nEnd Sub", "context": "매크로 실행 전 (\n먼저 마우스로 영역을 선택\n한 뒤 매크로를 실행해야 함)\n매크로 실행 후 결과\nOption Explicit\nSub merge_With_Parenthesis()\nDim colsCnt As Integer\n'선택영역 열 개수 넣을 변수\nDim strU As String\n'윗쪽(U)p 값을 넣을 변수\nDim strD As String\n'아래쪽(U)p 값을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nWith Selection\n'선택영역에서\n.\nCopy\n.Offset(3)\n'선택영역 3행 내려 복사\ncolsCnt = .Columns.Count\n'전체 열 개수를 추출\nFor i = 1 To colsCnt\n'1 부터 열 개수까지 1씩 증가하며 반복\nstrU = Cells(4, i)\n'위셀 값을 변수에 넣음\nstrD = Cells(5, i)\n'아래 셀 값을 변수에 넣음\nWith Cells(4, i).Resize(2)\n'상하 두 셀에서\n.ClearConten..."}
{"instruction": "Excel VBA code for: (1478) 월 합계내기 (엑셀 VBA 매크로)", "input": "", "output": "Sub bring_Sheet_Data()\nDim varTemp\n'동적배열로 사용할 변수\nConst rowsCnt As Integer = 31\n'전체 행 개수를 변수에 넣음\nConst colsCnt As Integer = 5\n'전체 열 개수를 변수에 넣음\nDim y As Long\n'행방향 반복구문에 사용할 변수\nDim x As Integer\n'열방향 반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nReDim\nvarTemp(1 To rowsCnt, 1 To colsCnt)\n'배열 크기 재지정\nFor y = 1 To rowsCnt\n'1 ~ 31까지 1씩 증가하며 반복\nFor x = 1 To colsCnt\n'1 ~ 5까지 1씩 증가하며 반복\nvarTemp(y, x) = Sheets(y + 1).Cells(Range(\"A1\").Value + 1, x + 1)\n'배열에 추출한 값을 넣음\nNext x\nNext y\nCells(3, 2).Resize(rowsCnt, colsCnt) = varTemp\n'배열값 시트에 뿌림\nEnd Sub\n\nSub delete_All_Data()\nDim s As Integer\n'일자 시트만큼 반복할 변수\nDim msg As String\n'메시지창 선택결과 넣을 변수\nmsg = MsgBox(\"모든 데이터가 삭제. 실행할까요?\", 16 + vbYesNo, \"데이터 삭제\")\nIf msg = vbYes Then\n'Yes를 선택한 경우\nFor s = 1 To Sheets.Count\n'1 ~ 마지막 시트까지 순환\nSheets(s).Cells(2, 2).Resize(31, 5).\nClearContents\n'데이터영역의 데이터를 삭제\nNext s\nElseIf msg = vbNo Then\n'No를 선택한 경우\nExit Sub\n'매크로 종료\nEnd If\nMsgBox \"모든 데이터가 삭제되었습니다.\"\n'메시지창 출력\nEnd Sub\n\nPrivate Sub Worksheet_Change(ByVal Target As Range)\n'시트값 변경 시 작동하는 이벤트\nDim strU As String\n'문자를 합쳐서 넣을 변수\nDim strEach As String\n'각 문자를 넣을 변수\nDim i As Integer\n'문자 길이 만큼 반복할 변수\nIf Target.\nAddress\n<> Range(\"F1\").Address Then Exit Sub\n'값이 변경될 셀의 주소가 F1이 아닐 경우 매크로 종료\nFor i = 1 To Len(Target)\n'1 ~ 문자 길이만큼 1씩 증가하며 반복\nstrEach = Mid(Target, i, 1)\n'각 문자를 추출하여 변수에 넣음\nIf\nIsNumeric\n(strEach) Then\n'각 문자가 숫자라면\nstrU = strU & strEach\n'각 숫자를 합쳐감\nEnd If\nNext i\nRange(\"A1\") = Val(strU)\n'추출한 문자를 숫자로 변환하여 B1에 넣음\n'---------------------------------------------------------------------------\n' 셀 값이 변경될 때 이벤트가 작동하면 이 코드가 loop되므로 이벤트를 일시 정지\n'---------------------------------------------------------------------------\nApplication.\nEnableEvents\n= False\n'이벤트 기능 정지\nbring_Sheet_Data\n'데이터 가져오는 프로시저 호출\nApplication.EnableEvents = True\n'이벤트 기능 복원\nEnd Sub", "context": "매크로 실행 전 Main 시트\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1478) 월 합계내기 (엑셀 VBA 매크로)\n재생\n1,771\n재생 (space/k)\n재생\n00:54\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:54\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n코드가 들어 있는 위치를 보여준뒤 엑셀창으로 이동한다.\n각 시트에 업체별 일일 데이터가 입력되어 잇다.\n스핀버튼을 클릭하면..."}
{"instruction": "Excel VBA code for: (1479) 리스트박스내 아이템 이동하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub move_Item_In_ListBox(control As IRibbonControl)\nUserForm1.\nShow\n'사용자폼 보이기\nEnd Sub\n\nPrivate Sub CommandButton1_Click()\nDim varM()\n'동적배열로 사용할 변수\nDim r As Integer\n'반복구문에 사용할 변수\nDim idxNo As Integer\n'목록상자 index 넣을 변수\nDim str As String\n'임시로 문자를 저장할 변수\nIf ListBox1.\nListIndex\n< 1 Then\n'제일 윗 행이라면\nMsgBox \"더이상 올라갈 수 없습니다.\", 64, \"첫 행\"\n'메시지창 출력\nExit Sub\n'매크로 종료\nEnd If\n'-----------------------------------------\n' 배열에 리스트박스 전체 목록을 넣는 코드\n'-----------------------------------------\nFor r = 1 To 12\n'1 ~ 12까지 1씩 증가하며 반복\nReDim Preserve\nvarM(1 To r)\n'동적배열 크기 재지정\nvarM(r) = ListBox1.List(r - 1)\n'배열에 목록상자 값을 넣음\nNext r\nidxNo = ListBox1.ListIndex\n'목록상자 값을 변수에 넣음\n'-------------------------------------------------\n' 소위 bubble sort 방식을 이용해 위아래 뒤집는 코드\n'-------------------------------------------------\nstr = ListBox1.\nList\n(idxNo - 1)\n'윗 index 값을 임시로 변수에 넣음\nvarM(idxNo) = ListBox1.List(idxNo)\n'아래 값을 위에 복사\nvarM(idxNo + 1) = str\n'임시로 저장한 값을 아래에 복사\nListBox1.List =\nWorksheetFunction.Transpose\n(varM)\n'배열 값을 목록상자에 뿌림\nListBox1.ListIndex = idxNo - 1\n'목록상자에서 위로 올린 값을 선택\nEnd Sub\n\nPrivate Sub CommandButton2_Click()\nDim varM()\nDim r As Integer\nDim idxNo As Integer\nDim str As String\nIf ListBox1.ListIndex = -1 Then Exit Sub\nIf ListBox1.ListIndex = ListBox1.ListCount - 1 Then\nMsgBox \"더이상 내려갈 수 없습니다.\", 64, \"마지막 행\"\nExit Sub\nEnd If\nFor r = 1 To 12\nReDim Preserve varM(1 To r)\nvarM(r) = ListBox1.List(r - 1)\nNext r\nidxNo = ListBox1.ListIndex\nstr = ListBox1.List(idxNo)\nvarM(idxNo + 1) = ListBox1.List(idxNo + 1)\nvarM(idxNo + 2) = str\nListBox1.List = WorksheetFunction.Transpose(varM)\nListBox1.ListIndex = idxNo + 1\nEnd Sub\n\nPrivate Sub CommandButton3_Click()\nUnload\nMe\n'사용자폼 닫기\nEnd Sub\n\nPrivate Sub UserForm_Initialize()\nDim varTemp()\n'모든 목록을 넣을 동적배열\nDim r As Integer\n'반복구문에 사용할 변수\nWith Me\n'사용자폼\n.Top = 100\n'위쪽 높이 100\n.Left = 300\n'왼쪽 300 위치에서 시작\nEnd With\nFor r = 1 To 12\n'1 ~ 12까지 1씩 증가하며 반복\nReDim Preserve varTemp(1 To r)\n'동적배열 크기 재지정\nvarTemp(r) =\nFormat\n(MonthName(r), \"m\")\n'각 월을 배열에 넣음\nNext r\nListBox1.List = WorksheetFunction.Transpose(varTemp)\n'배열을 행열 변환하여 목록상장에 넣음\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1479) 리스트박스내 아이템 이동하기 (엑셀 VBA 매크로)\n재생\n4,043\n재생 (space/k)\n재생\n00:19\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:19\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n메뉴에 있는 매크로 버튼을 클릭하여 매크로를 실행하고 사용자폼을 로딩한다.\n아이템을 선택하고 MoveUP 버튼을 클릭하면 선택된 아이템이..."}
{"instruction": "Excel VBA code for: (1480) 그룹별 최댓값만 찾아 표시하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Max_When_Bigger()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"D\").\nClearContents\n'기존 데이터 삭제\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'A열 각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nIf i > 0 Then\n'중복이 있을 경우\nIf\nWorksheetFunction.Max\n(Cells(r, 2).Offset(-i).Resize(i)) < Cells(r, 2) Then\n'중복된 값들이 제일 마지막\n﻿\n행보다 작거나 같으면\nCells(r, 4) = Cells(r, 1)\n'D열에 A열 값 입력\nEnd If\nEnd If\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nEnd Sub", "context": "1. A열의 중복된 이름의 개수가 불규칙한 상황\n2. 중복되는 이름 그룹의 마지막 값이 위의 이름들 값보다 크거나 같을 경우 D열에 A열의 이름을 표시\n3. 마지막 값이 최대값이 아닐 경우에는 표시하지 않음\n매크로 실행 전                                                        매크로 실행 후 결과\nOption Explicit\nSub find_Max_When_Bigger()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'중복개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"D\").\nClearContents\n'기존 데이터 삭제\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'A열 각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아..."}
{"instruction": "Excel VBA code for: (1481) 값이 입력된 셀 값 찾아 넣기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_The_Next_Number()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nDim C As Range\n'검색에 일치한 셀 값을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet\nrngAll = Range(\"E3:R3\")\n'현재시트 사용 영역을 변수에 넣음\nSet C = rngAll.\nFind\n(Range(\"D5\").Value, , , xlWhole)\n'D5와 전체 일치하는 값을 찾음\nIf Not C Is Nothing Then\n'일치하는 값이 있을 경우\nIf Range(\"D5\") = \"\" Then\n'빈셀일 경우\nRange(\"D5\") = Cells(3, 1).End(2)\n'제일 왼쪽 값을 넣음\nExit Sub\n'매크로 종료\nEnd If\nFor Each rngC In rngAll\n'전체영역(rngAll)의 각셀(rngC)을 순환\nIf Not\nIsEmpty\n(rngC) Then\n'빈셀이 아니라면\nIf rngC.Value <> Range(\"D5\").Value Then\n'값이 서로 일치하지 않으면\nIf\nWorksheetFunction.CountA\n(rngC.Resize(, _\n19 - rngC.Column)) > 0 Then\n'오른쪽에 데이터가 있다면\nIf rngC.Column > C.Column Then\n'셀값이 검색에 일치한 값보다 오른쪽 열이면\nRange(\"D5\") = rngC\n'D5 셀에 셀값을 넣음\nExit Sub\n'매크로 종료\nEnd If\nElse\n'오른쪽에 데이터가 없다면\nRange(\"D5\") = Cells(3, 1).End(2)\n'제일 왼쪽 값을 입력\nExit Sub\n'매크로 종료\nEnd If\nEnd If\nEnd If\nIf rngC.Column = 18 Then\n'셀값이 R3일 경우\nRange(\"D5\") = Cells(3, 1).End(2)\n'제일 왼쪽 값을 입력\nEnd If\nNext\nElse\nMsgBox \"E3:R3이 모두 입력되거나\" &\nvbCr\n& vbCr _\n& \"D5값이 잘못 입력됨.\", 64, \"입력오류\"\n'메시지창 출력\nEnd If\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 시 E3:R3 열의 제일 앞 숫자가 D5셀에 입력됨\n연속하여 매크로 실행 시 다음 숫자가 D5셀에 입력됨\nE3:R3 내의 숫자 개수는 불규칙함. 단 모든 숫자가 채워지지는 않음\n제일 마지막 숫자에 도달한 뒤 매크로 실행하면 제일 앞 숫자가 선택됨\n매크로 실행 전\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1481) 값이 입력된 셀 값 찾아 넣기 (엑셀 VBA 매크로)\n재생\n1,508\n재생 (space/k)\n재생\n00:23\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:23\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이..."}
{"instruction": "Excel VBA code for: (1482) 열과 열, 행과 행을 무작위로 섞기 (엑셀 VBA 매크로)", "input": "", "output": "Sub reshuffle_Entire_Rows_Columns()\nDim msg As String\n'메시지 출력에 사용할 변수\nDim rngA As Range\n'각 (A)rea를 넣을 변수\nDim rowsCnt As Long\n'각 area의 행 개수 넣을 변수\nDim colsCnt As Integer\n'각 area의 열 개수 넣을 변수\nDim varCnt\n'행 또는 열의 숫자만큼 카운터로 쓰일 배열\nDim varTemp\n'섞은 값을 넣을 배열\nDim varR\n'뒤섞은 결과 값을 넣을 배열\nDim i As Long\n'반복구문에 사용할 변수\nDim j As Long\n'반복구문에 사용할 변수\nmsg =\nMsgBox\n(\"열을 행(좌우)으로 섞는건 Yes, 열(상하)로\" & _\n\"섞는건 No 선택\", vbYesNoCancel, \"섞는 방향 선택\")\nFor Each rngA In Selection.\nAreas\n'선택영역 각 area를 순환\nRandomize\n'랜덤값 발생기 초기화\n'(계속 새로운 랜덤 기준값 생성)\nIf rngA.Cells.Count > 1 Then\n'(1개 셀만 선택했을 때 에러방지용)\nWith rngA\n'각 area 에서\nrowsCnt = .\nRows.Count\n'각 area의 행 개수를 변수에 넣음\ncolsCnt = .\nColumns.Count\n'각 area의 열 개수를 변수에 넣음\nSelect Case\nmsg\n'메시지 선택에 따라서\nCase\nvbYes\n'메시지창에서 Yes 선택시\nReDim\nvarCnt(1 To colsCnt)\n'카운터로 사용될 배열 크기 재지정\nReDim varTemp(1 To colsCnt)\n'섞은 값을 넣을 배열크기 재지정\nReDim varR(1 To rowsCnt, 1 To colsCnt)\n'결과배열 크기 재지정\nFor i = 1 To colsCnt\n'열 개수만큼 반복\nvarCnt(i) = i\n'카운터 배열에 순차적 값을 넣음\nNext i\nFor i = colsCnt To 1\nStep -1\n'제일 큰 열에서 부터 1씩 빼며 반복\nj =\nInt\n(\nRnd\n* i) + 1\n'무작위 값을 추출\nvarTemp(i) = varCnt(j)\n'무작위로 추출한 위치의 배열 값을 varTemp에 순차적으로 넣음\nvarCnt(j) = varCnt(i)\n'제일 뒤에 있는 배열 값을 추출한 곳에 채워 넣음\nNext i\nFor i = 1 To colsCnt\n'열 개수만큼 반복\nFor j = 1 To rowsCnt\n'행 개수만큼 반복\nvarR(j, i) = .Cells(j, varTemp(i))\n'결과 배열에 섞은 순서대로 데이터 채움\nNext j\nNext i\n.\nValue\n= varR\n'결과배열에 추출한 값을 각 area에 뿌림\nCase\nvbNo\nReDim varCnt(1 To rowsCnt)\n'카운터로 사용될 배열 크기 재지정\nReDim varTemp(1 To rowsCnt)\n'섞은 값을 넣을 배열크기 재지정\nReDim varR(1 To rowsCnt, 1 To colsCnt)\n'결과배열 크기 재지정\nFor i = 1 To rowsCnt\n'행 개수만큼 반복\nvarCnt(i) = i\n'카운터 배열에 순차적 값을 넣음\nNext i\nFor i = rowsCnt To 1 Step -1\n'제일 큰 행에서 부터 1씩 빼며 반복\nj = Int(Rnd * i) + 1\n'무작위 값을 추출\nvarTemp(i) = varCnt(j)\n'무작위로 추출한 위치의 배열 값을 varTemp에 순차적으로 넣음\nvarCnt(j) = varCnt(i)\n'제일 뒤에 있는 배열 값을 추출한 곳에 채워 넣음\nNext i\nFor i = 1 To rowsCnt\n'행 개수만큼 반복\nFor j = 1 To colsCnt\n'열 개수만큼 반복\nvarR(i, j) = .Cells(varTemp(i), j)\n'결과 배열에 섞은 순서대로 데이터 채움\nNext j\nNext i\n.Value = varR\n'결과배열에 추출한 값을 각 area에 뿌림\nEnd Select\nEnd With\nEnd If\nNext rngA\nEnd Sub", "context": "제목 그대로 선택한 영역의 열과 열, 행과 행을 무작위로 섞어주는 기능. Ctrl + 마우스를 이용하여 여러개의 구역(area)를 선택하여도 상관 없다.\n매크로 실행 전\n매크로 실행 후 나타나는 선택창\n선택창에서\nYes\n를 선택하여 행(좌우) 방향으로 데이터를 섞은 모습\n선택창에서\nNo\n를 선택하여 열(상하) 방향으로 데이터를 섞은 모습\nOption Explicit\nSub reshuffle_Entire_Rows_Columns()\nDim msg As String\n'메시지 출력에 사용할 변수\nDim rngA As Range\n'각 (A)rea를 넣을 변수\nDim rowsCnt As Long\n'각 area의 행 개수 넣을 변수\nDim colsCnt As Integer\n'각 area의 열 개수 넣을 변수\nDim varCnt\n'행 또는 열의 숫자만큼 카운터로 쓰일 배열\nDim varTemp\n'섞은 값을 넣을 배열\nDim varR\n'뒤섞은 결과 값을 넣을 배열\nDim i As Long\n'반복구문..."}
{"instruction": "Excel VBA code for: (1483) 네이버 실시간 검색어 Top 10 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub naver_Search_Top10()\nDim shp As Shape                                         '\n화살표 도형을 넣을 변수\nDim WinHttp As New\nWinHttp.WinHttpRequest\n'WinHttp로 사용할 변수\nDim strHtml As String\n'전체 HTML 문자를 넣을 변수\nDim lngNo As Long\n'\"실시간 급상승 검색어\"위치 찾을 변수\nDim varTemp() As String\n'순위 앞에서 끊어 넣을 배열 변수\nDim varVar() As String\n'임시 배열로 사용할 변수\nDim varR() As String\n'결과 값만 넣을 배열 변수\nDim i As Long\n'반복구문에 사용할 변수\nActiveSheet.UsedRange.Offset(1).Clear\n'기존 데이터 삭제\nFor Each shp In ActiveSheet.\nShapes\n'현재시트내 모든 도형 순환\nIf shp.Name <> \"Run Macro\" Then\n'매크로 실행 도형이 아니라면\nshp.Delete\n'도형 삭제\nEnd If\nNext shp\nWinHttp.\nOpen\n\"GET\", \"\nhttp://www.naver.com\n\"\n'네이버 페이지를 열기\nWinHttp.\nSend\n'열결을 보냄\nWinHttp.\nWaitForResponse\n'응답을 기다림\nstrHtml =\nWinHttp.ResponseText\n'전체 문자를 변수에 넣음\nlngNo =\nInStr\n(1, strHtml, \"실시간 급상승 검색어\", vbBinaryCompare)\n'실시간 급상승 검색어 위치 찾기\nstrHtml =\nMid\n(strHtml, lngNo, Len(strHtml) - lngNo)\n'실시간 급상승 검색어 뒤로만 추출\nvarTemp =\nSplit\n(strHtml, \"title=\"\"\")\n'titlex에서 끊어서 배열에 넣음\nFor i = 1 To 10\n'1 부터 10까지 1씩 늘리며 반복\nCells(i + 1, 1) = i & \"위\"\n'순위입력\nvarR = Split(varTemp(i), \"\"\">\")\n'결과순위만 추출하여 배열에 넣음\nCells(i + 1, 2) = varR(0)\n'상승어 입력\nvarVar = Split(varTemp(i), \"class=\"\"tx\"\">\")\n'tx에서 분리하여 배열에 넣음\nvarR = Split(varVar(1), \"</span>\")\n'결과순위만 추출하여 배열에 넣음\nIf varR(0) = \"New\" Then\n'분리된 문자가 New 라면\nCells(i + 1, 3) = \"New\"\n'C열에 New라고 입력\nElseIf varR(0) = \"상승\" Then\n'분리된 문자가 \"상승\"일 경우\nvarVar = Split(varTemp(i), \"rk\"\">\")\n'rk\"> 를 기준으로 분리\nvarR = Split(varVar(1), \"</span>\")\n'</span> 을 기준으로 분리\nActiveSheet.Shapes.\nAddShape\n(msoShapeUpArrow, _\nCells(i + 1, 3).Left + 10, Cells(i + 1, 3).Top + 1, 8, 13).Select\n'화살표 도형 삽입\nSelection.ShapeRange.\nShapeStyle\n= msoShapeStylePreset31\n'화살표를 빨간색으로 변경\nCells(i + 1, 4) = varR(0)\n'배열내 첫 단어를 C열에 입력\nEnd If\nNext i\nColumns.AutoFit\n'열너비 자동맞춤\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 결과 (실시간 데이터를 받으므로 매크로 실행 시간에 따라 결과가 다를 수 있음)\nOption Explicit\nSub naver_Search_Top10()\nDim shp As Shape                                         '\n화살표 도형을 넣을 변수\nDim WinHttp As New\nWinHttp.WinHttpRequest\n'WinHttp로 사용할 변수\nDim strHtml As String\n'전체 HTML 문자를 넣을 변수\nDim lngNo As Long\n'\"실시간 급상승 검색어\"위치 찾을 변수\nDim varTemp() As String\n'순위 앞에서 끊어 넣을 배열 변수\nDim varVar() As String\n'임시 배열로 사용할 변수\nDim varR() As String\n'결과 값만 넣을 배열 변수\nDim i As Long\n'반복구문에 사용할 변수\nActiveSheet.UsedRange.Offset(1).Cle..."}
{"instruction": "Excel VBA code for: (1484) 피벗테이블로 월별 합계내기 (엑셀 VBA 매크로)", "input": "", "output": "Sub pivot_Table_Practice_1()\nDim strName As String\n'피벗 테이블 이름 넣을 변수\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngT As Range\n'피벗테이블이 생성될 지점\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\n'------------------------------------\n' 피벗 테이블 조건을 설정하는 코드\n'------------------------------------\nstrName = \"PivotTable1\"\n'피벗 테이블 이름을 변수에\nSet rngAll = Range(\"A1\").CurrentRegion\n'전체 영역을 개체변수에\nWith Sheets(2)\n'Sheet2 에서\n.Activate\n'활성화\nCells.Delete xlUp\n'기존 데이터 삭제\nSet rngT = Range(\"A1\")\n'피벗테이블 생성 위치를 변수에\nEnd With\n'------------------------------------------\n' 피벗 테이블을 조건에 따라 생성하는 코드\n'------------------------------------------\nActiveWorkbook.PivotCaches.Create(1, rngAll, 5).\nCreatePivotTable\n_\nTableDestination:=rngT, _\nTableName:=strName, _\nDefaultVersion:=5\n'현재파일에 피벗테이블을 rngT 위치에 strName 이름 엑셀 2013 버전으로 생성\n'----------------------------------\n' 피벗 테이블의 테이블 생성 코드\n'----------------------------------\nWith ActiveSheet.\nPivotTables\n(strName)\n'현재시트 피벗테이블\nWith .\nPivotFields\n(\"월\")\n'\"월\" 필드\n.Orientation = xlRowField\n'행 방향\n.Position = 1\n'첫 번째에\nEnd With\nWith .PivotFields(\"품목\")\n'\"품목\" 필드\n.Orientation = xlColumnField\n'열 방향\n.Position = 1\n'첫 번째에\nEnd With\n'------------------------------------------------\n' 테이블에 데이터 입력하고 서식 지정하는 코드\n'------------------------------------------------\n.\nAddDataField\n.PivotFields(\"매출\"), \"Sum of 매출\", xlSum\n'\"매출\"의 합계를 데이터 필드에\n.PivotFields(\"Sum of 매출\").NumberFormat = \"#,##0_ \"\n'서식을 콤마 있는 숫자로\nEnd With\n'-----------------------------\n' 막대차트를 삽입하는 코드\n'-----------------------------\nWith ActiveSheet\n'현재 시트에서\n.\nShapes.AddChart2\n(201, xlColumnClustered).Select\n'\n차트\n삽입\nWith .Cells(Rows.Count, \"A\").End(xlUp)(3)\n'마지막 데이터 1행 건너뛴 위치\nSelection.Left = .Left\n'차트 왼쪽을 셀 왼쪽위치\nSelection.Top = .Top\n'차트 윗쪽을 셀 윗쪽 위치로\nEnd With\nActiveChart.SetSourceData Source:=.UsedRange\n'현재시트 사용영역을 차트영역으로\nEnd With\nActiveChart\n.ChartTitle.Text = \"월별 합계\"\n'차트 제목 입력\nSet rngAll = Nothing\n'개체변수(들) 초기화\nSet rngT = Nothing\nEnd Sub", "context": "매크로 실행 전 Sheet1의 데이터 (Sheet2는 비어 있는 상태)\n매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub pivot_Table_Practice_1()\nDim strName As String\n'피벗 테이블 이름 넣을 변수\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngT As Range\n'피벗테이블이 생성될 지점\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\n'------------------------------------\n' 피벗 테이블 조건을 설정하는 코드\n'------------------------------------\nstrName = \"PivotTable1\"\n'피벗 테이블 이름을 변수에\nSet rngAll = Range(\"A1\").CurrentRegion\n'전체 영역을 개체변수에\nWith Sheets..."}
{"instruction": "Excel VBA code for: (1486) 피벗테이블 이용 담당자별 월별 합계구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub pivot_Table_Practice_3()\nDim strName As String\n'피벗 테이블 이름 넣을 변수\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngT As Range\n'피벗테이블이 생성될 지점\nDim i As Integer\n'반복구문에 사용할 변수\nDim strFld As String\n'필드 이름 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\n'------------------------------------\n' 피벗 테이블 조건을 설정하는 코드\n'------------------------------------\nstrName = \"PivotTable1\"\n'피벗 테이블 이름을 변수에\nSet rngAll = Range(\"A1\").CurrentRegion\n'전체 영역을 개체변수에\nWith Sheets(2)\n'Sheet2 에서\n.Activate\n'활성화\nCells.Delete xlUp\n'기존 데이터 삭제\nSet rngT = Range(\"A1\")\n'피벗테이블 생성 위치를 변수에\nEnd With\n'-------------------------------------------\n' 피벗 테이블을 조건에 따라 생성하는 코드\n'-------------------------------------------\nActiveWorkbook.PivotCaches.Create(1, rngAll, 5).\nCreatePivotTable\n_\nTableDestination:=rngT, _\nTableName:=strName, _\nDefaultVersion:=5\n'현재파일에 피벗테이블을 rngT 위치에 strName 이름 엑셀 2013 버전으로 생성\n'----------------------------------\n' 피벗 테이블의 테이블 생성 코드\n'----------------------------------\nWith ActiveSheet.\nPivotTables\n(strName)\n'현재시트 피벗테이블\nFor i = 1 To 3\n'1 ~ 3까지 1씩 증가하며 반복\nstrFld =\nChoose\n(i, \"Rep\", \"Month\", \"Region\")\n'각 지역을 선택하여 변수에\nWith .\nPivotFields\n(strFld)\n'필드\n.Orientation = i\n'필드 위치(1=행, 2=열, 3=필터)\n.Position = 1\n'첫 번째에\nEnd With\nNext i\n'-----------------------------------------------\n' 테이블에 데이터 입력하고 서식 지정하는 코드\n'-----------------------------------------------\n.\nAddDataField\n.PivotFields(\"Sales\"), \"Sum of Sales\", xlSum\n'\"매출\"의 합계를 데이터 필드에\n.PivotFields(\"Sum of Sales\").NumberFormat = \"#,##0_ \"\n'서식을 콤마 있는 숫자로\nEnd With\nRange(\"B3\") = \"월\"\n'B3 셀에 \"열\" 입력\nColumns(\"B\").AutoFit\n'B열 열너비 자동맞춤\nSet rngAll = Nothing\n'개체변수(들) 초기화\nSet rngT = Nothing\nEnd Sub", "context": "매크로 실행 전 (Sheet2 는 비어 있는 상황)\n매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub pivot_Table_Practice_3()\nDim strName As String\n'피벗 테이블 이름 넣을 변수\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngT As Range\n'피벗테이블이 생성될 지점\nDim i As Integer\n'반복구문에 사용할 변수\nDim strFld As String\n'필드 이름 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\n'------------------------------------\n' 피벗 테이블 조건을 설정하는 코드\n'------------------------------------\nstrName = \"PivotTable1\"\n'피벗 테이블 이름을 변수에\nSet rngAll = Range(\"A1\").CurrentRegion\n'전..."}
{"instruction": "Excel VBA code for: (1487) 지정한 레벨에 따라 값을 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub place_Level_And_Copy()\nDim rngAll As Range\n'전체(All) 영역을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim rngR As Range\n'각 행(R)ow을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Range(\"I2\", Cells(Rows.Count, \"I\").End(3))\n'I열 제목 제외한 전체 데이터를 개체변수에 넣음\nrngAll.Offset(, -7).Resize(, 5).Clear\n'기존 데이터 삭제\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nCells(rngC.Row, rngC + 1) = rngC.\nPrevious\n'각 셀의 레벨위치에 값 복사\nNext rngC\nWith Cells(2, 2)\n.\nInterior.Color\n=\nvbYellow\n'노란색 채우기\n.Resize(, Cells(2, 9)) = Cells(2, 8)\n'첫 행 예외 처리\nEnd With\nFor Each rngR In rngAll.Offset(, -7).Resize(, 5).\nRows\n'전체영역을 왼쪽으로 7열 간뒤 오른쪽 5열로 확장하고 각 열 순환\nFor Each rngC In rngR.\nCells\n'각 열의 각 셀을 순환\nWith rngC\n'각 셀에서\nIf\nIsEmpty\n(.Offset(-1)) And _\n.\nColumn\n< Cells(.Row, 9) + 1 Then\n'윗셀이 비어 있거나 지정 열보다 왼쪽에 있을 경우\nrngC = .End(2)\n'셀에 제일 오른쪽 레벨 값을 채움\n.Interior.Color = vbYellow\n'노란색 채우기\nElseIf IsEmpty(rngC) And _\n.Column < Cells(.Row, 9) + 1 Then\n'셀값이 비어 있거나 지정열보다 왼쪽에 있을 경우\nrngC = .Offset(-1)\n'셀에 윗셀 값을 넣음\n.Interior.Color = vbYellow\n'노란색 채우기\nEnd If\nEnd With\nNext rngC\nNext rngR\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. I열의 개수에 따라 H열의 값을 각 행의 B열 부터 오른쪽으로 복사\n2. I열의 레벨이 1 인 경우 H열의 값을 복사\n3. B:F 열의 레벨 값은 위에 값이 있을 경우 윗 값을 복사\n4. 위에 값이 있더라도 B:F 열의 제일 오른쪽 값은 H열의 값을 복사\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub place_Level_And_Copy()\nDim rngAll As Range\n'전체(All) 영역을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim rngR As Range\n'각 행(R)ow을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngAll = Range(\"I2\", Cells(Rows.Count, \"I\").End(3))\n'I열 제목 제외한 전체 데이터를 개체변수에 넣음\nrngAll.Offset(, -7).Resize(, 5).Clear\n'기존 데이..."}
{"instruction": "Excel VBA code for: (1488) 특정 영역에 순차적으로 값 채우기 연습 15 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_23()\nDim rngCol As Range\n'각 열(Col)umn을 넣을 영역(개체)변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim cnt As Integer\n'숫자 카운터(c)ou(nt)er 로 사용할 변수\nSet rngCol = Range(\"A1:A5\")\n'첫 열을 개체변수에 넣음\nFor i = 1 To 5\n'5회 반복\nIf cnt = 0 Then\n'만일 카운터가 0일 경우\nfill_Cell rngCol, cnt\n'셀값을 채우는 하위 프로시저 호출\nElse\nDo\n'다음을 실행\nSet rngCol = rngCol.Offset(1, 1).Resize(rngCol.Rows.Count - 1)\n'영역을 오른쪽 열 한행 작은 영역으로 설정\nfill_Cell rngCol, cnt\n'셀값을 채우는 하위 프로시저 호출\nLoop Until\nrngCol.Cells.Count = 1\n'셀 개수가 1개가 될때까지 무한 반복\nD\no\nSet rngCol = rngCol.Offset(-1, 1).Resize(rngCol.Rows.Count + 1)\n'영역을 오른쪽 열 한행 큰 영역으로 설정\nfill_Cell rngCol, cnt\n'셀값을 채우는 하위 프로시저 호출\nLoop Until\nrngCol.Cells.Count = 5\n'셀 개수가 5개가 될때까지 무한 반복\nEnd If\nNext i\nSet rngCol = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nSub fill_Cell(\nByVal\nrngCol As Range,\nByRef\ncnt As Integer)\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nFor Each rngC In rngCol\n'열의 각 셀을 순환\ncnt = cnt + 1\n'카운터 1씩 늘려감\nrngC = cnt\n'셀에 카운터 값을 입력함\nNext rngC\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 결과. 피라미드 모양으로 숫자가 위에서 아래로 순차적으로 채워짐\nOption Explicit\nSub range_Fill_23()\nDim rngCol As Range\n'각 열(Col)umn을 넣을 영역(개체)변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim cnt As Integer\n'숫자 카운터(c)ou(nt)er 로 사용할 변수\nSet rngCol = Range(\"A1:A5\")\n'첫 열을 개체변수에 넣음\nFor i = 1 To 5\n'5회 반복\nIf cnt = 0 Then\n'만일 카운터가 0일 경우\nfill_Cell rngCol, cnt\n'셀값을 채우는 하위 프로시저 호출\nElse\nDo\n'다음을 실행\nSet rngCol = rngCol.Offset(1, 1).Resize(rngCol.Rows.Count - 1)\n'영역을 오른쪽 열 한행 작은 영역으로 설정\nfill_Cell rngCol, cnt\n'셀값을 채우는 하위 프로시저 호출\nLo..."}
{"instruction": "Excel VBA code for: (1489) 특정 영역에 순차적으로 값 채우기 연습 16 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_24()\nDim rngCol As Range\n'각 열(Col)umn을 넣을 영역(개체)변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim cnt As Integer\n'숫자 카운터(c)ou(nt)er 로 사용할 변수\nSet rngCol = Range(\"A1:A10\")\n'첫 열을 개체변수에 넣음\nFor i = 1 To 5\n'5회 반복\nIf cnt = 0 Then\n'만일 카운터가 0일 경우\nfill_Cell rngCol, cnt\n'셀값을 채우는 하위 프로시저 호출\nElse\nDo\n'다음을 실행\nSet rngCol = rngCol.Offset(1, 1).Resize(rngCol.Rows.Count - 2)\n'영역을 오른쪽 열 두행 작은 영역으로 설정\nfill_Cell rngCol, cnt\n'셀값을 채우는 하위 프로시저 호출\nLoop Until\nrngCol.Cells.Count = 2\n'셀 개수가 2개가 될때까지 무한 반복\nDo\nSet rngCol = rngCol.Offset(-1, 1).Resize(rngCol.Rows.Count + 2)\n'영역을 오른쪽 열 두행 큰 영역으로 설정\nfill_Cell rngCol, cnt\n'셀값을 채우는 하위 프로시저 호출\nLoop Until\nrngCol.Cells.Count = 10\n'셀 개수가 10개가 될때까지 무한 반복\nEnd If\nNext i\nSet rngCol = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nSub fill_Cell(\nByVal\nrngCol As Range,\nByRef\ncnt As Integer)\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nFor Each rngC In rngCol\n'열의 각 셀을 순환\ncnt = cnt + 1\n'카운터 1씩 늘려감\nrngC = cnt\n'셀에 카운터 값을 입력함\nNext rngC\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 결과. 다이아몬드 모양으로 숫자가 위에서 아래로 순차적으로 채워짐\nOption Explicit\nSub range_Fill_24()\nDim rngCol As Range\n'각 열(Col)umn을 넣을 영역(개체)변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim cnt As Integer\n'숫자 카운터(c)ou(nt)er 로 사용할 변수\nSet rngCol = Range(\"A1:A10\")\n'첫 열을 개체변수에 넣음\nFor i = 1 To 5\n'5회 반복\nIf cnt = 0 Then\n'만일 카운터가 0일 경우\nfill_Cell rngCol, cnt\n'셀값을 채우는 하위 프로시저 호출\nElse\nDo\n'다음을 실행\nSet rngCol = rngCol.Offset(1, 1).Resize(rngCol.Rows.Count - 2)\n'영역을 오른쪽 열 두행 작은 영역으로 설정\nfill_Cell rngCol, cnt\n'셀값을 채우는 하위 프로시저 호출\n..."}
{"instruction": "Excel VBA code for: (1490) 특정 영역에 순차적으로 값 채우기 연습 17 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_25()\nDim rngAll As Range\n'반복구간 영역을 넣을 변수\n﻿\n﻿\n﻿\nDim i As Integer\n'반복구문에 사용할 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim cnt As Integer\n'숫자 카운터(c)ou(nt)er 로 사용할 변수\nSet rngAll = Range\n(\"A3:A6, B6:C6, C5, C4,C3:D3\"\n)\n'반복 영역을 변수에 넣음\nFor i = 1 To 5\n'5회 반복\nFor Each rngC In rngAll\n'rngAll 영역의 각 셀을 순환\ncnt = cnt + 1\n'카운터 1씩 늘려감\nrngC = cnt\n'셀에 카운터 값을 입력함\nNext rngC\nrngAll.\nBorders.LineStyle\n= 1\n'외곽에 테두리 그리기\nrngAll.\nInterior.ColorIndex\n= 19\n'색 채우기\nSet\nrngAll = rngAll.Offset(, 4)\n'rngAll 영역을 오른쪽으로 4열 이동\nNext i\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 결과.\nOption Explicit\nSub range_Fill_25()\nDim rngAll As Range\n'반복구간 영역을 넣을 변수\n﻿\n﻿\n﻿\nDim i As Integer\n'반복구문에 사용할 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim cnt As Integer\n'숫자 카운터(c)ou(nt)er 로 사용할 변수\nSet rngAll = Range\n(\"A3:A6, B6:C6, C5, C4,C3:D3\"\n)\n'반복 영역을 변수에 넣음\nFor i = 1 To 5\n'5회 반복\nFor Each rngC In rngAll\n'rngAll 영역의 각 셀을 순환\ncnt = cnt + 1\n'카운터 1씩 늘려감\nrngC = cnt\n'셀에 카운터 값을 입력함\nNext rngC\nrngAll.\nBorders.LineStyle\n= 1\n'외곽에 테두리 그리기\nrngAll.\nInterior.ColorIndex\n= 19\n'색 채우기\nSet\nrngAl..."}
{"instruction": "Excel VBA code for: (1492) 특정 영역에 순차적으로 값 채우기 연습 19 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_27()\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim cnt As Integer\n'숫자 카운터(c)ou(nt)er 로 사용할 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim rngAll As Range\n'반복구간 영역을 넣을 변수\nSet\nrngAll = Range(\"A2, A6, B3, B5, C4, D3, D5\")\n'반복 영역을 변수에 넣음\nFor i = 1 To 5\n'5회 반복\nFor Each rngC In rngAll\n'rngAll 영역의 각 셀을 순환\ncnt = cnt + 1\n'카운터 1씩 늘려감\nrngC = cnt\n'셀에 카운터 값을 입력함\nNext rngC\nrngAll.\nBorders.LineStyle\n= 1\n'외곽에 테두리 그리기\nrngAll.\nInterior.ColorIndex\n= 19\n'색 채우기\nSet rngAll = rngAll.Offset(, 4)\n'rngAll 영역을 오른쪽으로 4열 이동\nNext i\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 결과. 가운데가 빈 다이아몬드 모양으로 숫자가 위에서 아래로 순차적으로 채워짐\nOption Explicit\nSub range_Fill_27()\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim cnt As Integer\n'숫자 카운터(c)ou(nt)er 로 사용할 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim rngAll As Range\n'반복구간 영역을 넣을 변수\nSet\nrngAll = Range(\"A2, A6, B3, B5, C4, D3, D5\")\n'반복 영역을 변수에 넣음\nFor i = 1 To 5\n'5회 반복\nFor Each rngC In rngAll\n'rngAll 영역의 각 셀을 순환\ncnt = cnt + 1\n'카운터 1씩 늘려감\nrngC = cnt\n'셀에 카운터 값을 입력함\nNext rngC\nrngAll.\nBorders.LineStyle\n= 1\n'외곽에 테두리 그리기\nrngAll.\nInterior...."}
{"instruction": "Excel VBA code for: (1493) 전각문자를 반각문자로 변환하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_each_Letter()\nDim rngAll As Range\n'전체(All)영역을 넣을 영역변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역변수\nDim i As Integer\n'셀의 문자길이만큼 반복할 변수\nDim strEach As String\n'추출한 각(Each) 문자 넣을 변수\nDim strU As String\n'문자를 합쳐(U)nion 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"A1:A11\")\n'전체영역을 개체(영역)변수에 넣음\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nFor i = 1 To Len(rngC)\n'각셀의 문자 길이 만큼 반복\nstrEach =\nMid\n(rngC, i, 1)\n'셀의 각 문자를 변수에 넣음\nstrU = strU &\nStrConv\n(strEach,\nvbNarrow\n)\n'전각을 반각으로 변환 후 합침\nNext i\nrngC.Next = strU\n'각셀의 오른쪽에 합친문자 뿌림\nstrU = \"\"\n'재사용 위하여 초기화\nNext rngC\nColumns(\"B\").\nAutoFit\n'B열 열너비 자동맞춤\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "전각문자를 반각문자로 바꿔주는 기능.\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub extract_each_Letter()\nDim rngAll As Range\n'전체(All)영역을 넣을 영역변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역변수\nDim i As Integer\n'셀의 문자길이만큼 반복할 변수\nDim strEach As String\n'추출한 각(Each) 문자 넣을 변수\nDim strU As String\n'문자를 합쳐(U)nion 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"A1:A11\")\n'전체영역을 개체(영역)변수에 넣음\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nFor i = 1 To Len(rngC)\n'각셀의 문자 길이 만큼 반복\nstrEach =\nMid\n(rngC, i, 1)\n'셀의 각 문자를 변수에..."}
{"instruction": "Excel VBA code for: (1494) 폴더내 파일 열지 않고 데이터 통합 기본코드 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub get_From_Closed_Files3()\nDim strSht As String\n'시트 이름을 넣을 변수\nDim rngData As Range\n'데이터 영역을 넣을 영역변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n'--------------------------------------------------------------------\n' 본인 시트명과 데이터 영역으로 수정사용. 시트명 틀리면 엑셀 에러창 뜸\n'--------------------------------------------------------------------\nstrSht = \"\nSheet1\n\"\n'데이터가 저장된 시트의 이름\nSet rngData = Range(\"\nB2:E4\n\")\n'데이터가 입력된 영역\nWith rngData\n'데이터 입력된 영역에서\n.ClearContents\n'기존 데이터 삭제\nrngData.Offset(10).ClearContents\n'임시 복사영역 '기존 데이터 삭제\nEnd With\n'-------------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'-------------------------------------------------\nChDir ThisWorkbook.Path\n'매크로 실행파일과 동일한 경로 기준\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더를 선택한 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'-------------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'-------------------------------------\nfileName =\nDir\n(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\n'-----------------------------------------------------------------\n' 배열수식을 이용하여 데이터 가져오고 수식을 값으로 변환하는 코드\n'-----------------------------------------------------------------\nWith rngData.Offset(10)\n'데이터 영역의 10행 아래 임시영역에서\n.\nFormulaArray\n= \"='\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & rngData.Address(1, 1, 1)\n'데이터 영역을 배열로 가져옴\n.\nValue\n= .\nValue\n'셀의 수식을 값으로 바꿈\nEnd With\n'-----------------------------------------------------------------\n' 데이터 통합을 이용하여 B7:E9 영역과 B12:E14 영역을 합하는 코드\n'-----------------------------------------------------------------\nWith rngData.Offset(5)\n'데이터 영역 5행 아래 영역에서\n[B2].\nConsolidate\nSources:=Array(.Address(1, 1, xlR1C1, 1), _\n.Offset(5).Address(1, 1, xlR1C1, 1)), Function:=\nxlSum\n, _\nTopRow:=False, LeftColumn:=False\n'데이터 통합기능을 이용해 합쳐간다\nEnd With\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nSet rngData = Nothing\n'개체변수 초기화(메모리 비우기)\n﻿\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력﻿\nEnd Sub", "context": "폴더내 모든 파일을 통합하는 가장 빠른 코드를 찾기 위해 한 참을 헤매었는데, 이 코드를 알기 전에는 안보이더니 이 코드를 알게된 후 인터넷을 돌아다녀보니 유사한 코드가 여럿 눈에 들어왔다. 역시 아는 것만 보이나 보다.\n지금껏 올렸던 그 어떤 코드보다도 빠르게 파일을 열지 않고 통합할 수 있다. 파일 크기에 따라 영향을 받지만 첨부한 예제 파일과 같이 작은 파일의 경우 대략\n1초에 100개\n가량의 파일을 작업할 수 있다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1494) 폴더내 파일 열지 않고 데이터 통합 기본코드 2 (엑셀 VBA 매크로)\n재생\n3,176\n공유하기\n재생 (space/k)\n재생\n00:25\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:25\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함..."}
{"instruction": "Excel VBA code for: (1495) 폴더속 모든파일내 각 시트를 현재파일 각 시트에 통합하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_All_Sheets_In_Folder_7()\nDim rngT As Range\n'데이터 복사될 영역 넣을 변수\nDim strSht As String\n'시트 이름을 넣을 변수\nDim rngData As Range\n'데이터 영역을 넣을 영역변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim i As Integer\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngT = Range(\"A2:C4\")\n'데이터가 복사될 영역\n'-------------------\n' 기존 데이터 삭제\n'-------------------\nFor i = 1 To 12\n'1 ~ 12까지 반복\nWith Worksheets(i)\n'각 시트에서\n.Range(rngT.Address).ClearContents\n'기존 데이터 삭제\n.Range(rngT.Offset(6).Address).ClearContents\nEnd With\n'임시 복사영역 '기존 데이터 삭제\nNext i\n'----------------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'----------------------------------------------------\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더를 선택한 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'-----------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'-----------------------------------\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nFor i = 1 To 12\nSet rngData = Worksheets(i).Range(\"A1:C3\")\n'데이터가 입력된 영역\nstrSht = i & \"월\"\n'데이터가 저장된 시트의 이름\nWith Worksheets(i).Range(rngT.Offset(6).\nAddress\n)\n'데이터 복사될 영역 6행 아래 임시영역에서\n.\nFormulaArray\n= \"='\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & rngData.Address(1, 1, 1)\n'데이터 영역을 배열로 가져옴\n.Value = .Value\n'셀의 수식을 값으로 바꿈\nEnd With\nWith Worksheets(i).Range(rngT.Offset(3).Address)\nWorksheets(i).[A2].\nConsolidate\nSources:=Array(.Address(1, 1, xlR1C1, 1), _\n.Offset(3).Address(1, 1, xlR1C1, 1)), Function:=xlSum, _\nTopRow:=False, LeftColumn:=False\n'데이터 통합기능을 이용해 합쳐간다\nEnd With\nNext i\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nSet rngData = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1495) 폴더속 모든파일내 각 시트를 현재파일 각 시트에 통합하기 (엑셀 VBA 매크로)\n재생\n1,500\n재생 (space/k)\n재생\n00:49\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:49\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n데이터를 통합할 현재시트에 1 ~ 12월로 구분된 12개의 시트가 있음\n폴더내 각 파일에도 동일한 이름의 1..."}
{"instruction": "Excel VBA code for: (1497) 문자 + 숫자로 입력된 데이터 정렬하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_Text_As_Ascending()\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim colNo As Integer\n'열 번호를 넣을 변수\nDim rngC As Range\n'데이터영역의 각 셀(C)ell을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim strEach As String\n'각(Each) 문자를 넣을 변수\nDim strU As String\n'합쳐진(U)nion 문자를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith\nSelection\n'선택영역에서\n'-------------------------------------------------\n' 영역선택 오류 시 사용자에게 이를 알리는 코드\n'-------------------------------------------------\nIf .\nAreas.Count\n> 1 Or .Columns.Count > 1 Then\n'복수영역 또는 1열 이상 선택 시\nMsgBox \"1개의 area만, 1개의 열만 선택가능\", 64, \"영역설정 에러\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nIf .\nCells.Count\n= 1 Then\n'1셀만 선택 시\nMsgBox \"1셀 이상 선택\", 64, \"영역설정 에러\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\ncolsCnt = .EntireRow.SpecialCells(2).\nColumns.Count\n'전체 열개수 추출하여 변수에\ncolNo = .Column\n'열번호 추출\n.Offset(, 1).EntireColumn.\nInsert\n'오른쪽에 열 삽입\n'------------------------------------------------\n' 셀내의 각 문자가 숫자인지 확인 후 합치는 코드\n'------------------------------------------------\nFor Each rngC In Selection\n'선택영역의 각셀(rngC)을 순환\nFor i = 1 To Len(rngC)\n'1부터 전체 문자 길이까지 1씩 증가\nstrEach = Mid(rngC, i, 1)\n'각 분자를 변수에 넣음\nIf strEach\nLike \"[0-9]\"\nOr strEach = \".\" Then\n'만약 각 문자가 숫자 또는 점(.)이라면\nstrU = strU & strEach\n'각 문자를 합쳐감\nEnd If\nNext i\nrngC.\nNext\n= strU\n'합쳐진 문자를 오른쪽에 넣음\nstrU = \"\"\n'재사용 하기 위하여 초기화\nNext\n'--------------------------------------------------------------------\n' 선택영역을 전체열로 확장 후 오름차순 정렬하고 임시열 삭제하는 코드\n'--------------------------------------------------------------------\nWith .EntireRow\n'선택영역을 전체열로 확장\n.\nSort\n.Columns(colNo + 1).Cells(1), 1\n'선택영역의 오른쪽열 기준 오름차순 정렬\n.Columns(colNo + 1).Delete\n'임시로 사용한 정렬기준 데이터 삭제\n.Cells(colNo).Select\n'첫 번째셀 선택\nEnd With\nEnd With\nEnd Sub", "context": "(\nhttp://blog.naver.com/rosa0189/60210799623\n:\n아래 코드를 보완한 코드를 여기 올림. 아래코드는 문자가 모두 \"정렬\"로 동일한 경우에만 정상작동. 예를 들어 A1, E7, B10, D7, C3 .....과 같은 데이터의 경우에는 숫자를 기준으로 오름차순 정렬하여 원치 않는 결과가 나올 수 있음.)\n문자 + 숫자가 입력된 영역의 데이터를 선택하고 매크로 실행하면 숫자에 따라 오름차순 정렬해주는 기능. 아래 동영상에서 보듯\n한 개의 열만을 선택하고 매크로를 실행\n하여야 한다.\n매크로 실행 전                                                   A열을 기준으로 일반적인 정렬을 하였을 경우\nA열을 영역 선택하고 매크로 실행한 결과 (숫자를 기준으로 오름차순으로 정렬되며, 다른 열의 데이터도 함께 A열에 따라 이동한다.)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1497)..."}
{"instruction": "Excel VBA code for: (1498) 두 영역의 데이터 서로 바꾸기 (엑셀 VBA 매크로)", "input": "", "output": "Sub swap_Two_Areas()\nDim intAreas As Integer\n'area 개수를 넣을 변수\nDim rngLeft As Range\n'왼쪽 영역을 넣을 영역변수\nDim rngRight As Range\n'오른쪽 영역을 넣을 개체 영역변수\nDim varTemp\n'임시로 데이터를 저장할 배열변수\nWith Selection\n'선택 영역에서\nintAreas = .\nAreas\n.\nCount\n'영역(area)의 개수를 변수에 넣음\nIf intAreas <> 2 Then\n'영역이 두 개가 아니면 중단\nMsgBox \"선택영역이 2개가 아님\", 64, \"영역선택 오류\"\nExit Sub\n'매크로 종료\nEnd If\nSet rngLeft = .Areas(1)\n'왼쪽 area를 개체변수에 넣음\nSet rngRight = .Areas(2)\n'오른쪽 area를 개체변수에 넣음\nIf rngLeft.\nRows.Count\n<> rngRight.Rows.Count Or _\nrngLeft.\nColumns.Count\n<> rngRight.Columns.Count Then\n'왼쪽 영역과 오른쪽 영역의 행 또는 열 개수가 다를 경우\nMsgBox \"두 영역의 행/열 크기가 다름\", 64, \"영역선택 오류\"\nExit Sub\n'매크로 종료\nEnd If\nEnd With\nvarTemp = rngLeft\n'왼쪽 영역을 임시배열에 넣음\nrngLeft = rngRight.Value\n'오른쪽 영역을 왼쪽 영역에 복사\nrngRight = varTemp\n'오른쪽 영역에 배열 값을 넣음\nSet rngLeft = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngRight = Nothing\nEnd Sub", "context": "Ctrl + 마우스\n를 이용하여 두 영역을 선택하고 매크로를 실행하면 선택한 두 영역의 데이터를 서로 바꾸어주는 기능이다. 당연히 두 개의 영역만을 선택하고 매크로를 실행해야 하며,\n바꾸려는 두 영역의 행/열 크기는 동일\n하여야 한다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1498) 두 영역의 데이터 서로 바꾸기 (엑셀 VBA 매크로)\n재생\n693\n재생 (space/k)\n재생\n00:26\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:26\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가..."}
{"instruction": "Excel VBA code for: (1499) 정렬을 이용하여 빈셀만 아래로 보내기 (엑셀 VBA 매크로)", "input": "", "output": "Sub send_Blank_Cells_To_End()\nDim rngAll As Range\n'전체 영역을 넣을 영역변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"E2\", Cells(Rows.Count, \"E\").End(3))\n'E열 제목제외한 전체데이터 변수에\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nIf Len(rngC.Offset(, -4)) <> 0 Then\n'왼쪽 4번째셀 즉 A열이 빈셀이 아니라면\nrngC.\nNext\n=\n1\n'오른쪽 셀에 1 입력\nEnd If\nNext rngC\nActiveSheet.UsedRange.\nSort\nCells(2, 6), 1, Header:=xlYes\n'F열 기준 오름차순 정렬\nColumns(\"F\").Delete\n'임시 열 삭제\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "매크로 실행 전                                                   매크로 실행 후 결과\nOption Explicit\nSub send_Blank_Cells_To_End()\nDim rngAll As Range\n'전체 영역을 넣을 영역변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nSet rngAll = Range(\"E2\", Cells(Rows.Count, \"E\").End(3))\n'E열 제목제외한 전체데이터 변수에\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nIf Len(rngC.Offset(, -4)) <> 0 Then\n'왼쪽 4번째셀 즉 A열이 빈셀이 아니라면\nrngC.\nNext\n=\n1\n'오른쪽 셀에 1 입력\nEnd If\nNext rngC\nActiveSheet.UsedRange.\nSort\nCells(2, 6), 1, H..."}
{"instruction": "Excel VBA code for: (1500) 홀수/짝수열만 보이거나 숨기기 (엑셀 VBA 매크로)", "input": "", "output": "Sub show_Odd_Or_Even_Columns()\nDim rngAll As Range\n'전체(All) 영역을 넣을 변수\nDim strName As String\n'도형의 문자를 넣을 변수\nWith ActiveSheet.\nShapes\n(Application.Caller)\n'매크로 실행한 도형\nstrName = .\nTextFrame2.TextRange\n.Text\n'도형문자를 변수에 넣음\nEnd With\nSet rngAll = Range(\"B1:AF1\")\n'전체 영역을 변수에 넣음\nrngAll.\nEntireColumn\n.\nHidden\n= False\n'전체 영역의 숨기기 해제\nSelect Case\nstrName\n'strName을 선택\nCase\n\"홀  수\"\n' \"홀  수\"가 선택된 경우\nCall odd_Or_Even(rngAll, 1)\n' 하위 프로시저를 (전체영역, 1)과 함께 호출\nCase\n\"짝  수\"\n' \"짝  수\"가 선택된 경우\nCall odd_Or_Even(rngAll, 0)\n' 하위 프로시저를 (전체영역, 0)과 함께 호출\nEnd Select\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nSub odd_Or_Even(ByRef rngAll As Range, ByRef intNo As Integer)\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim rngU As Range\n'합쳐진 영역을 넣을 변수\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\nIf rngC.Column\nMod 2\n= intNo Then\n'각 셀의 열을 2로 나눈 결과가 intNo면\nIf rngU Is Nothing Then\n'rngU가 비어 있을 경우\nSet rngU = rngC\n'첫 셀을 넣음\nElse\n'rngU가 비어 있지 않을 경우\nSet rngU =\nUnion\n(rngU, rngC)\n'각 영역을 합쳐감\nEnd If\nEnd If\nNext rngC\nrngU.EntireColumn.Hidden = True\n'합쳐진 영역을 숨기기\nEnd Sub", "context": "전체 버튼을 클릭했을 때의 결과\n홀수 버튼을 클릭하였을 때의 결과(3, 5, 7 ... 열이 숨겨짐)\n짝수 버튼을 클릭하였을 때의 결과(2, 4, 6, 8 ... 열이 숨겨짐)\nOption Explicit\nSub show_Odd_Or_Even_Columns()\nDim rngAll As Range\n'전체(All) 영역을 넣을 변수\nDim strName As String\n'도형의 문자를 넣을 변수\nWith ActiveSheet.\nShapes\n(Application.Caller)\n'매크로 실행한 도형\nstrName = .\nTextFrame2.TextRange\n.Text\n'도형문자를 변수에 넣음\nEnd With\nSet rngAll = Range(\"B1:AF1\")\n'전체 영역을 변수에 넣음\nrngAll.\nEntireColumn\n.\nHidden\n= False\n'전체 영역의 숨기기 해제\nSelect Case\nstrName\n'strName을 선택\nCase\n\"홀  수\"\n' \"홀  수\"가 선택된 경우..."}
{"instruction": "Excel VBA code for: (1502) 셀병합된 데이터 정렬하기 6 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_Irregulary_Merged_Cells()\nDim intCol As Integer\n'정렬할 열을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'행 방향 반복할 변수\nDim c As Integer\n'열 방향 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트(일시) 중지\nintCol = 2\n'(선택영역의) 2열 기준 정렬\nWith Selection\n'선택영역에서\nIf .Cells.Count = 1 Or\nWorksheetFunction.CountA\n(.Cells) < 2 _\nOr\n.Columns.Count\n< intCol Then\n'한 셀 선택, 데이터가 2개 이하 또는 intCol보다 선택영역 열개수가 작으면\nMsgBox \"데이터 영역 설정 오류로 중단합니다.\", 64, \"영역설정 오류\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nEnd With\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.\nClear\n'기존 데이터 삭제\nSelection.\nCopy\n.Cells(1, 1)\n'선택영역을 Sheet2에 복사\n.Activate\n'활성화\nEnd With\nCall\nunMerge_and_Fill\n'셀병합 해제 후 복사하는 하위 코드 실행\nWith ActiveSheet.UsedRange\n.\nSort\nCells(1, intCol), 1, Header:=xlNo\n'B열기준 오름차순 정렬\nApplication.\nDisplayAlerts\n=\nFalse\n'화면경고 중단\nFor r = .Rows.Count To 2 Step -1\n'전체행에서 1씩 빼며 2행 까지 반복\nIf Cells(r, intCol) = Cells(r - 1, intCol) Then\n'B열 위아래 셀이 같은 값이면\nFor c = 2 To .Columns.Count\n'2열부터 1씩 증가하며 전체열 개수까지 반복\nCells(r - 1, c).Resize(2).\nMerge\n'셀병합\nNext c\nEnd If\nNext r\nApplication.DisplayAlerts = True\n'화면경고 복원\n.Borders.\nLineStyle\n= 1\n'테두리 그리기\nEnd With\nColumns.AutoFit\n'열너비 자동맞춤\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub\n\nSub unMerge_and_Fill()\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim r As Long\n'카운터로 사용할 변수\nFor Each rngC In ActiveSheet.UsedRange\n'데이터 영역 각 셀을 순화\nIf rngC.MergeCells Then\n'만일 선택셀이 셀병합 되어 있다면\nWith rngC.\nMergeArea\n'셀병합된 area를\n.\nUnMerge\n'셀병합을 풀고\n.Value = rngC\n'셀병합 풀린영역 셀병합전 값으로 채움\nEnd With\nEnd If\nNext\nEnd Sub", "context": "셀병합이 적용된 B열을 기준으로 오름차순 정렬하기는 기능. 이를 위해,\n1. 셀병합이 적용된 셀들의 셀병합을 해제한 후 데이터를 복사하고,\n2. B열 기준으로 오름차순 정렬을 적용한 다음,\n3. B열 기준으로 다시 셀병합하고, 셀병합을 해제한 다른 열도 동시에 셀병합을 수행한 뒤,\n4. 마지막으로 테두리를 그려주는 작업을 수행.\n매크로 실행 전 Sheet1 (\n제목 제외한 A2:D10 영역을 먼저 선택\n하고 매크로 실행)\n매크로 실행 후 Sheet2 의 결과 (B열을 기준으로 오름차순 정렬됨)\nOption Explicit\nSub sort_Irregulary_Merged_Cells()\nDim intCol As Integer\n'정렬할 열을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'행 방향 반복할 변수\nDim c As Integer\n'열 방향 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트(일시)..."}
{"instruction": "Excel VBA code for: (1503) 일치한 값의 열 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Function topRow(rngSel As Range)\n'(찾을 값을 넣은 영역)\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nApplication.Volatile\n'엑셀 calculation 시 이 함수도 강제 재계산\nFor Each rngC In Range(\"A1:I6\")\n'A1:I6영역 각셀 순환\nIf rngC = rngSel Then\n'서로 값이 같은 경우\ntopRow = Cells(1, rngC.Column)\n'열 값을 함수에 되돌려 줌\nExit Function\n'함수 종료\nEnd If\nNext rngC\ntopRow = \"일치 없음\"\n'일치하는 값이 없을 경우 \"일치 없음\"을 함수에 돌려줌.\nEnd Function", "context": "K열에 있는 값들이 A1:I6 영역에 있을 경우, 일치한 위치의 열 값을 추출하고, 만일 일치하는 값이 없을 경우에는 \"일치 없음\"을 출력하는 사용자정의 함수. 일치하는 값 구분을 쉽게 하기 위해 색표시 해둠.\n셀에 =topRow(K2)라고 입력\n아래로 복사\nOption Explicit\nFunction topRow(rngSel As Range)\n'(찾을 값을 넣은 영역)\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nApplication.Volatile\n'엑셀 calculation 시 이 함수도 강제 재계산\nFor Each rngC In Range(\"A1:I6\")\n'A1:I6영역 각셀 순환\nIf rngC = rngSel Then\n'서로 값이 같은 경우\ntopRow = Cells(1, rngC.Column)\n'열 값을 함수에 되돌려 줌\nExit Function\n'함수 종료\nEnd If\nNext rngC\ntopRow = \"일치 없음\"\n'일치하는 값이 없을 경우 \"일치 없..."}
{"instruction": "Excel VBA code for: (1504) 연결된 문자 중 두 단어를 서로 바꾸기 (엑셀 VBA 매크로)", "input": "", "output": "Sub switch_4th_Or_5th()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nDim var\n'단어를 \"-\" 나누어 넣을 배열변수\nDim strTemp As String\n'임시로 값을 넣을 변수\nDim strU As String\n'합친 문자를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet\nrngAll = Range(\"B2:B11\")\n'데이터 영역을 개체변수에 넣음\nFor Each rngC In rngAll\n'전체영역(rngAll)의 각셀(rngC)을 순환\nvar = Split(rngC, \"-\")\n' \"-\"를 구분자로 셀 값을 분리\nIf\nUBound\n(var) = 4 Then\n'분리된 단어가 4개일 경우\nstrTemp = var(UBound(var) - 1)\n'끝에서 두 번째 단어를 변수에 넣음\nvar(UBound(var) - 1) = var(UBound(var))\n'제일 끝 단어를 끝에서 두 번째에 넣음\nvar(UBound(var)) = strTemp\n'임시로 저장한 단어를 제일 뒤에 넣음\nElse\n'분리된 단어가 5개일 경우\nstrTemp = var(UBound(var) - 2)\n'끝에서 세 번째 단어를 변수에 넣음\nvar(UBound(var) - 2) = var(UBound(var) - 1)\n'끝에서 두 번째 끝에서 세 번째에 넣음\nvar(UBound(var) - 1) = strTemp\n'임시로 저장한 단어를 끝에서 두 번째에 넣음\nEnd If\nstrU =\nJoin\n(var, \"-\")\n'배열 값을 \"-\"를 구분자로 합침\nrngC.Next = strU\n'합친 문자를 셀에 뿌리\nNext\nColumns(\"C\").AutoFit\n'열너비 자동 맞춤\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "하이픈(-)으로 연결된 문자 중 4번째와 5번째의 단어를 서로 바꾸는 기능. 알아보기 쉽도록 색으로 표시해 두었다. B열내의 문자가 어떤 것은 4개, 어떤 것은 5개의 단어가 합쳐져 불규칙한 상황.\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub switch_4th_Or_5th()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nDim var\n'단어를 \"-\" 나누어 넣을 배열변수\nDim strTemp As String\n'임시로 값을 넣을 변수\nDim strU As String\n'합친 문자를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet\nrngAll = Range(\"B2:B11\")\n'데이터 영역을 개체변수에 넣음\nFor Each rngC In rngAll\n'전체영역(rngAll)의 각셀(rngC)을 순환\nvar =..."}
{"instruction": "Excel VBA code for: (1505) 영단어와 한글 분리하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub split_English_And_Korean()\nDim r As Long\n'행(r)ow 을 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim strU As String\n'문자를 합쳐(U)nion 갈 변수\nDim strEach As String\n'각(Each) 문자를 합쳐갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nFor i = 1 To\nLen\n(Cells(r, 1))\n'1부터 셀의 전체 문자길이 까지 1씩 증가하며 반복\nstrEach =\nMid\n(Cells(r, 1), i, 1)\n'각 문자를 변수에 넣음\nIf (strEach >= \"가\" And strEach <= \"힣\") Or _\nstrEach = \"(\" Then\n'문자가 한글 또는 시작 괄호인 경우\nExit For\n'For 구문 종료\nEnd If\nstrU = strU & strEach\n'문자를 합쳐감\nNext i\nCells(r, 2) =\nTrim\n(strU)\n'앞뒤 공백제거 후 B열에 뿌림\nCells(r, 3) =\nRight\n(Cells(r, 1), Len(Cells(r, 1)) - i + 1)\n'영어 제외한 나머지만 C열에 뿌림\nstrU = \"\"\n'재사용 위하여 초기화\nLoop Until\nCells(r + 1, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\nColumns.AutoFit\n'열너비 자동 맞춤\nEnd Sub", "context": "영어 단어와 한글을 분리하여 오른쪽 열에 나누어 주는 기능.\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub split_English_And_Korean()\nDim r As Long\n'행(r)ow 을 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim strU As String\n'문자를 합쳐(U)nion 갈 변수\nDim strEach As String\n'각(Each) 문자를 합쳐갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 늘려감\nFor i = 1 To\nLen\n(Cells(r, 1))\n'1부터 셀의 전체 문자길이 까지 1씩 증가하며 반복\nstrEach =\nMid\n(Cells(r, 1), i, 1)\n'각 문자를 변수에 넣음\nIf (strEach >= \"가\" And strEach <= \"힣\") Or _\nstrEach = \"(\" Then..."}
{"instruction": "Excel VBA code for: (1506) 학교별로 오름차순 정렬하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_As_Per_School()\nDim cnt As Integer\n'카운터(c)ou(nt)er로 사용할 변수\nDim rngAll As Range\n'전체(All) 영역을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"B:D\").ClearContents\n'기존 데이터 삭제\nSet\nrngAll = Range(Cells(1, 1), Cells(Rows.Count, \"A\").End(3))\n'A열 전체 데이터를 개체변수에 넣음\nFor Each rngC In rngAll\n'전체영역 각 셀을 순환\ncnt = cnt + 1\nIf\nInStr\n(rngC, \"고등학교\") Then\n' \"고등학교\"가 포함된 경우\nrngC.Offset(, 1) = cnt\n'B열에 카운터 입력\nElseIf InStr(rngC, \"중학교\") Then\n' \"중학교\"가 포함된 경우\nrngC.Offset(, 2) = cnt\n'C열에 카운터 입력\nElseIf InStr(rngC, \"초등학교\") Then\n' \"초등학교\"가 포함된 경우\nrngC.Offset(, 3) = cnt\n'D열에 카운터 입력\nEnd If\nNext rngC\nFor i = 2 To 4\n'B:D 열까지 반복\nActiveSheet.UsedRange.\nSort\nCells(1, i), 1\n'각 열을 오름차순 정렬\nWith Columns(i).\nSpecialCells(2)\n.Offset(, 1 - i)\n'A열 문자셀 영역에서\n.Sort .Cells(1), 1\n'오름차순 정렬\nEnd With\nNext i\nColumns(\"B:D\").\nDelete\n'임시로 값 넣을 열 삭제\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\"\nEnd Sub", "context": "초등학교, 중학교, 고등학교의 이름이 서로 뒤 섞인 상태. 초등학교 => 중학교 => 고등학교의 순으로 정렬하는 기능.\n매크로 실행 전                                                  매크로 실행 후 결과\nOption Explicit\nSub sort_As_Per_School()\nDim cnt As Integer\n'카운터(c)ou(nt)er로 사용할 변수\nDim rngAll As Range\n'전체(All) 영역을 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nColumns(\"B:D\").ClearContents\n'기존 데이터 삭제\nSet\nrngAll = Range(Cells(1, 1), Cells(Rows.Count, \"A\").End(3))\n'A열 전체 데이터를 개체변수에 ..."}
{"instruction": "Excel VBA code for: (1507) 선택적 자동필터 적용하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub slective_Auto_Filter()\nDim rngAll As Range\n'전체 영역을 넣을 변수\nDim rngCri As Range\n'필터 조건을 넣을 변수\nDim varCri\n'배열로 사용할 변수\nDim i As Integer\n'반복구문에 사용할 변수\nSet rngCri = Columns(\"G\").SpecialCells(2)\n'필터 조건을 변수에 넣음\nIf Not rngCri\nIs Nothing\nThen\n'필터 조건이 있다면\nReDim varCri(1 To rngCri.Cells.Count)\n'배열 크기 재지정\nFor i = 1 To rngCri.Cells.Count\n'1부터 필터조건 개수까지 반복\nvarCri(i) =\nCStr\n(rngCri.Cells(i))\n'문자로 변환하여 배열에 넣음\nNext i\nSet rngAll = Range(\"A1\").\nCurrentRegion\n'A1 연결영역을 변수에 넣음\nrngAll.\nAutoFilter\nCells(1, 6).Value, varCri, 7, , 1\n'자동필터 적용\nEnd If\nSet rngCri = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nSub remove_Filter()\nIf ActiveSheet.FilterMode = True Then\n'필터가 적용되어 있다면\nActiveSheet.UsedRange.AutoFilter\n'현재시트 사용영역의 자동필터 해제\nEnd If\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1507) 선택적 자동필터 적용하기 (엑셀 VBA 매크로)\n재생\n3,118\n재생 (space/k)\n재생\n00:44\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:44\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\nF1 셀에 1 즉, A열을 선택하고 G열에는 필터될 값들을 입력\n매크로 실행하면 G열의 값들만 필터링 되어 보여줌\nRemove Filter ..."}
{"instruction": "Excel VBA code for: (1508) 각 문자의 합 구하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub sum_Of_Each_Letter()\nDim rngC As Range\n'A2:F10 영역의 각 셀을 넣을 변수\nDim rngEach As Range\n'H2:H4영역의 각 셀을 넣을 변수\nDim lngsum As Long\n'합계를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each\nrngC\nI\n﻿\nn\nRange(\"H2:H4\")\n'H2:H4 영역 각 셀을 순환\nFor Each\nrngEach\nIn\nRange(\"A2:F10\")\n'전체 영역내 각 셀을 순환\nIf rngEach = rngC Then\n'셀의 문자가 일치하면\nlngsum = lngsum + rngEach.Next\n'합계에 문자 오른쪽 값을 합쳐감\nEnd If\nNext\nrngEach\nrngC.Next = lngsum\n'합쳐진 값을 오른쪽 셀에 뿌림\nlngsum = 0\n'재사용 위하여 초기화\nNext\nrngC\nEnd Sub", "context": "H열에 있는 문자와 일치하는 A2:F10 셀에 있는 각 문자의 합을 I열에 출력하는 기능.\n매크로 실행 전\n매크로 실행 후 Sheet1의 결과\nOption Explicit\nSub sum_Of_Each_Letter()\nDim rngC As Range\n'A2:F10 영역의 각 셀을 넣을 변수\nDim rngEach As Range\n'H2:H4영역의 각 셀을 넣을 변수\nDim lngsum As Long\n'합계를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor Each\nrngC\nI\n﻿\nn\nRange(\"H2:H4\")\n'H2:H4 영역 각 셀을 순환\nFor Each\nrngEach\nIn\nRange(\"A2:F10\")\n'전체 영역내 각 셀을 순환\nIf rngEach = rngC Then\n'셀의 문자가 일치하면\nlngsum = lngsum + rngEach.Next\n'합계에 문자 오른쪽 값을 합쳐감\nEnd If\nNext\nrngEach\nrng..."}
{"instruction": "Excel VBA code for: (1509) 네이버 영화랭킹 50 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub naver_Movie_Top50()\nDim WinHttp As New WinHttp.WinHttpRequest\n'WinHttp로 사용할 변수\nDim strHtml As String\n'전체 HTML 문자를 넣을 변수\nDim lngNo As Long\n'\"랭킹테이블\" 위치 찾을 변수\nDim varTemp() As String\n'순위 앞에서 끊어 넣을 배열 변수\nDim varVar() As String\n'임시 배열로 사용할 변수\nDim varR() As String\n'결과 값만 넣을 배열 변수\nDim i As Long\n'반복구문에 사용할 변수\nActiveSheet.UsedRange.Offset(1).Clear\n'기존 데이터 삭제\nWinHttp.Open \"GET\", \"\nhttp://movie.naver.com/movie/sdb/rank/rmovie.nhn\n\"\n'네이버 음악순위 페이지를 열기\nWinHttp.Send\n'열결을 보냄\nWinHttp.WaitForResponse\n'응답을 기다림\nstrHtml =\nStrConv\n(WinHttp.ResponseBody,\nvbUnicode\n)\n'Body를 유니코드로 변수에 넣음\nlngNo =\nInStr\n(1, strHtml, \"랭킹 테이블\",\nvbBinaryCompare\n)\n'\"랭킹 테이블\" 위치 찾기\nstrHtml = Mid(strHtml, lngNo, Len(strHtml) - lngNo)\n'\"랭킹 테이블\" 뒤로만 추출\nvarTemp =\nSplit\n(strHtml, \"title=\"\"\")\n'titlex에서 끊어서 배열에 넣음\nFor i = 1 To 50\n'1 부터 50까지 1씩 늘리며 반복\nCells(i + 1, 1) = i & \"위\"\n'순위입력\nvarR = Split(varTemp(i), \"\"\">\")\n'결과순위만 추출하여 배열에 넣음\nCells(i + 1, 2) = varR(0)\n'곡명을 입력\nvarVar = Split(varTemp(i), \"icon_\")\n'icon_ 에서 분리하여 배열에 넣음\nvarR = Split(varVar(1), \"_\")\n'na, down, up 추출하여 배열에 넣음\nSelect Case varR(0)\n'배열내 첫 단어\nCase \"up\"\n'순위 올라간 경우\nWith Cells(i + 1, 3)\n.Value =\nChr\n(\"-24087\")\n'윗 방향 화살표 입력\n.Font.Color = -16776961\n'빨간색으로\nEnd With\nCase \"down\"\n'순위 내려간 경우\nCells(i + 1, 3) = Chr(\"-24088\")\n'아래 방향 화살표 입력\nEnd Select\nvarVar = Split(varTemp(i), \"range ac\"\">\")\n'range ac\"> 에서 분리하여 배열에 넣음\nvarR = Split(varVar(1), \"</td>\")\n'결과순위만 추출하여 배열에 넣음\nCells(i + 1, 4) = varR(0)\n'배열내 첫 단어를 C열에 입력\nNext i\nColumns(\"C\").\nHorizontalAlignment\n= xlRight\n'오른쪽 맞춤\nColumns.AutoFit\n'열너비 자동맞춤\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub naver_Movie_Top50()\nDim WinHttp As New WinHttp.WinHttpRequest\n'WinHttp로 사용할 변수\nDim strHtml As String\n'전체 HTML 문자를 넣을 변수\nDim lngNo As Long\n'\"랭킹테이블\" 위치 찾을 변수\nDim varTemp() As String\n'순위 앞에서 끊어 넣을 배열 변수\nDim varVar() As String\n'임시 배열로 사용할 변수\nDim varR() As String\n'결과 값만 넣을 배열 변수\nDim i As Long\n'반복구문에 사용할 변수\nActiveSheet.UsedRange.Offset(1).Clear\n'기존 데이터 삭제\nWinHttp.Open \"GET\", \"\nhttp://movie.naver.com/movie/sdb/rank/rmovie.nhn\n\"\n'네이버 음악순위 페이지를 열기\nWinHttp.Send\n'열결..."}
{"instruction": "Excel VBA code for: (1510) 숫자 마지막 자리로 정렬하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_As_Per_Last_Digit()\nDim rngC As Range\n'각 셀을 넣을 영역변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim wf As\nWorksheetFunction\n'workshseetfunction 넣을 변수\nDim intTemp As Integer\n'임시로 값을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nActiveSheet.UsedRange.\nCopy\n.Cells(1, 1)\n'Sheet2에 전체 데이터 복사\n.Activate\n'활성화\nEnd With\nSet\nwf = WorksheetFunction\nDo\n'다음을 실행\nr = r + 1\n'행 1씩 증가\nWith Sheets(3)\n'Sheet3에서\n.Cells(1, 1).Resize(7) = _\nwf.\nTranspose\n(Cells(r, 1).Resize(, 7))\n'각 행을 복사\nFor Each rngC In .Columns(1).\nSpecialCells(2)\n'A열 각 문자를 순환\nrngC.Next = Right(rngC, 1)\n'오른쪽 문자를 오른쪽 셀에\nNext rngC\n.UsedRange.\nSort\n.Cells(1, 2), 1\n'B열 기준 오름차순 정렬\nFor Each rngC In .Columns(2).SpecialCells(2)\n'A열 각 문자를 순환\nIf rngC = rngC.Offset(1) Then\n'위아래 문자가 동일할 경우\nIf rngC.Offset(, -1) > rngC.Offset(1, -1) Then\n'위 값이 아래 값보다 클 경우\nintTemp = rngC.Offset(1, -1)\n'아래 값을 변수에 넣음\nrngC.Offset(1, -1) = rngC.Offset(, -1)\n'아래 값에 위 값을 넣음\nrngC.Offset(, -1) = intTemp\n'위 값에 변수내 값을 되돌려줌\nEnd If\nEnd If\nNext rngC\nCells(r, 1).Resize(, 7) = _\nwf.Transpose(.Cells(1, 1).Resize(7))\n'정렬한 값을 가져오기\nEnd With\nLoop Until\nCells(r + 1, 1) = vbNullString\n'A열에 빈셀 나올때까지 무한 반복\nSheets(2).Columns.AutoFit\n'열너비 자동 맞춤\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "셀에 입력된 숫자의 마지막 자리수의 숫자를 이용하여 각 행을 좌에서 우로 오름차순 정렬하는 기능.\n매크로 실행 전 Sheet1\n매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub sort_As_Per_Last_Digit()\nDim rngC As Range\n'각 셀을 넣을 영역변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim wf As\nWorksheetFunction\n'workshseetfunction 넣을 변수\nDim intTemp As Integer\n'임시로 값을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nActiveSheet.UsedRange.\nCopy\n.Cells(1, 1)\n'Sheet2에 전체 데이터 복사\n.Activate\n'활성화\nEnd With\nSet\nwf = Worksh..."}
{"instruction": "Excel VBA code for: (1511) 각 sheet를 별도의 엑셀 파일로 저장하기 4 (VBA 매크로)", "input": "", "output": "Sub save_EachSheet_Into_SeparateFiles_4(control As IRibbonControl)\nDim wks As Worksheet\n'각 시트를 넣을 변수\nDim strName As String\n'(활성화된 파일의)파일 이름을 넣을 변수\nDim newName As String\n'파일경로 + 파일이름 + 시트이름 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveWorkbook\n'활성화된 파일에서\nstrName =\nSplit\n(.Name, \".\")(0)\n'파일 확장자 제거후 파일이름만 추출\nFor Each wks In Worksheets\n'각 sheet를 순환\nWith wks\nnewName = ActiveWorkbook.\nPath\n& \"\\\" & .[B2] _\n& \" \" & .[C2] & \" \" & .[D2] & \" \" & .[E2] & \".xlsx\"\n'활성화된 파일과 동일한 경로 + A2+B2+C2+D2를 파일 이름으로\nEnd With\nIf\nLen\n(\nDir\n(newName)) <> 0 Then\n'파일 존재 유무 확인\nMsgBox \"파일이 이미 존재. 기존 파일 삭재후 재실행\", 64, \"동일 파일 존재\"\nExit Sub\nEnd If\nwks.\nCopy\n'시트를 새로운 파일에 복사함\nWith ActiveWorkbook\n.\nSaveAs\nFilename:=newName\n'각 파일을 새로운 이름으로 저장\n.Close\n'저장한 파일을 닫음\nEnd With\nNext wks\nEnd With\nEnd Sub", "context": "1. 파일에 여러개의 시트가 있음.\n2. 각 시트의 A2:D2 셀의 입력된 값을 파일 이름으로 각 시트를 별도의 엑셀파일로 저장하는 기능.\n3. 파일의 저장위치는 매크로를 실행하는 파일과 동일한 폴더 경로에 저장.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1511) 각 sheet를 별도의 엑셀 파일로 저장하기 4 (VBA 매크로)\n재생\n2,001\n재생 (space/k)\n재생\n00:20\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:20\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 ..."}
{"instruction": "Excel VBA code for: (1513) 가로데이터 열로 바꾸기 (엑셀 VBA 매크로)", "input": "", "output": "Sub trans_Each_Line()\nDim lngCnt As Long\n'문자 입력 셀 개수 넣을 변수\nDim varTemp\n'배열로 사용할 변수\nDim r As Long\n'배열 행(1차원) 1씩 늘려갈 변수\nDim c As Integer\n'열 반향 늘려갈 변수\nDim y As Long\n'각 행을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).UsedRange.ClearContents\n'기존 데이터 삭제\nlngCnt =\nWorksheetFunction.CountA\n(ActiveSheet.UsedRange)\n'문자개수 변수에\nReDim\nvarTemp(1 To lngCnt, 1 To 2)\n'배열크기 재 지정\nc = 1\n'열 시작값 초기화\nDo\n'다음을 실행\ny = y + 1\n'행을 1씩 늘려감\nDo Until\nCells(y, c) = \"\"\n'각 행에 빈셀 나올때까지\nr = r + 1\n'배열 1차원을 1씩 늘려감\nIf c = 1 Then\n'c가 1이면\nvarTemp(r, 1) = Cells(y, c)\n'배열의 1열에 값을 넣음\nElse\n'c가 1이 아니면\nvarTemp(r, 2) = Cells(y, c)\n'배열의 2열에 값을 넣음\nEnd If\nc = c + 1\n'열 위치 1씩 늘려감\nLoop\nc = 1\n'재사용 위하여 열 시작값 초기화\nLoop Until\nCells(y, 1) = \"\"\n'A열에 빈셀 나오때까지 무한반복\nSheets(2).Cells(1, 1).Resize(\nUBound\n(varTemp, 1), 2) = varTemp\n'배열 값을 시트에 뿌림\nSheets(2).Activate\n'Sheet2 활성화\nEnd Sub", "context": "매크로 실행 전 Sheet1 (Sheet2 는 비어 있는 상태)          매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub trans_Each_Line()\nDim lngCnt As Long\n'문자 입력 셀 개수 넣을 변수\nDim varTemp\n'배열로 사용할 변수\nDim r As Long\n'배열 행(1차원) 1씩 늘려갈 변수\nDim c As Integer\n'열 반향 늘려갈 변수\nDim y As Long\n'각 행을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSheets(2).UsedRange.ClearContents\n'기존 데이터 삭제\nlngCnt =\nWorksheetFunction.CountA\n(ActiveSheet.UsedRange)\n'문자개수 변수에\nReDim\nvarTemp(1 To lngCnt, 1 To 2)\n'배열크기 재 지정\nc = 1\n'열 시작값 초기화\nDo\n'다음을 실행\ny = y..."}
{"instruction": "Excel VBA code for: (1514) 복수의 열 선택하여 정렬하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_Multiple_Columns()\nDim wks As Worksheet\n'현재 시트를 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수(rows) (C)ou(nt) 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수(col)umn(s) (C)ou(nt) 넣을 변수\nDim rngCol As Range\n'선택영역(r)a(ng)e 각 열(Col)umn 을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nIf Selection.Cells.Count = 1 Or\nWorksheetFunction.CountA\n(Selection) < 2 Then\n'1개의 셀 또는 2개 미만의 데이터만 선택 시\nMsgBox \"1개 이상의 셀/2개 이상의 데이터를 선택하시오\", 64, \"셀선택 오류\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet wks = ActiveSheet\n'현재 시트를 개체변수에 넣음\nrowsCnt = Selection.\nRows.Count\n'전체 행개수를 변수에 넣음\ncolsCnt = Selection.\nColumns.Count\n'전체 열개수를 변수에 넣음\nWorksheets.\nAdd\nafter:=Sheets(Sheets.Count)\n'제일 뒤에 임시 시트 추가\nwks.Activate\n'wks 시트 활성화\nWith Sheets(Sheets.Count)\n'임시 시트에서\nFor Each rngCol In Selection.Columns\n'선택영역의 각 열을 순환\n.Cells(.Rows.Count, \"A\").End(3)(2).Resize(rowsCnt) = rngCol.Value\n'A열 종단셀 윗방향 바로 아래셀에 각 열의 값을 복사\nNext rngCol\n.Columns(1).\nSort\n.[A1], 1\n'오름차순 정렬\nFor i = 1 To colsCnt\n'열 개수만큼 반복\nSelection.Columns(i) = _\n.Cells(1 + (i - 1) * rowsCnt, 1).Resize(rowsCnt).Value\n'각 열에 정렬한 데이터를 뿌림\nNext i\nEnd With\nWith Application\n'엑셀프로그램에서\n.\nDisplayAlerts\n=\nFalse\n'화면 경고 멈춤\nSheets(Sheets.Count).Delete\n'임시 시트 삭제\n.DisplayAlerts = True\n'화면 경고 복원\nEnd With\nSet wks = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전 영역을 선택함                                매크로 실행 후 결과\nOption Explicit\nSub sort_Multiple_Columns()\nDim wks As Worksheet\n'현재 시트를 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수(rows) (C)ou(nt) 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수(col)umn(s) (C)ou(nt) 넣을 변수\nDim rngCol As Range\n'선택영역(r)a(ng)e 각 열(Col)umn 을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nIf Selection.Cells.Count = 1 Or\nWorksheetFunction.CountA\n(Selection) < 2 Then\n'1개의 셀 또는 2개 미만의 데이터만 선택 시\nMsgBox \"1개 이상의 셀/2개 이상의 데이터를 선택하시오\", 64, \"셀선택 오류\"\nExit Sub\n'메시지..."}
{"instruction": "Excel VBA code for: (1515) 문자와 섞인 숫자의 가격 합산하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub split_And_Consolidate()\nDim rngC As Range\n'전체영역의 각 셀(C)ell을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim varTemp\n'값을 분리하여 넣을 배열 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(3)\n'Sheet3에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nRange(\"A2\", Cells(Rows.Count, \"A\").End(3)).Copy .Cells(1, 1)\n'전체 A열 데이터를 Sheet3에 복사\n.Activate\n'활성화\nEnd With\nColumns(1).SpecialCells(2).\nReplace\n\"개\", \"\"\n' \"개\"를 삭제\nFor Each rngC In Columns(1).SpecialCells(2)\n'A열 문자입력셀 각 셀을 순환\nvarTemp =\nSplit\n(rngC, \", \")\n'콤마+공백(space)로 분리하여 배열에 넣음\nFor i =\nLBound\n(varTemp) To\nUBound\n(varTemp)\n'배열 하한~상한값 까지 반복\nCells(Rows.Count, \"B\").End(3)(2) = Trim(varTemp(i))\n'배열내 값을 앞뒤 공백을 제거한 수에 셀에 뿌림\nNext i\nNext\nCall\ninitiate_TextToColumns_xlDelimited\n'앞서 문자분리 사용했을 경우 설정한 값을 초기화 하기 위한 코드 호출\nRange(\"B1\").Delete shift:=xlUp\n'B1셀을 삭제하고 위로 끌어 올림\nWith Columns(\"B\").SpecialCells(2)\n'B열 모든 문자가 입력된 셀에서\n.\nTextToColumns\n_\nDestination:=.Cells(1).Offset(, 2), _\nDataType:=\nxlDelimited\n, _\nSpace:=True\n'공백을 이용하여 문자분리 수행\nEnd With\n[G1].\nConsolidate\nSources:=[D1].CurrentRegion.Address(1, 1, xlR1C1, 1), _\nFunction:=xlSum, TopRow:=False, LeftColumn:=True, CreateLinks:=False\n'데이터 통합을 이용하여 데이터를 통합\n[G1].CurrentRegion.\nSort\n[G1], 1\n'G열 기준 오름차순 정렬\nColumns(\"A:F\").Delete\n'임시로 사용한 A:F열 삭제\nFor Each rngC In Columns(\"A\").SpecialCells(2).Offset(, 2)\n'C열 문자입력셀 각 셀을 순환\nWith rngC\n'각 셀에서\n.\nFormula\n= \"=\nVLOOKUP\n(RC[-2], Sheet2!R1C1:R10C2, 2, 0)\"\n'VLOOKUP을 이용 하여 품목의 값을 찾는 기능 실행\n.Value = .Value\n'수식을 값으로 복사\nEnd With\nrngC.Offset(, 1).\nFormulaR1C1\n= \"=RC[-2]*RC[-1]\"\n'값과 수량을 곱하는 수식입력\nNext rngC\nColumns(\"D\").NumberFormat = \"#,###\"\n'D열 서식에 콤마적용\nColumns.AutoFit\n'열너비 자동맞춤\nEnd Sub\n\nSub initiate_TextToColumns_xlDelimited()\n'문자분리 기능을 초기화하는 하위 코드\nWith Cells(Rows.Count, 1)\n'A열 마지막 행에\n.Value = \"temp\"\n'temp 라는 임시 값 입력\n.TextToColumns _\nDestination:=Cells(Rows.Count, 2), _\nDataType:=xlDelimited, _\nTextQualifier:=xlDoubleQuote, _\nConsecutiveDelimiter:=False, _\nTab:=False, _\nSemicolon:=False, _\nComma:=False, _\nSpace:=False, _\nOther:=False, _\nOtherChar:=\"\", _\nFieldInfo:=Array(Array(1, 1)), _\nTrailingMinusNumbers:=True\n'문자 분리 옵션 모두 초기화\nCells(Rows.Count, 1).EntireRow.Delete\n'임시로 값 입력한 행 삭제\nEnd With\nEnd Sub", "context": "매크로 실행 전 Sheet1                                          매크로 실행 전 Sheet2 (Sheet3은 비어 있음)\n매크로 실행 후 Sheet3 의 결과\nOption Explicit\nSub split_And_Consolidate()\nDim rngC As Range\n'전체영역의 각 셀(C)ell을 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim varTemp\n'값을 분리하여 넣을 배열 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(3)\n'Sheet3에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nRange(\"A2\", Cells(Rows.Count, \"A\").End(3)).Copy .Cells(1, 1)\n'전체 A열 데이터를 Sheet3에 복사\n.Activate\n'활성화\nEnd With\nColumns(1).SpecialCell..."}
{"instruction": "Excel VBA code for: (1517) 중복열 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Duplicated_Columns()\nDim rngAll As Range\n'A열 전체 데이터를 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수를 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수를 넣을 변수\nDim x As Integer\n'varL 열 개수만큼 반복할 변수\nDim varL\n'왼쪽열 넣을 배열 변수\nDim c As Integer\n'varR 열 개수만큼 반복할 변수\nDim varR\n'오른쪽열 넣을 배열 변수\nDim wf As\nWorksheetFunction\n'엑셀 함수 넣을 변수\nDim r As Long\n'행 개수만큼 반복할 변수\nDim cnt As Long\n'반복 개수 카운터로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet\nwf = WorksheetFunction\n'엑셀 함수를 변수에 넣음\nWith Sheets(2)\n'Sheet2 에서\n.\nUsedRange.Clear\n'기존 데이터 삭제\nCells.Copy .Cells(1, 1)\n'전체 데이터를 복사\n.UsedRange.Offset(1, 1).Clear\n'제목행/제목열 삭제\nEnd With\nWith Sheets(3)\n'Sheet3 에서\n.UsedRange.Clear\n'기존 데이터 삭제\nCells.Copy .Cells(1, 1)\n'전체 데이터를 복사\n.Activate\n'활성화\nEnd With\nSet rngAll = Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'A열 전체를 변수에 넣음\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\nrowsCnt = .\nRows.Count\n- 1\n'전체행 개수 - 1을 변수에 넣음\ncolsCnt = .\nColumns.Count\n'전체 열 개수를 변수에 넣음\nEnd With\nFor x = 2 To colsCnt\n'2번째 열부터 마지막 열까지 반복\nvarL = rngAll.Offset(, x - 1)\n'열 전체를 배열 varL에 넣음\nFor c = x + 1 To colsCnt\n'x+1  부터 마지막 열까지 반복\nvarR = rngAll.Offset(, c - 1)\n'열 전체를 배열 varR에 넣음\nIf\nwf.Count\n(varL) > 0 Or _\nwf.Count(varR) > 0 Then\n'빈 열이 아닐 경우\nFor r = 1 To rowsCnt\n'1 ~ 마지막 행까지 반복\nIf varL(r, 1) = varR(r, 1) Then\n'좌우 데이터가 일치하면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nElse\n'좌우 데이터가 다를 경우\nExit For\n'For 구문을 종료\nEnd If\nNext r\nIf cnt = rowsCnt Then\n'전체 행이 일치하면\nrngAll.Offset(, c - 1).Clear\n'오른쪽 열의 데이터를 삭제\nEnd If\ncnt = 0\n'재사용 위하여 카운터 초기화\nEnd If\nNext c\nNext x\nFor x = colsCnt To 2 Step -1\n'마지막 열부터 1씩 줄이며 반복\nIf\nwf.CountA\n(rngAll.Offset(, x - 1)) = 0 Then\n'전체 열에 데이터 없을 경우\nrngAll.Offset(, x - 1).\nEntireColumn.Delete\n'열 전체를 삭제\nEnd If\nNext x\nActiveSheet.UsedRange.Offset(1).Copy _\nSheets(2).Cells(2, 1)\n'행 제외한 전체 데이터를 Sheet2 A2에복사\nSheets(2).Activate\n'Sheet2 활성화\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. 1행의 제목행을 제외한 중복되는 열을 삭제\n2. 중복조건은 랜덤하며, 데이터는 중간에 공백셀도 있음.\n3. 중복데이터 삭제 후 좌에서 우로 정렬.\n매크로 실행 전 Sheet1 (Sheet2 와 Sheet3은 비어 있는 상태. Sheet2 또는 Sheet3 이 없는 경우 에러가 발생하므로 3개의 시트가 있어야 함.)\n매크로 실행 후 Sheet2 의 결과 (Sheet 3을 임시 데이터 영역으로 사용한 뒤 Sheet2에 결과를 복사.)\nOption Explicit\nSub remove_Duplicated_Columns()\nDim rngAll As Range\n'A열 전체 데이터를 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수를 넣을 변수\nDim colsCnt As Integer\n'전체 열 개수를 넣을 변수\nDim x As Integer\n'varL 열 개수만큼 반복할 변수\nDim varL\n'왼쪽열 넣을 배열 변수\nDim c As Integer\n'varR 열 개수만큼 반복할..."}
{"instruction": "Excel VBA code for: (1518) 다양한 방법으로 숫자 채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_Numbers_1()\nDim i As Long\n'반복구문에 사용할 변수\nDim y As Long\n'행방향 1씩 늘려갈 변수\nDim x As Integer\n'열방향 1씩 늘려갈 변수\nFor i = 1 To 20\n'1부터 1씩 늘리며 20까지 반복\nx = x + 1\n'열방향 1씩 늘려감\nCells(y + 1, x) = i\n'셀에 값을 뿌림\nIf x = 4 Then\n'열이 4에 도달하면\nx = 0\n'열을 0으로 초기화 하고\ny = y + 1\n'행을 1 늘림\nEnd If\nNext i\nEnd Sub\n\nSub fill_Numbers_2()\nDim rngC As Range\n'전체영역의 각 셀을 넣을 변수\nDim i As Long\n'값을 1씩 늘려갈 변수\nFor Each rngC In Range(\"A1:D5\")\n'A1:D5 각셀(rngC)을 순환\ni = i + 1\n'숫자를 1씩 늘려감\nrngC = i\n'숫자를 각 셀에 뿌림\nNext\nEnd Sub\n\nSub fill_Numbers_3()\nDim i As Long\n'값을 1씩 늘려갈 변수\nDim y As Long\n'행방향 1씩 늘려갈 변수\nDim x As Integer\n'열방향 1씩 늘려갈 변수\nFor x = 1 To 5\n'열방향 1씩 늘려감\nFor y = 1 To 4\n'행방향 1씩 늘려감\ni = i + 1\n'입력할 값을 1씩 늘려감\nCells(x, y) = i\n'값을 셀에 뿌림\nNext y\nNext x\nEnd Sub\n\nSub fill_Numbers_4()\nDim rngC As Range\n'전체영역 각 셀을 넣을 변수\nDim i As Long\n'숫자 1씩 늘려갈 변수\nDim colsCnt As Integer\n'열 개수 넣을 변수\nWith Range(\"A1:D5\")\n'A1:D5 영역에서\ncolsCnt = .Columns.Count\n'열 개수를 변수에 넣음\nFor Each rngC In .Resize(1)\n'1행의 각셀을 순환\ni = i + 1\n'카운터를 1씩 늘려감\nrngC = i\n'각 셀에 값을 채움\nNext rngC\n.\nDataSeries\nxlColumns, step:=colsCnt\n'열방향으로 열 개수만큼 늘리며 채워감\nEnd With\nEnd Sub\n\nSub fill_Numbers_5()\nDim rngC As Range\n'전체영역 각 셀을 넣을 변수\nDim i As Long\n'숫자 1씩 늘려갈 변수\nDim rowsCnt As Integer\n'행 개수 넣을 변수\nWith Range(\"A1:D5\")\n'A1:D5 영역에서\nrowsCnt = .Rows.Count\n'행 개수를 변수에 넣음\nFor Each rngC In .Resize(, 1)\n'선택영역의 각셀을 순환\nIf i = 0 Then\n'i 가 0이면\ni = 1\n'1을 입력\nElse\n'i가 0이 아니면\ni = i + .Columns.Count\n'열 개수만큼 늘려감\nEnd If\nrngC = i\n'첫 열에 값을 채움\nNext rngC\n.DataSeries xlRows, step:=1\n'행방향으로 행 개수만큼 늘리며 채워감\nEnd With\nEnd Sub\n\nSub fill_Numbers_6()\nDim i As Long\n'값을 1씩 늘려갈 변수\nDim y As Long\n'행방향 1씩 늘려갈 변수\nDim x As Integer\n'열방향 1씩 늘려갈 변수\nDim varTemp\nReDim\nvarTemp(1 To 5, 1 To 4)\n'배열 크기 재지정\nFor x = 1 To 5\n'열방향 1씩 늘려감\nFor y = 1 To 4\n'행방향 1씩 늘려감\ni = i + 1\n'입력할 값을 1씩 늘려감\nvarTemp(x, y) = i\n'값을 배열에 넣음\nNext y\nNext x\nCells(1, 1).Resize(5, 4) = varTemp\n'배열값 셀에 뿌림\nEnd Sub\n\nSub fill_Numbers_7()\nWith Range(\"A1:D5\")\n'A1:D5 영역에서\n.\nFormulaR1C1\n= \"=(ROW(RC)-1)*4 + COLUMN(RC)\"\n'수식을 입력\n.\nValue\n= .\nValue\n'수식을 값으로 변환\nEnd With\nEnd Sub\n\nSub fill_Numbers_8()\nWith Range(\"A1:D5\")\n'A1:D5 영역에서\n.\nFormulaArray\n= _\n\"={1,2,3,4;5,6,7,8;9,10,11,12;13,14,15,16;17,18,19,20}\"\n'배열수식을 입력\n.Value = .Value\n'수식을 값으로 변환\nEnd With\nEnd Sub\n\nSub fill_Numbers_9()\nDim i As Long\n'반복구문에 사용할 변수\nDim y As Long\n'행방향 1씩 늘려갈 변수\nDim x As Integer\n'열방향 1씩 늘려갈 변수\nFor i = 1 To 5\n'1부터 1씩 늘리며 5까지 반복\nCells(i, 1).Resize(, 4) = _\nApplication.\nTranspose\n(\nEvaluate\n(\"row(\" & (i - 1) * 4 + 1 & \":\" & i * 4 & \")\"))\n'Evaluate 메서드와 행열변환 함수로 셀에 값을 뿌림\nNext i\nEnd Sub", "context": "아래와 같이 숫자를 채우는 방법은 여러가지가 있다. 여러 가지 다양한 방법을 적용하다 보면 조금더 최적화된 코드를 찾을 수도 있고, 코드 작성 중 막히면 돌아가는 길도 쉽게 보인다.\n매크로 실행 전                                                   매크로 실행 후 결과\nSub fill_Numbers_1()\nDim i As Long\n'반복구문에 사용할 변수\nDim y As Long\n'행방향 1씩 늘려갈 변수\nDim x As Integer\n'열방향 1씩 늘려갈 변수\nFor i = 1 To 20\n'1부터 1씩 늘리며 20까지 반복\nx = x + 1\n'열방향 1씩 늘려감\nCells(y + 1, x) = i\n'셀에 값을 뿌림\nIf x = 4 Then\n'열이 4에 도달하면\nx = 0\n'열을 0으로 초기화 하고\ny = y + 1\n'행을 1 늘림\nEnd If\nNext i\nEnd Sub\nSub fill_Numbers_2()\nDim rngC As Range\n'전..."}
{"instruction": "Excel VBA code for: (1519) 정렬되지 않은 데이터의 그룹별 최댓값만 추출하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub leave_The_Biggest_Of_Each_Group_1()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 영역변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Range(\"A1\")\n'현재시트 사용영역을 Sheet2에 복사\n.Activate\n'활성화\nEnd With\nSet rngAll = Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'제목 제외한 A열 전체를 변수에 넣음\nFor Each rngC In rngAll.Offset(, 6)\n'rngAll을 6칸 우로 이동하고 각 셀을 순환\nWith rngC\n.\nFormulaArray\n= _\n\"=IF(\nMAX\n(IF(R2C1:R16C1=RC[-6], R2C5:R16C5))=RC[-2], RC[-2], \"\"\"\")\"\n'각 셀에 배열수식을 입력\n.\nValue\n= .\nValue\n'각 셀을 값으로 변환(배열수식 없애는 작업)\nEnd With\nNext rngC\nrngAll.Resize(, 7).\nSort\n[G2], 1\n'G열을 오름차순 정렬\nRange(Cells(Rows.Count, \"G\").End(3)(2), _\nCells(Rows.Count, \"A\").End(3)).\nClear\n'불필요한 데이터들 삭제\nColumns(\"G\").Delete\n'임시로 사용한 G열 삭제\nActiveSheet.UsedRange.Sort [A2], 1, Header:=xlYes\n'A열 기준 오름차순정렬\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. A열에 중복된 값이 많이 있음.\n2. 중복 값중 D열에 최댓값이 있는 행만을 추출.\n3. 매크로 실행 후 결과 값 확인을 쉽게 하기 위하여 추출될 값이 있는 셀에는 색으로 표시하여둠.\n매크로 실행 전 Sheet1                                   매크로 실행 후 Sheet3의 결과\nOption Explicit\nSub leave_The_Biggest_Of_Each_Group_1()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 영역변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Range(\"A1\")\n'현재시트 사용영역을 Sheet2에 복사\n.Activate\n'활성화\nEnd With\nSet ..."}
{"instruction": "Excel VBA code for: (1520) 정렬되지 않은 데이터의 그룹별 최댓값만 추출하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub leave_The_Biggest_Of_Each_Group_2()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 영역변수\nDim colsCnt As Integer\n'열 개수를 넣을 변수\nDim varR()\n'배열로 사용할 변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nDim r As Long\n'행방향(배열 1차원) 늘려갈 변수\nDim c As Integer\n'열방향 반복구문에 사용할변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Range(\"A1\")\n'현재시트 사용영역을 Sheet2에 복사\n.Activate\n'활성화\nEnd With\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\ncolsCnt = .\nColumns.Count\n'열 개수를 변수에\nReDim varR(1 To .Rows.Count, 1 To colsCnt)\n'배열 크기 재지정\nEnd With\nSet rngAll = Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'제목 제외한 A열 전체를 변수에 넣음\nFor Each rngC In rngAll.Offset(, 6)\n'rngAll을 6칸 우로 이동하고 각 셀을 순환\nrngC.\nFormulaArray\n= _\n\"=IF(MAX(IF(R2C1:R16C1=RC[-6], R2C5:R16C5))=RC[-2], RC[-2], \"\"\"\")\"\n'각 셀에 배열수식을 입력\nrngC = rngC.Value\n'각 셀을 값으로 변환(배열수식 없애는 작업)\nIf Len(rngC) > 0 Then\n'셀 값이 존재하면\nr = r + 1\n'배열 위치 1씩 늘려감\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nvarR(r, c) = rngC.Offset(, c - 7)\n'배열에 각 행의 값을 넣음\nNext c\nEnd If\nNext rngC\nActiveSheet.UsedRange.Offset(1).Clear\n'임시 데이터 제목행 제외하고 삭제\nCells(2, 1).Resize(UBound(varR, 1), colsCnt) = varR\n'배열값 셀에 뿌림\nrngAll.Resize(, colsCnt).\nSort\n[A2], 1, Header:=xlNo\n'A열을 오름차순 정렬\n'A열 기준 오름차순정렬\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. A열에 중복된 값이 많이 있음.\n2. 중복 값중 D열에 최댓값이 있는 행만을 추출.\n3. 매크로 실행 후 결과 값 확인을 쉽게 하기 위하여 추출될 값이 있는 셀에는 색으로 표시하여둠.\n매크로 실행 전 Sheet1                                  매크로 실행 후 Sheet3의 결과\nOption Explicit\nSub leave_The_Biggest_Of_Each_Group_2()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 영역변수\nDim colsCnt As Integer\n'열 개수를 넣을 변수\nDim varR()\n'배열로 사용할 변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nDim r As Long\n'행방향(배열 1차원) 늘려갈 변수\nDim c As Integer\n'열방향 반복구문에 사용할변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sh..."}
{"instruction": "Excel VBA code for: (1521) 정렬되지 않은 데이터의 그룹별 최댓값만 추출하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub leave_The_Biggest_Of_Each_Group_3()\nDim rngAll As Range\n'전체(All) 데이터 영역을 넣을 영역변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Range(\"A1\")\n'현재시트 사용영역을 Sheet2에 복사\n.Activate\n'활성화\nEnd With\nWith ActiveSheet\n'현재 시트에서\nSet rngAll = .UsedRange\n'사용영역을 개체변수에 넣음\n.UsedRange.\nSort\nkey1\n:=[A2], order1:=1, _\nkey2\n:=[E2], order2:=1, Header:=xlYes\n'A열 / E열 오름차순 정렬\nEnd With\nSet rngAll = Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'제목 제외한 A열 전체를 변수에\nWith Sheets(3)\n'Sheet3에서\n.UsedRange.Clear\n'기존 데이터 삭제\nRows(1).Copy .Range(\"A1\")\n'제목행 복사\nFor Each rngC In rngAll\n'제목제외한 A열 각 셀을 순환\nIf rngC <> rngC.Offset(1) Then\n'위아래 셀이 다른 경우\n.Cells(.Rows.Count, \"A\").End(3)(2).Resize(, 6) = _\nrngC.Resize(, 6).Value\n'행 전체의 값을 복사\nEnd If\nNext rngC\n.Activate\n'활성화\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. A열에 중복된 값이 많이 있음.\n2. 중복 값중 D열에 최댓값이 있는 행만을 추출.\n3. 매크로 실행 후 결과 값 확인을 쉽게 하기 위하여 추출될 값이 있는 셀에는 색으로 표시하여둠.\n매크로 실행 전 Sheet1                                  매크로 실행 후 Sheet3의 결과\nOption Explicit\nSub leave_The_Biggest_Of_Each_Group_3()\nDim rngAll As Range\n'전체(All) 데이터 영역을 넣을 영역변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Range(\"A1\")\n'현재시트 사용영역을 Sheet2에 복사\n.Activate\n'활성화\nE..."}
{"instruction": "Excel VBA code for: (1522) 정렬되지 않은 데이터의 그룹별 최댓값만 추출하기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub leave_The_Biggest_Of_Each_Group_4()\nDim colsCnt As Integer\n'열 개수를 넣을 변수\nDim varR()\n'배열로 사용할 변수\nDim rngAll As Range\n'전체(All) 데이터 영역을 넣을 영역변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역 변수\nDim r As Long\n'행방향(배열 1차원) 늘려갈 변수\nDim c As Integer\n'반복구문에 사용할변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Range(\"A1\")\n'현재시트 사용영역을 Sheet2에 복사\n.Activate\n'활성화\nEnd With\nWith ActiveSheet.UsedRange\ncolsCnt = .\nColumns.Count\n'열 개수를 변수에\nReDim\nvarR(1 To .\nRows.Count\n, 1 To colsCnt)\n'배열 크기 재지정\n.\nSort\nkey1\n:=[A2], order1:=1, _\nkey2\n:=[E2], order2:=1, Header:=xlYes\n'A열 / E열 오름차순 정렬\nEnd With\nSet rngAll = Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'제목 제외한 A열 전체를 변수에\nFor Each rngC In rngAll\n'제목제외한 A열 각 셀을 순환\nIf rngC <> rngC.Offset(1) Then\n'위아래 셀이 다른 경우\nr = r + 1\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nvarR(r, c) = rngC.Offset(, c - 1)\n'배열에 각 행의 값을 넣음\nNext c\nEnd If\nNext rngC\nActiveSheet.UsedRange.Offset(1).Clear\n'임시로 사용한 데이터 삭제\nCells(2, 1).Resize(\nUBound\n(varR, 1), colsCnt) = varR\n'배열값 셀에 뿌림\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. A열에 중복된 값이 많이 있음.\n2. 중복 값중 D열에 최댓값이 있는 행만을 추출.\n3. 매크로 실행 후 결과 값 확인을 쉽게 하기 위하여 추출될 값이 있는 셀에는 색으로 표시하여둠.\n매크로 실행 전 Sheet1                                  매크로 실행 후 Sheet3의 결과\nOption Explicit\nSub leave_The_Biggest_Of_Each_Group_4()\nDim colsCnt As Integer\n'열 개수를 넣을 변수\nDim varR()\n'배열로 사용할 변수\nDim rngAll As Range\n'전체(All) 데이터 영역을 넣을 영역변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역 변수\nDim r As Long\n'행방향(배열 1차원) 늘려갈 변수\nDim c As Integer\n'반복구문에 사용할변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Shee..."}
{"instruction": "Excel VBA code for: (1523) 정렬되지 않은 데이터의 그룹별 최댓값만 추출하기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub leave_The_Biggest_Of_Each_Group_5()\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim c As Integer\n'열(c)olumn 방향 반복구문에 사용할변수\nDim v As Long\n'동적배열 크기 늘려갈 변수\nDim varR()\n'동적배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith ActiveSheet\n'현재 시트에서\ncolsCnt = .UsedRange.Columns.Count\n'전체 열 개수를 변수에 넣음\n.UsedRange.\nSort\nkey1:=[A2], order1:=1, _\nkey2:=[E2], order2:=1, Header:=xlYes\n'A열 / E열 오름차순 정렬\nEnd With\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 1) <> Cells(r + 1, 1) Then\n'각 셀이 바로 아래 셀과 다르면\nv = v + 1\n'동적배열 1씩 늘려감\nReDim Preserve\nvarR(1 To colsCnt, 1 To v)\n'동적배열 크기 재지정\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nvarR(c, v) = Cells(r, 1).Offset(, c - 1)\n'배열에 각 행의 값을 넣음\nNext c\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nWith Sheets(2)\nRows(1).Copy .Cells(1, 1)\n'제목행 복사\n.Activate\n'활성화\nEnd With\nCells(2, 1).Resize(\nUBound\n(varR, 2), colsCnt) = _\nWorksheetFunction\n.\nTranspose\n(varR)\n'배열값 행열 변환하여 셀에 뿌림\nActiveSheet.UsedRange.\nSort\n[A2], 1, Header:=xlYes\n'A열을 오름차순 정렬\nEnd Sub", "context": "1. A열에 중복된 값이 많이 있음.\n2. 중복 값중 D열에 최댓값이 있는 행만을 추출.\n3. 매크로 실행 후 결과 값 확인을 쉽게 하기 위하여 추출될 값이 있는 셀에는 색으로 표시하여둠.\n매크로 실행 전 Sheet1                                   매크로 실행 후 Sheet3의 결과\nOption Explicit\nSub leave_The_Biggest_Of_Each_Group_5()\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim c As Integer\n'열(c)olumn 방향 반복구문에 사용할변수\nDim v As Long\n'동적배열 크기 늘려갈 변수\nDim varR()\n'동적배열로 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith ActiveSheet\n'현재 시트에서\ncolsCnt = .UsedRange.Colu..."}
{"instruction": "Excel VBA code for: (1524) 정렬되지 않은 데이터의 그룹별 최댓값만 추출하기 6 (엑셀 VBA 매크로)", "input": "", "output": "Sub leave_The_Biggest_Of_Each_Group_6()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Range(\"A1\")\n'현재시트 사용영역을 Sheet2에 복사\n.Activate\n'활성화\nEnd With\nWith ActiveSheet\n'현재 시트에서\nSet rngAll = .UsedRange\n'사용영역을 개체변수에 넣음\n.UsedRange.\nSort\nkey1:=[A2], order1:=1, _\nkey2:=[E2], order2:=2, Header:=xlYes\n'A열 오름차순, E열 내림차순 정렬\nEnd With\nrngAll.\nRemoveDuplicates\nColumns:=1, Header:=xlYes\n'제목행 제외하고 중복 제거\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. A열에 중복된 값이 많이 있음.\n2. 중복 값중 D열에 최댓값이 있는 행만을 추출.\n3. 매크로 실행 후 결과 값 확인을 쉽게 하기 위하여 추출될 값이 있는 셀에는 색으로 표시하여둠.\n매크로 실행 전 Sheet1                                 매크로 실행 후 Sheet3의 결과\nSub leave_The_Biggest_Of_Each_Group_6()\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존 데이터 삭제\nActiveSheet.UsedRange.Copy .Range(\"A1\")\n'현재시트 사용영역을 Sheet2에 복사\n.Activate\n'활성화\nEnd With\nWith ActiveSheet\n'현재 시트에서\nSet rngAll = .UsedRange\n'사용영역을..."}
{"instruction": "Excel VBA code for: (1526) 두 시트의 다른 데이터 찾아 표시하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Changed_Data_2()\nDim s As Integer\n'2회 반복할 변수\nDim varO As Variant\n'Old 시트내 A열 넣을 배열변수\nDim colsCnt As Integer\n'전체 열 개수 넣기 위한 변수\nDim varOld As Variant\n'Old 시트 전체자료 넣기위한 배열변수\nDim rowsCnt As Long\n'New 전체행 넣을 변수\nDim varNew As Variant\n'New 시트 전체자료 넣기 위한 배열변수\nDim j As Long\n'New 배열내 행을 늘려갈 변수\nDim vO As Variant\n'varO 내 각 값을 넣을 배열변수\nDim i As Long\n'Old 배열내 행을 늘려나갈 변수\nDim x As Integer\n'열 개수 늘려갈 변수\nDim cnt As Long\n'카운터로 사용할 변수\nWith WorksheetFunction\n'엑셀함수\nIf .\nCountA\n(Range(\"A2:A3\")) < 2 Or _\n.CountA(Sheets(2).Range(\"A2:A3\")) < 2 Then\n'Old 또는 New시트 A2:A3셀이 빈 경우\nMsgBox \"작업할 데이터가 부족합니다.\", 64, \"데이터 입력 오류\"\nExit Sub\n'메시지 출력 후 매크로 종료\nEnd If\nEnd With\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n.Calculation =\nxlCalculationManual\n'셀계산 수동으로 전환\nEnd With\n'---------------------------------------------------------------\n'Old/New 시트가 오름차순 정렬 안된 경우 대비하여 정렬하는 코드\n'---------------------------------------------------------------\nFor s = 1 To 2\n'Old시트와 New 시트 2회 반복\nWith Worksheets(s)\n'각 시트에서\n.UsedRange.\nSort\n.Cells(2, 1), 1, Header:=xlYes\n'사용영역 A열 기준으로 1행에 제목행이 있는 것을 기준으로 오름차순 정렬\nEnd With\nNext s\n'-------------------------------------------------------\n'각 배열에 제목 제외한 Old / New 시트의 데이터를 넣음\n'-------------------------------------------------------\nvarO = Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'제목 제외한 A열을 배열에 넣음\nWith Sheets(1).UsedRange\n'Old 시트 사용영역에서\n.Offset(1).Interior.Color = xlNone\n'기존 모든 색 삭제\n﻿\ncolsCnt = .Columns.Count\n'전체 열 개수를 변수에 넣음\nvarOld = .Offset(1).Resize(.Rows.Count - 1)\n'제목빼고 배열에 넣음\nEnd With\nWith Sheets(2)\n'New 시트\nrowsCnt = .Cells(.Rows.Count, \"A\").End(3).Row - 1\n'행 개수를 변수에 넣음\nvarNew = .UsedRange.Offset(1).Resize(.UsedRange.Rows.Count - 1)\n'제목 빼고 배열에 넣음\nj = 2\n'New시트 2행부터 시작\n'-----------------------------------------------------\n' 먼저 \"이름\"이 일치하는지 검색 후 나머지 열들을 검사\n'-----------------------------------------------------\nFor Each vO In varO\n'Old 시트 A열 각 셀을 순환\ni = i + 1\n'Old 시트 A열 행을 늘려감\nFor j = j To rowsCnt + 1\n'검색 일치한 다음 행부터 반복\nIf vO = varNew(j - 1, 1) Then\n'1열(이름)이 일치할 경우\nFor x = 2 To colsCnt\n'2열에서 마지막 열까지 반복\nIf varOld(i, x) <> varNew(j - 1, x) Then\n'서로 값이 다를 경우\nCells(i + 1, x).\nInterior.ColorIndex\n= 36\n'셀에 옅은 노란색으로 채움\nEnd If\nNext x\nExit For\n'For 구문 종료\nEnd If\ncnt = cnt + 1\n'카운터 1씩 늘려감\nIf cnt = rowsCnt Then\n'카운터가 전체행과 일치할 경우\nMsgBox \"일치하는 데이터가 전혀 없음\", 64, \"데이터 불일치\"\nExit Sub\n'매크로 종료\nEnd If\nNext j\n'-------------------------------------------------\n' New 시트의 행 위치를 조건에 따라 올려가는 코드\n'-------------------------------------------------\nIf j = rowsCnt + 2 Then\n'New 시트 마지막 행 도달 시\nj = j - cnt\n'행값에서 카운터 빼줌(행위치 추가 안함)\nElse\n'New 시트 마지막 행이 아닐 경우\nj = j - cnt + 1\n'행값에서 카운터 빼준 후 1더함(1행 추가)\nEnd If\ncnt = 0\n'카운터 초기화\nNext vO\nEnd With\nWith Application\n'엑셀에서\n.Calculation =\nxlCalculationAutomatic\n'셀계산 자동으로 돌려놓음\n.ScreenUpdating = True\n'화면업데이트 재 실행\nEnd With\nMsgBox \"데이터 검색이 완료되었습니다.\"\n'완료 메시지 출력\nEnd Sub", "context": "아래의 코드는\nA열(이름)이 오름차순 정렬되어 있을 때\n서로 다른 두 시트의 데이터를 비교하여 일치하지 않는 데이터에 옅은 노란색으로 표시를 하여주는 코드이다.\n이 코드는 두 시트에 있는 A열의 이름이 대부분 일치하고 일부의 데이터가 다르거나 할 때 유용하다. Old 시트 A1:G100000 와 New 시트 A1:G100000 에 데이터를 넣고, 즉 각 시트에 100,000 행의 데이터를 넣고 비교 시 조건에 따라 차이는 나지만 내 컴퓨터로 대개\n2 ~ 3초\n정도가 소요된다.\n하지만, 이 코드는 치명적인 단점도 있다.\n두 데이터가 비슷할수록 속도가 빠르고, 차이가 많이 나면 많이 날 수록 속도가 떨어진다\n.\n만일 100,000행의 데이터 중 1,000 개 정도만 A열(이름)이 서로 일치하는 상황일 경우 Ctrl + Break 기능을 모르면 매크로 실행 후 엑셀을 강제 종료해야 한다. 사실 그런 상황이면 두 데이터를 비교하는 것은 무의미하다. 만일 두 데이터를 정렬하면 안되는 경우이거..."}
{"instruction": "Excel VBA code for: (1528) 값에 따라 정리 후 각 시트로 분류하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_And_AdvancedFilter()\nDim wks As Worksheet\n'각 시트를 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngAll As Range\n'전체 데이터 영역을 넣을 변수\nDim varTemp As Variant\n'임시 데이터 저장공간으로 사용할 배열 변수\nDim r As Long\n'반복하여 행 방향 늘려갈 변수\nDim varR\n'중복 없는 목록 넣을 배열 변수\nWith\nApplication\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n.\nDisplayAlerts\n=\nFalse\n'화면 경고 중단\n'--------------------------------\n' Sheet1 제외한 모든 시트 삭제\n'--------------------------------\nFor Each wks In ActiveWorkbook.\nSheets\n'현재파일 각 시트 순환\nIf wks.Name <> \"Sheet1\" Then\n'Sheet1 이 아닐 경우\nwks.Delete\n'시트 삭제\nEnd If\nNext wks\n.DisplayAlerts = True\n'화면 경고 복원\nEnd With\nWith ActiveSheet.UsedRange\n'현재시트 사용 영역에서\nSet rngAll = .Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 1)\nEnd With\n'----------------------------------------------\n' 배열에 값을 넣고 이를 Sheet2에 뿌리는 코드\n'----------------------------------------------\nReDim\nvarTemp(1 To rngAll.Cells.Count, 1 To 3)\n'배열크기 재지정\nFor Each rngC In rngAll\n'데이터 영역 각 셀을 순환\nIf rngC <= 3 Then\n'값이 3보다 작거나 같을 경우\nr = r + 1\n'배열 1차원 방향(행) 크기 늘려감\nvarTemp(r, 1) = Cells(rngC.Row, 1)\n'ABC 입력\nvarTemp(r, 2) = Cells(1, rngC.Column)\n'가나다 입력\nvarTemp(r, 3) = rngC\n'셀 값 입력\nEnd If\nNext rngC\nSheets.\nAdd\nafter:=Sheets(\nSheets.Count\n)\n'제일 뒤에 시트 추가\nCells(2, 1).Resize(UBound(varTemp, 1), 3) = varTemp\n'배열값 시트에 뿌림\n'----------------------------------------------\n'중복 목록을 제거한 후 varR 배열에 넣는 코드\n'----------------------------------------------\nColumns(1).SpecialCells(2).Copy Cells(2, 4)\n'A열을 D열에 복사\nWith Columns(4)\n'D열에서\n.\nRemoveDuplicates\n1, 1\n'중복 제거\n.\nSort\nCells(1, 4), 1, Header:=xlYes\n'오름차순 정렬\nEnd With\nvarR = Columns(4).SpecialCells(2)\n'중복제거한 이름을 배열에 넣음\nCells(1, 1).Resize(, 4) = Array(\"이름\", \"Name\", \"값\", \"이름\")\n'제목행 넣음\nSet rngAll = ActiveSheet.UsedRange.Resize(, 3)\n'A:C열을 개체변수에 넣음\nr = 1\n'재사용 위하여 초기화\n'--------------------------------\n'새로운 시트들을 생성하는 코드\n'--------------------------------\nDo\n'다음을 실행\nSheets.Add after:=Sheets(Sheets.Count)\n'제일 뒤에 시트 추가\nActiveSheet.Name = varR(r, 1)\n'현재시트 이름을 변수내의 값으로 바꿈\nr = r + 1\n'배열크기 늘려감\nLoop Until\nr > UBound(varR, 1)\n'배열 마지막 행까지 반복\nSheets(2).Activate\n'Sheet2 활성화\nr = 1\n'재사용 위하여 초기화\n'------------------------------------------------\n'고급필터 이용하여 데이터 각 시트로 옮기는 코드\n'------------------------------------------------\nDo\n'다음을 실행\nRange(\"D2\") = varR(r, 1)\n'D2셀에 배열 값을 넣음\nrngAll.\nAdvancedFilter\nAction:=xlFilterCopy, _\nCriteriaRange:=Range(\"D1:D2\"), _\nCopyToRange:=Sheets(r + 2).Cells(1, 1), _\nUnique:=False\n'고급필터 적용\nr = r + 1\nLoop Until\nr > UBound(varR, 1)\n'배열 마지막 행까지 반복\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "B2:J11 셀의 값 중 3보다 작거나 같은 값을 1행값, 1열 값, 셀값의 3열로 추출한 후 이를 각 시트로 분류하는 기능.\n아래와 같은 코드는 공부하기 좋은 소재이다. 왼쪽에 엑셀창을 띄워 놓고, 오른쪽에 매크로창을 띄워 놓은 다음\nF8\n키와\nCtrl + F8\n키를 계속해서 눌러가며 엑셀창에서 일어나는 결과와 지역창(Locals)의 변수값이 변하는 것을 코드와 함께 비교해 보면 각 코드의 기능을 알 수 있다. 다시 한 번 명심하자. F8 키 누른 횟수와 자신의 매크로 실력이 비례한다는 것을. ^^\n매크로 실행 전 Sheet1                                                   매크로 실행후 Sheet2 의 데이터\n매크로 실행 후 생성된 시트들 중 A시트. 이름에 따라 각 값들이 분류됨\n매크로 실행 후 생성된 시트들 중 J시트. 이름에 따라 각 값들이 분류됨\nOption Explicit\nSub extract_And_AdvancedFilter()..."}
{"instruction": "Excel VBA code for: (1529) Old 와 New 두 시트의 유일한 데이터, 중복데이터 및 중복 없는 통합데이터 추출 6 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Duplicated_Data_5()\nDim s As Integer\n'시트(s)heet 개수 늘려갈 변수\nDim colsCnt As Integer\n'전체 열(col)umn(s) 개수(C)ou(nt) 넣을 변수\nDim varCol As Variant\n'중복삭제 열 개수 넣을 배열변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nWith WorksheetFunction\n'엑셀함수\nIf .\nCountA\n(Range(\"A2:A3\")) < 2 Or _\n.CountA(Sheets(2).Range(\"A2:A3\")) < 2 Then\n'1번 또는 2번시트 A2:A3셀이 빈 경우\nMsgBox \"작업할 데이터가 부족합니다.\", 64, \"데이터 입력 오류\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nEnd With\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n.Calculation =\nxlCalculationManual\n'셀계산 수동으로 전환\nEnd With\nWorksheets.\nFillAcrossSheets\nRange(\"1:1\")\n'전체 시트에 제목행 복사\nFor s = 3 To 5\n'3 ~ 5번 시트에서 반복\nSheets(s).UsedRange.Offset(1).Clear\n'기존 데이터 삭제\nNext s\n'---------------------------------------------------\n'열 개수 추출하고 Old / New 시트의 중복을 제거\n'---------------------------------------------------\ncolsCnt = Sheets(1).UsedRange.Columns.Count\n'전체 열 개수를 변수에 넣음\nReDim varCol(0 To colsCnt - 1)\n'배열크기 재지정\nFor s = 0 To colsCnt - 1\n'전체 열 개수만큼 반복\nvarCol(s) = s + 1\n'배열에 열 개수를 넣음\nNext s\nFor s = 1 To 2\n'Old와 New 시트의 중복 제거\nSheets(s).UsedRange.\nRemoveDuplicates\n_\nColumns:=(varCol), Header:=xlYes\n'전체열 모두 일치 시 중복제거\nNext s\n'----------------------------------------------\n' Old 시트에서 데이터 추출하여 각 시트에 뿌림\n'----------------------------------------------\nWith Range(\"A2\", Cells(Rows.Count, \"A\").End(xlUp)).Offset(, colsCnt)\n.\nFormula\n= \"=\nVLOOKUP\n(A2,New!A:A,1,FALSE)\"\n'VLOOKUP 수식 입력\n.\nValue\n= .\nValue\n'수식을 값으로 변환\nFor Each rngC In Columns(colsCnt + 1).\nSpecialCells\n(2, 16)\n'N/A 셀만 순환\nSheets(3).Cells(Rows.Count, \"A\").End(3)(2).Resize(, colsCnt) = _\nrngC.Offset(, -colsCnt).Resize(, colsCnt).Value\nNext rngC\n'각 행을 OldOnly 시트에 복사\nFor Each rngC In Columns(colsCnt + 1).\nSpecialCells(2, 7)\n'N/A 셀만 제외하고 순환\nSheets(4).Cells(Rows.Count, \"A\").End(3)(2).Resize(, colsCnt) = _\nrngC.Offset(, -colsCnt).Resize(, colsCnt).Value\nNext rngC\n'각 행을 Both 시트에 복사\n.\nClearContents\n'임시로 입력한 데이터 삭제\nEnd With\nSheets(2).Activate\n'New 시트 활성화\n'----------------------------------------------\n' New 시트에서 데이터 추출하여 각 시트에 뿌림\n'----------------------------------------------\nWith Range(\"A2\", Cells(Rows.Count, \"A\").End(xlUp)).Offset(, colsCnt)\n.Formula = \"=VLOOKUP(A2,Old!A:A,1,FALSE)\"\n'VLOOKUP 수식 입력\n.Value = .Value\n'수식을 값으로 변환\nFor Each rngC In Columns(colsCnt + 1).SpecialCells(2, 7)\n'N/A 셀만 제외하고 순환\nSheets(4).Cells(Rows.Count, \"A\").End(3)(2).Resize(, colsCnt) = _\nrngC.Offset(, -colsCnt).Resize(, colsCnt).Value\nNext rngC\n'각 행을 Both 시트에 복사\nFor Each rngC In Columns(colsCnt + 1).SpecialCells(2, 16)\n'N/A 셀만 순환\nSheets(5).Cells(Rows.Count, \"A\").End(3)(2).Resize(, colsCnt) = _\nrngC.Offset(, -colsCnt).Resize(, colsCnt).Value\nNext rngC\n'각 행을 NewOnly 시트에 복사\n.ClearContents\n'임시로 입력한 데이터 삭제\nEnd With\n'----------------------------------------------------\n' 각 시트의 서식을 설정하고, 정렬한 뒤 열너비 맞춤\n'----------------------------------------------------\nFor s = 3 To 5\n'3 ~ 5번 시트에서 반복\nWith Sheets(s)\n'각 시트에서\n.UsedRange.\nSort\n.[A1], 1, Header:=True\n'각 시트를 이름순으로 오름차순 정렬\n.Columns.AutoFit\n'열너비 자동 맞춤\nEnd With\nNext s\nWith Application\n'엑셀에서\n.Calculation =\nxlCalculationAutomatic\n'셀계산 자동으로 복원\n.ScreenUpdating = True\n'화면업데이트 재 실행\nEnd With\nSheets(1).Activate\nMsgBox \"데이터 추출이 완료되었습니다.\"\n'완료 메시지 출력\nEnd Sub", "context": "앞서 올린 코드 (\nhttp://blog.naver.com/rosa0189/60208378698\n) 와 동일한 기능을 함. 앞의 코드는 배열을 이용하였고, 이번에는 VLOOKUP을 응용하여 사용함.\nOld시트의 A열(이름)과 New 시트의 A열(이름)만 비교.\nOld 시트와 New 시트에 여러 데이터가 있음.\nOld 시트에만 있는 데이터를 OldOnly시트에, 양쪽에 이름이 있는 데이터를 Both시트에, New 시트에만 있는 데이터를 NewOnly시트에 추출하는 기능.\n최소 2행 이상의 데이터가 있어야 하며, 데이터의 행 또는 열 개수 제한이 없음.\n매크로 사용이 익숙치 않으면 첨부된 코드를 다운받고 자신의 데이터를 Old 시트와 New 시트에 복사하여 넣고 매크로 버튼만 클릭하면 된다. 본인의 데이터에 날짜열이 없을 경우 아래 코드에서 Sheets(i).Columns(\"E\").NumberFormat = \"yyyy-mm-dd\" 행을 삭제하면 된다.\n0초\n0초\n100%\n광고 후 계속됩..."}
{"instruction": "Excel VBA code for: (1530) 하이픈(-)으로 연결된 데이터 정렬하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_Hyphened_Text()\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim colNo As Integer\n'열 번호를 넣을 변수\nDim rngC As Range\n'데이터영역의 각 셀(C)ell을 넣을 변수\nDim varTemp\n'각 셀을 하이픈으로 분리해 넣을 배열변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Selection\n'선택영역에서\n'--------------------------------------------------\n' 영역선택 오류 시 사용자에게 이를 알리는 코드\n'--------------------------------------------------\nIf .\nAreas.Count\n> 1 Or .Columns.Count > 1 Then\n'복수영역 또는 1열 이상 선택 시\nMsgBox \"1개의 area만, 1개의 열만 선택가능\", 64, \"영역설정 에러\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nIf .Cells.Count = 1 Then\n'1셀만 선택 시\nMsgBox \"1셀 이상 선택\", 64, \"영역설정 에러\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\ncolsCnt = .EntireRow.SpecialCells(2).Columns.Count\n'전체 열개수 추출하여 변수에\ncolNo = .Column\n'열번호 추출\n.Offset(, 1).Resize(, 2).\nEntireColumn\n.Insert\n'오른쪽에 열 삽입\n'--------------------------------------------------\n' 셀내의 각 문자를 하이픈을 기준으로 분리하는 코드\n'--------------------------------------------------\nFor Each rngC In Selection\n'선택영역의 각셀(rngC)을 순환\nvarTemp =\nSplit\n(rngC, \"-\")\n'각 셀을 하이픈(-)을 기준으로 분리\nrngC.Next =\nVal\n(varTemp(0))\n'선택영역 오른쪽열에 하이픈 왼쪽값을 값으로 입력\nrngC.Offset(, 2) = Val(varTemp(1))\nNext\n'선택영역 오른쪽 두 번째 열에\n'하이픈 오른쪽을 값을 값으로 입력\n'---------------------------------------------------------------------\n' 선택영역을 전체열로 확장 후 오름차순 정렬하고 임시열 삭제하는 코드\n'---------------------------------------------------------------------\nWith .EntireRow\n'선택영역을 전체열로 확장\n.\nSort\nkey1:=.Cells(1, colNo + 1), _\norder1:=1, key2:=.Cells(1, colNo + 2), order2:=1\nEnd With\n'선택영역 1열/2열 건너뛴 열을 기준 오름차순 정렬\n.Offset(, 1).Resize(, 2).EntireColumn.Delete\n'임시로 사용한 정렬기준 데이터 삭제\n.Cells(colNo).Select\n'첫 번째셀 선택\nEnd With\nEnd Sub", "context": "하이픈(-)으로 연결된 데이터의 경우 일반적인 정렬을 하게 되면 하이픈 앞의 숫자 크기는 무시하고 숫자 순서대로만 정렬한다. 아래의 매크로 실행 시 하이픈 앞과 뒤의 숫자 크기에 따라 정렬을 하여준다.\n매크로 실행 전                            (일반적인 정렬을 한 결과)             매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1530) 하이픈(-)으로 연결된 데이터 정렬하기 (엑셀 VBA 매크로)\n재생\n926\n재생 (space/k)\n재생\n00:24\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:24\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했..."}
{"instruction": "Excel VBA code for: (1532) 기상청 강수량 데이터 가져오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub weather_Info()\nDim WinHttp As New\nWinHttp\n.WinHttpRequest\n'WinHttp로 사용할 변수\nDim strAddr As String\n'기상청 http 주소를 넣을 변수\nDim intYear As Integer\n'년도를 1씩 늘려갈 변수\nDim strHtml As String\n'전체 HTML 문자를 넣을 변수\nDim lngNo As Long\n'필요한 문자 위치 찾아 넣을 변수\nDim varTemp() As String\n'문자를 분리하여 임시로 넣을 배열 변수\nDim varR()\n'결과 값만 넣을 배열 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim strWord As String\n'</td> 앞의 문자만 넣을 변수\nDim v As Long\n'배열 위치 늘려갈 변수\nDim x As Integer\n'열방향 늘려갈 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nActiveSheet.UsedRange.Offset(4).EntireRow.Delete\n'기존 데이터 삭제\nintYear = Range(\"C2\")\n'시작년도에 C2셀 값을 넣음\nDo\n'다음을 실행\nstrAddr = \"\nhttp://www.kma.go.kr/weather/climate/past_table.jsp?stn\n=\" & _\nRange(\"C1\") & \"&yy=\" & intYear & \"&obs=\" & Range(\"C4\") & \"&x=29&y=9\"\n'조건에 따른 http 주소를 추출\nWinHttp.\nOpen\n\"GET\", strAddr\n'기상청 해당 페이지를 열기\nWinHttp.\nSend\n'열결을 보냄\nWinHttp.\nWaitForResponse\n'응답을 기다림\nstrHtml =\nStrConv\n(WinHttp.ResponseBody, vbUnicode)\n'Body를 유니코드로 변수에 넣음\n'-----------------------------------------------------------\n'전체 문자중 앞뒤 잘라내고 필요한 구간만 추출하는 코드\n'-----------------------------------------------------------\nlngNo =\nInStr\n(1, strHtml, \"<td scope=\"\"row\"\">\", vbBinaryCompare)\n'<td scope=\"\"row\"\"> 위치 찾음\nstrHtml = Mid(strHtml, lngNo, Len(strHtml) - lngNo)\n'\"row\">\n뒤로만 문자\n추출\nlngNo = InStr(1, strHtml, \"합계\", vbBinaryCompare)\n'\"합계\" 위치 찾음\nstrHtml = Mid(strHtml, 1, lngNo)\n'\"합계\" 앞쪽만 문자 추출\nvarTemp =\nSplit\n(strHtml, \"<td >\")\n'<td>에서 끊어서 배열에 넣음\nCells(Rows.Count, \"A\").End(3)(2).Offset(, 2) = intYear\n'년도 입력\n﻿\n'---------------------------------\n'년도/일 값을 복사해 넣는 코드\n'---------------------------------\nCells(Rows.Count, \"A\").End(3)(2) = \"년도\"\n'년도 문자 입력\nCells(Rows.Count, \"A\").End(3)(2).Resize(31) = intYear\n'A열에 년도 입력\nCells(Rows.Count, \"C\").End(3).Offset(, -1) = \"일\"\n'일 문자 입력\nFor i = 1 To 31\n'1 ~ 31까지 반복\nCells(Rows.Count, \"B\").End(3)(2) = i & \"일\"\n'날짜 입력\nNext i\n'-------------------------------------------------\n'추출한 값을 배열에 넣어 시트에 뿌리는 코드\n'-------------------------------------------------\nReDim varR(1 To 31, 1 To 12)\n'배열크기 재지정\nv = 1\n'배열 위치 1행 부터 시작\nFor i = 1 To\nUBound\n(varTemp)\n'1 에서 배열 상한값까지 반복\nIf x = 12 Then\n'12번째 열에 도착하면\nx = 0\n'열 위치 초기화\nv = v + 1\n'배열 행을 1씩 늘려감\nEnd If\nx = x + 1\n'열 위치 1씩 늘려감\nstrWord = Split(varTemp(i), \"</td>\")(0)\n'최종 데이터만 추출\nIf strWord <> \"&nbsp;\" Then\n'&nbsp; 아닐 경우\nvarR(v, x) = strWord\n'배열에  값을 넣음\nEnd If\nNext i\nCells(Rows.Count, \"B\").End(3)(2).Offset(-31, 1).Resize(31, 12) = varR\n'배열 값을 시트에 뿌림\nx = 0\n'재사용 위하여 초기화\nintYear = intYear + 1\n'년도를 1 늘려감\nLoop Until\nintYear = Range(\"C3\") + 1\n'종료년도까지 무한 반복\nWith ActiveSheet.UsedRange\n'현재시트 사용 영역에서\n.Offset(4).Resize(.Rows.Count - 4).Borders.LineStyle = 1\n'테두리 적용\nEnd With\n'-----------------------------\n'서식을 지정해주는 코드\n'-----------------------------\nWith Columns(\"C:N\")\n'C:N열까지\n.\nNumberFormat\n= \"0.00\"\n'서식을 소숫점 2자리까지\n.AutoFit\n'열너비 자동 맞춤\nEnd With\nFor Each rngC In Columns(1).SpecialCells(2)\n'A열 각 문자셀 순환\nIf rngC = \"년도\" Then\n'셀값이 \"년도\"일 경우\nrngC.Offset(, 2).NumberFormat = \"#\"\n'오른쪽 두번째셀 서식을 일반숫자로\nEnd If\nNext rngC\nRange(\"C1:C4\").NumberFormat = \"#\"\n'C1:C4 영역 서식을 일반 숫자로\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1532) 기상청 강수량 데이터 가져오기 (엑셀 VBA 매크로)\n재생\n2,146\n재생 (space/k)\n재생\n00:46\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:46\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n관측소, 시작년, 종료년 선택하고 매크로를 실행\n﻿조건에 따른 자료를 기상청 홈페이지에서 가져온다..."}
{"instruction": "Excel VBA code for: (1535) 외곽 이중선, 내부 가는선 (엑셀 VBA 매크로)", "input": "", "output": "Sub draw_LInes_xlDouble()\nDim i As Integer\n'반복구문에 사용할 변수\nFor i = 7 To 10\n'7 ~ 10까지 반복\nRange(\"B2:E5\").\nBorders\n(i).\nLineStyle\n= xlDouble\nNext i\n'외곽 테두리 이중선\nFor i = 11 To 12\n'11 ~ 12까지 반복\nRange(\"B2:E5\").Borders(i).LineStyle = 1\nNext i\n'내부 가는선\nEnd Sub", "context": "특정 영역의 외곽에 이중선, 내부는 가는선으로 그리는 기능.\n매크로 실행 전                                            매크로 실행 후 결과\nOption Explicit\nSub draw_LInes_xlDouble()\nDim i As Integer\n'반복구문에 사용할 변수\nFor i = 7 To 10\n'7 ~ 10까지 반복\nRange(\"B2:E5\").\nBorders\n(i).\nLineStyle\n= xlDouble\nNext i\n'외곽 테두리 이중선\nFor i = 11 To 12\n'11 ~ 12까지 반복\nRange(\"B2:E5\").Borders(i).LineStyle = 1\nNext i\n'내부 가는선\nEnd Sub..."}
{"instruction": "Excel VBA code for: (1536) 에러 없는 행만 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Without_Error()\nDim colscnt As Integer\n'열 개수 추출할 변수\nDim lastRow As Long\n'마지막 행 넣을 변수\nDim varR\n'추출한 값들을 넣을 배열변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열 행 증가에 사용할 변수\nDim x As Integer\n'열 방향 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트(일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\ncolscnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열 개수 추출하여 변수에\nlastRow = Cells(Rows.Count, \"A\").End(3).\nRow\n'마지막행 추출하여 변수에\nReDim varR(1 To lastRow, 1 To colscnt)\n'배열 크기 재지정\nFor i = 1 To lastRow\n'1에서 1씩 증가하며 마지막행까지\nIf\nNot IsError\n(Cells(i, 1)) Then\n'셀값에 에러가 포함되어 있지 않으면\nr = r + 1\n'배열 위치 1씩 늘려감\nFor x = 1 To colscnt\n'열 개수만큼 반복\nvarR(r, x) = Cells(i, x)\n'배열에 값을 넣음\nNext x\nEnd If\nNext i\n.Cells(1, 1).Resize(lastRow, colscnt) = varR\n'배열값 시트에 뿌림\n.Columns.AutoFit\n'열너비 자동 맞춤\nEnd With\nMsgBox \"매크로가 종료되었습니다.\"\n'매크로 종료 메시지창 출력\nEnd Sub", "context": "매크로 실행 전 Sheet1 (A열에 여러 에러가 있음)              매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub extract_Without_Error()\nDim colscnt As Integer\n'열 개수 추출할 변수\nDim lastRow As Long\n'마지막 행 넣을 변수\nDim varR\n'추출한 값들을 넣을 배열변수\nDim i As Long\n'반복구문에 사용할 변수\nDim r As Long\n'배열 행 증가에 사용할 변수\nDim x As Integer\n'열 방향 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트(일시) 정지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\ncolscnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열 개수 추출하여 변수에\nlastRow = Cells(Rows.Count, \"A\"..."}
{"instruction": "Excel VBA code for: (1537) 모든 시트의 특정 데이터 Main시트에 통합 3 (VBA 매크로)", "input": "", "output": "Sub find_Matching_Data_In_Other_Sheets_3()\nDim wks As Worksheet\n'각 시트를 넣을 변수\nDim colsCnt As Integer\n'열 개수를 넣을 변수\nDim rngT As Range\n'데이터가 복사될 타겟 지점\nActiveSheet.UsedRange.Offset(1).Clear\n'기존 데이터 삭제\nSheets(1).Rows(1).Copy\n[A1]\n'제목행을 현재시트에 복사\nFor Each wks In ActiveWorkbook.Worksheets\n'각 시트를 순환\nIf wks.Name <> \"Total\" Then\n'시트 이름이 Total이 아니면\nWith wks.UsedRange\n'각 시트 사용 영역에서\ncolsCnt = .Columns.Count\n'열 개수를 변수에 넣음\n.\nAutoFilter\n8, \"미\", , , 1\n'자동필터 적용하여 \"미\"만 추출\nSet rngT = Cells(Rows.Count, \"A\").End(3)(2)\n'각 시트의 데이터가 복사될 위치\n.Offset(1).\nCopy\nrngT\n'추출한 각 시트의 데이터 Total에 복사\nRange(rngT, Cells(Rows.Count, \"A\").End(3)).Offset(, colsCnt) = wks.\nName\n'시트 이름을 제일 마지막 열에 넣음\n.AutoFilter\n'자동필터 해제\n﻿            End With\n﻿\nEnd If\nNext wks\nColumns.AutoFit\n'열너비 자동 맞춤\nEnd Sub", "context": "1. Total 시트를 제외한 모든 시트의 8열(H열)에 있는 \"미\" 데이터를 Total 시트에 통합하는 기능\n2. Total 시트 제일 오른쪽 열에는 각 시트의 이름을 넣음\n(빈 시트가 있으면 에러나므로 빈 시트 없이 매크로를 실행하도록 한다.)\n매크로 실행 전 Total 시트                                           매크로 실행전 Sheet1\n매크로 실행 전 Sheet2 의 데이터                    매크로 실행 후 Total 시트의 결과\nOption Explicit\nSub find_Matching_Data_In_Other_Sheets_3()\nDim wks As Worksheet\n'각 시트를 넣을 변수\nDim colsCnt As Integer\n'열 개수를 넣을 변수\nDim rngT As Range\n'데이터가 복사될 타겟 지점\nActiveSheet.UsedRange.Offset(1).Clear\n'기존 데이터 삭제\nSheets(1).R..."}
{"instruction": "Excel VBA code for: (1538) 모든 시트의 특정 데이터 Main시트에 통합 4 (VBA 매크로)", "input": "", "output": "Private Sub Workbook_Open()\nDim varList As Variant\n'목록을 넣을 배열 변수\nDim i As Integer\n'반복구문에 사용할 변수\nvarList = Array(\"미결\", \"완료\", \"진행중\")\n'목록을 배열에 넣음\nWith Worksheets(\"Total\").\nDropDowns\n(\"Drop Down 1\")\n'Total시트 콤보박스에서\n.RemoveAllItems\n'기존 목록을 모두 삭제\nFor i = LBound(varList) To UBound(varList)\n'배열 하한값에서 상한값까지 반복\n.\nAddItem\nvarList(i)\n'배열내 값을 목록에 추가\nNext\n.\nListIndex\n= 1\n'목록 첫 번째 값을 기본으로 표시\nEnd With\nEnd Sub\n\nSub find_Matching_Data_In_Other_Sheets_3()\nDim strCri As String\n'필터 조건을 넣을 변수\nDim wks As Worksheet\n'각 시트를 넣을 변수\nDim colsCnt As Integer\n'열 개수를 넣을 변수\nDim rngT As Range\n'데이터가 복사될 타겟 지점\nWith ActiveSheet.DropDowns(\nApplication.Caller\n)\n'현재시트 콤보박스 호출\nstrCri = .\nList\n(.ListIndex)\n'필터링 조건을 변수에 넣음\nEnd With\nActiveSheet.UsedRange.Offset(1).Clear\n'기존 데이터 삭제\nSheets(1).Rows(1).Copy\n[A1]\n'제목행을 현재시트에 복사\nFor Each wks In ActiveWorkbook.Worksheets\n'각 시트를 순환\nIf wks.Name <> \"Total\" Then\n'시트 이름이 Total이 아니면\nWith wks.UsedRange\n'각 시트 사용 영역에서\ncolsCnt = .Columns.Count\n'열 개수를 변수에 넣음\n.\nAutoFilter\n8, strCri, , , 1\n'자동필터 적용하여 \"미\"만 추출\nSet rngT = Cells(Rows.Count, \"A\").End(3)(2)\n'각 시트의 데이터가 복사될 위치\n.Offset(1).\nCopy\nrngT\n'추출한 각 시트의 데이터 Total에 복사\nRange(rngT, Cells(Rows.Count, \"A\").End(3)).Offset(, colsCnt) = wks.\nName\n'시트 이름을 제일 마지막 열에 넣음\n.AutoFilter\n'자동필터 해제\n﻿            End With\n﻿\nEnd If\nNext wks\nColumns.AutoFit\n'열너비 자동 맞춤\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1538) 모든 시트의 특정 데이터 Main시트에 통합 4 (VBA 매크로)\n재생\n1,301\n재생 (space/k)\n재생\n00:35\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:35\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n(파일을 열면 Workbook_Open 코드가 실행되며 목록에 검색조건을 넣음)\nSheet1과 Sheet2에 데이터가 있음..."}
{"instruction": "Excel VBA code for: (1539) 이름/날짜 달라지면 행 바꿔 데이터 정리하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub when_Name_And_Date_Change()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim y As Long\n'이름/날짜 중복 아닐 때마다 행을 늘릴 변수\nDim rngT As Range\n'복사될 위치(T)arget 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2 에서\nRows(1).Copy .Cells(1, 1)\n'제목행 Sheet2 에 복사\n.UsedRange.Offset(1).\nClearContents\n'기존 데이터 삭제\nEnd With\nr = 2\n'Sheet1 행을 2행 부터 시작\ny = 1\n'Sheet2 제목행부터 시작\nDo\n'다음을 실행\ny = y + 1\n'Sheet2의 행을 1씩 늘려감\nSet\nrngT = Sheets(2).Cells(y, Columns.Count).End(1)\n'복사될 지점 변수에 넣음\nIf Cells(r, 2) = Cells(r + 1, 2) And _\nCells(r, 2) = Cells(r + 1, 2) Then\n'2열과 3열이 모두 일치 시\nrngT.Resize(, 3) = _\nCells(r, 1).Resize(, 3).Value\n'각 행에 구분/이름/날짜 복사\nDo\n'다음을 실행\nSet rngT = rngT.Offset(, 3)\n'복사될 위치 오른쪽으로 3열 이동\nrngT.Resize(, 3) = _\nCells(r, 4).Resize(, 3).Value\n'코드1/코드2/코드명 복사\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r - 1, 2) <> Cells(r, 2) Or _\nCells(r - 1, 3) <> Cells(r, 3)\n'날짜가 달라질 때까지 무한 반복\nElse\nrngT.Resize(, 6) = _\nCells(r, 1).Resize(, 6).Value\n'코드1/코드2/코드명 복사\nr = r + 1\n'행을 1씩 증가\nEnd If\nIf r > 100000 Then\n'10만행 넘어갈 경우\nMsgBox \"10만행을 넘어 종료. 데이터 이상유무 확인요\", 16, \"데이터 오류\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nLoop Until\nCells(r, 2) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nWith Sheets(2)\n.Columns(\"C\").\nNumberFormat\n= \"m\"\"월\"\" d\"\"일\"\";@\"\n'C열 서식 월-일 날짜로 지정\n.Columns.AutoFit\n'열너비 자동맞춤\nEnd With\nMsgBox \"매크로가 종료되었습니다.\"\n'매크로 종료 메시지창 출력\"\nEnd Sub", "context": "이름 또는 날짜가 변경될 때마다 행을 바꿔가며 데이터를 정리하는 기능\n매크로 실행 전 Sheet1 의 입력된 데이터\n매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub when_Name_And_Date_Change()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim y As Long\n'이름/날짜 중복 아닐 때마다 행을 늘릴 변수\nDim rngT As Range\n'복사될 위치(T)arget 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2 에서\nRows(1).Copy .Cells(1, 1)\n'제목행 Sheet2 에 복사\n.UsedRange.Offset(1).\nClearContents\n'기존 데이터 삭제\nEnd With\nr = 2\n'Sheet1 행을 2행 부터 시작\ny = 1\n'Sheet2 제목행부터 시작\nDo\n'다음을 실행\ny = y + 1\n'Sheet2의 행..."}
{"instruction": "Excel VBA code for: (1540) 조건에 따라 두 값을 더하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub add_One_Or_Subtract()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngT As Range\n'위쪽 값을 넣을 변수\nDim intSum As Integer\nColumns(\"C\").ClearContents\n'기존 C열의 데이터 삭제\n[C1]\n=\n[A1]\n'C1에 A1셀 값을 입력(예외)\nFor Each rngC In Range([A2], Cells(Rows.Count, \"A\").End(3))\n'A열 전체 데이터 영역 각 셀을 순환\nIf Len(rngC) > 0 Then\n'빈셀이 아니라면\nIf rngC.Offset(-1, 2) <> \"\" Then\n'오른쪽 2열, 위로 1행 셀에 값이 있으면\nSet rngT = rngC.Offset(-1, 2)\n'오른쪽 2열, 위로 1행에 있는 값을 변수에\nElse\n'빈셀이라면\nSet rngT = rngC.Offset(, 2).End(3)\n'오른쪽 2열간 셀에서 종단셀 윗방향 셀을 변수에\nEnd If\nIf (rngC + rngT) < 0 Then\n'두 값을 합쳐서 0보다 작으면\nrngC.Offset(, 2) = -1\n'최솟값인 -1을 입력\nElse\n'두 값을 합쳐서 0보다 크면\nrngC.Offset(, 2) = rngC + rngT\n'C열에 두 값을 합친 값을 넣음\nEnd If\nEnd If\nNext rngC\nEnd Sub", "context": "A열의 값을 같은 행 C열의 위쪽에 있는 값과 더함\n단 -1 이 최솟값임. 즉 C열에 -1이 있는 상황에서 A열의 -1과 더하면 -2가 아닌 최솟값인 -1이 그대로 유지됨.\nA1셀은 C1 위에 셀이 없으므로 예외 처리함. 즉, C1 셀은 그냥 A1셀의 값을 넣음.\n매크로 실행 전                                                       매크로 실행 후 결과\nOption Explicit\nSub add_One_Or_Subtract()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngT As Range\n'위쪽 값을 넣을 변수\nDim intSum As Integer\nColumns(\"C\").ClearContents\n'기존 C열의 데이터 삭제\n[C1]\n=\n[A1]\n'C1에 A1셀 값을 입력(예외)\nFor Each rngC In Range([A2], Cells(Rows.Count, \"A\").End(3))\n'A열 전체 데이터 영역 각 셀을 ..."}
{"instruction": "Excel VBA code for: (1541) 연속되는 모델명 나열하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_The_Numbers_Between()\nDim rngAll As Range\n'전체(All)영역을 넣을 영역변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역변수\nDim i As Integer\n'셀의 문자길이만큼 반복할 변수\nDim rngT As Range\n'데이터가 복사될 위치(T)arget 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n'--------------------------------\n'데이터를 복사하고 서식 지정\n'--------------------------------\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Clear\n'기존데이터 삭제\nColumns(\"D:E\").\nCopy\n.Cells(1, 1)\n'D:E  복사하여 A열에 붙여넣기\nColumns(\"D:E\").Copy .Cells(1, 3)\n'D:E  복사하여 C열에 붙여넣기\n.Activate\n'활성화\nEnd With\nColumns(\"A:D\").\nNumberFormat\n= \"\n@\n\"\n'A:D열의 서식을 문자로 지정\n'------------------------------------\n'알파벳과 숫자를 모두 제거하는 코드\n'------------------------------------\nFor i = 65 To 90\n'65 ~ 90까지 반복\nColumns(\"A:B\").\nReplace\nChr(i), \"\"\n'알파벳을 모두 삭제\nNext i\nFor i = 0 To 9\n'0 ~ 9까지 반복\nColumns(\"C:D\").Replace i, \"\"\n'숫자를 모두 삭제\nNext i\n'--------------------------------------------------\n'영역을 변수에 넣고 혹시모를 공백 제거하는 코드\n'--------------------------------------------------\nSet rngAll = Range(\"A1\", Cells(Rows.Count, \"A\").End(3))\n'A열을 개체(영역)변수에 넣음\"\nFor Each rngC In rngAll.Resize(, 4)\n'A:D열 각 셀을 순환\nrngC =\nTrim\n(rngC)\n'혹시 모를 공백을 제거\nNext rngC\n'--------------------------------------\n'조건에 따라 데이터를 옮기는 코드\n'--------------------------------------\nFor Each rngC In rngAll\n'A열 각 셀을 순환\nSet rngT = Cells(Rows.Count, \"F\").\nEnd(3)(2)\n'데이터 복사될 위치 설정\nIf rngC <= rngC.Next Then\n'A열이 B열보다 값이 작거나 같다면\nIf rngC.Next - rngC = 0 Then\n'A:B열이 똑 같다면\nrngT = rngC.Offset(, 3) & rngC\n'D열에 값 입력\nrngT.Next = rngC.Offset(, 3) & rngC.Next\n'E열에 값 입력\nElse\n'B열이 크다면\nrngT = rngC.Offset(, 3) & rngC\n'D열에 값 입력\nrngT.Next = rngC.Offset(, 3) & rngC.Next\n'E열에 값 입력\nFor i = 1 To rngC.Next - rngC\n'B열-A열 개수만큼 반복\nSet rngT = rngT.Offset(1)\n'데이터 복사될 위치 1행 내림\nrngT = rngC.Offset(, 3) & rngC + i\n'D열에 연속 값을 입력\nNext i\nEnd If\nElse\n'A열이 B열보다 클 경우\nrngT = rngC.\nAddress\n(0, 0) & \"셀 오류\"\n'데이터 오류 알림\"\nrngT.Interior.\nColorIndex\n= 36\n'옅은 노란색으로 표시\nEnd If\nNext rngC\nColumns(\"F:G\").AutoFit\n'F:G열 열너비 자동 맞춤\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. D열과 E열에 입력된 모델명 사이의 모델명을 연속으로 나열하는 기능\n2. 혹시 실수로 데이터를 뒤집어 입력(5행 색으로 표시한 데이터)한 경우는 이를 결과데이터에 표시\n매크로 실행 전 Sheet1에 입력된 데이터 (Sheet2는 비어 있음)\n매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub find_The_Numbers_Between()\nDim rngAll As Range\n'전체(All)영역을 넣을 영역변수\nDim rngC As Range\n'각 셀(C)ell 을 넣을 영역변수\nDim i As Integer\n'셀의 문자길이만큼 반복할 변수\nDim rngT As Range\n'데이터가 복사될 위치(T)arget 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n'--------------------------------\n'데이터를 복사하고 서식 지정\n'--------------------------------..."}
{"instruction": "Excel VBA code for: (1542) 빠진 숫자 15까지 채워넣기 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Rows_Upto_15()\nDim rowsCnt As Long\n'배열의 행(1차원) 크기 지정할 변수\nDim varTemp\n'추출한 값들을 넣을 배열 변수\nDim r As Long\n'행 늘려갈 변수\nDim y As Long\n'배열의 행(1차원) 크기 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim x As Integer\n'열방향 크기 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nRows(1).Copy .Cells(1, 1)\n'제목행 Sheet2에 복사\nEnd With\nColumns(\"G\").Copy Cells(1, 100)\n'CV열에 임시로 데이터 복사\nColumns(\"CV\").\nRemoveDuplicates\n1\n'중복 제거\nrowsCnt = Cells(Rows.Count, \"CV\").End(3).\nRow\n* 15 + 30\n'배열 크기 지정위한 행 개수 추출\nReDim\nvarTemp(1 To rowsCnt, 1 To 8)\n'배열 크기 재지정\nColumns(\"CV\").Delete\n'임시열 삭제\nr = 2\n'2행부터 시작\nDo\n'다음을 실행\nIf Cells(r, 7) <> Cells(r + 1, 7) Then\n'G열의 위 아래 값이 다르면\nFor i = 0 To 15\n'0부터 15까지 1씩 증가하며 반복\ny = y + 1\n'배열 행 1씩 늘려감\nFor x = 1 To 7\n'1 ~ 7까지 반복\nvarTemp(y, x) = Cells(r, x)\n'배열에 A:G열 까지의 값 입력\nNext x\nvarTemp(y, 8) = i\n'배열에 BitNo 순차적으로 입력\nNext i\nEnd If\nr = r + 1\n'행을 1씩 늘려감\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nSheets(2).Activate\n'Sheet2 활성화\nCells(2, 1).Resize(\nUBound\n(varTemp, 1), 8) = varTemp\n'배열내 값을 시트에 뿌림\nEnd Sub", "context": "(H열의 숫자는 0 ~ 15까지 연속되도록 하는 것이 목표임. 매크로 실행 전 H열 숫자가 15까지 없는 경우가 보임)\nG열의 연속되는 값이 변경될 때마다 H열에 숫자가 0~15까지 순차적으로 채워지도록 하기 위해 행을 삽입하고 빠진 숫자들을 복사.\n매크로 실행 전 Sheet1 (Sheet2는 비어 있음)             매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub insert_Rows_Upto_15()\nDim rowsCnt As Long\n'배열의 행(1차원) 크기 지정할 변수\nDim varTemp\n'추출한 값들을 넣을 배열 변수\nDim r As Long\n'행 늘려갈 변수\nDim y As Long\n'배열의 행(1차원) 크기 늘려갈 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim x As Integer\n'열방향 크기 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith S..."}
{"instruction": "Excel VBA code for: (1543) 입력일로 부터 현재 날짜까지 나열하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub generate_Date_UpTo_Today()\nDim r As Long\n'행과 날짜 늘려갈 변수\nDim dteToday As\nDate\n'날짜 넣을 변수\nDo\n'다음을 실행\ndteToday = Range(\"A2\") + r\n'A2의 날짜부터 1씩 늘려감\nr = r + 1\n'행/날짜 1씩 늘려감\nCells(r, 4) = dteToday\n'D열에 날짜 입력\nIf r > 10000 Then\n'10,000행이 넘을 경우\nMsgBox \"날짜입력 오류. 1만행 복사되어 종료됨\", 16, \"입력오류\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nLoop Until dteToday =\nDate\n'오늘 날짜가 될때까지 무한 반복\nColumns(\"D\").AutoFit\n'D열 열너비 자동 맞춤\nMsgBox \"매크로가 종료되었습니다.\"\n'메시지창 출력\nEnd Sub", "context": "입력한 날짜로 부터 현재 날짜까지 나열해주는 기능. 동일한 매크로를 내일 실행 할 경우 당연히 오늘보다 하루 더 늘어난다. 날짜관련 기능을 너무 소홀히 한 것 같아 Date_Time 카테고리를 추가하였다. 앞으로 날짜나 시간 내용은 이 카테고리에 올릴 예정.\n매크로 실행 전                                                   매크로 실행 후 결과\nOption Explicit\nSub generate_Date_UpTo_Today()\nDim r As Long\n'행과 날짜 늘려갈 변수\nDim dteToday As\nDate\n'날짜 넣을 변수\nDo\n'다음을 실행\ndteToday = Range(\"A2\") + r\n'A2의 날짜부터 1씩 늘려감\nr = r + 1\n'행/날짜 1씩 늘려감\nCells(r, 4) = dteToday\n'D열에 날짜 입력\nIf r > 10000 Then\n'10,000행이 넘을 경우\nMsgBox \"날짜입력 오류. 1만행 복사되어 종료됨\", ..."}
{"instruction": "Excel VBA code for: (1544) 엑셀 파일 열지 않고 데이터 가져오기 (VBA 매크로)", "input": "", "output": "Sub get_From_Closed_File()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'파일 이름을 넣을 변수\nDim shtName As String\n'시트 이름을 넣을 변수\nDim rngAll As Range\n'가져올 데이터 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nstrPath = \"\nC:\\Users\\사용자\\Desktop\\\n\"\n'폴더 경로\n'\nstrPath =\nThisWorkbook.Path\n& \"\\\"\n'폴더 경로\nfileName = \"\nBook1.xlsx\n\"\n'파일 이름\nshtName = \"\nSheet1\n\"\n'시트 이름\nSet rngAll = Range(\"\nC4:D5\n\")\n'가져올 데이터 영역\nFor Each rngC In rngAll\n'가져올 영역의 각 셀을 순환\nrngC.Formula = \"='\" & strPath & \"[\" & fileName & \"]\" _\n& shtName & \"'!\" & rngC.Address(0, 0)\n'가져올 셀의 수식을 입력\nrngC = rngC.Value\n'셀값을 수식에서 값으로 변환\nNext rngC\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "이미 유사한 기능을 여러가지 방법으로 해보았다. 아래 코드는 닫혀진 특정 엑셀 파일에서 데이터를 가져오는 기능이다. 아래 노란색으로 표시한 경로만 자신의 경로로 바꾸어 사용하면 된다.\n데이터를 가져올 파일) Book1.xlsx 파일의 Sheet1 시트내의 C4:D5\n매크로 실행 전                                                   매크로 실행 후 결과\nOption Explicit\nSub get_From_Closed_File()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'파일 이름을 넣을 변수\nDim shtName As String\n'시트 이름을 넣을 변수\nDim rngAll As Range\n'가져올 데이터 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nstrPath = \"\nC:\\Users\\사용자\\Desktop\\\n\"\n'폴더 경로\n'\nstrPath =\nThi..."}
{"instruction": "Excel VBA code for: (1545) 폴더(하위폴더 포함)내 엑셀파일 특정 시트의 데이터 통합 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_From_All_Folders_2()\nDim strPath As String\n'폴더의 경로를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\n'--------------------\n' 폴더 선택창 출력\n'--------------------\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\neachFolder strPath\n'eachFolder 코드를 호출\nActiveSheet.UsedRange.\nSort\n[A1], 1, Header:=True\n'오름차순 정렬\nMsgBox \"매크로가 종료되었습니다.\"\n'메시지 출력\nEnd Sub\n\nPrivate Function eachFolder(mainFolder As String)\nDim strSht As String\n'시트이름을 넣을 변수\nDim rngData As Range\n'가져올 데이터가 있는 셀 넣을 변수\nDim fSO As Scripting.FileSystemObject\n'파일 시스템을 넣을 변수\nDim fldName As Scripting.Folder\n'상위폴더 넣을 변수\nDim fileName As Object\n'파일이름 넣을 변수\nDim subFolder As Scripting.Folder\n'하위폴더 넣을 변수\nDim rngT As Range\n'데이터가 복사될 위치 넣을 변수\nstrSht = \"\nSheet1\n\"\n'데이터를 가져오려는 시트\nSet rngData = Range(\"\nB3\n\")\n'데이터를 가져오려는 셀\nSet fSO = New\nScripting\n.\nFileSystemObject\n'새로운 파일시스템개체를 변수에\nSet fldName = fSO.GetFolder(mainFolder)\n'선택한 폴더의 이름을 변수에 넣음\nFor Each fileName In fldName.\nFiles\n'폴더내 각 파일을 순환\nIf InStr(fileName, \".xlsx\") Then\n'파일이 엑셀 파일이면\nSet rngT = Cells(Rows.Count, \"A\").End(3)(2)\n'종단셀 윗방향 바로 아래셀\nrngT = Split(fileName.Name, \".\")(0)\n'파일 이름입력\nrngT.Next.\nFormula\n= \"='\" & mainFolder & \"\\\" & \"[\" & fileName.Name _\n& \"]\" & strSht & \"'!\" & rngData.\nAddress\n(0, 0)\n'가져올 셀의 수식을 입력\nWith rngT.Resize(, 2)\n'두 셀의 데이터를\n.Value = .Value\n'수식을 값으로 변환\nEnd With\nEnd If\nNext fileName\n'--------------------------------\n' 재귀 호출로 하위 폴더 순환\n'--------------------------------\nFor Each subFolder In fldName.\nSubFolders\n'각 폴더의 하위폴더를 순환\neachFolder subFolder.Path\n'각 폴더경로로 eachFolder함수호출\nNext subFolder\nSet rngData = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet fSO = Nothing\nSet fldName = Nothing\nSet rngT = Nothing\nEnd Function", "context": "폴더내 데이터 파일(여러 시트가 있으며 그중에 하나는 Sheet1 )\n폴더내 하위 폴더들 및 파일 (확장자가 .xlsx 가 아닌 파일들은 무시함)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1545) 폴더(하위폴더 포함)내 엑셀파일 특정 시트의 데이터 통합 2 (엑셀 VBA 매크로)\n재생\n2,361\n공유하기\n재생 (space/k)\n재생\n00:46\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:46\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요..."}
{"instruction": "Excel VBA code for: (1546) 중복없는 이름을 행/열 변환하여 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Private Sub Worksheet_Change(ByVal Target As Range)\nIf Target.Count > 1 Then Exit Sub\n'복수의 셀을 선택하면 매크로 종료\nIf Target.Column <> 1 Then Exit Sub\n'A열이 아니면 매크로 종료\nWith Application\n.ScreenUpdating = False\n'화면 업데이트(일시) 정지\n.\nEnableEvents\n= False\n'이벤트 트리거링 기능을 중지\nIf Cells(Rows.Count, \"A\").End(3).Row <> _\nWorksheetFunction.\nCountA\n(Columns(\"A\")) Then\n'중간에 있는 이름 삭제하여 공백 생기면\nColumns(\"A\").\nSpecialCells(4)\n.Delete shift:=xlUp\nEnd If\n'공백을 삭제하여 위로 끌어 올림\nColumns(\"A\").Copy Cells(1, 1000)\n'A열을 임시열에 복사\nWith Columns(\"ALL\")\n'임시열에서\n.\nRemoveDuplicates\n1\n'중복을 제거\n.Sort Cells(1, 1000), 1\n'오름차순 정렬\nSheets(2).Rows(1).Clear\n'Sheet2의 1행 데이터 삭제\nSheets(2).Cells(1, 1).Resize(, .SpecialCells(2).Cells.Count) = _\nApplication.\nTranspose\n(.SpecialCells(2))\n'행/열 변환하여 Sheet2에 복사\n.Delete\n'임시열 삭제\nEnd With\n.EnableEvents = True\n'이벤트 트리거링 기능 복원\nEnd With\nSheets(2).Activate\nEnd Sub", "context": "Sheet1 의 A열에 있는 이름을 중복 제거하고 유일한 목록만 Sheet2 에 행으로 넣는 기능.\n매크로 실행 전                                                    매크로 실행 전 Sheet1 은 비어 있는 상태\nA8셀에 문자 입력하여 매크로 실행됨                       매크로 실행 후 Sheet2 의 결과\nOption Explicit\nPrivate Sub Worksheet_Change(ByVal Target As Range)\nIf Target.Count > 1 Then Exit Sub\n'복수의 셀을 선택하면 매크로 종료\nIf Target.Column <> 1 Then Exit Sub\n'A열이 아니면 매크로 종료\nWith Application\n.ScreenUpdating = False\n'화면 업데이트(일시) 정지\n.\nEnableEvents\n= False\n'이벤트 트리거링 기능을 중지\nIf Cells(Rows.Count, \"..."}
{"instruction": "Excel VBA code for: (1548) 데이터 이동하여 재배치하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub relocate_Data()\nDim colsCnt As Integer\n'열(col)umn 개수(C)ou(nt) 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim rngCol As Range\n'열(Col)umn 넣을 영역(개체)변수\nDim rowsCnt As Long\n'행(rows) 개수(C)ou(nt) 넣을 변수\nDim rngT As Range\n'복사될 위치(T)arget 넣을 변수\nRange(\"G1\").CurrentRegion.Offset(1).ClearContents\n'G1셀과 연결된 현재영역 제목행 아래 모두삭제\ncolsCnt = Range(\"B5\").CurrentRegion.\nColumns\n.\nCount\n'B5 연결된 영역의 열 개수를 변수에\nFor i = 1 To colsCnt\n'열 개수만큼 반복\nSet rngCol = Range(Cells(3, i), Cells(Rows.Count, i).End(3))\n'각 열의 데이터를 변수에 넣음\nrowsCnt = rngCol.\nRows.Count\n'각 열의 데이터의 행 개수를 변수에\nSet rngT = Cells(Rows.Count, \"G\").End(3)(2)\n'G열에 데이터가 복사될 위치\nrngT.Resize(rowsCnt) = Cells(1, i)\n'G열에 종류를 입력\nrngT.Offset(, 1).Resize(rowsCnt) = rngCol\n.Value\n'H열에 재료(과일)를 입력\nNext i\nColumns(\"G:H\").AutoFit\n'G:H열 열너비 자동맞춤\nSet rngCol = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngT = Nothing\nEnd Sub", "context": "매크로 실행 전                                                                             매크로 실행 후 결과\nOption Explicit\nSub relocate_Data()\nDim colsCnt As Integer\n'열(col)umn 개수(C)ou(nt) 넣을 변수\nDim i As Integer\n'반복구문에 사용할 변수\nDim rngCol As Range\n'열(Col)umn 넣을 영역(개체)변수\nDim rowsCnt As Long\n'행(rows) 개수(C)ou(nt) 넣을 변수\nDim rngT As Range\n'복사될 위치(T)arget 넣을 변수\nRange(\"G1\").CurrentRegion.Offset(1).ClearContents\n'G1셀과 연결된 현재영역 제목행 아래 모두삭제\ncolsCnt = Range(\"B5\").CurrentRegion.\nColumns\n.\nCount\n'B5 연결된 영역의 열 개수를 변수에\nFo..."}
{"instruction": "Excel VBA code for: (1550) 주가 바뀔 때마다 행 삽입하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Row_Every_Week_1()\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor i = Cells(Rows.Count, \"A\").End(3).Row To 3 Step -1\n'마지막 행부터 1행씩 줄여가며 반복\nIf\nWeekday\n(Cells(i - 1, 1)) >= Weekday(Cells(i, 1)) Then\n'윗 행 요일이 아래행보다 크거나 같으면\nCells(i, \"A\").EntireRow.Insert\n'행 삽입\nEnd If\nNext i\nEnd Sub", "context": "이와 같은 코드는 날짜가 연달아 입력되어야 한다는 조건하에 성립한다. 몇 달씩 건너 뛰면서 특정 요일만 입력되면 그 때에는 훨씬더 복잡한 코드를 이용하여 행을 삽입해야 한다.\n매크로 실행 전 (요일이 바뀌는 데이터 미리 표시함)     매크로 실행 후 결과로 행이 삽입됨.\nOption Explicit\nSub insert_Row_Every_Week_1()\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nFor i = Cells(Rows.Count, \"A\").End(3).Row To 3 Step -1\n'마지막 행부터 1행씩 줄여가며 반복\nIf\nWeekday\n(Cells(i - 1, 1)) >= Weekday(Cells(i, 1)) Then\n'윗 행 요일이 아래행보다 크거나 같으면\nCells(i, \"A\").EntireRow.Insert\n'행 삽입\nEnd If\nNext i\nEnd Sub..."}
{"instruction": "Excel VBA code for: (1551) 짝수 번호에만 노란색 채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub paint_Even_Number_In_Yellow_1()\nDim i As Long\n'반복구문에 사용할 변수\nDim lastRow As Long\n'A열 마지막 행을 넣을 변수\nlastRow = Cells(Rows.Count, \"A\").End(3).\nRow\n'마지막 행을 변수에 넣음\nFor i = 1 To lastRow\n'1부터 마지막 행까지 반복\nIf Cells(i, 1) > 0 And Cells(i, 1)\nMod\n2 = 0 Then\n'셀이 0보다 크고 2로 나눈 나머지가 0이면\nDo\n'다음을 실행\nCells(i, 1).Resize(, 3).Interior.ColorIndex = 6\n'셀을 노란색으로 칠함\ni = i + 1\n'행을 1씩 늘려감\nLoop While\nCells(i, 1) = \"\" And i < lastRow\n'빈셀이고 마지막 행 아니면 무한반복\nEnd If\nNext i\nEnd Sub", "context": "대개 이런 코드들은 질문 받았던 내용을 간단히 답변하고 코드 버리기 아까워서 초보님들 참고용으로 올리는 것입니다. 코드에 익숙하지 않았을 때에는 Do ... Loop 구문을 사용하다가 뻑하면 loop에 걸려서 Ctrl + Break 누르곤 하죠. 가끔은 엑셀이 죽기도 하구요. 그럴 수록 더 연습해야 합니다. ^^\n매크로 실행 전                                                 매크로 실행 후 결과\nOption Explicit\nSub paint_Even_Number_In_Yellow_1()\nDim i As Long\n'반복구문에 사용할 변수\nDim lastRow As Long\n'A열 마지막 행을 넣을 변수\nlastRow = Cells(Rows.Count, \"A\").End(3).\nRow\n'마지막 행을 변수에 넣음\nFor i = 1 To lastRow\n'1부터 마지막 행까지 반복\nIf Cells(i, 1) > 0 And Cells(i, 1)\nMod\n2 ..."}
{"instruction": "Excel VBA code for: (1552) 라벨(메일머지) 인쇄 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub sample_Mail_Merge_2()\nDim rngT As Range\n'노란색으로 표시한 데이터 복사될 영역\nDim rngAll As Range\n'Sheet2의 E열 전체 데이터 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp\n'데이터 순서 정할 배열 변수\nDim rngEach As Range\n'데이터 복사영역 각 셀을 순환\nDim i As Long\n'반복구문에 사용할 변수\nDim c As Long\n'열 방향 늘려갈 변수\nDim cnt As Long\n'4회 카운팅할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nSet rngT = Range(\"E7:E8,C10, B11\")\n'데이터가 복사될 영역을 변수에 넣음\nWith Sheets(3)\n'Sheet2 에서\n.UsedRange.Clear\n'기존 데이터 삭제\nSheets(2).UsedRange.Offset(1).\nCopy\n.Cells(1, 1)\n'필터링된 데이터 Sheet3에 복사\nSet rngAll = .Range(.Range(\"E2\"), .Cells(Rows.Count, \"E\").End(3))\nEnd With\n'E열 전체 데이터 영역을 변수에 넣음\nFor Each rngC In rngAll\n'전체 영역 각 셀을 순환\nIf Len(rngC) > 0 Then\n'셀이 비어 있지 않다면\nvarTemp =\nArray\n(-3, -2, 1, 0)\n'배열에 복사될 셀의 순서 넣음\nFor Each rngEach In rngT\n'데이터 복사될 영역 각 셀을 순환\nrngEach = rngC.Offset(, varTemp(i))\n'각 셀에 데이터를 넣음\ni = i + 1\n'배열 위치 1씨 늘려감\nNext rngEach\ni = 0\n'재사용 위하여 초기화\nc = c + 1\n'열 방향 1회 증가\nIf c = 2 Then\n'2회 데이터 옮겼으면\nSet rngT = rngT.Offset(24, -7)\n'아래 왼쪽으로 복사될 위치 변경\nc = 0\n'재사용 위하여 초기화\nElse\n'1회만 데이터 옮겼을 경우\nSet rngT = rngT.Offset(, 7)\n'데이터 복사위치 오른쪽으로 7열 이동\nEnd If\ncnt = cnt + 1\n'카운터 1씩 늘려감\nIf cnt = 4 Then\n'카운터가 4라면(4개 모두 입력되었으면)\nActiveSheet.\nPrintPreview\n'화면 미리보기\n'ActiveSheet.PrintOut\n'실제 인쇄\ncnt = 0\n'카운터 재사용 위하여 초기화\nCall\ndelete_All\n'삭제하는 코드 호출\nSet rngT = rngT.Offset(-48)\n'데이터 복사될 위치 왼쪽위로 이동\nEnd If\nEnd If\nNext rngC\nIf cnt > 0 Then\n'카운터가 0보다 크면\nActiveSheet.PrintPreview\n'화면 미리보기\n'        ActiveSheet.PrintOut\n'마지막 페이지 인쇄\nEnd If\nCall delete_All\n'삭제하는 코드 호출(인쇄 종료 후 데이터삭제)\nSet rngAll = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngT = Nothing\nEnd Sub\n\nSub delete_All()\nDim i As Long\n'반복구문에 사용할 변수\nDim rngAll As Range\n'데이터 복사될 영역을 넣을 변수\nSet rngAll = Range(\"E7:E8,C10, B11, L7:L8, J10, I11\")\n'영역을 변수에 넣음\nrngAll.\nClearContents\n'영역내 데이터 삭제\nSet rngAll = rngAll.Offset(24)\n'아래로 24칸 이동\nrngAll.ClearContents\n'영역내 데이터 삭제\nEnd Sub", "context": "매크로 실행 전 (화면에 4개의 양식이 있지만, 지면의 제한으로 2개만 화면 캡춰함)\n매크로 실행 실행 뒤 한 페이지에 4개씩 인쇄되는 모습\n전체 목록이 들어 있는 시트\n\"인쇄\" 시트는 비어 있는 상태이며, \"데이터\"시트에서 자신이 인쇄하고자 하는 목록만 필터링을 한 상태에서 매크로를 실행하면\n화면에 보이는 필터링된 목록만\n\"인쇄\"시트로 옮겨서 인쇄를 진행한다.\n아래 코드는 화면인쇄를 기본으로 해놓았으며, 주석처리된 ActiveSheet.PrintOut 을 활성화 시키면 프린터에 직접 인쇄된다.\n아래의 코드를 잘 활용하여 본인의 데이터에 적용하여 사용하시기를 바라면서 이만 ....\nOption Explicit\nSub sample_Mail_Merge_2()\nDim rngT As Range\n'노란색으로 표시한 데이터 복사될 영역\nDim rngAll As Range\n'Sheet2의 E열 전체 데이터 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp\n'데..."}
{"instruction": "Excel VBA code for: (1554) 데이터 이동하며 재배치하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub transpose_Data()\nDim rngRow As Range\n'각 행(R)ow 넣을 영역(개체)변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngT As Range\n'복사될 위치 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nRange(\"L1\").CurrentRegion.ClearContents\n'L1과 연결된 기존 데이터 삭제\nSet rngRow = Range(\"D2:I2\")\n'D2:I2 영역을 개체변수에 넣음\nFor i = 2 To Cells(Rows.Count, \"C\").End(3).\nRow\n'1부터 마지막 행까지 반복\nCells(Rows.Count, \"O\").End(3)(2, -2).Resize(, 3) = _\nCells(i, 1).Resize(, 3).Value\n'A:C열을 복사\nFor Each rngC In rngRow.Cells\n'각 행의 셀들을 순환\nIf Not\nIsEmpty\n(rngC) Then\n'빈셀이 아니라면\nSet rngT = Cells(Rows.Count, \"O\").\nEnd(3)(2)\n'종단셀 윗방향 아래셀을 변수에\nrngT = rngC\n'복사위치에 셀 값을 넣음\nrngT.Next = Cells(1, rngC.Column)\n'복사위치 오른쪽에 1행 값을 넣음\nEnd If\nNext rngC\nSet rngRow = rngRow.Offset(1)\n'복사위치 아래로 1행 이동\nNext i\nColumns.AutoFit\n'열너비 자동맞춤\nSet rngRow = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "왼쪽의 데이터를  오른쪽과 같이 재 배치하는 기능.\nOption Explicit\nSub transpose_Data()\nDim rngRow As Range\n'각 행(R)ow 넣을 영역(개체)변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngT As Range\n'복사될 위치 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nRange(\"L1\").CurrentRegion.ClearContents\n'L1과 연결된 기존 데이터 삭제\nSet rngRow = Range(\"D2:I2\")\n'D2:I2 영역을 개체변수에 넣음\nFor i = 2 To Cells(Rows.Count, \"C\").End(3).\nRow\n'1부터 마지막 행까지 반복\nCells(Rows.Count, \"O\").End(3)(2, -2).Resize(, 3) = _\nCells(i, 1).Resize(, 3..."}
{"instruction": "Excel VBA code for: (1556) Activate 와 Select 의 속도비교 (엑셀 VBA 매크로)", "input": "", "output": "Sub sheets_Activate()                       Sub sheets_Select()\nDim i As Long                                   Dim i As Long\nApplication.ScreenUpdating = False    Application.ScreenUpdating = False\nFor i = 1 To 1000                                For i = 1 To 1000\nSheets(1).\nActivate\nSheets(1).\nSelect\nSheets(2).Activate                             Sheets(2).Select\nSheets(3).Activate                             Sheets(3).Select\nNext i                                               Next i\nEnd Sub", "context": "Activate 와 Select의 차이점은 잘 알고 계시리라 믿는다. 혹시 두 기능의 차이점을 모르시는 초보님이시라면\nhttp://blog.naver.com/rosa0189/60150828912\n참조.\nActivate 와 Select는 크게 속도 차이가 없거나, Activate이 Select보다는 빠를 것으로 생각하였다. 그런데, 실제로 확인해보니 셀작업에서는 Select가 Activate보다 5% 내외 정도 더 빨라서 그리 큰 차이가 없었지만, 시트작업에서는 아래와 같이 조금 더 차이가 났다.\n두 코드는 매크로의 속도를 상당히 저하시키므로 제일 마지막에 특정 셀 또는 시트의 최종 선택 시 한 두번 정도 사용하는 것 이외에 연속으로 수백번 또는 수 천번 이상 사용할 일이 아예 없지만, 왜 두 코드의 속도 차이가 나는지는 아직도 모르겠다(아래 류지환님 댓글을 보니 알겠다. Select : 선택만, Activat : 선택 + 활성화). 시간을 두고 생각해 봐야겠다. 하지만, 하나 확실한..."}
{"instruction": "Excel VBA code for: (1557) 엑셀 공부하다 기억해둬야 할 것 메모 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub play_WAV()\nIf Cells(1, 1) > 1 Then\nExecuteExcel4Macro \"SOUND.PLAY(, \"\"C:\\Sample.wav\"\")\"\nEnd If\nEnd Sub", "context": "형 중앙선 택시기사 \"확 치어 죽\"\n김종국, 부동시\n해솔마을 통장 선거(민주주의는 공짜가 없다)\n상가앞 신호등 신호변경(세상을 바꿀 수 있다고 믿는 ...)\n머리 좋고 나쁨의 차이. 엄마가 좋아, 아빠가 좋아. 인생의 수수께끼.\n비즈니스 클래스, 호텔결혼, 와인선물, 콘서트 놀러감 : 개인회생, 파산신청은 모럴해저드. 개인회생 변호사, 금목걸이/모피코트 입고와서 파산신청\n100억 기부한\n실업급여, 재 취직시 10만원이라도 갚아야. 형평성에 어긋남.\n100원이라도 기부하는 사람은 양아치는 아니다.(사람 구분법 1)\n만원 갚으면 만원 더 얹어 돌려줌\n인생은 돈줍기 게임\n윤준배\n결혼을 잘하려면 사소한 것에 주의를 기울여라, 강남 타워팰리스 산책 가족.\n엄마가 좋아 아빠가 좋아? 머리는 타고나는 것이다. 엉뚱한 사람이 머리가 좋은거다.\n문어통 국사만점 컨닝 사건\n잘할 자신은 없어도, 열심히 할 자신은 있다.\n사이시옷\n한자 중국어 발음으로 읽기\n50년의 반격\n내가 택시 사주면 될거 아냐\n변리..."}
{"instruction": "Excel VBA code for: (1558) 각 행의 중복제거 후 오름차순 정렬 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Dupes_In_Row()\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim rngRow As Range\n'각 행을 넣을 영역(개체)변수\nDim i As Long\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 1\n'1행부터 시작\nSet rngRow = Cells(r, 1).Resize(, 12)\n'첫 행을 개체변수에 넣음\nDo\n'다음을 실행\nIf r = 1 Then\n'첫 행이라면\nSet rngRow = rngRow\n'첫 행을 그대로 개체변수에 넣음\nElse\n'2행 부터는\nSet rngRow = rngRow.Offset(1).\nCells(1)\n.Resize(, 12)\nEnd If\n'1행씩 아래로 내려서 개체변수에 넣음\nFor i = 12 To 1 Step -1\n'열 개수인 12회 반복\nIf WorksheetFunction.\nCountIf\n(rngRow, Cells(r, i)) > 1 Then\n'중복이 있을 경우\nCells(r, i).Delete shift:=xlToLeft\n'셀 값을 삭제하고 왼쪽으로 이동\nEnd If\nNext i\nrngRow.\nSort\nrngRow.Cells(1), 1, , , , , , , , ,\nxlSortRows\n'행(좌우) 방향으로 오름차순 정렬\nr = r + 1\n'행을 1씩 늘려감\nIf Cells(r, 1) = \"\" Then Exit Do\n'A열에 빈셀 출현하면 Do 구문종료\nLoop\n'무한 반복\nSet rngRow = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "보통 중복제거를 열방향으로 진행하며, 정렬 또한 위아래 방향이다. 아래의 코드는 각 행에 중복 값이 있을 경우 이를 삭제하고 왼쪽으로 밀어서 데이터를 모은 후 행, 즉 좌우 방향으로 오름차순 정렬한다.\n매크로 실행 전\n매크로 실행 후 중복이 제거되고 좌에서 우로 오름차순 정렬된 결과\nOption Explicit\nSub remove_Dupes_In_Row()\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim rngRow As Range\n'각 행을 넣을 영역(개체)변수\nDim i As Long\n'열 개수만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 1\n'1행부터 시작\nSet rngRow = Cells(r, 1).Resize(, 12)\n'첫 행을 개체변수에 넣음\nDo\n'다음을 실행\nIf r = 1 Then\n'첫 행이라면\nSet rngRow = rngRow\n'첫 행을 그대로 개체변수에 넣음\nElse\n'2행 부터는..."}
{"instruction": "Excel VBA code for: (1559) 중복 제거 후 재배치 (엑셀 VBA 매크로)", "input": "", "output": "Sub no_Dupes_And_Join()\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim i As Long\n'중복행 개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.Copy\n'현재시트 복사본 생성\nWith Columns(\"A:B\")\n'A:B열에서\n.\nSort\nkey1:=[A1], key2:=[B1], order1:=1\n'A열 B열 오름차순 정렬\n.RemoveDuplicates\nArray\n(1, 2)\n'중복 제거\nEnd With\nr = 1\n'1행 부터 시작\nDo\n'다음을 실행\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nCells(Rows.Count, \"D\").End(3)(2) = Cells(r, 1)\n'D열에 A열 값 입력\nCells(Rows.Count, \"E\").End(3)(2).Resize(, i + 1) = _\nWorksheetFunction.\nTranspose\n(Cells(r, 2).Offset(-i).Resize(i + 1))\n'E열 종단셀 윗방향 아래셀에 행열 변환하여 중복되는 값들을 복사하여 넣음\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nColumns.AutoFit\n'열너비 자동 맞춤\nEnd Sub", "context": "매크로 실행 전 데이터                          매크로 실행 후 새로운 창의 결과\nOption Explicit\nSub no_Dupes_And_Join()\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim i As Long\n'중복행 개수 구할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.Copy\n'현재시트 복사본 생성\nWith Columns(\"A:B\")\n'A:B열에서\n.\nSort\nkey1:=[A1], key2:=[B1], order1:=1\n'A열 B열 오름차순 정렬\n.RemoveDuplicates\nArray\n(1, 2)\n'중복 제거\nEnd With\nr = 1\n'1행 부터 시작\nDo\n'다음을 실행\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nC..."}
{"instruction": "Excel VBA code for: (1560) 특정 영역에 순차적으로 값 채우기 연습 20 (엑셀 VBA 매크로)", "input": "", "output": "Sub range_Fill_28()\nDim rngA As Range\n'9개 셀 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'반복구문에 사용할 변수\nDim cnt As Long\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nSet\nrngA =\nRange\n(\"A1, C3, A3, C1, B1, A2:C2, B3\")\n'값이 입력될 범위 순서대로 변수에 넣음\nFor r = 1 To 100\n'100회 반복\nFor\nEach\nrngC\nIn\nrngA\n'9개셀 영역의 각 셀을 순환\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nrngC = cnt\n'각 셀에 카운터 값을 입력함\nNext\nrngC\nSet rngA = rngA.Offset(4)\n'9개 영역을 아래로 4행 이동\nNext r\nSet rngA = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "셀에 값을 순차적으로 채우는 것을 많이 해보아서 앞으로는 별로 할 것이 없을 것 같다. 아래 코드의 작동 원리를 알면 자신이 원하는 위치에 원하는 값을 순차적으로 넣을 수 있을 것이라 생각된다.\n매크로 실행 전\n위의 그림처럼 값이 입력되는 것을 보면 조금 복잡해 보이지만, Set rngA = Range(\"A1, C3, A3, C1, B1, A2:C2, B3\") 코드에 입력된 순서대로 값이 채워지는 원리를 알고 For Each .. In ... 구문의 원리를 알면 전혀 복잡하지 않다.\nOption Explicit\nSub range_Fill_28()\nDim rngA As Range\n'9개 셀 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'반복구문에 사용할 변수\nDim cnt As Long\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nSet\nrngA =\nRange\n(\"A1, C3, A3, C..."}
{"instruction": "Excel VBA code for: (1561) 데이터 이동하며 재배치하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub mixed_Data_Relocation_1()\nDim rngA As Range\n'윗행 반복영역을 넣을 변수\nDim rngB As Range\n'아래행 반복영역을 넣을 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\n.Cells(1, 1).Resize(, 5) = _\nArray\n(\"과목대분류\", \"과목\", \"일정\", \"강사\", \"수업료\")\n'제목행 입력\nSet rngA = Range(\"A1, B2, A2, C2:D2\")\n'윗행 반복영역을 변수에 넣음\nSet rngB = Range(\"A1, B3, A3, C3:D3\")\n'아래행 반복영역을 변수에 넣음\nDo\n'다음을 실행\nmove_Data rngA\n'(윗행)데이터를 옮기는 하위코드 호출\nmove_Data rngB\n'(아래행)\n데이터를 옮기는 하위코드 호출\nSet rngA = rngA.Offset(3)\n'윗행 반복영역을 아래로 3행 이동\nSet rngB = rngA.Offset(3)\n'아래행 반복영역을 아래로 3행 이동\nr = r + 3\n'행을 3씩 늘려감\nLoop Until\nLen(Cells(r, 1)) = 0\n'A열에 빈셀 나올때까지 무한 반복\n.Columns(\"C\").\nNumberFormat\n= _\n\"yyyy\"\"-\"\"mm\"\"-\"\"dd hh:mm:ss;@\"\n'C열의 서식을 년월일/시간분초로 설정\n.Columns(\"E\").NumberFormat = \"#,###\"\n'E열의 서식을 천단위 콤마로 설정\n.Columns.AutoFit\n'열너비 자동 맞춤\nEnd With\nSet rngA = Nothing\nSet rngB = Nothing\nMsgBox \"매크로 종료.  Sheet2 확안하세요.\"\n'매크로 종료 메시지 출력\nEnd Sub\n\nSub move_Data(ByVal rngR As Range)\n'영역을 받아서 데이터 옮기는 코드\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'1부터 5까지 숫자 늘려갈 변수\nFor Each rngC In rngR\n'반복영역의 각 셀을 순환\ni = i + 1\n'숫자를 1씩 늘려감\nSheets(2).Cells(Rows.Count, i).End(3)(2) = rngC\n'종단셀 윗방향 아래에 셀값 입력\nNext rngC\nEnd Sub", "context": "매크로 실행 전 Sheet1 의 데이터\n매크로 실행 후 Sheet2 로 데이터가 이동되며 재 배치된 결과\nOption Explicit\nSub mixed_Data_Relocation_1()\nDim rngA As Range\n'윗행 반복영역을 넣을 변수\nDim rngB As Range\n'아래행 반복영역을 넣을 변수\nDim r As Long\n'행 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\n.Cells(1, 1).Resize(, 5) = _\nArray\n(\"과목대분류\", \"과목\", \"일정\", \"강사\", \"수업료\")\n'제목행 입력\nSet rngA = Range(\"A1, B2, A2, C2:D2\")\n'윗행 반복영역을 변수에 넣음\nSet rngB = Range(\"A1, B3, A3, C3:D3\")\n'아래행 반복영역을 변수에 넣음\nD..."}
{"instruction": "Excel VBA code for: (1562) 데이터 이동하며 재배치하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub mixed_Data_Relocation_2()\nDim rngA As Range\n'각 (A)rea 넣을 변수\nDim lastRow As Long\n'마지막행을 넣을 변수\nDim colsCnt As Long\n'전체 열개수를 넣을 변수\nDim varTemp\n'추출한 값을 넣을 배열로 사용할 변수\nDim r As Long\n'행 개수 만큼 반복할 변수\nDim v As Long\n'배열 행방향(1차원) 늘려갈 변수\nDim x As Long\n'열 개수 만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nActiveSheet.Copy\n'현재시트 새로운 파일에 복사\nActiveSheet.Shapes(1).Delete\n'매크로 버튼 삭제\nColumns(\"A\").Insert\n'A열에 빈 열 삽입\nFor Each rngA In Columns(\"C\").SpecialCells(2).\nAreas\n'C열 문자 입력된 영역을 순환\nrngA.Offset(, -2) = rngA.Offset(-1, -1).Cells(1).Value\nNext rngA\n'각 과목을 복사\nColumns(\"C\").\nCut\n'B열 잘라내어\nColumns(\"B\").\nInsert Shift\n:=xlToRight\n'A열에 붙여 넣음\nlastRow = Cells(Rows.Count, \"A\").End(3).\nRow\n'마지막 행을 변수에\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열 개수를 변수에\nReDim varTemp(1 To lastRow, 1 To colsCnt)\n'배열크기 재지정\nFor r = 1 To lastRow\n'1부터 마지막 행까지 반복\nIf\nNot\nIsEmpty\n(Cells(r, 1)) Then\n'빈 셀이 아니라면\nv = v + 1\n'배열크기 1씩 늘려감\nFor x = 1 To colsCnt\n'1부터 열 개수까지 반복\nvarTemp(v, x) = Cells(r, x)\n'배열에 값을 넣음\nNext x\nEnd If\nNext r\nActiveSheet.UsedRange.Clear\n'현재시트 사용영역 삭제\nCells(1, 1).Resize(UBound(varTemp, 1), colsCnt) = varTemp\n'배열내 값을 시트에 뿌림\nColumns(\"C\").NumberFormat = _\n\"yyyy\"\"-\"\"mm\"\"-\"\"dd hh:mm:ss;@\"\n'C열의 서식을 년월일/시간분초로 설정\nColumns(\"E\").NumberFormat = \"#,###\"\n'E열의 서식을 천단위 콤마로 설정\nColumns.AutoFit\n'열너비 자동 맞춤\nEnd Sub", "context": "이 코드를 요청하신 분이 행이나 열의 제한으로 불만이 조금 있으신 것 같아서 이런 종류의 작업은 여러가지 방법을 이용하여 가능하다. 아래는 초보님들이 두려워하시는 배열을 이용하였다.\n매크로 실행 전 Sheet1 의 데이터\n매크로 실행 후 새로운 창이 열리고 데이터가 이동되며 재 배치된 결과\nOption Explicit\nSub mixed_Data_Relocation_2()\nDim rngA As Range\n'각 (A)rea 넣을 변수\nDim lastRow As Long\n'마지막행을 넣을 변수\nDim colsCnt As Long\n'전체 열개수를 넣을 변수\nDim varTemp\n'추출한 값을 넣을 배열로 사용할 변수\nDim r As Long\n'행 개수 만큼 반복할 변수\nDim v As Long\n'배열 행방향(1차원) 늘려갈 변수\nDim x As Long\n'열 개수 만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nActiveShee..."}
{"instruction": "Excel VBA code for: (1563) 일치하는 데이터 다른 시트로 이동 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Move_And_Inform()\nDim rngAll As Range\n'D열 전체 데이터를 넣을 변수\nDim varTemp\n'추출한 값을 넣을 배열변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim cnt As Long\n'옮기 데이터 개수 넣을 카운터\nDim x As Long\n'열 방향 반복할 변수\nDim v As Long\n'배열 행방향(1차원) 크기 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nWith Sheets(1)\n'Sheet1에셔\n.\nUnprotect\n\"qqq111\"\n'비번과 함께 Sheet1 잠금 해제\nSet rngAll = .Range(\"D7\", .Cells(Rows.Count, \"D\").End(3))\n'D열 전체 데이터를 변수에\nReDim\nvarTemp(1 To rngAll.Rows.Count, 1 To 11)\n'배열크기 재지정\nFor Each rngC In rngAll\n'D열 각 셀을 순환\nIf rngC = Range(\"B2\") Then\n'셀 값이 B2와 일치하면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nWith Sheets(3)\n'Sheet3 에서\n.Cells(.Rows.Count, \"C\").End(3)(2).Resize(, 11) = _\nrngC.Offset(, -2).Resize(, 11).Value\nEnd With\n'종단셀 윗방향 아래셀에 전체행을 복사\nElse\n'셀 값이 B2와 일치하지 않으면\nv = v + 1\n'배열크기 1씩 늘려감\nFor x = 1 To 11\n'1부터 11가지 1씩 늘려가며 반복\nvarTemp(v, x) = .Cells(rngC.Row, x + 1)\n'배열에 값을 넣음\nNext x\nEnd If\nNext rngC\nIf cnt > 0 Then\n'카운터가 1보다 크면\nMsgBox\n\"총 \" & cnt & \"개의 데이터가 옮겨졌습니다.\"\n'메시지 창 출력\n.Range(\"B6\", .Cells(Rows.Count, \"L\")).End(3).ClearContents\n'기존데이터 삭제\n.Cells(7, 2).Resize(rngAll.Rows.Count, 11) = varTemp\n'추출한 배열내 데이터 시트에 뿌림\nElse\n'카운터가 0이라면\nMsgBox \"일치하는 데이터가 없습니다.\"\n'메시지창 출력\nEnd If\n.\nProtect\n\"qqq111\"\n'비번과 함께 시트 잠금\nEnd With\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "Sheet1 은 비번과 함께 시트잠금된 상태. 데이터는 B:L 열에 입력되어 있으며, A열 및 K열 이후로도 데이터가 입력된 상황.\n\"데이터\"시트의 D열에 있는 모델명과 \"출력\"시트의 G3 셀이 일치할 경우, \"데이터\" 시트내의 일치한 데이터를 삭제하고 \"데이터나열시트\"로 이동\n일치하는 데이터 있을 경우 데이터 개수를 메시지창으로 출력. 일치 데이터 없는 경우 없다고 메시지창으로 출력.\n매크로 실행 전 데이터가 입력된 \"데이터\" 시트\n매크로를 실행 시키는 \"출력\" 시트\n매크로 실행 전 \"데이터나열시트\". 일치하는 데이터가 이 시트로 옮겨짐\n매크로 실행 후 일치하는 데이터 있을 경우 나타나는 창\n매크로 실행 후 결과\nOption Explicit\nSub find_Move_And_Inform()\nDim rngAll As Range\n'D열 전체 데이터를 넣을 변수\nDim varTemp\n'추출한 값을 넣을 배열변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim cnt As Lo..."}
{"instruction": "Excel VBA code for: (1565) 폴더내 모든파일 특정시트 마지막 행만 가져오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_All_Sheets_In_Folder_8()\nDim strSht As String\n'시트 이름을 넣을 변수\nDim colsCnt As Long\n'가져올 열 개수 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim r As Long\n'행을 1씩 늘려갈 변수\nDim rngData As Range\n'데이터 영역을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Offset(1).ClearContents\n'기존 데이터 삭제\n'----------------------------------------------------------\n' 본인 시트명으로 수정사용. 시트명 틀리면 엑셀 에러창 뜸\n'----------------------------------------------------------\nstrSht = \"\nSheet1\n\"\n'데이터가 저장된 시트의 이름\ncolsCnt =\n5\n'가져올 열의 개수\n'--------------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'--------------------------------------------------\nWith Application.FileDialog(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더를 선택한 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'-------------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'-------------------------------------\nfileName = Dir(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nr = 1\n'1행부터 시작\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nr = r + 1\n'행을 1씩 늘려감\n'----------------------------------------------------------------------\n' 수식을 이용하여 각 파일의 마지막행 찾고 배열함수로 값을 가져오는 코드\n'----------------------------------------------------------------------\nCells(r, 1).Formula = \"=\nCOUNTA\n('\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & \"$A:$A)\"\n'A열의 데이터 개수를 찾아 셀에 입력\nSet\nrngData = Range(Cells(Cells(r, 1), 1), Cells(Cells(r, 1), colsCnt))\n'각 파일의 마지막 데이터가 입력된 영역\nWith Cells(r, 1).Resize(, 5)\n.\nFormulaArray\n= \"='\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & rngData.Address(1, 1, 1)\n'데이터 영역을 배열로 가져옴\n.\nValue\n= .\nValue\n'셀의 수식을 값으로 바꿈\nEnd With\nCells(r, 1).Offset(, colsCnt) = fileName\n'파일 이름을 마지막 열에 넣음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nActiveSheet.UsedRange.Sort [A2], 1, Header:=xlYes\n'오름차순 정렬\nSet rngData = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "1. 데이터 폴더내에 여러 엑셀파일이 있음\n2. 각 엑셀 파일에는 데이터의 행 개수가 다르며, 마지막 행 데이터만 현재시트로 가져오는 기능.\n3. 제일 오른쪽 열에는 각 파일의 이름을 입력.\n폴더내 데이터 파일 Book1.xlsx                            폴더내 데이터 파일 Book2.xlsx\n매크로 실행 전                                                 실행 후 결과 (\n동영상 만든 후 시트이름 기능 추가\n)\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1565) 폴더내 모든파일 특정시트 마지막 행만 가져오기 (엑셀 VBA 매크로)\n재생\n1,167\n재생 (space/k)\n재생\n00:31\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:31\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표..."}
{"instruction": "Excel VBA code for: (1569) 년도별로 유량데이터 내림차순 정리하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub relocate_Data_2()\nDim r As Long\n'행 늘려갈 변수\nConst\nrowsCnt As Long = 31\n'행 개수 넣을 변수\nConst colsCnt As Long = 12\n'열 개수 넣을 변수\nConst totalRow As Long = 365\n'전체 행 개수 넣을 변수\nDim rngT As Range\n'데이터가 복사될 위치\nApplication.ScreenUpdating = False\n'화면 업데이트 정지\nSheets(3).UsedRange.Offset(, 1).\nClear\n'기존 데이터 삭제\nWith Sheets(2)\n'Sheet2 에서\nr = 5\n'5행부터 시작\nDo\n'다음을 실행\nIf Len(.Cells(r, 3)) Then\n'빈셀이 아니라면\nRange(\"A2\").Resize(rowsCnt, colsCnt).\nValue\n= _\n.Cells(r, 3).Offset(5, -1).Resize(rowsCnt, colsCnt).\nValue\n'A2:L32셀에 데이터 값으로 복사\n'기존 \"유량\"시트의 raw data가 서식이 currency로 되어 있어 값으로 복사함\nCall\nmove_And_Sort\n'데이터 정리하는 하위코드 호출\nSet rngT = Sheets(3).Cells(1, Columns.Count).End(1)(1, 2)\n'종단셀 왼쪽방향 오른쪽 셀을 변수에\nrngT =\nSplit\n(.Cells(r, 3), \"년\")(0)\n'1행에 \"년\" 제외한 년도 입력\nrngT.Offset(1).Resize(totalRow) = _\nRange(\"N2\").Resize(totalRow).Value\n'데이터를 복사\nEnd If\nr = r + 53\n'53행씩 늘려감\nLoop Until Len(.Cells(r, 3)) = 0\n'빈셀 나올때까지 무한 반복\nEnd With\nWith Sheets(3)\n'Sheet3에서\nSet rngT = .Cells(1, Columns.Count).\nEnd(1)(1, 2)\n'각 데이터가 복사될 위치\nrngT = \"평균\"\n'열제목에 \"평균\"이라고  입력\nrngT.Offset(1).Resize(totalRow).\nFormulaR1C1\n= _\n\"=AVERAGE(RC[\" & -(.UsedRange.Columns.Count) + 2 & \"]:RC[-1])\"\n'마지막 열에 평균을 넣는 수식\n.UsedRange.Columns(rngT.Column).\nNumberFormat\n= \"#.00\"\n'서식을 소숫점 2자리로 설정\nActiveSheet.UsedRange.Offset(1).ClearContents\n'임시로 복사한 데이터 삭제\n.Activate\n'Sheet3 활성화\n.Columns.AutoFit\n'열너비 자동 맞춤\nEnd With\nSet rngT = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\n'매크로 종료 메시지창 출력\nEnd Sub\n\nSub move_And_Sort()\nDim i As Long\n'반복구문에 사용할 변수\nDim rngCol As Range\n'열(Col)umn 넣을 영역(개체)변수\nDim rowsCnt As Long\n'행(rows) 개수(C)ou(nt) 넣을 변수\nDim rngT As Range\n'복사될 위치(T)arget 넣을 변수\nColumns(\"N\").ClearContents\n'N열의 임시데이터 삭제\nFor i = 1 To 12\n'12번  반복\nSet rngCol = Range(Cells(2, i), Cells(Rows.Count, i).End(3))\n'각 열의 데이터를 변수에 넣음\nrowsCnt = rngCol.Rows.Count\n'각 열의 데이터의 행 개수를 변수에\nSet rngT = Cells(Rows.Count, \"N\").End(3)(2)\n'N열에 데이터가 복사될 위치\nrngT.Resize(rowsCnt) = rngCol.Value\n'O열에 값 입력\nNext i\nSet rngCol = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngT = Nothing\n[\nN2:N366\n]\n.\nSort\n[N2], 2\n'내림차순 정렬\nEnd Sub", "context": "복수의 열로 입력된 각 년도별 유량 데이터를 1개의 열로 바꾼 뒤 내림차순으로 정렬하고 이를 년도별로 정리하고 제일 오른쪽 행에 년도별 평균값을 추출하는 기능.\n데이터를 임시로 넣어서 데이터 정리할 Sheet1 시트\n데이터가 입력된 \"유량\" 시트. 아래로 년도별 데이터가 계속 있음\n매크로 실행 전 \"비유량(유황)\" 시트\n매크로 실행 후 \"비유량(유황)\" 시트의 데이터 정리 결과\nOption Explicit\nSub relocate_Data_2()\nDim r As Long\n'행 늘려갈 변수\nConst\nrowsCnt As Long = 31\n'행 개수 넣을 변수\nConst colsCnt As Long = 12\n'열 개수 넣을 변수\nConst totalRow As Long = 365\n'전체 행 개수 넣을 변수\nDim rngT As Range\n'데이터가 복사될 위치\nApplication.ScreenUpdating = False\n'화면 업데이트 정지\nSheets(3).UsedRange.Offse..."}
{"instruction": "Excel VBA code for: (1570) 셀병합된 데이터 정렬하기 8 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_Irregulary_Merged_Cells_2()\nDim intCol As Integer\n'정렬할 열을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'행 방향 반복할 변수\nDim c As Integer\n'열 방향 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트(일시) 중지\nintCol = 3\n'(선택영역의) 3열 기준 정렬\nWith Selection\n'선택영역에서\nIf .Cells.Count = 1 Or\nWorksheetFunction.CountA\n(.Cells) < 2 _\nOr\n.Columns.Count\n< intCol Then\n'한 셀 선택, 데이터가 2개 이하 또는 intCol보다 선택영역 열개수가 작으면\nMsgBox \"데이터 영역 설정 오류로 중단합니다.\", 64, \"영역설정 오류\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nEnd With\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.\nClear\n'기존 데이터 삭제\nSelection.\nCopy\n.Cells(1, 1)\n'선택영역을 Sheet2에 복사\n.Activate\n'활성화\nEnd With\nCall\nunMerge_and_Fill\n'셀병합 해제 후 복사하는 하위 코드 실행\nWith ActiveSheet.UsedRange\n.\nSort\nCells(1, intCol), 1, Header:=xlYes\n'C열기준 오름차순 정렬\nApplication.\nDisplayAlerts\n=\nFalse\n'화면경고 중단\nFor r = .Rows.Count To 2 Step -1\n'전체행에서 1씩 빼며 2행 까지 반복\nIf Cells(r, intCol) = Cells(r - 1, intCol) Then\n'C열 위아래 셀이 같은 값이면\n﻿\nFor c = 1 To .Columns.Count\n'1씩 증가하며 전체열 개수까지 반복\nIf c = 1\nOr\nc = 3 Or c = 4 Or c = 9 Or c = 10 Or c = 11 Then\n'A, C, D, I, J, K 열일 경우﻿\n﻿\nCells(r - 1, c).Resize(2).\nMerge\n'셀병합\n﻿\nEnd If\n﻿\nNext c\nEnd If\nNext r\nApplication.DisplayAlerts = True\n'화면경고 복원\n.Borders.\nLineStyle\n= 1\n'테두리 그리기\nEnd With\nColumns.AutoFit\n'열너비 자동맞춤\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub\n\nSub unMerge_and_Fill()\nDim rngC As Range\n'선택영역 각 셀을 넣을 변수\nDim r As Long\n'카운터로 사용할 변수\nFor Each rngC In ActiveSheet.UsedRange\n'데이터 영역 각 셀을 순화\nIf rngC.MergeCells Then\n'만일 선택셀이 셀병합 되어 있다면\nWith rngC.\nMergeArea\n'셀병합된 area를\n.\nUnMerge\n'셀병합을 풀고\n.Value = rngC\n'셀병합 풀린영역 셀병합전 값으로 채움\nEnd With\nEnd If\nNext\nEnd Sub", "context": "셀병합이 적용된 C열을 기준으로 오름차순 정렬하기는 기능. 이를 위해,\n셀병합이 적용된 셀들의 셀병합을 해제한 후 데이터를 복사하고,\nC열 기준으로 오름차순 정렬을 적용한 다음,\nC열 기준으로 다시 셀병합. 단, A, C, D, I, J, K 열은 원래대로 셀병합을 하되, B, E, F, G, H 열은 분리된 셀모양을 원래대로 유지.\n마지막으로 테두리를 그려주는 작업을 수행.\n매크로 실행 전 Sheet1 (\n제목 포함\n한 A1:K10 영역을 먼저 선택\n하고 매크로 실행)\n매크로 실행 후 Sheet2 의 결과 (C열을 기준으로 오름차순 정렬됨)\nOption Explicit\nSub sort_Irregulary_Merged_Cells_2()\nDim intCol As Integer\n'정렬할 열을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim r As Long\n'행 방향 반복할 변수\nDim c As Integer\n'열 방향 반복할 변수\nApplication.Scree..."}
{"instruction": "Excel VBA code for: (1571) 텍스트파일 특정문자 포함행부터 3행 가져오기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub import_Textfiles_From_Certain_Row_2()\nDim strName1 As String\n'검색할 단어를 넣을 변수\nDim strName2 As String\n'검색할 단어를 넣을 변수\nDim lngNo As Long\n'전체 가져올 행을 넣을 변수\nDim fileNames As Variant\n'모든 파일 넣을 배열 변수\nDim i As Long\n'반복 구문에 사용할 변수\nDim strInput As String\n'각 행의 불러온 문자 넣을 변수\nDim varTemp As Variant\n'각 행을 tab으로 쪼개어 넣을 배열 변수\nDim r As Long\n'행(r)ow을 1씩 늘려갈 변수\nDim cnt As Long\n'행 개수 카운터로 사용할 변수\nDim cntAll As Long\n'3행 + 3 행 총 6행 카운터로 사용할 변수﻿\nDim c As Long\n'열(c)olumn을 1씩 늘려갈 변수\nDim blnTF As Boolean\n'시작행 판단한 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.ClearContents\n'기존 데이터 삭제\nstrName1 = \"\nfound\n\"\n'검색할 단어를 변수에 넣음\nstrName2 = \"\nABC\n\"\n'검색할 단어를 변수에 넣음\nlngNo = 3\n'검색 일치한 행부터 가져올 행개수\nfileNames = Application.GetOpenFilename(\"텍스트파일,*.txt;*.csv;*.prn\", _\nTitle:=\"텍스트 파일을 선택\", MultiSelect:=True)\n'파일을\n열어서 파일명을 변수에 넣음\nIf TypeName(fileNames) = \"Boolean\" Then Exit Sub\n'취소 선택 시 매크로 종료\nFor i = 1 To UBound(fileNames)\n'선택한 파일 개수만큼 반복\nOpen\nfileNames(i) For\nInput\nAs #1\n'각 파일을 열기\nLine Input\n#1, strInput\n'각 행을 불러와 strInput에 넣음\nDo Until EOF(1)\n'파일의 마지막까지 실행\nIf InStr(strInput, strName1) Or InStr(strInput, strName2) Then\n'행에 strName1 또는 strName2 포함되어 있으면\nblnTF = True\n'blnTF 를 참으로 바꿈\nEnd If\nIf blnTF = True Then\n'blnTF가 참인 경우에\nvarTemp = Split(strInput,\nvbTab\n)\n'불러온 행을 tab으로 나누어 배열에 넣음\nr = r + 1\n'행을 1씩 늘려감\ncnt = cnt + 1\n'카운터 1씩 늘려감\nFor c =\nLBound\n(varTemp) To\nUBound\n(varTemp)  '배열 개수만큼 반복\nCells(r, c + 1) = varTemp(c)\n'배열값을 셀에 뿌림\nNext c\nEnd If\nIf cnt = lngNo Then\n'카운터가 3이라면\ncnt = 0\n'카운터를 초기화\nblnTF = False\n'blnTF를 초기화\ncntAll = cntAll + 1\n'총 카운터를 늘려감\nIf cntAll = 2 Then\nExit Do\n'총 카운터가 2이면 Do 구문 종료\nEnd If\nLine Input #1, strInput\n'다음 행을 불러옴\nLoop\n'무한 반복\nClose\n#1\n'열은 파일 닫기\nNext i\nEnd Sub", "context": "Tab으로 구분된 텍스트 파일내의 \"found\" 라는 문자가 포함된 또는 \"ABC\" 라는 문자가 포함된 행으로 부터 3행을 가져오는 기능.\n매크로 실행 전\nsample1.txt 파일\nsample2.txt 파일\nsample3.txt 파일\n매크로 실행 후 파일창이 나타나고 위에 있는 3개의 텍스트파일을 선택한 결과\nOption Explicit\nSub import_Textfiles_From_Certain_Row_2()\nDim strName1 As String\n'검색할 단어를 넣을 변수\nDim strName2 As String\n'검색할 단어를 넣을 변수\nDim lngNo As Long\n'전체 가져올 행을 넣을 변수\nDim fileNames As Variant\n'모든 파일 넣을 배열 변수\nDim i As Long\n'반복 구문에 사용할 변수\nDim strInput As String\n'각 행의 불러온 문자 넣을 변수\nDim varTemp As Variant\n'각 행을 tab으로 쪼개어 넣을 배열..."}
{"instruction": "Excel VBA code for: (1574) 600명을 무작위로 15 ~ 25명씩 30개 반으로 나누기 (엑셀 VBA 매크로)", "input": "", "output": "Sub split_Class_Randomly()\nDim lngCnt As Long\n'전체 이름의 총합을 넣을 변수\nDim varTemp\n()\nAs\nString\n'모든 이름을 넣을 배열변수\nDim vC\n'각 셀을 넣을 배열변수\nDim r As Long\n'반복구문에 사용할 변수\nDim varR() As String\n'전체 뒤섞은 이름을 넣을 배열변수\nDim k As Long\n'무작위로 추출한 숫자 넣을 변수\nDim lngRandom As Long\n'15 ~ 25 사이 숫자 무작위로 넣을 변수\nDim v As Long\n'전체 이름 개수만큼 반복에 사용할 변수\nDim varRnd() As String\n'15 ~ 25개 섞은 이름 넣을 변수\nDim x As Long\n'전체 이름 개수만큼 반복에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nRandomize\n'랜덤 초기화\nDo\nSheets(2).Cells.ClearContents\n'Sheet2의 기존 데이터 삭제\nWith [A1].CurrentRegion\n'A1 셀의 인접셀 영역에서\nlngCnt = .Cells.Count\n'전체 셀 개수를 변수에 넣음\nReDim varTemp(1 To lngCnt)\n'배열크기  전체 이름 개수로 재지정\n'----------------------------------\n'varTemp에 모든 이름을 다 넣음\n'----------------------------------\nFor Each vC In .\nCells\n'영역내 각 셀을 순환\nr = r + 1\n'배열위치 1씩 늘려감\nvarTemp(r) = vC\n'배열에 이름을 넣음\nNext vC\nReDim varR(1 To lngCnt)\n'배열크기 전체 이름 개수로 재지정\n'-----------------------------------------\n'varTemp를 무작위로 섞어 varR에 넣음\n'-----------------------------------------\nFor r = lngCnt To 1\nStep -1\n'전체 이름개수에서 1씩빼며 반복\nk = Int(\nRnd\n* r) + 1\n'무작위 값을 추출\nvarR(r) = varTemp(k)\n'varTemp의 값을 무작위로 varR에 넣음\nvarTemp(k) = varTemp(r)\n'varTemp의 추출한 값에 제일 큰 값을 채워 넣음\nNext r\nFor r = 1 To lngCnt\n'전체 이름 개수만큼 반복\nReDim varRnd(1 To 25)\n'배열크기 재지정\nlngRandom = 15 + Int(Rnd * 10) + 1\n'15 ~ 25 사이의 숫자를 무작위로 추출\n'----------------------------------------------------\n'varR내 이름을 15 ~ 25개씩 varRnd에 넣고 셀에 뿌림\n'----------------------------------------------------\nFor v = 1 To lngRandom\n'15 ~ 25 개수만큼 반복\nx = x + 1\n'배열 위치 1씩 늘려감\nvarRnd(v) = varR(x)\n'varR 값을 varRnd에 순차적으로 넣음\nIf x = lngCnt Then\n'전체 이름개수에 도달하면\nWith Sheets(2)\n.Cells(1, Columns.Count).End(1)(1, 2).Resize(25) = _\nApplication.\nTranspose\n(varRnd)\n'varRnd 내의 값을 행열변환하여 시트에 뿌림\n.Columns(1).Delete\n'1열 삭제\nIf .UsedRange.Columns.Count = 30 Then\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\n.Activate\n'활성화\nExit Sub\n'Sheet2의 열(반) 개수가 30이면 매크로 종료\nElse\n'열(반) 개수가 30이 아니라면\nGoTo\nrepeat_Code\n'코드를 처음부터 반복\nEnd If\nEnd With\nEnd If\nNext v\nSheets(2).Cells(1, Columns.Count).End(1)(1, 2).Resize(25) = _\nApplication.Transpose(varRnd)\n'varRnd 내의 값을 행열변환하여 시트에 뿌림\nNext r\nEnd With\nrepeat_Code:\nr = 0\n'재사용 위하여 초기화\nx = 0\n'재사용 위하여 초기화\nLoop\nEnd Sub", "context": "매크로 실행 전 Sheet1 A1:J600 영역에 600명의 이름이 입력된 상황\n매크로 실행 후 Sheet 2의 결과\nOption Explicit\nSub split_Class_Randomly()\nDim lngCnt As Long\n'전체 이름의 총합을 넣을 변수\nDim varTemp\n()\nAs\nString\n'모든 이름을 넣을 배열변수\nDim vC\n'각 셀을 넣을 배열변수\nDim r As Long\n'반복구문에 사용할 변수\nDim varR() As String\n'전체 뒤섞은 이름을 넣을 배열변수\nDim k As Long\n'무작위로 추출한 숫자 넣을 변수\nDim lngRandom As Long\n'15 ~ 25 사이 숫자 무작위로 넣을 변수\nDim v As Long\n'전체 이름 개수만큼 반복에 사용할 변수\nDim varRnd() As String\n'15 ~ 25개 섞은 이름 넣을 변수\nDim x As Long\n'전체 이름 개수만큼 반복에 사용할 변수\nApplication.ScreenUpdat..."}
{"instruction": "Excel VBA code for: (1575) 각 월의 마지막 날짜, 수량 추출 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub max_Of_Each_Month_1()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 월 중복개수 구할 변수\nDim rngA As Range\n'중복 영역을 넣을 영역변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nActiveSheet.Copy\n'(원본 보호 위해) 현재시트 복사\n﻿\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nIf\nMonth\n(Cells(r, 1)) = Month(Cells(r + 1, 1)) Then\n'월(月)이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nSet rngA = Cells(r, 1).Offset(-i).Resize(i + 1, 1)\n'동일한 月 데이터 영역을 변수에 넣음\nrngA.Resize(, 2).\nSort\nrngA.Cells(1), 2\n'동일한 月을 내림차순 정렬\nFor Each rngC In rngA\n'동일한 月 영역의 각 셀을 순환\nIf Not\nIsEmpty\n(rngC.Offset(, 1)) Then\n'빈셀 아니라면\nWith Cells(1, Columns.Count)\n'1행 종단셀 왼쪽방향\n.End(1)(1, 2) = Month(Cells(r, 1)) & \"월\"\n'오른쪽셀에 월 입력\n.End(1)(2) =\nFormatDateTime\n(rngC,\nvbShortDate\n)\n'아래셀에 날짜 입력\n.End(1)(3) = rngC.Next\n'2행 아래에 수량 입력\nEnd With\nExit For\n'For 구문 종료\nEnd If\nNext rngC\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nColumns.AutoFit\n'열너비 자동 맞춤\nSet rngA = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. 각 月의 마지막 날짜 및 수량을 추출\n2. 마지막 날짜의 수량이 0 일 경우에는 그 앞의 날짜 및 수량을 추출\n매크로 실행 전 Sheet1 에 데이터가 입력된 모습 (알아보기 쉽도록 미리 색칠해둠)\n매크로 실행 후 복사된 시트에 추출된 결과\nOption Explicit\nSub max_Of_Each_Month_1()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 월 중복개수 구할 변수\nDim rngA As Range\n'중복 영역을 넣을 영역변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nActiveSheet.Copy\n'(원본 보호 위해) 현재시트 복사\n﻿\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nIf\nMonth\n(Cells(r, 1)) = Month(Cells(r + 1, 1)) Then\n'월(月)이 바로 아래 셀과 같으면\ni =..."}
{"instruction": "Excel VBA code for: (1576) 각 월의 마지막 날짜, 수량 추출 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub max_Of_Each_Month_1()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 월 중복개수 구할 변수\nDim rngA As Range\n'중복 영역을 넣을 영역변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nDim rngT As Range\n'날짜를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nActiveSheet.Copy\n'(원본 보호 위해) 현재시트 복사\n﻿\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nIf\nMonth\n(Cells(r, 1)) = Month(Cells(r + 1, 1)) Then\n'월(月)이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nSet rngA = Cells(r, 1).Offset(-i).Resize(i + 1, 1)\n'동일한 月 데이터 영역을 변수에 넣음\nFor Each rngC In rngA\n'동일한 月 영역의 각 셀을 순환\nIf rngC.Offset(, 1) <> \"\" Then\n'B열이 빈 셀이 아니라면\nSet rngT = rngC\n'셀 값을 개체변수 rngT에 넣음\nEnd If\nNext rngC\nIf\nNot\nrngT\nIs\nNothing\nThen\n'값이 존재하면\nWith Cells(1, Columns.Count)\n'1행 종단셀 왼쪽방향\n.End(1)(1, 2) = Month(rngT) & \"월\"\n'오른쪽셀에 월 입력\n.End(1)(2) =\nFormatDateTime\n(rngT,\nvbShortDate\n)\n'아래셀에 날짜 입력\n.End(1)(3) = rngT.Next\n'2행 아래에 수량 입력\nEnd With\nElse\nCells(1, Columns.Count).End(1)(1, 2) = Month(Cells(r, 1)) & \"월\"\nEnd If\n'오른쪽셀에 월 입력\nSet rngT = Nothing\n'재사용 위하여 초기화\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nCells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nColumns.AutoFit\n'열너비 자동 맞춤\nSet rngA = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "1. 각 月의 마지막 날짜 및 수량을 추출\n2. 마지막 날짜의 수량이 0 일 경우에는 그 앞의 날짜 및 수량을 추출\n매크로 실행 전 Sheet1 에 데이터가 입력된 모습 (알아보기 쉽도록 미리 색칠해둠)\n매크로 실행 후 복사된 시트에 추출된 결과\nOption Explicit\nSub max_Of_Each_Month_1()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 월 중복개수 구할 변수\nDim rngA As Range\n'중복 영역을 넣을 영역변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nDim rngT As Range\n'날짜를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nActiveSheet.Copy\n'(원본 보호 위해) 현재시트 복사\n﻿\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nIf\nMonth\n(Cells(r, 1)) = Month(Cells(r + 1, 1))..."}
{"instruction": "Excel VBA code for: (1577) 절대좌표와 상대좌표 이용한 셀값 입력 (엑셀 VBA 매크로)", "input": "", "output": "Sub absolute_And_Relative_Addition()\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nColumns(\"E\").ClearContents\n'(서식 유지하며)기존 데이터만 삭제\nFor Each rngC In Columns(\"B\").SpecialCells\n(2)\n'B열내 문자 있는 셀만 순환\nrngC.Offset(, 3).FormulaR1C1 = _\n\"=\" & rngC.Offset(, 1).\nAddress(1, 1, 2)\n& \" + RC[-1]\"\nNext rngC\n'절대좌표와 상대좌표 이용해 값을 입력\nFor Each rngC In Columns(\"E\").SpecialCells\n(4)\n'E열내 공백셀만 순환\nIf IsEmpty(rngC) Then rngC.\nFormula\n= rngC.Offset(-1).\nFormulaR1C1\nNext rngC\n'빈셀일 경우 윗 셀의 수식을 복사\nEnd Sub", "context": "B열의 문자와 문자 사이의 간격이 불규칙한 상황\nE열에 B열 문자 입력된 값을 기준으로 C1 + D1, C1 + D2, C1 + D3, C4 + D4, C5 + D5, C5 + D6, C5 + D7 ..... 과 같이 절대좌표와 상대좌표 이용하여 값을 입력해야 하는 상황\n매크로 실행 전                                                 매크로 실행 후 결과\nOption Explicit\nSub absolute_And_Relative_Addition()\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nColumns(\"E\").ClearContents\n'(서식 유지하며)기존 데이터만 삭제\nFor Each rngC In Columns(\"B\").SpecialCells\n(2)\n'B열내 문자 있는 셀만 순환\nrngC.Offset(, 3).FormulaR1C1 = _..."}
{"instruction": "Excel VBA code for: (1578) 빈행 삭제하고 빈셀 채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Blank_Rows_And_Fill()\nDim varTemp\n'추출한 값을 넣을 2차원 배열변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nDim v As Long\n'배열 행방향(1차원) 늘려갈 변수\nDim x As Long\n'열방향 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\nReDim varTemp(1 To .\nRows\n.\nCount\n, 1 To .\nColumns\n.\nCount\n)\n'배열크기 전체 행/열 크기로 재지정\nFor Each rngC In Columns(\"C\").SpecialCells(2)\n'C열 문자입력된 셀 각 셀을 순환\nIf Not\nIsEmpty\n(rngC) Then\n'빈셀이 아니라면\nv = v + 1\n'배열크기 1씩 늘려감\nFor x = 1 To .Columns.Count\n'열 개수만큼 반복\nvarTemp(v, x) = rngC.Offset(, -3 + x)\n'배열에 값을 순차적으로 넣음\nNext x\nEnd If\nNext rngC\nWith Sheets(2)\n'Sheet2 에서\n.Activate\n'활성화\n.UsedRange.ClearContents\n'기존 입력된 데이터 삭제\nEnd With\nCells(1, 1).Resize(.Rows.Count, .Columns.Count) = varTemp\nEnd With\n'배열내 값을 A1 셀 기준으로 셀에 뿌림\nFor Each rngC In ActiveSheet.UsedRange\n'Sheet2 각 셀을 순환\nIf rngC = \"\" Or rngC = \"\"\"\" Then\n' 따옴표 이거나 빈셀이면\nrngC = rngC.Offset(-1)\n'윗셀 값으로 입력\nEnd If\nNext rngC\nColumns(\"F\").\nNumberFormat\n= \"yyyy-mm-dd\"\n'F열의 서식을 년-월-일로 지정\nColumns.AutoFit\n'전체 열너비 자동맞춤\nMsgBox \"매크로가 종료되었습니다.\"\n'매크로 종료 메시지창 출력\nEnd Sub", "context": "1. C열을 기준으로 빈 행 삭제\n2. 빈셀 또는 큰 따옴표가 입력된 셀은 위 셀값을 입력\n매크로 실행 전 Sheeet1 에 데이터가 입력되어 있음\n매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub delete_Blank_Rows_And_Fill()\nDim varTemp\n'추출한 값을 넣을 2차원 배열변수\nDim rngC As Range\n'각 셀을 넣을 영역변수\nDim v As Long\n'배열 행방향(1차원) 늘려갈 변수\nDim x As Long\n'열방향 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\nReDim varTemp(1 To .\nRows\n.\nCount\n, 1 To .\nColumns\n.\nCount\n)\n'배열크기 전체 행/열 크기로 재지정\nFor Each rngC In Columns(\"C\").SpecialCells(2)\n'C열..."}
{"instruction": "Excel VBA code for: (1580) 데이터간의 행 개수 입력하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub count_Rows()\nDim rngB As Range\n'A열의 공백(B)lank 구역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nColumns(\"B\").ClearContents\n'(서식은 유지하며) 기존 데이터만 삭제\nFor Each rngB In Columns(\"A\").\nSpecialCells(4).\nAreas\n'A열 공백셀 구역을 순환\nrngB.Offset(-1, 1).Cells(1, 1) = rngB.Rows.Count + 1\nNext rngB\n'공백셀 오른쪽위 첫 셀에 공백행 + 1 입력\nFor Each rngC In Columns(\"A\").SpecialCells(2)\n'B열의 문자입력셀 순환\nIf rngC.\nNext\n= \"\" Then rngC.Next = 1\n'오른쪽 셀이 빈셀이면 1을 입력\nNext rngC\nEnd Sub", "context": "A열에 입력된 데이터와 데이터 간의 행 개수를 B열에 입력하는 기능\n매크로 실행 전                                                        매크로 실행 후 결과\nOption Explicit\nSub count_Rows()\nDim rngB As Range\n'A열의 공백(B)lank 구역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nColumns(\"B\").ClearContents\n'(서식은 유지하며) 기존 데이터만 삭제\nFor Each rngB In Columns(\"A\").\nSpecialCells(4).\nAreas\n'A열 공백셀 구역을 순환\nrngB.Offset(-1, 1).Cells(1, 1) = rngB.Rows.Count + 1\nNext rngB\n'공백셀 오른쪽위 첫 셀에 공백행 + 1 입력\nFor Each rngC In Columns(\"A\").SpecialCells(2)\n'B열의 문자입력셀 순환\nIf rngC.\nNex..."}
{"instruction": "Excel VBA code for: (1581) 중복 없는 전체조합 무작위 추출 (엑셀 VBA 매크로)", "input": "", "output": "Sub complete_Random_Combination()\nDim vA\n'식당/술집/노래방 순환할 배열변수\nDim vB\n'유/무 순환한 배열변수\nDim vC\n'A/B/C/D/E 순환한 배열변수\nDim vD\n'10/20/30/40/50 순환한 배열변수\nDim vE\n'무통장/신용카드/체크카드/현금 순환한 배열변수\nDim i As Long\n'반복 구문에 사용할 변수\nActiveSheet.UsedRange.ClearContents\n'기존 데이터 삭제\nFor Each vA In\nArray\n(\"식당\", \"술집\", \"노래방\")\n'각 장소를 순환\nFor Each vB In Array(\"유\", \"무\")\n'각 옵션을 순환\nFor Each vC In Array(\"A\", \"B\", \"C\", \"D\", \"E\")\n'각 팀을 순환\nFor Each vD In Array(10, 20, 30, 40, 50, 60, 70)\n'각 할인율을 순환\nFor Each vE In Array(\"무통장\", \"신용카드\", \"체크카드\", \"현금\")\n'각 결제수단을 순환\ni = i + 1\n'배열위치 1씩 늘려감\nCells(i, 1).Resize(, 5) = Array(vA, vB, vC, vD, vE)\n'추출한 값을 셀에 뿌림\nNext vE, vD, vC, vB, vA\nCall\nrandom_Reshuffle_Rows\n'좌우로 섞는 하위코드 호출\nColumns.AutoFit\n'열너비 자동 맞춤\nEnd Sub\n\nSub random_Reshuffle_Rows()\nDim varA As Variant\n'각 (A)rea를 넣을 배열\nDim rowsCnt As Long\n'각 area의 행 개수 넣을 변수\nDim colsCnt As Long\n'각 area의 열 개수 넣을 변수\nDim varR\n'뒤섞은 결과 값을 넣을 배열\nDim varCnt() As Long\n'행 또는 열의 숫자만큼 카운터로 쓰일 배열\nDim varNo() As Long\n'행 또는 열 개수만큼 순차적으로 숫자 넣을 배열\nDim i As Long\n'행 또는 열 개수만큼 반복할 변수\nDim y As Long\n'행 또는 열 개수만큼 반복할 변수\nDim j As Long\n'랜덤 값을 넣을 변수\nRandomize\n'랜덤 초기화\nWith [A1].CurrentRegion\n'각 area 에서\nvarA = .Value\n'varA에 각 area값을 넣음\nrowsCnt = .Rows.Count\n'각 area의 행 개수를 변수에 넣음\ncolsCnt = .Columns.Count\n'각 area의 열 개수를 변수에 넣음\nReDim varR(1 To rowsCnt, 1 To colsCnt)\n'결과배열 크기 재지정\nReDim varCnt(1 To colsCnt)\n'카운터로 사용될 배열 크기 재지정\nFor i = 1 To colsCnt\n'열 개수만큼 반복\nvarCnt(i) = i\n'카운터 배열에 순차적 값을 넣음\nNext i\nFor y = 1 To rowsCnt\n'행 개수만큼 반복\nvarNo = varCnt\n'varNo 배열에 varCnt값을 넣음\nFor i = colsCnt To 1 Step -1\n'제일 큰 열에서 부터 1씩 빼며 반복\nj =\nInt\n(\nRnd\n* i) + 1\n'무작위 값을 추출\nvarR(y, i) = varA(y, varNo(j))\n'무작위로 추출한 위치의 배열 값을 varR에 순차적으로 넣음\nvarNo(j) = varNo(i)\n'제일 뒤에 있는 배열 값을 추출한 곳에 채워 넣음\nNext i\nNext y\n.Value = varR\n'결과배열에 추출한 값을 각 area에 뿌림\nEnd With\nEnd Sub", "context": "매크로 실행 전                                          매크로 실행 후 결과(아래로 데이터 더 있음)\nOption Explicit\nSub complete_Random_Combination()\nDim vA\n'식당/술집/노래방 순환할 배열변수\nDim vB\n'유/무 순환한 배열변수\nDim vC\n'A/B/C/D/E 순환한 배열변수\nDim vD\n'10/20/30/40/50 순환한 배열변수\nDim vE\n'무통장/신용카드/체크카드/현금 순환한 배열변수\nDim i As Long\n'반복 구문에 사용할 변수\nActiveSheet.UsedRange.ClearContents\n'기존 데이터 삭제\nFor Each vA In\nArray\n(\"식당\", \"술집\", \"노래방\")\n'각 장소를 순환\nFor Each vB In Array(\"유\", \"무\")\n'각 옵션을 순환\nFor Each vC In Array(\"A\", \"B\", \"C\", \"D\", \"E\")\n'각 팀을 순환\nFor Each v..."}
{"instruction": "Excel VBA code for: (1582) 폴더내 .csv 파일들의 데이터 통합하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_CSV_Data()\nDim strFilter As String\n'필터링될 파일 확장자 넣을 변수\nDim fileNames As Variant\n'모든 파일 넣을 배열 변수\nDim fileName As Variant\n'각 파일을 넣을 변수\nDim xlApp As\nNew Excel.Application\n'엑셀 프로그램 넣을 변수\nDim wkb As Workbook\n'workbook을 넣을 변수\nDim varH\n'H 열의 데이터를 넣을 배열변수\nDim varR\n'계산한 최종 결과 값을 넣을 배열변수\nDim vC\n'배열의 각 요소를 순환할 배열변수\nDim i As\nCurrency\n'0.001 씩 반복하여 늘려갈 변수\nDim cnt As Long\n'범위 이외의 데이터 개수 카운팅할 변수\nDim rngAll As Range\n'A열 데이터 영역을 넣을 영역(개체)변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim x As Long\n'열방향 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nChDir\nThisWorkbook.Path\n'매크로 실행파일과 동일한 경로 기준\nstrFilter = \"Text Files (*.csv),*.csv*\"\n'csv 파일만 필터링\n'-------------------------------\n'파일 선택창을 띄우는 코드\n'-------------------------------\nfileNames = Application.GetOpenFilename(strFilter, , _\n\"엑셀 파일(들)을 선택\", MultiSelect:=True)\n'csv 파일(들)을 선택\nIf\nTypeName\n(fileNames) = \"Boolean\" Then Exit Sub\n'취소 선택 시 매크로 종료\n'-----------------------------------\n'선택한 파일을 모두 순환하는 코드\n'-----------------------------------\nFor Each fileName In fileNames\n'선택한 각 csv 파일을 순환\nSet wkb = xlApp.Workbooks.\nOpen\n(fileName)\n'파일을 열어 개체변수에 넣음\n'-----------------------------------\n'특정 셀의 값들을 배열에 넣는 코드\n'-----------------------------------\nWith wkb.Sheets(1)\n'데이터 파일 첫 번째 시트에서\nIf .Range(\"H18\") <> \"\" Then\n'1개 이상의 데이터가 있을 경우\nvarH = .Range(\"H18\", .Cells(Rows.Count, \"H\").End(3))\n'H열의 전체 데이터를 배열에 넣음\nReDim varR(1 To 24)\n'1차원 배열의 크기 재지정\nvarR(1) = .[A5]\n'A5 셀을 배열에 넣음\nvarR(2) =\nFormatDateTime\n(.[A4], vbShortDate)\n'날짜만을 추출하여 배열에 넣음\nvarR(3) = .[A7]\n'A7 셀을 배열에 넣음\n'-------------------------------------\n'H열 데이터 값을 카운팅 해가는 코드\n'-------------------------------------\nFor Each vC In varH\n'배열내 각 값을 순환\nFor i = 0.001 To 0.02\nStep 0.001\n'0.001씩 올려가며 0.02 될때까지 반복\nIf vC = i Then\n'두 값이 일치하면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nvarR(4 + i * 1000) = varR(4 + i * 1000) + 1\n'값을 1씩 더해감\nEnd If\nNext i\nNext vC\nvarR(4) = UBound(varH, 1) - cnt\n'0.001 ~ 0.02를 벗어나는 데이터의 개수를 변수에\ncnt = 0\n'재사용 위하여 카운터 초기화\nEnd If\nwkb.\nClose\nFalse\n'열은 파일을 저장없이 닫음\nEnd With\nCells(Rows.Count, 1).End(3)(2).Resize(, 24) = varR\n'배열내 값을 행 늘려가면서 셀에 뿌림\nNext fileName\n'-----------------------------------------------\n'합계 셀에 수식을 넣거나 결과 값을 넣는 코드\n'-----------------------------------------------\nIf Range(\"A4\") <> \"\" Then\n'데이터가 1개 이상 있을 경우\nSet rngAll = Range(\"A4\", Cells(Rows.Count, 1).End(3))\n'A열의 데이터를 개체변수에 넣음\nrngAll.Offset(, 24).\nFormulaR1C1\n= \"=SUM(RC[-21]:RC[-1])\"\n'Y열에 합계 수식을 넣음\nFor Each rngC In Range(\"D2:X2\")\n'D2:X2 셀을 순환\nx = x + 1\n'열방향 1씩 늘려감\nrngC =\nApplication.Sum\n(rngAll.Offset(, 2 + x))\n'합계를 셀에 입력\nNext rngC\nx = 0\n'재사용 위하여 초기화\nEnd If\nSet wkb = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nSub clear_Data()\nRange(\"D2:X2\").\nClearContents\n'D2:X2 내의 값을 삭제\nActiveSheet.UsedRange.Offset(3).ClearContents\n'현재시트 사용영역 3행 아래로 삭제\nEnd Sub", "context": "폴더내에 여러 .csv 데이터 파일이 존재\n각 .csv 파일을 열고 A5셀의 값을 Lot No 열(A열)에 가져옴\n각 .csv 파일내 A4 셀의 값을 DATE 열(B열)에 가져옴\n각 .csv 파일내 A7 셀의 값을 \"설비\"열(C열)에 가져옴\n각 .csv 파일내 H열에 있는 데이터와 D3:X3 셀 값이 일치 시 각 값의 개수를 1씩 늘려감\n각 .csv 파일내 H열의 값과 D3:X3 영역의 값이 일치하지 않을 경우 D열에 개수를 구함\nY열에는 각 행 데이터의 합계를 구함\nD2:X2 셀에는 각 열에 있는 데이터의 합계를 구함\n매크로 실행 전 통합 시트가 비어 있는 모습\n폴더 내의 각 .csv 파일내 데이터. 시험 데이터이므로 모두 동일한 위치에 데이터 입력. 단 H18 아래의 데이터 행의 개수는 각 .csv 파일마다 모두 다른 상황.\n매크로 실행 후 통합 시트내에 파일이 통합된 결과\nOption Explicit\nSub combine_CSV_Data()\nDim strFilter As Str..."}
{"instruction": "Excel VBA code for: (1584) 주문양식 이것 저것 수정하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub order_Rearrangement()\nDim cnt As Long\n'묶음 카운터로 사용할 변수\nDim r As Long\n'행 늘려갈 변수\nDim i As Long\n'중복개수를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nSheets(1).\nName\n= \"Sheet1\"\n'시트 이름을 Sheet1 으로 바꿈\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\n.\nValue\n= .\nValue\n'모든 셀의 수식을 값으로 바꿈\nEnd With\n[A1].Resize(, 5) =\nArray\n(\"브랜드\", \"주문번호\", \"이름\", \"주민번호\", \"묶음\")\n'A1:E1 셀에 새로운 제목행 입력\nWith Columns(\"D\")\n'D열에서\n.\nReplace\n\"주민번호앞\", \"\"\n' \"주민번호앞\" 문자를 삭제\n.Replace \"주민번호뒤\", \"-\"\n' \"주민번호뒤\" 문자를 하이픈(-)으로 바꿈\nEnd With\nRange(\"A2\", Cells(Rows.Count, \"A\").End(3)).Offset(, 1) = _\nSheets(2).Range(\"A1\")\n'B열에 Sheet2의 A1 셀 값을 넣음\nr = 1\n'1행 부터 시작\nDo\n'다음을 실행\nIf Cells(r, 4) = Cells(r + 1, 4) Then\n'D열 위 아래 셀 값이 같으면\ni = i + 1\n'중복개수 1씩 늘려감\nElse\n'D열 위아래 셀 값이 다르면\nIf i > 0 Then\n'i 가 1보다 크면(즉, 중복 있으면)\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nCells(r, 5).Offset(-i).Resize(i + 1) = cnt\n'셀에 카운터 값을 입력\ni = 0\n'재사용 위하여 중복개수 초기화\nEnd If\nEnd If\nr = r + 1\n'행을 1씩 늘려감\nLoop Until\nLen(Cells(r, 1)) = 0\n'A열에 빈 셀 나올때까지 무한 반복\nEnd Sub", "context": "1. 시트의 이름을 Sheet1 으로 변경\n2. 시트내의 수식을 모두 없애고 값으로 입력\n3. 1 행의 제목을 지정한 내용으로 변경\n4. D열에서 문자 제거하고 주민번호만 남도록 함\n5. D열에 중복된 주민번호만 순차적으로 번호를 E열에 입력\n매크로 실행 전 Download 시트\n매크로 실행 후 결과\nOption Explicit\nSub order_Rearrangement()\nDim cnt As Long\n'묶음 카운터로 사용할 변수\nDim r As Long\n'행 늘려갈 변수\nDim i As Long\n'중복개수를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nSheets(1).\nName\n= \"Sheet1\"\n'시트 이름을 Sheet1 으로 바꿈\nWith ActiveSheet.UsedRange\n'현재시트 사용영역에서\n.\nValue\n= .\nValue\n'모든 셀의 수식을 값으로 바꿈\nEnd With\n[A1].Resize(, 5) =\nArr..."}
{"instruction": "Excel VBA code for: (1585) 폴더내 그림파일과 일치 시 사진(그림) 영구삽입 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Pictures_In_One_Column()\nDim msg As String\n'Yes/No 선택 값을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim C As Range\n'검색에 일치한 셀을 넣을 변수\nDim v As Long\n'배열크기 늘려갈 변수\nDim varName() As String\n'파일이름 넣을 동적배열 문자형 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\n'----------------------------------------------------\n'사용자가 영역을 제대로 선택했는지 확인하는 코드\n'----------------------------------------------------\nIf TypeName(Selection) <> \"Range\" Then\n'선택한 것이 영역이 아니면\nMsgBox \"영역을 선택하고 매크로 실행\", 64, \"영역선택 오류\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nIf Selection.Cells.Count = 1 Then\n'선택영역의 셀이 1개면\nmsg = MsgBox(\"한개의 셀만 선택함. 계속할까요?\", vbYesNo, \"확인\")\nIf msg = vbNo Then Exit Sub\n'No 선택 시 매크로 종료\nEnd If\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\n'----------------------------\n'폴더 선택창을 띄우는 코드\n'----------------------------\nWith Application.FileDialog(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\nActiveSheet.\nPictures\n.Delete\n'기존 사진들 삭제\nfileName =\nDir\n(strPath)\n'(폴더내)각 그림파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\n'-------------------------------------\n'폴더내 모든 파일을 배열에 넣는 코드\n'-------------------------------------\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\nv = v + 1\n'배열크기 1씩 늘려감\nReDim Preserve varName(1 To v)\n'기존 데이터 유지하면 동적배열 크기 재지정\nvarName(v) = strPath & fileName\n'배열내에 파일경로 포함 파일이름 넣음\nfileName =\nDir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\n'---------------------------------------------------\n'각 셀과 일치하는 이름 찾아 그림 영구삽입하는 코드\n'---------------------------------------------------\nFor Each rngC In Selection\n'선택영역의 각 셀을 순환\nFor i = 1 To UBound(varName)\n'1부터 배열 상한 값까지 순환\nIf varName(i) = rngC Then\n'파일과 셀내의 파일 이름 일치 시\nActiveSheet.\nPictures.Insert\n(varName(i)).Select\n'각 그림파일 삽입\nSet C = rngC.MergeArea\n'셀병합 된 경우 셀병합 셀을 C에 넣음\nWith Selection\n'선택된 그림파일\n.Name = \"#Temp#\"\n'(임시로) 이름을 \"#Temp#\"로 지정\n.ShapeRange.LockAspectRatio = msoFalse\n'그림의 가로/세로크기 고정 해제\n.Height = C.Height - 4\n'그림의 가로크기 지정\n.Width = C.Width - 4\n'그림의 세로크기 지정\n.Copy\n'그림을 복사\nActiveSheet.\nPasteSpecial Link:=False\n'그림 링크깨고 붙여넣기\nActiveSheet.Pictures(\"#Temp#\").Delete\n'원본 그림파일 삭제\nEnd With\nWith Selection\n'(복사되어)선택된 그림파일\n.Left = C.Left + 2\n'그림의 왼쪽위치 지정\n.Top = C.Top + 2\n'그림의 윗쪽위치 지정\nEnd With\nEnd If\nNext i\nNext rngC\nEnd Sub", "context": "1. 매크로 실행 전 그림파일 이름이 적힌 영역을 선택하고 실행\n2. 매크로 버튼을 제외한 시트내의 모든 그림파일을 삭제하고 그림을 불러오므로 주의\n3. 기존 삽입된 그림의 삭제를 원하지 않을 경우  ActiveSheet.Pictures.Delete  코드를 삭제하면 됨.\n4. 당연한 얘기지만 경로내에 그림이 없거나, 셀이 비어 있는 경우 그림 삽입이 되지 않음.\n5. 선택영역의 각 셀크기보다 약간 작게 삽입되므로 셀의 크기는 사용자가 알아서 조정.\n매크로 실행 전 그림파일 경로가 적힌 시트           매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1585) 폴더내 그림파일과 일치 시 사진(그림) 영구삽입 2 (엑셀 VBA 매크로)\n재생\n2,316\n공유하기\n재생 (space/k)\n재생\n00:26\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:26\n실시간\n설정\n전체 화면 (f)\n..."}
{"instruction": "Excel VBA code for: (1586) 두 데이터 비교하는 기본코드 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Matching_Data()\nDim varL\n'왼쪽(L)eft 영역 첫 번째열 넣을 변수\nDim varLeft\n'왼쪽(Left) 영역 전체를 넣을 변수\nDim varR\n'오른쪽(R)ight 영역 첫 번째열 넣을 변수\nDim varRight\n'오른쪽(Right) 영역 전체를 넣을 변수\nDim vL\n'varL 배열내 각 값을 순환할 변수\nDim vR\n'varR 배열내 각 값을 순환할 변수\nDim l As Long\n'왼쪽(l)eft 위치 더해갈 변수\nDim r As Long\n'오른쪽(r)right 위치 더해갈 변수\nDim x As Long\n'열 방향 반복할 변수\nDim cnt As Long\n'값이 일치한 개수 카운팅할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nRange(\"F1:F10\").ClearContents\n'기존 데이터 삭제\nvarL = Range(\"\nA1:A10\n\")\n'왼쪽 영역 첫 번째열을 변수에\nvarLeft = Range(\"\nA1:E10\n\")\n'왼쪽 영역을 변수에 넣음\nvarR = Range(\"\nG1:G10\n\")\n'오른쪽 영역 첫 번째열을 변수에\nvarRight = Range(\"\nG1:K10\n\")\n'오른쪽 영역을 변수에 넣음\nFor Each vL In varL\n'왼쪽 영역 배열내 각 값을 순환\nl = l + 1\n'행방향 1씩 늘려감\nDo\n'다음을 실행\nFor Each vR In varR\n'오른쪽 영역 배열내 각 값을 순환\nr = r + 1\n'행방향 1씩 늘려감\nIf vL = vR Then\n'첫 열의 값이 일치할 경우\nFor x = 2 To\n5\n'2 ~ 전체 열 개수만큼 반복\nIf varLeft(l, x) = varRight(r, x) Then\n'값이 일치할 경우\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nElse\n'값이 다를 경우\ncnt = 0: Exit For\n'카운터 초기화 하고 For 구문 종료\nEnd If\nNext x\nIf cnt = 4 Then\n'전체 값이 일치한 경우\nCells(l,\n6\n) = Cells(r, 7).Resize(,\n5\n).Address(0, 0)\n'셀에 일치한 영역의 주소를 입력\ncnt = 0\n'카운터 초기화\nExit Do\n'Do 구문 종료\nEnd If\nEnd If\nNext vR\nLoop Until True\nr = 0\n'재사용 위하여 초기화\nNext vL\nMsgBox \"매크로가 종료되었습니다. ^^\"\n'종료 메시지창 출력\nEnd Sub", "context": "지금껏 두 데이터를 비교하는 여러 코드를 공부해봤다. 순수 엑셀의 기능만으로 두 데이터를 비교했을 때 가장 빠른 코드중의 하나가 아닐까 생각된다. 항상 그렇듯, 두 데이터를 배열에 넣고, 배열내 데이터를 비교하고 이의 결과 값을 출력하는 방식이다. 결과 값도 배열에 넣어 셀에 한 번에 뿌려야 하지만 너무 코드가 복잡해지므로 이는 생략하고 직접 값을 셀에 뿌림. 두 데이터를 비교하는 경우가 빈번하므로 재 사용을 위하여 기본 코드에 정리하여 둔다.\n매크로 실행 전(왼쪽 오른쪽 일치하는 데이터는 알아보기 쉽게 미리 색으로 칠하여 둠)\n매크로 실행 후 결과\nOption Explicit\nSub find_Matching_Data()\nDim varL\n'왼쪽(L)eft 영역 첫 번째열 넣을 변수\nDim varLeft\n'왼쪽(Left) 영역 전체를 넣을 변수\nDim varR\n'오른쪽(R)ight 영역 첫 번째열 넣을 변수\nDim varRight\n'오른쪽(Right) 영역 전체를 넣을 변수\nDim v..."}
{"instruction": "Excel VBA code for: (1587) 폴더내 모든 파일의 특정시트 특정열 불러오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_Column_In_Folder_1()\nDim strSht As String\n'시트 이름을 넣을 변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim strCol As String\n'가져올 열 넣을 변수\nDim rngT As Range\n'각 열이 복사될 위치 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nActiveSheet.UsedRange.Offset(, 1).ClearContents\n'기존데이터 삭제\n﻿\nstrSht = \"\nSheet1\n\"\n'데이터가 저장된 시트의 이름\nstrCol = \"\nC\n\"\n'가져올 열을 변수에 넣음\nstrCol = \"$\" & strCol & \":$\" & strCol\n'가져올 열을 절대($)주소로 변경\n'-------------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'-------------------------------------------------\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더를 선택한 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'-------------------------------------\n' 폴더내 엑셀파일 유무를 확인하는 코드\n'-------------------------------------\nfileName =\nDir\n(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 엑셀 파일이 없음.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\n'-----------------------------------------------------------------\n' 배열수식을 이용하여 데이터 가져오고 수식을 값으로 변환하는 코드\n'-----------------------------------------------------------------\nSet rngT = Cells(1, Columns.Count).End(1)(1, 2)\n'각 열이 복사되는 기준위치를 변수에\nrngT.\nFormula\n= \"=COUNTA('\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & strCol & \")\"\n'C열의 데이터 개수를 찾아 변수에 넣음\nWith rngT.Offset(1).Resize(rngT.Value)\n'각 열의 데이터\n.\nFormulaArray\n= \"='\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & Cells(1, strCol).Resize(rngT.Value).Address(1, 1, 1)\n'데이터 영역을 배열 이용하여 가져옴\n.\nValue\n= .\nValue\n'셀의 수식을 값으로 바꿈\nEnd With\nrngT = fileName\n'1행에 파일 이름을 넣음\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nColumns.AutoFit\n'열너비 자동 맞춤\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "폴더내 모든 엑셀 파일내에 있는 특정 시트(예제에서는 Sheet1) 특정 열(예제에서는 C열)에 있는 모든 데이터를 가져오는 기능.\n데이터는 현재시트 B열 부터 오른쪽 열에 순차적으로 입력\n1행에는 가져온 데이터의 파일 이름을 입력\n매크로 실행 전\n매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1587) 폴더내 모든 파일의 특정시트 특정열 불러오기 (엑셀 VBA 매크로)\n재생\n5,134\n공유하기\n재생 (space/k)\n재생\n00:25\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:25\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입..."}
{"instruction": "Excel VBA code for: (1589) 파일내 모든 표의 특정열 가져오기 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_Table_Columns()\nDim i As Long\n'반복구문에 사용할 변수\nDim wks As Worksheet\n'시트를 넣을 변수\nDim tblObj As\nListObject\n'테이블을 넣을 변수\nDim rowsCnt As Long\n'행 개수를넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim v As Long\n'배열크기 늘려갈 변수\nDim varTemp()\n'동적 배열로 사용할 변수\ni = 1\n'1행 부터 시작\nrowsCnt = ActiveSheet.\nListObjects\n(1).ListRows.Count\n'표의 행 개수를 변수에 넣음\nFor Each wks In Worksheets\n'각 시트를 순환\nFor Each tblObj In wks.\nListObjects\n'시트내 각 표를 순환\nv = v + 1\n'배열크기 1씩 늘려감\nReDim Preserve varTemp(1 To rowsCnt + 1, 1 To v)\n'기존 값을 유지하며 배열크기 재지정\nvarTemp(1, v) = tblObj.Name\n'배열 첫 행에 표 이름을 넣음\nFor Each rngC In wks.Range(tblObj.Name & \"\n[\n나이\n]\n\").Cells\n'표의 필드가 \"나이\"인 열의 각 셀을 순환\ni = i + 1\n'값을 1씩 늘려감\nvarTemp(i, v) = rngC\n'셀 값을 배열에 넣음\nNext rngC\ni = 1\n'재사용 위하여 초기화\nNext tblObj\nNext wks\nWorkbooks.Add\n'(기존 데이터 보존) 새로운 시트를 열기\n[A1].Resize(rowsCnt + 1, UBound(varTemp, 2)) = varTemp\n'배열내 값을 시트에 뿌리기\nEnd Sub", "context": "0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1589) 파일내 모든 표의 특정열 가져오기 (엑셀 VBA 매크로)\n재생\n1,467\n재생 (space/k)\n재생\n00:15\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:15\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n파일 내에 시트내에 여러 시트가 있으며, 각 시트에는 표들이 삽입되어 있음\n매크로 실행 시 새로운 창을 열고, 1행에 각 표의 이름..."}
{"instruction": "Excel VBA code for: (1590) 선택영역의 공백행과 다음행을 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_Blank_And_Next_Row()\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nWith Selection\n'선택 영역에서\nFor i = .Rows.Count To 1\nStep -1\n'마지막 행부터 1씩 줄여가며 반복\nIf\nWorksheetFunction\n.\nCountA\n(.Rows(i)) = 0 Then\n'전체행이 비어 있을 경우\n.Rows(i).Resize(2).\nDelete\nshift:=xlUp\n'공백행과 아래행을 삭제\nEnd If\nNext i\nEnd With\nEnd Sub", "context": "선택영역의 공백행과 다음행을 삭제(전체행이 공백인 경우에만 적용)\n(주변에 있는 데이터를 보존하기 위해) ﻿행 삭제 후 데이터 위로 끌어 올림\n선택영역의 전체 공백행만 삭제하려면 첨부한 delete_Blank_Rows.xlsm 파일의 코드 사용\n매크로 실행 전 영역을 선택한 모습\n매크로 실행 후 결과 (공백행과 다음 행을 삭제함)\nOption Explicit\nSub delete_Blank_And_Next_Row()\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nWith Selection\n'선택 영역에서\nFor i = .Rows.Count To 1\nStep -1\n'마지막 행부터 1씩 줄여가며 반복\nIf\nWorksheetFunction\n.\nCountA\n(.Rows(i)) = 0 Then\n'전체행이 비어 있을 경우\n.Rows(i).Resize(2).\nDelete\nshift:=xlUp\n'공백행과 ..."}
{"instruction": "Excel VBA code for: (1591) 이름과 라운드 찾기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Name_And_Round()\nDim rngRow As Range\n'1행의 라운드 넣을 영역변수\nDim rngCol As Range\n'B열의 이름 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim R As Range\n'찾은 행 넣을 변수\nDim C As Range\n'찾을 열 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Offset(1, 2).ClearContents\n'기존 데이터 삭제\nSet\nrngRow = .Range(\"C1\", .Cells(1, Columns.Count).End(1))\n'1행의 라운드를 변수에 넣음\nSet rngCol = .Range(\"B2\", .Cells(Rows.Count, \"B\").End(3))\nEnd With\n'B열의 이름을 변수에 넣음\nFor Each rngC In Range(\"B2\", Cells(Rows.Count, \"B\").End(3))\n'B열의 각 이름을 순환\nSet R = rngCol.\nFind\n(rngC, , , xlWhole)\n'이름 일치한 셀을 변수에 넣음\nSet C = rngRow.Find(rngC.Next, , , xlWhole)\n'라운드 일치한 셀을 변수에 넣음\nIf\nNot R Is Nothing\nAnd Not C Is Nothing Then\n'이름과 라운드 모두 일치한 경우\nSheets(2).Cells(R.Row, C.Column) = rngC.Offset(, 2)\nEnd If\n'셀에 점수를 넣음\nSet R = Nothing\n'재사용 위하여 초기화\nSet C = Nothing\n'재사용 위하여 초기화\nNext rngC\nMsgBox \"매크로가 종료되었습니다.\"\n'매크로 종료 메시지창 출력\nEnd Sub", "context": "매크로 실행 전 Sheet1\n매크로 실행 전 Sheet2\n매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub find_Name_And_Round()\nDim rngRow As Range\n'1행의 라운드 넣을 영역변수\nDim rngCol As Range\n'B열의 이름 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim R As Range\n'찾은 행 넣을 변수\nDim C As Range\n'찾을 열 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nWith Sheets(2)\n'Sheet2에서\n.UsedRange.Offset(1, 2).ClearContents\n'기존 데이터 삭제\nSet\nrngRow = .Range(\"C1\", .Cells(1, Columns.Count).End(1))\n'1행의 라운드를 변수에 넣음\nSet rngCol = .Range(\"B2\", .Cells(Rows.Count, \"B\")..."}
{"instruction": "Excel VBA code for: (1592) 데이터 이동하며 재배치하기 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub relocate_Data()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim colNo As Long\n'열 위치를 넣을 변수\nWith\nApplication\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\n.Calculation =\nxlCalculationManual\n'계산 모드 수동으로\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Offset(3, 2).ClearContents\n'기존 데이터 삭제\n.Range(\"C2\") = Range(\"L2\")\n'\"선택\" 값을 입력\nEnd With\nFor Each rngC In Range(\"B1:J1\")\n'B1:J1제목행에서\nIf rngC = Range(\"L2\") Then\n'셀값이 L2 셀과 일치하면\ncolNo = rngC.Column\n'셀의 열 값을 변수에 넣음\nExit For\n'(일치하는 셀 찾았으므로)For 구문 종료\nEnd If\nNext rngC\nIf colNo = 0 Then\n'일치하는 셀이 없으면\nMsgBox \"선택값에 오류가 있습니다.\", 16, \"입력오류\"\nExit Sub\n'오류 메시지창 출력 후 매크로 종료\nEnd If\nCall\nmove_Data(colNo)\n'열번호와 함께 데이터를 옮기는 하위 코드 호출\n.ScreenUpdating = True\n'자동화면 업데이트 복원\n.Calculation =\nxlCalculationAutomatic\n'계산모드 자동으로 복원\nEnd With\nMsgBox \"매크로가 종료되었습니다.\", 64, \"매크로 종료\"\n'종료 메시지창 출력\nEnd Sub\n\nSub move_Data(ByVal lngCol As Long)\n'옮길 데이터의 열번호를 받은 코드\nDim rngC As Range\n'각 셀을 순환\nDim lngMon As Long\n'月을 넣을 변수\nFor Each rngC In Range(Cells(2, lngCol), Cells(Rows.Count, lngCol).End(3))\n'일치한 열의 전체 행 데이터 각셀 순환\nIf rngC.Offset(, 1 - lngCol) <> 0 Then\n'A열에 날짜 있을 경우\nlngMon =\nMonth\n(rngC.Offset(, 1 - lngCol))\n'A열의 날짜를 변수에 넣음\nElse\n'A열에 날짜가 없을 경우\nlngMon = Month(rngC.Offset(, 1 - lngCol).End(3))\nEnd If\n'윗행의 날짜를 변수에 넣음\nSheets(2).Cells(lngMon + 3, Columns.Count).End(1)(1, 2) = rngC\nNext rngC\n'Sheet2 셀에 값을 입력\nSheets(2).Activate\n'Sheet2 활성화\nEnd Sub", "context": "\"선택\"에 입력한 열의 데이터를 월별로 재 배치하는 기능\n\"선택\"에 값을 잘못 입력하여도 오류 발생하지 않도록 함\n매크로 실행 전 Sheet1 에 입력된 데이터(아래로 데이터 더 있음)\n매크로 실행 전 Sheet2 의 양식\n매크로 실행 후 Sheet2 의 결과\nOption Explicit\nSub relocate_Data()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim colNo As Long\n'열 위치를 넣을 변수\nWith\nApplication\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\n.Calculation =\nxlCalculationManual\n'계산 모드 수동으로\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.Offset(3, 2).ClearContents\n'기존 데이터 삭제\n.Range(\"C2\") = Range(\"L2\")\n'\"선택\" 값을 입력\nEnd With\nFor Each rngC In Range(..."}
{"instruction": "Excel VBA code for: (1593) 중첩 If 문을 이용한 판정 (엑셀 VBA 매크로)", "input": "", "output": "Sub nesting_Multiple_If()\nDim rngC As Range\n'A열 각 셀을 넣을 변수\nFor Each rngC In Columns(\"A\").SpecialCells(2)\n'A열의 문자 입력된 각 셀을 순환\nIf rngC = rngC.Next Then\n'A열이 B열하고 같을 경우\nrngC.Offset(, 3) = \"Y\"\n'D열에 Y 입력\nElseIf rngC > 0 And rngC.Next = 0 Then\n'A열이 0보다 크고 B열은 0인 경우\nrngC.Offset(, 3) = \"삭제\"\n'D열에 \"삭제\" 입력\nElseIf rngC = 0 And rngC.Next > 0 Then\n'A열이0이고 B열이 0보다 큰 경우\nrngC.Offset(, 3) = \"추가\"\n'D열에 \"추가\"입력\nElseIf rngC <> 0 And rngC.Next <> 0 And rngC <> rngC.Next Then\n'A/B열 모두 0이 아니고 A열과 B열이 다른 경우\nrngC.Offset(, 3) = \"수정\"\n'D열에 수정 입력\nEnd If\nNext rngC\nEnd Sub", "context": "A열과 B열이 같으면 : Y\nA열이 0보다 크고 B열이 0이면 : 삭제\nA열이 0이고 B열이 0보다 크면 : 추가\nA열과 B열 모두 0이 아니고, A열이 B열이 아니라면 : 수정\nC열에 함수 입력 전\nC1 셀에 아래의 합수 입력하고 아래로 복사한 결과\n=IF(A1=B1, \"Y\", (IF(AND(A1>0,B1=0),\"삭제\", (IF(AND(A1=0,B1>0), \"추가\", (IF(AND A1<>0, B1<>0, A1<>B1), \"수정\",\"\")))))))\n위의 기능을 VBA 사용하여 구현하면 아래와 같다. 모양만 다르지 동일한 방법을 사용한 것임.\n매크로 실행 후 D열에 값이 입력된 결과\nOption Explicit\nSub nesting_Multiple_If()\nDim rngC As Range\n'A열 각 셀을 넣을 변수\nFor Each rngC In Columns(\"A\").SpecialCells(2)\n'A열의 문자 입력된 각 셀을 순환\nIf rngC = rngC.Next Then\n'A열이..."}
{"instruction": "Excel VBA code for: (1594) 중복행 제일 윗행만 남기고 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub leave_The_First_Dupes()\nDim r As Long\n'행(r)ow 늘려갈 변수\nr = Cells(Rows.Count, \"A\").End(3).\nRow\n'마지막 행을 변수에 넣음\nDo\n'다음을 실행\nIf Cells(r, 1) = Cells(r - 1, 1) Then\n'각 셀이 바로 위 셀과 같으면\nCells(r, 1) =\nvbNullString\n'아래 셀을 삭제\nEnd If\nr = r - 1\n'행을 1씩 감소\nLoop Until r = 1\n'1행에 다다를 때까지 무한 반복\nEnd Sub", "context": "이런 코드는 대개 For ... Next 구문을 사용한다. For ... Next는 많이 해보았으므로 아래에는 Do ... Loop 구문을 사용하였다. 여러 가지 다양한 방법으로 가능하다.\n매크로 실행 전(아래로 데이터 더 있음)                     매크로 실행 후 결과\nOption Explicit\nSub leave_The_First_Dupes()\nDim r As Long\n'행(r)ow 늘려갈 변수\nr = Cells(Rows.Count, \"A\").End(3).\nRow\n'마지막 행을 변수에 넣음\nDo\n'다음을 실행\nIf Cells(r, 1) = Cells(r - 1, 1) Then\n'각 셀이 바로 위 셀과 같으면\nCells(r, 1) =\nvbNullString\n'아래 셀을 삭제\nEnd If\nr = r - 1\n'행을 1씩 감소\nLoop Until r = 1\n'1행에 다다를 때까지 무한 반복\nEnd Sub..."}
{"instruction": "Excel VBA code for: (1595) 선택한 파일들 다른 폴더로 이동하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub move_Selected_Files()\nDim strFilter As String\n'필터링될 파일 확장자 넣을 변수\nDim strPath As String\n'옮겨질 경로를 넣을 변수\nDim fileNames As Variant\n'모든 파일 넣을 배열 변수\nDim fileName As Variant\n'각 파일을 넣을 변수\nDim strName As Variant\n'전체 경로에서 파일 이름만 추출할 변수\nDim msg As String\n'메시지창 결과 넣을 변수\nChDir ThisWorkbook.Path\n'매크로 실행파일과 동일한 경로 기준\nstrFilter = \"Text Files (*.txt),*.txt*\"\n'txt 파일만 선택됨\nstrPath = \"\nC:\\Users\\사용자\\Desktop\\\n\"\n'옮겨질 폴더경로를 변수에 넣음\n'---------------------------\n'파일 선택창을 띄우는 코드\n'---------------------------\nfileNames = Application.\nGetOpenFilename\n(strFilter, , _\n\"엑셀 파일(들)을 선택\", MultiSelect:=True)\n'엑셀 파일(들)을 선택\nIf TypeName(fileNames) = \"Boolean\" Then Exit Sub\n'취소 선택 시 매크로 종료\n'----------------------------\n'선택한 파일을 옮기는 코드\n'----------------------------\nFor Each fileName In fileNames\n'선택한 각 엑셀 파일을 순환\nstrName =\nSplit\n(fileName, \"\\\")\n'\\ 를 구분으로 문자 분리\nstrName = strName(UBound(strName))\n'제일 마지막의 파일 이름만 추출\nIf\nDir\n(strPath & strName) <> \"\" Then\n'동일한 파일이 옮겨질 폴더에 이미 있으면\nmsg = MsgBox(strName & \" 파일이 이미 있습니다. 덮어 쓸까요?\", vbYesNo, \"파일 존재\")\n'메시지창 출력\nIf msg = vbYes Then\n'Yes 선택 시\nKill\nstrPath & strName\n'기존파일 삭제\nName\nfileName\nAs\nstrPath & strName\n'선택된 파일 이동\nElse\n'No 선택 시\nExit Sub\n'매크로 종료\nEnd If\nElse\nName fileName As strPath & strName\n'선택된 파일 이동\nEnd If\nNext fileName\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "선택한 .txt 파일을 다른 폴더로 옮기는 기능\n﻿복사될 폴더에 이미 파일 있을 경우 덮어 씌울지 물어봄\n﻿주황색으로 표시한 이동될 폴더 경로는 자신의 폴더 경로로 수정해서 사용.\n매크로 실행전 A폴더      매크로 실행전 B폴더              매크로 실행후 A폴더     매크로 실행후 B폴더\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1595) 선택한 파일들 다른 폴더로 이동하기 (엑셀 VBA 매크로)\n재생\n1,897\n재생 (space/k)\n재생\n00:34\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:34\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도..."}
{"instruction": "Excel VBA code for: (1596) 패턴 일치하는 영역 찾기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_A_Pattern_Area()\nDim blnTF As\nBoolean\n'전체 일치하는 영역 존재여부 판단할 변수\nDim rngLeft As Range\n'왼쪽의 영역을 넣을 변수\nDim rngRight As Range\n'오른쪽 D:E 열의 값을 넣을 변수\nDim r As Long\n'A열 전체 행 개수만큼 반복할 변수\nDim i As Long\n'D:E열 셀 개수만큼 반복할 변수\nDim j As Long\n'일치하는 셀의 개수 넣을 변수\nDim cnt As Long\n'전체 일치하는 영역의 개수 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nColumns(\"A:B\").Interior.ColorIndex =\nxlNone\n'A:B 열의 채우기 색을 모두 삭제\nSet rngRight = Range(\"D1\", Cells(Rows.Count, \"D\").End(3)).CurrentRegion\n'D열의 찾을 패턴을 변수에 넣음\nSet rngLeft = Cells(1, 1).Resize(rngRight.Rows.Count, rngRight.Columns.Count)\n'비교할 왼쪽의 데이터 영역을 변수에 넣음\nFor r = 1 To Cells(Rows.Count, \"A\").End(3).\nRow\n'A열의 마지막 행까지 반복\nFor i = 1 To rngRight.Cells.Count\n'D:E 영역의 셀 개수만큼 반복\nIf rngLeft.\nCells(i)\n= rngRight.Cells(i) Then\n'두 영역의 셀값이 일치하면\nj = j + 1\n'카운터를 1씩 늘려감\nElse\n'두 영역의 셀값이 다르면\nj = 0\n'카운터를 초기화\nExit For\n'For 구문 종료\nEnd If\nNext i\nIf j = rngRight.Cells.Count Then\n'카운터가 패턴영역 셀 개수와 일치 시\nblnTF =\nTrue\n'일치영역 존재여부를 \"참\"으로 설정\ncnt = cnt + 1\n'카운터 1씩 늘려감\nrngLeft.Interior.\nColorIndex\n= 6\n'패턴 일치한 영역에 노란 색채우기\nEnd If\nSet rngLeft = rngLeft.Offset(1)\n'왼쪽 비교영역을 한 행 내림\nNext r\nIf blnTF = True Then\n'전체 일치하는 영역이 있었을 경우\nMsgBox \"모두 \" & cnt & \" 개의 영역이 일치함\"\n'몇 개 영역이 일치하는지 알리는 창 출력\nElse\n'전체 일치하는 영역이 없을 경우\nMsgBox \"일치하는 영역이 없습니다.\"\n'일치하는 영역 없다는 메시지창 출력\nEnd If\nSet rngRight = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet rngLeft = Nothing\nEnd Sub", "context": "D:E 열에 입력된 데이터와 동일한 패턴으로 데이터가 입력된 영역을 A:B 열에서 찾고, 일치하는 경우 노란색으로 색칠하고 전체 일치한 영역의 개수를 메시지 창을 이용하여 출력하는 기능.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1596) 패턴 일치하는 영역 찾기 (엑셀 VBA 매크로)\n재생\n1,918\n재생 (space/k)\n재생\n00:36\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:36\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n..."}
{"instruction": "Excel VBA code for: (1597) 특정행 제외하고 공백셀 행에 색채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_Color_Except_Name_Row()\nDim rngC As Range\n'B열의 각 셀을 넣을 변수\nFor Each rngC In Columns(\"B\").\nSpecialCells(4)\n'B열의 공백셀 영역 각셀 순환\nIf\nIsEmpty\n(rngC) Then\n'셀이 비어 있을 경우\nIf rngC.Offset(1) <> \"도시\" Then\n'아래셀이 \"도시\"가 아닌 경우\nrngC.Offset(, -1).Resize(, 4).Interior.\nColorIndex\n= 6\nEnd If\n'왼쪽 1열 간 위치에서 오른쪽 4열 색칠\nEnd If\nNext rngC\nEnd Sub", "context": "1.  B열이 공백인 경우 그 행의 A:D 열까지 노란색으로 색채우기\n2.  아래 셀이 \"도시\"인 행은 제외\n매크로 실행 전(아래로 데이터 더 있음)                     매크로 실행 후 결과\nOption Explicit\nSub fill_Color_Except_Name_Row()\nDim rngC As Range\n'B열의 각 셀을 넣을 변수\nFor Each rngC In Columns(\"B\").\nSpecialCells(4)\n'B열의 공백셀 영역 각셀 순환\nIf\nIsEmpty\n(rngC) Then\n'셀이 비어 있을 경우\nIf rngC.Offset(1) <> \"도시\" Then\n'아래셀이 \"도시\"가 아닌 경우\nrngC.Offset(, -1).Resize(, 4).Interior.\nColorIndex\n= 6\nEnd If\n'왼쪽 1열 간 위치에서 오른쪽 4열 색칠\nEnd If\nNext rngC\nEnd Sub..."}
{"instruction": "Excel VBA code for: (1599) 문자 분리 후 상품 개수만큼 행 복사 (엑셀 VBA 매크로)", "input": "", "output": "Sub split_And_Copy_As_Numbered()\nDim colsCnt As Long\n'전체 열 개수 넣을 변수\nDim rngAll As Range\n'주문상품 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp\n'문자를 쪼개 넣을 배열 변수\nDim r As Long\n'반복구문에 사용할 변수\nDim varS\n'쪼개진 문자 또 쪼개어 넣을 배열변수\nDim lngNo As Long\n'개수를 추출할 변수\nDim s As Long\n'개수만큼 반복할 변수\nDim v As Long\n'동적배열 크기 늘려갈 변수\nDim varR\n()\n'동적배열로 사용할 변수\nDim x As Long\n'열 개수 -1 만큼 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'열 개수를 변수에 넣음\nSet rngAll = Range(\"F2\", Cells(Rows.Count, \"F\").End(3))\n'F열 전체 데이터 변수에 넣음\nFor Each rngC In rngAll\n'전체 데이터의 각 셀을 순환\nvarTemp = Split(rngC, \",\")\n'콤마(,)로 문자를 분리하여 배열에 넣음\nFor r =\nLBound\n(varTemp) To\nUBound\n(varTemp)\n'varTemp 개수만큼 반복\nvarS = Split(varTemp(r), \":\")\n'varTemp를 콜론(:) 으로 분리하여 배열에 넣음\nlngNo =\nTrim\n(Split(varS(1), \"개\")(0))\n'문자 \"개\"로 분리하여 개수 추출\nFor s = 1 To lngNo\n'개수만큼 반복\nv = v + 1\n'배열크기 1씩 늘려감\nReDim Preserve varR(1 To colsCnt + 1, 1 To v)\n'배열크기 재지정\nFor x = 1 To colsCnt - 1\n'전체 열 개수 -1 만큼 반복\nvarR(x, v) = Cells(rngC.Row, x)\n'A:E 열의 데이터 배열에 입력\nNext x\nvarR(colsCnt, v) = Trim(varS(0))\n'상품명을 배열에 입력\nvarR(colsCnt + 1, v) = Trim(varS(1))\n'개수를 배열에 입력\nNext s\nNext\nNext rngC\nWorkbooks.\nAdd\n'새로운 시트 추가\nCells(1, 1).Resize(UBound(varR, 2), UBound(varR, 1)) = _\nWorksheetFunction.\nTranspose\n(varR)\n'배열내 값을 시트에 뿌림\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "1. F열의 주문상품을 상품별로 분리\n2. 분리된 상품의 개수만큼 행을 복사\n매크로 실행 전\n매크로 실행 후 새로운 파일에 데이터가 옮겨진 결과(아래로 데이터 더 있음)\nOption Explicit\nSub split_And_Copy_As_Numbered()\nDim colsCnt As Long\n'전체 열 개수 넣을 변수\nDim rngAll As Range\n'주문상품 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim varTemp\n'문자를 쪼개 넣을 배열 변수\nDim r As Long\n'반복구문에 사용할 변수\nDim varS\n'쪼개진 문자 또 쪼개어 넣을 배열변수\nDim lngNo As Long\n'개수를 추출할 변수\nDim s As Long\n'개수만큼 반복할 변수\nDim v As Long\n'동적배열 크기 늘려갈 변수\nDim varR\n()\n'동적배열로 사용할 변수\nDim x As Long\n'열 개수 -1 만큼 반복할 변수\nApplication.ScreenUpd..."}
{"instruction": "Excel VBA code for: (1600) 선택영역의 대칭데이터 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub mirro_The_Selection()\nDim x As Long\n'열(x-축)방향 늘려갈 변수\nDim colsCnt As Long\n'선택영역 열(col)umn(s) 개수(C)ou(nt) 넣을 변수\nDim y As Long\n'열 개수 줄여갈 변수\ncolsCnt = Selection.Columns.Count\n'선택영역의 전체 열 개수를 변수에 넣음\ny = colsCnt\n'변수 y에 전체 열개수를 넣음\nWith Selection\n'선택 영역에서\nFor x = 1 To colsCnt\n'1 부터 1씩 늘려가며 전체 열개수까지 반복\n.Offset(, colsCnt - 1 + x).\nResize(, 1)\n= .Columns(y).\nValue\n'오른쪽으로 열 개수만큼 건너 뛰며 복사\ny = y - 1\n'복사할 영역의 열을 1씩 빼나감\nNext x\nEnd With\nEnd Sub", "context": "선택영역 오른쪽에 선택영역의 대칭 데이터를 복사하는 기능.\n매크로 실행 전\n매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1600) 선택영역의 대칭데이터 복사하기 (엑셀 VBA 매크로)\n재생\n721\n재생 (space/k)\n재생\n00:16\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:16\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n영역을 선택하고 매크로 실행하면 선택영역의..."}
{"instruction": "Excel VBA code for: (1602) 목록별 필터링 후 인쇄 (엑셀 VBA 매크로)", "input": "", "output": "Sub filter_And_Print()\nDim shtNo As Long\n'현재시트 번호(index)를 넣을 변수\nDim rngAll As Range\n'데이터 영역 및 중복없는 목록 넣을 변수\nDim wks As Worksheet\n'임시로 추가한 시트 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nshtNo = ActiveSheet.Index\n'현재 시트의 번호를 변수에 넣음\nSet rngAll = Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'제목 제외한 A열 데이터 변수에\nSet wks = Worksheets.\nAdd\n(after:=Sheets(Sheets.Count))\n'임시 시트를 제일 뒤에 추가\nrngAll.Copy Cells(1, 1)\n'A열을 A1셀 위치에 복사\nWith Columns(1)\n'A열에서\n.\nRemoveDuplicates\n1\n'중복제거\n.\nSort\nCells(1, 1), 1\n'오름차순 정렬\nSet rngAll = .SpecialCells(2)\n'A열의 문자(중복없는 목록)만 변수에 넣음\nEnd With\nSheets(shtNo).Activate\n'데이터 시트 활성화\nWith ActiveSheet\n'현재 시트에서\nFor i = 1 To rngAll.Cells.Count\n'중복없는 목록 개수만큼 반복\n.UsedRange.\nAutoFilter\n1, rngAll.Cells(i)\n'사용영역 1열을 중복없는 목록으로 자동필터\n.\nPrintPreview\n'인쇄 미리보기\n'        .PrintOut\n'실제인쇄(\n화면보기 아닌 실제 인쇄하려면 위행 PrintPreview 삭제후 주석제거)\nNext i\nIf .\nFilterMode\nThen\n'필터 적용되어 있으면\n.ShowAllData\n'모든 데이터를 보이도록 함\n.UsedRange.AutoFilter\n'사용영역의 자동필터 제거\nEnd If\nEnd With\nApplication.\nDisplayAlerts\n= False\n'화면 경고 중지\nSheets(Sheets.Count).\nDelete\n'임시 시트 삭제\nSheets(shtNo).Activate\n'데이터 시트 활성화\nApplication.DisplayAlerts = True\n'화면 경고 복원\nSet rngAll = Nothing\n'개체변수(들) 초기화(메모리 비우기)\nSet wks = Nothing\nEnd Sub", "context": "아래 예제 A열에는 \"불량\", \"보류\", \"우량\"의 세 목록이 뒤섞여 있음. (아래는 예제이므로 3개의 목록만 넣었지만 목록의 개수에는 제한이 없음)\n\"보류\", \"불량\", \"우량\"과 같이 오름차순으로 순차적으로 한 번씩 필터링하고 인쇄를 실행\n매크로 실행 전 데이터가 입력된 시트(아래로 데이터 더 있음)\n매크로 실행 후 출력된 데이터의 결과\nOption Explicit\nSub filter_And_Print()\nDim shtNo As Long\n'현재시트 번호(index)를 넣을 변수\nDim rngAll As Range\n'데이터 영역 및 중복없는 목록 넣을 변수\nDim wks As Worksheet\n'임시로 추가한 시트 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nshtNo = ActiveSheet.Index\n'현재 시트의 번호를 변수에 넣음\nSet rngAll = Range(\"A..."}
{"instruction": "Excel VBA code for: (1603) 메일머지 예제 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub mail_Merge_Sample()\nDim rngAll As Range\n'전체 이름 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nWith Sheets(\"\n2014\n년검진대상\n\")\n'2014년검진대상 시트에서\nSet rngAll = .Range(\"\nB\n2\", .Cells(Rows.Count, \"\nB\n\").End(3))\nEnd With\n'B2 셀부터 B열 마지막 셀까지\nFor Each rngC In rngAll\n'전체 이름의 각 이름을 순환\nRange(\"\nB3\n\") =\nrngC\n'B3 셀에 이름을 넣음\nRange(\"\nE4\n\") = rngC.Offset(,\n1\n)\n'E4 셀에 금액을 넣음\nRange(\"\nB18\n\") =\nrngC\n'B18셀에 이름을 넣음\nActiveSheet.PrintPreview\n'인쇄 미리보기\n'        ActiveSheet.PrintOut\n'실제인쇄(위 PrintPreview 삭제후 주석제거)\nNext rngC\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "메일 머지(동일한 양식에 이름이나 제목만 바꾸어 인쇄하는 것) 기능을 여러번 올렸는데 막상 어려워서 제대로 사용을 못하시는 것 같다. 아래와 같은 코드를 요청한 분이 계셔서 아주 간단히 코드를 작성하여, 누구나(?) 사용할 수 있도록 해보았다. 코드에서 노란색으로 표시한\n시트이름 및 셀 위치\n만 자신의 양식에 맞추어 수정하여 사용하면 된다.\n(아래 내용과 함께 더 많은 메일머지 예제 엑셀파일이 첨부되어 있음)\n매크로 실행 전 양식 시트\n출력될 데이터가 입력된 \"2014년검진대상\"시트\n화면 인쇄된 결과(화살표는 매크로 실행 전과의 구분을 위해 임의로 넣은 것임)\nOption Explicit\nSub mail_Merge_Sample()\nDim rngAll As Range\n'전체 이름 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nWith Sheets(\"\n2014\n년검진대상..."}
{"instruction": "Excel VBA code for: (1604) 각 행의 구역(area) 개수 세기 (엑셀 VBA 매크로)", "input": "", "output": "Sub count_Areas_Number()\nDim rngRow As Range\n'각 열을 넣을 변수\nColumns(\"AA\").ClearContents\n'기존 데이터 삭제\nWith ActiveSheet.UsedRange\n'현재시트 사용 영역에서\nFor Each rngRow In .Rows\n'각 행을 순환\nIf WorksheetFunction.\nCountA\n(rngRow) > 0 Then\n'만일 각 행에 입력된 셀이 있으면\nWith rngRow\n'각 행에서\n.Cells(1).Offset(, .Columns.Count) = .\nSpecialCells(2).Areas\n.Count\nEnd With\n'열 개수만큼 오른쪽으로 간 위치에 문자입력된 영역의 area 개수 입력\nElse\n'빈 행일 경우\nrngRow.Cells(1).Offset(, .Columns.Count) = 0\nEnd If\n'열 개수만큼 오른쪽으로 간 셀에 0 입력\nNext rngRow\nEnd With\nEnd Sub", "context": "각 행에 문자가 입력되어 있음. 연속되는 문자를 1개로 보고 각 행에서 개수를 추출하는 기능. 다른 기능은 함수가 VBA(매크로)보다 손쉬울 때가 많이 있지만, 이 기능은 매크로가 훨 구현하기 쉽다.\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub count_Areas_Number()\nDim rngRow As Range\n'각 열을 넣을 변수\nColumns(\"AA\").ClearContents\n'기존 데이터 삭제\nWith ActiveSheet.UsedRange\n'현재시트 사용 영역에서\nFor Each rngRow In .Rows\n'각 행을 순환\nIf WorksheetFunction.\nCountA\n(rngRow) > 0 Then\n'만일 각 행에 입력된 셀이 있으면\nWith rngRow\n'각 행에서\n.Cells(1).Offset(, .Columns.Count) = .\nSpecialCells(2).Areas\n.Count\nEnd With\n'열 개수만큼 오른쪽으로 간 위..."}
{"instruction": "Excel VBA code for: (1605) 데이터 있는 시트만 별도 파일로 저장하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub save_EachSheet_Into_SeparateFiles_4()\nDim wks As Worksheet\n'각 시트를 넣을 변수\nDim newName As String\n'파일경로 + 날짜 + 시트이름 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveWorkbook\n'활성화된 파일에서\nFor Each wks In Worksheets\n'각 sheet를 순환\nnewName = .\nPath\n& \"\\\" & Date & \" \" & wks.Name & \".xlsx\"\n'활성화된 파일과 동일한 경로 + 시트이름을 변수에 넣음\nIf Len(\nDir\n(newName)) <> 0 Then\n'동일이름의 파일 존재 유무 확인\nMsgBox \"파일이 이미 존재. 기존 파일 삭재후 재시행\", 64, \"동일 파일 존재\"\nExit Sub\n'매크로 종료\nEnd If\nIf wks.Range(\"A1\") <> \"\" Then\n'A1 셀이 빈셀이 아니라면\nwks.Copy\n'시트를 새로운 파일에 복사함\nWith ActiveWorkbook\n'현재 활성화된 파일에서\n.\nSaveAs\nfileName:=newName\n'각 파일을 새로운 이름으로 저장\n.Close\n'저장한 파일을 닫음\nEnd With\nEnd If\nNext wks\nEnd With\nEnd Sub", "context": "1.  A1 셀에 데이터가 있는 시트만 별도의 파일로 저장\n2.  저장될 파일 이름은 현재 날짜 + 시트이름\n3.  매크로 파일과 동일한 폴더에 저장\nSheet1                 Sheet2                  Sheet3                  Sheet4                 Sheet5\n매크로 실행 전 폴더내 매크로 파일\n매크로 실행 후 결과로 생성된 3 개의 파일\nOption Explicit\nSub save_EachSheet_Into_SeparateFiles_4()\nDim wks As Worksheet\n'각 시트를 넣을 변수\nDim newName As String\n'파일경로 + 날짜 + 시트이름 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)정지\nWith ActiveWorkbook\n'활성화된 파일에서\nFor Each wks In Worksheets\n'각 sheet를 순환\nnewName = ..."}
{"instruction": "Excel VBA code for: (1606) 선택영역 각 행에 빈행 삽입하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub insert_Rows_In_Selection_2()\nDim strAddr As String\n'선택영역 셀 주소 넣을 변수\nDim input_Value As String\n'입력값을 넣을 변수\nDim msg As String\n'메시지 넣을 문자 변수\nConst\nintMin As Long=\n1\n'최솟값을 넣을 변수\nConst\nintMax As Long=\n100\n'최댓값을 넣을 변수\nDim colsCnt As Long\n'전체 열개수 넣을 변수\nDim rowsCnt As Long\n'전체 행 개수 넣을 변수\nDim totalRow As Long\n'선택영역 행 x 입력창 값 넣을 변수\nDim varTemp\n'정적배열로 사용할 변수\nDim r As Long\n'행 늘려갈 변수\nDim c As Long\n'열 늘려갈 변수\nDim y As Long\n'배열위치 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nstrAddr = Selection.Address\n'선택영역의 셀주소를 변수에 넣음\n'---------------------------------------------\n' 입력창으로 삽입할 행의 개수 결정하는 코드\n'---------------------------------------------\nDo\n'다음을 실행\ninput_Value =\nInputBox\n(intMin & \" 과 \" & intMax & \" 사이의 숫자를 입력.\")\n'입력창 값을 변수에 넣음\nIf input_Value = \"\" Then Exit Sub\n'입력값 없으면 매크로 중단\nIf\nIsNumeric\n(input_Value) Then\n'입력값이 숫자이면\nIf input_Value >= intMin And input_Value <= intMax Then\nExit Do\n'최솟값보다 크거나 같고, 최댓값보다 작거나 같으면 Do 구문 종료\nEnd If\nEnd If\nmsg = \"번호입력 오류.\" &\nvbCr\n& vbCr\n'메시지창 내용 + 줄바꿈 2번\nmsg = msg & intMin & \" 과 \" & intMax & \" 사이의 숫자를 입력.\"\n'메시지창 내용\nMsgBox msg, 64, \"입력오류\"\n'메시지창 출력\nLoop\n'무한 반복\n'-----------------------------------------\n' 행/열개수, 전체행개수를 추출하는 코드\n'-----------------------------------------\nrowsCnt = Selection.Rows.Count\n'선택영역 행 개수를 변수에 넣음\ncolsCnt = Selection.Columns.Count\n'선택영역 열 개수를 변수에 넣음\ntotalRow = rowsCnt * input_Value + rowsCnt\n'선택영역 행 x 입력창 값 + 행개수를 변수에 넣음\n'-----------------------------------------\n' 1백만 행 넘을 경우 매크로 중단하는 코드\n'-----------------------------------------\nIf totalRow > 1000000 Then\n'삽입될 행이 1000000 행이 넘을 경우\nMsgBox \"삽입될 행이 1000000행을 넘어갑니다.\"\n'메시지 출력\nExit Sub\n'매크로 종료\nEnd If\nReDim varTemp(1\nTo\ntotalRow, 1 To colsCnt)\n'배열크기 재지정\n'--------------------------------------------\n' 선택영역을 배열에 넣었다 셀에 뿌리는 코드\n'--------------------------------------------\ny = 1\n'배열 위치 1부터 시작\nFor r = 1 To rowsCnt\n'행 개수만큼 반복\nFor c = 1 To colsCnt\n'열 개수만큼 반복\nvarTemp(y, c) = Selection.Cells(r, c).FormulaR1C1\n'배열에 선택영역 값을 넣음\nNext c\ny = y + input_Value + 1\n'배열 값 입력될 위치 늘려감\nNext\nWith Selection\n.ClearContents\n'선택의 데이터 삭제\n.Cells(1).Resize(totalRow - rowsCnt, colsCnt).Insert shift:=\nxlDown\nEnd With\n'전체행 - 선택영역 행 개수만큼 행삽입\nRange(strAddr).Cells(1).Resize(totalRow, colsCnt) = varTemp\n'배열값 셀에 뿌림\nEnd Sub", "context": "매크로 실행 전 영역을 먼저 선택한 모습                         매크로 실행 후 결과 (입력창 3 선택 결과)\n위 예제의 경우 매크로 실행 후 입력창에서 3을 넣은 경우\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1606) 선택영역 각 행에 빈행 삽입하기 2 (엑셀 VBA 매크로)\n재생\n1,269\n재생 (space/k)\n재생\n00:30\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:30\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변..."}
{"instruction": "Excel VBA code for: (1607) 중복구역내 불일치 하는 데이터 색으로 표시하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Typo()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngA As Range\n'중복 영역(A)rea을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nIf Cells(r, 1) = Cells(r + 1, 1) And _\nCells(r, 2) = Cells(r + 1, 2) Then\n'A/B열의 값이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nIf i > 0 Then\n'데이터가 위 아래 중복되는 경우\nSet\nrngA = Cells(r, 6).Offset(-i).Resize(i + 1)\n'중복 구역을 변수에 넣음\nCall\npaint_In_Yellow(rngA)\nEnd If\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until\nIsEmpty\n(Cells(r, 1))\n'A열에 빈셀 나올때까지 무한 반복\nSet rngA = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nSub paint_In_Yellow(rngArea As Range)\nDim j As Long\n'반복구문에 사용할 변수\nDim strEach As String\n'rngArea 의 첫 셀 값을 넣을 변수\nDim cnt As Long\n'카운터(c)ou(nt)er 로 사용할 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nstrEach = rngArea.\nCells(1)\n'rngArea 의 첫 셀을 변수에 넣음\nFor j = 1 To 6\n'F열부터 K열까지 6회 반복\nFor Each rngC In rngArea\n'rngArea 의 각 셀을 순환\nIf rngC = strEach Then\n'각 셀값이 strEach일 경우\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nElse\n'셀값이 strEach와 다른 경우\nExit For\n'For 구문 종료\nEnd If\nNext rngC\nIf cnt <> rngArea.\nCount\nThen\n'카운터가 rngArea 셀개수와 일치하지 않으면\nrngArea.Interior.\nColorIndex = 6\n'영역을 노란색으로 칠함\nEnd If\nSet rngArea = rngArea.Offset(, 1)\n'영역을 오른쪽으로 1열 옮김\nstrEach = rngArea.Cells(1)\n'rngArea 의 첫 셀을 변수에 넣음\ncnt = 0\n'재사용 위하여 카운터 초기화\nNext j\nEnd Sub", "context": "A/B열의 반/이름이 일치하는 행의 데이터는 F:K열 까지 위아래 값이 일치해야함.\n사용자 입력 시 오타로 인하여 동일한 반/이름에도 불구하고 F:K열에 다른 데이터가 입력되는 경우가 있음(아래 그림에서 오타를 \"불일치\"라고 가정하여 입력함)\n이와 같이 아래위 데이터가 불일치 하는 경우 이를 색으로 표시.\n매크로 실행 전 (편의상 오타난 셀들은 구분하기 쉽도록 \"불일치\"라고 하여 입력하고 색칠로 표시함)\n매크로 실행 후 결과\nOption Explicit\nSub find_Typo()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngA As Range\n'중복 영역(A)rea을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nr = 2\n'2행 부터 시작\nDo\n'다음을 실행\nIf Cells(r, 1) = Cells(r + 1, 1) And _\nCells(r, ..."}
{"instruction": "Excel VBA code for: (1608) 선택영역의 열을 Alt + 엔터로 셀병합하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub merge_Column_With_Selection()\nDim i As Long\n'열 개수만큼 반복할 변수\nDim varTemp\n'전체 열의 값을 넣을 배열 변수\nDim rngC As Range\n'각 열의 각 셀을 넣을 변수\nDim strU As String\n'Alt + 엔터와 함께 값을 합쳐 넣을 변수\nWith Selection\n'선택 영역에서\nFor i = 1 To .Columns.Count\n'1 부터 열 개수까지 반복\nFor Each rngC In .Columns(i).\nCells\n'각 열의 각 셀을 순환\nIf\nNot\nIsEmpty\n(rngC) Then\n'셀 값이 비어 있지 않다면\nIf strU = \"\" Then\n'만일 strU 가 비어 있다면\nstrU = rngC\n'strU에 셀 값을 넣음\nElse\n'strU가 비어 있지 않다면\nstrU = strU &\nChr(10)\n& rngC\n'Alt + 엔터와 함께 값을 합쳐감\nEnd If\nEnd If\nNext rngC\n.Columns(i).ClearContents\n'열의 값을 모두 삭제\nApplication.\nDisplayAlerts\n= False\n'화면 경고 중지\n.Columns(i).Merge\n'열을 셀병합\nApplication.DisplayAlerts = True\n'화면 경고 복원\n.Columns(i) = strU\n'열에 합쳐진 값을 넣음\nstrU = \"\"\n'재사용 위하여 초기화\nNext i\nEnd With\nEnd Sub", "context": "매크로 실행 전 영역을 선택한 상황                       매크로 실행 후 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1608) 선택영역의 열을 Alt + 엔터로 셀병합하기 (엑셀 VBA 매크로)\n재생\n1,139\n재생 (space/k)\n재생\n00:11\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:11\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\n영역을 선택하고 매크로 ..."}
{"instruction": "Excel VBA code for: (1609) 규칙적으로 행 건너 뛰며 데이터 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub filter_As_Numbered()\nDim rowsCnt As Long\n'전체 열(rows)(C)ou(nt) 개수를 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim r As Long\n'행(r)ow을 1씩 늘려갈 변수\nDim varTemp\n'추출한 값을 임시(Temp)로 넣을 배열(var) 변수\nDim v As Long\n'배열(v)ar 위치(1차원 즉 행방향) 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nIf Range(\"E2\") <> \"\" Then\n'E2 셀이 빈셀이 아니면\nRange(\"E2\", Cells(Rows.Count, \"E\").End(3)).ClearContents\nEnd If\n'E2셀 아래 모든 데이터 삭제\nrowsCnt = Cells(Rows.Count, \"A\").End(3).\nRow - 1\n'전체 열 개수를 변수에 넣음(마지막행 -1)\nReDim varTemp(1 To rowsCnt, 1 To 1)\n'배열크기 재지정\nr = 2\n'2행부터 시작\nDo\n'다음을 실행\nv = v + 1\n'배열 위치 1씩 늘려감\nvarTemp(v, 1) = Cells(r, 1)\n'배열에 셀 값을 넣음\nr = r + Range(\"D2\")\n'D2 셀의 값 만큼 행을 건너 뜀\nLoop Until\nIsEmpty\n(Cells(r, 1))\n'A열에 빈셀 나올때까지 무한 반복\nRange(\"E2\").Resize(rowsCnt, 1) = varTemp\n'배열에 입력된 추출된 값을 셀에 뿌림\nEnd Sub", "context": "매크로 실행 전 (아래로 1000행까지 데이터 있음)\n매크로 실행 후 결과 (아래로 추출한 데이터 더 있음)\nOption Explicit\nSub filter_As_Numbered()\nDim rowsCnt As Long\n'전체 열(rows)(C)ou(nt) 개수를 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim r As Long\n'행(r)ow을 1씩 늘려갈 변수\nDim varTemp\n'추출한 값을 임시(Temp)로 넣을 배열(var) 변수\nDim v As Long\n'배열(v)ar 위치(1차원 즉 행방향) 늘려갈 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nIf Range(\"E2\") <> \"\" Then\n'E2 셀이 빈셀이 아니면\nRange(\"E2\", Cells(Rows.Count, \"E\").End(3)).ClearContents\nEnd If\n'E2셀 아래 모든 데이터 삭제\nrowsCnt = Cells..."}
{"instruction": "Excel VBA code for: (1610) Old 와 New 두 시트의 유일한 데이터, 중복데이터 및 중복 없는 통합데이터 추출 7 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Duplicated_Data_6()\nDim s As Integer\n'시트(s)heet 개수 늘려갈 변수\nDim colsCnt As Integer\n'전체 열 개수 넣기 위한 변수\nDim varCol As Variant\n'중복삭제 열 개수 array 넣을 배열변수\nDim v As Long\n'중복삭제 array 반복할 변수\nDim varO As Variant\n'Old 시트내 A열 넣을 배열변수\nDim varOld As Variant\n'Old 시트 전체자료 넣기위한 배열변수\nDim varN As Variant\n'New 시트내 A열 넣을 변수\nDim varNew As Variant\n'New 시트 전체자료 넣기 위한 배열변수\nDim rowsCnt As Long\n'Old + New 전체행 넣을 변수\nDim varBoth\n'양쪽(B)oth에 중복된 자료 넣을 배열\nDim vO As Variant\n'varO 내 각 값을 넣을 배열변수\nDim vN As Variant\n'varN 내 각 값을 넣을 배열변수\nDim i As Long\n'Old 배열내 행을 늘려나갈 변수\nDim j As Long\n'New 배열내 행을 늘려갈 변수\nDim x As Integer\n'열 개수 늘려갈 변수\nDim cnt As Long\n'카운터로 사용할 변수\nDim r As Long\n'배열 크기 늘려갈 변수\nWith WorksheetFunction\n'엑셀함수\nIf .CountA(Range(\"A2:A3\")) < 2 Or _\n.CountA(Sheets(2).Range(\"A2:A3\")) < 2 Then\n'1번 또는 2번시트 A2:A3셀이 빈 경우\nMsgBox \"작업할 데이터가 부족합니다.\", 64, \"데이터 입력 오류\"\nExit Sub\n'메시지 출력 후 매크로 종료\nEnd If\nEnd With\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시)정지\n.Calculation =\nxlCalculationManual\n'셀계산 수동으로 전환\nEnd With\nFor s = 1 To 2\n'1 ~ 2번 시트에서 반복\nSheets(s).UsedRange.Offset(1).Interior.ColorIndex =\nxlNone\nNext s\n'제목행 제외한 모든 색채우기 제거\nSheets(3).UsedRange.Clear\n'Sheet3의 기존 데이터 삭제\n'-------------------------------------------------\n'열 개수 추출하고 Old / New 시트의 중복을 제거\n'-------------------------------------------------\ncolsCnt = Sheets(1).UsedRange.Columns.Count\n'전체 열 개수를 변수에 넣음\nReDim\nvarCol(0 To colsCnt - 1)\n'배열크기 재지정\nFor v = 0 To colsCnt - 1\n'전체 열 개수만큼 반복\nvarCol(v) = v + 1\n'배열에 열 개수를 넣음\nNext v\nFor s = 1 To 2\n'Old와 New 시트의 중복 제거\nSheets(s).UsedRange.\nRemoveDuplicates\n_\nColumns:=(varCol), Header:=xlYes\n'전체열 모두 일치 시 중복제거\nNext s\n'--------------------------------------------------------\n'각 배열에 제목 제외한 Old / New 시트의 데이터를 넣음\n'--------------------------------------------------------\nWith Sheets(1).UsedRange\n'1번 시트 사용영역에서\nvarO = Range(\"A2\", _\nCells(Rows.Count, \"A\").End(3))\n'제목 제외한 A열을 배열에 넣음\nvarOld = .Offset(1).Resize(.Rows.Count - 1)\nEnd With\n'제목빼고 배열에 넣음\nWith Sheets(2)\n'2번 시트\nvarN = Range(.Range(\"A2\"), _\n.Cells(Rows.Count, \"A\").End(3))\n'A열을 배열에 넣음\nWith .UsedRange\n'사용 영역에서\nvarNew = .Offset(1).Resize(.Rows.Count - 1)\n'제목빼고 배열에 넣음\nEnd With\nEnd With\n'---------------------------------------\n'varBoth 배열의 크기를 결정하는 코드\n'---------------------------------------\nIf\nUBound\n(varOld, 1) > UBound(varNew, 1) Then\n'Old 행이 더 크면\nrowsCnt = UBound(varOld, 1)\n'Old행을 rowsCnt에 넣고\nElse\n'New 행이 더 크거나 같으면\nrowsCnt = UBound(varNew, 1)\n'New 행을 rowsCnt에 넣음\nEnd If\nReDim varBoth(1 To rowsCnt, 1 To colsCnt)\n'배열크기 재지정\n'------------------------------------------------------\n' 먼저 \"이름\"이 일치하는지 검색 후 나머지 열들을 검사\n'------------------------------------------------------\nFor Each vO In varO\n'Old A열 각 셀을 순환\ni = i + 1\n'Old A열 행을 늘려감\n﻿\n﻿\nDo\n'다음을 실행﻿\nFor Each vN In varN\n'New A열 각 셀을 순환\nj = j + 1\n'New A열 행을 늘려감\nIf vO = vN Then\n'이름이 일치하면\nFor x = 2 To colsCnt\n'2 ~ 마지막 열까지 반복\nIf varOld(i, x) = varNew(j, x) Then\n'값이 같다면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nElse\n:\ncnt = 0\n'카운터 값을 초기화\nExit\nFor\n'값이 다르면 for 구문 종료\nEnd If\nNext x\n'---------------------------------------------------------\n' 중복 데이터를 varBoth에 넣고 varOld / varNew에서는 삭제\n'---------------------------------------------------------\nIf cnt = colsCnt - 1 Then\n'2 ~ 마지막 열까지 같다면\ncnt = 0\n'재사용 위하여 초기화\n﻿\n﻿\nCells(i + 1, 1).Resize(, colsCnt).Interior.\nColorIndex = 6\n'Old 시트의 중복 데이터에 노란 색채우기\nSheets(2).Cells(j + 1, 1).Resize(, colsCnt).Interior.ColorIndex = 6\n'New 시트의 중복 데이터에 노란 색채우기﻿\nr = r + 1\n'배열 개수 1씩 늘려감\nFor x = 1 To colsCnt\n'전체 열 개수만큼 반복\nvarBoth(r, x) = varOld(i, x)\n'중복데이터를 varBoth에 넣음\nvarOld(i, x) =\nEmpty\n'varOld 내의 중복데이터 삭제\nvarNew(j, x) = Empty\n'varNew 내의 중복데이터 삭제\nNext x\nExit Do\n'Do 구문종료\nEnd If\nEnd If\nNext vN\nLoop Until True\n'1회만 실행 후 종료\nj = 0\n'New의 행값 초기화\nNext vO\n'-------------------------------------------------------------\n' varOld, varNew, varBoth 배열에 추출한 값을 All 시트에 통합\n'-------------------------------------------------------------\n﻿\nRows(1).Copy Sheets(3).Cells(1, 1)\n'제목행 Sheet3에 복사\nWith Sheets(3).Cells(Rows.Count, \"A\")\n.End(3)(2).Resize(UBound(varOld, 1), _\ncolsCnt) = varOld\n'varOld 배열값을 All에 뿌림\nIf r > 0 Then\n'배열이 비어 있지 않으면\n.End(3)(2).Resize(UBound(varBoth, 1), _\ncolsCnt) = varBoth\n'varBoth 배열값을 All에 뿌림\nEnd If\n.End(3)(2).Resize(UBound(varNew, 1), colsCnt) = varNew\n'varNew 배열값을 All에 뿌림\nEnd With\n'-----------------------------------------------------\n' ALL 시트의 서식을 설정하고, 정렬한 뒤 열너비 맞춤\n'-----------------------------------------------------\nWith Sheets(3)\n'ALL 시트에서\n.Columns(\"E\").\nNumberFormat\n= \"yyyy-mm-dd\"\n'E열의 서식을 날짜로 설정\n.UsedRange.\nSort\n.[A1], 1, Header:=True\n'이름순으로 오름차순 정렬\n.Columns.AutoFit\n'열너비 자동 맞춤\nEnd With\nWith Application\n.Calculation =\nxlCalculationAutomatic\n'셀계산 자동으로 복원\n.ScreenUpdating = True\n'화면업데이트 복원\nEnd With\nMsgBox \"데이터 작업이 완료되었습니다.\"\n'완료 메시지 출력\nEnd Sub", "context": "(\n양쪽시트에 중복된 데이터는 삭제되지 않지만, 한 시트에 동일한 데이터가 두 개 이상 있으면 한 개만 남겨두고 나머지는 삭제되므로 주의\n.)\nOld 시트와 New 시트에 여러 데이터가 있음.\n매크로 실행 후 Old시트와 New 시트에 중복된 데이터를 노란색으로 표시하여 준다.\n매크로 실행 후 Old시트와 New 시트에 색이 칠해지지 않은 데이터는 그 시트에만 있는 중복이 없는 유일한 데이터를 의미.\nOld 시트에만 있는 유일한 데이터 + Old/New 양쪽에 중복된 데이터 + New 시트에만 있는 유일한 데이터(즉 중복이 없는 합쳐진 통합 데이터)를 ALL시트에 추출하는 기능.\n최소 2행 이상의 데이터가 있어야 하며, 데이터의 행 또는 열 개수 제한이 없음.\n전체 행에서 1자만 틀려도 전체행은 다른 데이터로 취급한다\n.\n매크로 사용이 익숙치 않으면 첨부된\n엑셀 예제파일을 내려 받고 자신의 데이터를 Old 시트와 New 시트에 복사하여 붙여넣고 매크로 버튼만 클릭\n하면 된다. 본인의..."}
{"instruction": "Excel VBA code for: (1611) 선택영역 행 값을 합쳐서 붙여넣기 (엑셀 VBA 매크로)", "input": "", "output": "Sub paste_And_Concat()\nDim rngSel As Range\n'선택영역 전체를 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim v As Long\n'배열크기 늘려갈 변수\nDim varTemp\n'각 행의 문자 넣을 배열 변수\nDim strU As String\n'각 행의 문자를 합쳐 넣을 변수\nOn Error\nResume Next\n'에러 발생해도 다음 코드 진행\nSet rngSel = Application.InputBox(\"마우스로 복사될 위치를 선택하시오!\",\nType:=8\n)\nIf rngSel Is Nothing Then Exit Sub\n'취소 선택시 매크로 중단\nOn Error GoTo 0\n'에러검출기능 복원\nReDim varTemp(1 To Selection.Columns.Count)\n'배열크기를 선택영역 열크기로 재지정\nFor i = 1 To Selection.Count\n'선택영역 셀 개수만큼 반복\nFor Each rngC In Selection.\nRows(i).Cells\n'선택영역 각 행의 각 셀을 순환\nv = v + 1\n'배열크기 1씩 늘려감\nvarTemp(v) = rngC\n'배열에 각 셀 값을 넣음\nNext rngC\nv = 0\n'재사용 위하여 초기화\nstrU =\nJoin\n(varTemp, \" \")\n'공백과 함께 배열값 합침\nIf\nIsEmpty\n(rngSel) Then\n'복사될 위치의 셀이 빈셀이면\nrngSel = strU\n'선택영역 행의 합쳐진 값만 복사\nElse\n'복사될 위치의 셀이 빈셀이 아니라면\nrngSel = rngSel & \" \" & strU\n'복사될 위치 값 + 공백 + 선택영역 행 합쳐진 값\nEnd If\nSet rngSel = rngSel.Offset(1)\n'복사될 위치 한 행 아래로 내림\nstrU = \"\"\n'재사용 위하여 초기화\nNext\nSet rngSel = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "선택영역의 각 행 값을 복사될 위치의 셀 값과 공백(space)으로 합쳐 복사하는 기능.\n매크로 실행 전 영역을 선택한 모습                           매크로 실행 후 A1 셀 선택하여 복사한 결과\n매크로 실행 전 영역을 선택한 모습                           매크로 실행 후 A6 셀 선택하여 복사한 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1611) 선택영역 행 값을 합쳐서 붙여넣기 (엑셀 VBA 매크로)\n재생\n968\n재생 (space/k)\n재생\n00:20\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:20\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발..."}
{"instruction": "Excel VBA code for: (1613) 셀병합 후 Alt + Enter로 합치기 (엑셀 VBA 매크로)", "input": "", "output": "Sub merge_And_Alt_Enter()\nDim colsCnt As Long\n'전체 열 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngA As Range\n'중복 영역을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열개수를 변수에 넣음\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nWith Application\n.DisplayAlerts = False\n'화면 경고 중지\nCells(r - i, 1).Resize(i + 1).\nMerge\n'A 열을 셀병합\n.DisplayAlerts = True\n'화면 경고 복원\nEnd With\nIf i > 0 Then\n'데이터가 위아래로 중복될 경우\nSet rngA = Cells(r - i, 2).Resize(i + 1, colsCnt - 1)\n'B열부터 중복 구역을 변수에\nCall\nalt_Enter(rngA)\n'전체 열을 Alt + Enter로 셀병합하는 코드 호출\nEnd If\ni = 0\n'재사용 위하여 초기화\nEnd If\nr = r + 1\n'행을 1씩 증가\nLoop Until Cells(r, 1) = \"\"\n'A열에 빈셀 나올때까지 무한 반복\nSet rngA = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nSub alt_Enter(rngArea As Range)\nDim i As Long\n'열 개수만큼 반복할 변수\nDim varTemp\n'전체 열의 값을 넣을 배열 변수\nDim rngC As Range\n'각 열의 각 셀을 넣을 변수\nDim strU As String\n'Alt + 엔터와 함께 값을 합쳐 넣을 변수\nWith rngArea\n'rngArea 영역에서\nFor i = 1 To .Columns.Count\n'1 부터 열 개수까지 반복\nFor Each rngC In .Columns(i).\nCells\n'각 열의 각 셀을 순환\nIf\nNot\nIsEmpty\n(rngC) Then\n'셀 값이 비어 있지 않다면\nIf strU = \"\" Then\n'만일 strU 가 비어 있다면\nstrU = rngC\n'strU에 셀 값을 넣음\nElse\n'strU가 비어 있지 않다면\nstrU = strU &\nChr(10)\n& rngC\n'Alt + 엔터와 함께 값을 합쳐감\nEnd If\nEnd If\nNext rngC\n.Columns(i).ClearContents\n'열의 값을 모두 삭제\nApplication.\nDisplayAlerts\n= False\n'화면 경고 중지\n.Columns(i).Merge\n'열을 셀병합\nApplication.DisplayAlerts = True\n'화면 경고 복원\n.Columns(i) = strU\n'열에 합쳐진 값을 넣음\nstrU = \"\"\n'재사용 위하여 초기화\nNext i\nEnd With\nEnd Sub", "context": "A열에 중복인 데이터를 1개만 남겨두고 셀병합\nB열 부터 마지막 열까지는 셀병합하고 Alt + Enter로 값을 합쳐 넣음\n매크로 실행 전 (아래로 계속 데이터 더 있음)\n매크로 실행 후 결과\nOption Explicit\nSub merge_And_Alt_Enter()\nDim colsCnt As Long\n'전체 열 개수 넣을 변수\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nDim rngA As Range\n'중복 영역을 넣을 영역변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\ncolsCnt = ActiveSheet.UsedRange.Columns.Count\n'전체 열개수를 변수에 넣음\nr = 2\n'2행 부터 시작\nDo\nIf Cells(r, 1) = Cells(r + 1, 1) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n..."}
{"instruction": "Excel VBA code for: (1615) 순차적으로 1행씩 채우기 (엑셀 VBA 매크로)", "input": "", "output": "Sub fill_Multiple_Blocks()\nDim r As Long\n'행방향 반복할 변수\nDim c As Long\n'열방향 반복할 변수\nWith\nApplication\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\n.Calculation = xlCalculationManual\n'셀 계산 수동으로 전환\nIf Range(\"B4\") = \"\" Then\n'B4셀에 데이터가 있을 경우\nFor r = 4 To 16\nStep 6\n'행방향으로 6행씩 건너 뛰며 3회 반복\nFor c = 2 To 12 Step 5\n'열방향으로 5열씩 건너 뛰며 3회 반복\nCells(r, c).Resize(, 3) = Cells(r, c).Resize(, 3).Offset(4)\n.Value\nNext c\n'각 구역에 날짜값 입력된 행을 복사\nNext r\nElse\n'B4 셀이 비어 있는 경우\nFor r = 8 To 20 Step 6\n'행방향으로 6행씩 건너 뛰며 3회 반복\nFor c = 2 To 12 Step 5\n'열방향으로 5열씩 건너 뛰며 3회 반복\nIf Cells(r - 1, c) = \"\" Then\n'데이터가 꽉 차지 않은 경우\nCells(r, c).\nEnd(3)\n(2)\n.Resize(, 3) = Cells(r, c).Resize(, 3).Value\nElse\n'종단셀 윗방향 바로 아래셀에 날짜행 복사\nMsgBox \"데이터가 찼습니다. 비우고 재실행\", 64, \"공간 없음\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nNext c\nNext r\nEnd If\n.ScreenUpdating = True\n'화면 업데이트 복원\n.Calculation = xlCalculationAutomatic\n'셀 계산 자동으로 복원\nEnd With\nEnd Sub\n\nSub delete_All()\nDim msg As String\n'메시지 넣을 변수\nDim r As Long\n'행방향 반복할 변수\nDim c As Long\n'열방향 반복할 변수\nmsg = MsgBox(\"정말 삭제하시겠습니까?\", vbYesNo + vbCritical, \"데이터 삭제\")\n'정말 삭제할지 확인하는 메시지창 출력\nIf vbYes Then\n'Yes 선택 시\nFor r = 4 To 16 Step 6\n'행방향으로 6행씩 건너 뛰며 3회 반복\nFor c = 2 To 12 Step 5\n'열방향으로 5열씩 건너 뛰며 3회 반복\nCells(r, c).Resize(4, 3).\nClearContents\n'각 구역의 기존 데이터삭제\nNext c\nNext r\nEnd If\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 값이 순차적으로 복사되며 채워진다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1615) 순차적으로 1행씩 채우기 (엑셀 VBA 매크로)\n재생\n1,562\n재생 (space/k)\n재생\n00:23\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:23\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라이선스\n디버그 정보 다운로드\n고화질 재생이 가능한 영상입니다.\n설정에서 해상도를 변경해보세요.\n더 알아보기\n00:00\n동영상의 순서별 설명 :\nC8 셀 및 색칠해진 셀에는 =TODAY() 함수가 입력되어 당일 날짜가..."}
{"instruction": "Excel VBA code for: (1616) 일치하는 값 찾아 동일행에 배치하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Matching_Data()\nDim varL\n'왼쪽(L)eft 영역 첫 번째열 넣을 변수\nDim varLeft\n'왼쪽(Left) 영역 전체를 넣을 변수\nDim varR\n'오른쪽(R)ight 영역 첫 번째열 넣을 변수\nDim varRight\n'오른쪽(Right) 영역 전체를 넣을 변수\nDim vL\n'varL 배열내 각 값을 순환할 변수\nDim vR\n'varR 배열내 각 값을 순환할 변수\nDim l As Long\n'왼쪽(l)eft 위치 더해갈 변수\nDim r As Long\n'오른쪽(r)right 위치 더해갈 변수\nDim x As Long\n'열 방향 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nActiveSheet.\nCopy\n'원본 데이터 보존위해 시트 복사\nvarL = Range(\"A1\", Cells(Rows.Count, \"A\").End(3))\n'왼쪽 영역 첫 번째열을 변수에\nvarLeft = Range(\"A1\").\nCurrentRegion\n'왼쪽 영역을 변수에 넣음\nvarR = Range(\"E1\", Cells(Rows.Count, \"E\").End(3))\n'오른쪽 영역 첫 번째열을 변수에\nvarRight = Range(\"E1\").CurrentRegion\n'오른쪽 영역을 변수에 넣음\nRange(\"E1\").CurrentRegion.\nClearContents\n'오른쪽 영역 데이터 삭제\nFor Each vL In varL\n'왼쪽 영역 배열내 각 값을 순환\nl = l + 1\n'행방향 1씩 늘려감\nFor Each vR In varR\n'오른쪽 영역 배열내 각 값을 순환\nr = r + 1\n'행방향 1씩 늘려감\nIf vL = vR Then\n'첫 열의 값이 일치할 경우\nFor x = 1 To 3\n'2 ~ 전체 열 개수만큼 반복\nCells(l, 4 + x) = varRight(r, x)\n'셀에 배열의 값 뿌림\nNext x\nExit For\n'For 구문 종료\nEnd If\nNext vR\nr = 0\n'재사용 위하여 초기화\nNext vL\nMsgBox \"매크로가 종료되었습니다. ^^\"\n'종료 메시지창 출력\nEnd Sub", "context": "왼쪽 A열의 데이터와 오른쪽 E열 데이터의 행을 일치시키는 기능.\n매크로 실행 전\n매크로 실행 후 결과\nSub find_Matching_Data()\nDim varL\n'왼쪽(L)eft 영역 첫 번째열 넣을 변수\nDim varLeft\n'왼쪽(Left) 영역 전체를 넣을 변수\nDim varR\n'오른쪽(R)ight 영역 첫 번째열 넣을 변수\nDim varRight\n'오른쪽(Right) 영역 전체를 넣을 변수\nDim vL\n'varL 배열내 각 값을 순환할 변수\nDim vR\n'varR 배열내 각 값을 순환할 변수\nDim l As Long\n'왼쪽(l)eft 위치 더해갈 변수\nDim r As Long\n'오른쪽(r)right 위치 더해갈 변수\nDim x As Long\n'열 방향 반복할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시)중지\nActiveSheet.\nCopy\n'원본 데이터 보존위해 시트 복사\nvarL = Range(\"A1\", Cells(Rows...."}
{"instruction": "Excel VBA code for: (1617) 숫자만 남겨 두고 왼쪽으로 밀기 (엑셀 VBA 매크로)", "input": "", "output": "Sub shift_Number_To_Left()\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nFor Each rngC In ActiveSheet.\nUsedRange\n'현재시트 사용영역의 각 셀을 순환\nIf Not\nIsNumeric\n(rngC) Then\n'셀 값이 숫자 아니라면\nrngC = vbNullString\n'셀에 공백을 넣음\nEnd If\nNext rngC\nActiveSheet.UsedRange.SpecialCells(4).Delete shift:=xlToLeft\n'현지시트 사용영역 공백셀을 왼쪽으로 밀며 삭제\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub shift_Number_To_Left()\nDim rngC As Range\n'각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nFor Each rngC In ActiveSheet.\nUsedRange\n'현재시트 사용영역의 각 셀을 순환\nIf Not\nIsNumeric\n(rngC) Then\n'셀 값이 숫자 아니라면\nrngC = vbNullString\n'셀에 공백을 넣음\nEnd If\nNext rngC\nActiveSheet.UsedRange.SpecialCells(4).Delete shift:=xlToLeft\n'현지시트 사용영역 공백셀을 왼쪽으로 밀며 삭제\nEnd Sub..."}
{"instruction": "Excel VBA code for: (1619) 괄호안의 단어 중복 시 삭제 (엑셀 VBA 매크로)", "input": "", "output": "Sub remove_Parenthesis_When_Matched()\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim varL\n'왼쪽(L)eft 주소 쪼개 넣을 배열 변수\nDim varR\n'오른쪽(R)ight 주소 쪼개 넣을 배열 변수\nDim strL As String\n'왼쪽(L)eft 주소 넣을 문자(str)ing형변수\nDim strR As String\n'오른쪽(R)ight 주소 넣을 문자형\n(str)ing\n변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nWith Columns(\"B\")\n'B열에서\n.ClearContents\n'기존 데이터삭제\nColumns(\"A\").\nCopy\n.Cells(1, 1)\n'A열 복사하여 B열에 붙여넣기\nEnd With\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'A열 데이터 영역 각 셀을 순환\nIf InStr(rngC, \"(\") Then\n'셀이 괄호( 를 포함하고 있다면\nstrL =\nSplit\n(rngC, \"(\")\n(0)\n'셀의 문자를 ( 로 쪼개고 첫 값을 변수에 넣음\nvarL = Split(strL, \" \")\n'첫 문자를 공백으로 쪼개어 배열에 넣음\nstrL = varL(\nUBound\n(varL))\n'배열의 마지막 값을 변수에 넣음\nstrR = Split(rngC, \")\")(0)\n'셀의 문자를 ) 로 쪼개고 첫 값을 변수에 넣음\nvarR = Split(strR, \"(\")\n'첫 문자를 공백으로 쪼개어 배열에 넣음\nstrR = varR(UBound(varR))\n'배열의 마지막 값을 변수에 넣음\nEnd If\nIf strL = strR Then\n'괄호 왼쪽과 괄호안의 문자가 일치하면\nrngC.Next.\nReplace\n\"(*)\", \"\"\n'괄호 포함한 모든 괄호안의 문자 삭제\nEnd If\nNext rngC\nColumns.AutoFit\n'열너비 자동 맞춤\nEnd Sub", "context": "1.  괄호 앞의 동(洞)과 괄호 안의 동이 일치 시 괄호 포함한 괄호 안의 단어를 모두 삭제하는 기능\n2.  A2셀과 같이 괄호 앞(방배1동)과 괄호 내(방배동)의 문자가 일치하지 않으면 삭제하지 않음\n매크로 실행 전 (아래로 데이터 더 있음) - 삭제될 단어는 구분의 편의를 위해 미리 색칠해 놓음\n매크로 실행 후 결과\nOption Explicit\nSub remove_Parenthesis_When_Matched()\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim varL\n'왼쪽(L)eft 주소 쪼개 넣을 배열 변수\nDim varR\n'오른쪽(R)ight 주소 쪼개 넣을 배열 변수\nDim strL As String\n'왼쪽(L)eft 주소 넣을 문자(str)ing형변수\nDim strR As String\n'오른쪽(R)ight 주소 넣을 문자형\n(str)ing\n변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nWith..."}
{"instruction": "Excel VBA code for: (1620) 전화번호만 추출하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub extract_Phone_Numbers()\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim i As Long\nDim strU As String\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nColumns(\"B\").ClearContents\n'B열에서 기존 데이터삭제\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'A열 데이터 영역 각 셀을 순환\nFor i = 1 To Len(rngC)\n'각 셀의 문자 길이 만큼 반복\nIf\nMid\n(rngC, i, 1)\nLike\n\"\n[0-9 -]\n\" Then\n'문자가 숫자, 공백 또는 - 이면\nstrU = strU & Mid(rngC, i, 1)\n'문자를 합쳐감\nEnd If\nNext i\nrngC.Next =\nTrim\n(strU)\n'B열에 좌우공백 제거 후 입력\nstrU = \"\"\n'재사용 위하여 초기화\nNext rngC\nColumns(\"B\").AutoFit\n'B열 열너비 자동 맞춤\nEnd Sub", "context": "​\n매크로 실행 전 (아래로 데이터 더 있음)\n매크로 실행 후 결과\nOption Explicit\nSub extract_Phone_Numbers()\nDim rngC As Range\n'각 셀(C)ell 을 넣을 변수\nDim i As Long\nDim strU As String\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nColumns(\"B\").ClearContents\n'B열에서 기존 데이터삭제\nFor Each rngC In Range(\"A2\", Cells(Rows.Count, \"A\").End(3))\n'A열 데이터 영역 각 셀을 순환\nFor i = 1 To Len(rngC)\n'각 셀의 문자 길이 만큼 반복\nIf\nMid\n(rngC, i, 1)\nLike\n\"\n[0-9 -]\n\" Then\n'문자가 숫자, 공백 또는 - 이면\nstrU = strU & Mid(rngC, i, 1)\n'문자를 합쳐감\nEnd If\nNext i\nrngC.Next =\nTrim\n(s..."}
{"instruction": "Excel VBA code for: (1621) 텍스트 파일 가져와 계산하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub bring_All_Animals()\nDim strFilter As String\n'필터링될 파일 확장자 넣을 변수\nDim fileNames As Variant\n'모든 파일 넣을 배열 변수\nDim fileName As Variant\n'경로포함한 각 파일을 넣을 변수\nDim wkb As Workbook\n'workbook을 넣을 변수\nDim strFile As String\n'파일 이름과 확장자만 넣을 변수\nChDir\nThisWorkbook.Path\n'매크로 실행파일과 동일한 경로 기준\nstrFilter = \"Text Files (*.txt),*.txt*\"\n'txt 파일만 선택되도록 함\nfileNames = Application.\nGetOpenFilename\n(strFilter, , _\n\"엑셀 파일(들)을 선택\", MultiSelect:=True)\n'텍스트 파일(들)을 선택\nIf TypeName(fileNames) = \"Boolean\" Then Exit Sub\n'취소 선택 시 매크로 종료\nFor Each fileName In fileNames\n'선택한 각 텍스트 파일을 순환\nSet wkb = Workbooks.Open(fileName)\n'파일을 열고 개체변수에 넣음\nstrFile = Mid(fileName,\nInStrRev\n(fileName, \"\\\") + 1)\n'파일 이름과 확장자만 추출하여 변수에 넣음\nActiveSheet.Name = strFile\n'시트의 이름을 파일이름으로 변경\nCall\ncalculate_Val\n'계산을 수행하는 하위 프로시저 호출\nWith\nWorkbooks\n(\"bring_All_Animals.xlsm\")\n'매크로파일에서\nActiveSheet.Copy After:=.Sheets(.Sheets.Count)\n'제일 뒤에 시트 추가하며 복사\nEnd With\nwkb.Close False\n'파일을 저장없이 닫음\nNext fileName\nSheets(1).Activate\n'매크로 버튼이 있는 Sheet1 을 활성화\nSet wkb = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nSub calculate_Val()\nDim kalchi As Range\n'갈치 넣을 변수\nDim doeji As Range\n'돼지 넣을 변수\nDim domi As Range\n'도미 넣을 변수\nDim kirin As Range\n'기린 넣을 변수\nDim varTemp(\n1 To\n6\n,\n1 To 6\n)\nAs Single\n'가로6 세로 6의 배열 선언\nDim r As Long\n'행 반복에 사용할 변수\nDim c As Long\n'열 반복에 사용할 변수\nWith Rows(1)\n'1행에서\nSet kalchi = .\nFind\n(What:=\"갈치\", Lookat:=xlPart)\n'갈치를 변수에 넣음\nSet doeji = .Find(What:=\"돼지\", Lookat:=xlPart)\n'돼지를 변수에 넣음\nSet domi = .Find(What:=\"도미\", Lookat:=xlPart)\n'도미를 변수에 넣음\nSet kirin = .Find(What:=\"기린\", Lookat:=xlPart)\n'기린을 변수에 넣음\nEnd With\nIf kalchi\nIs\nNothing\nOr doeji Is Nothing Or _\ndomi Is Nothing Or kirin Is Nothing Then\n'검색에 일치하는 값이 없을 경우\nMsgBox \"찾으려는 동물이 없습니다.\", 64, \"데이터 에러\"\nEnd\n'메시지 출력 후 전체 매크로 종료\nEnd If\nr = 2\n'2행 부터 시작\nFor c = 1 To 6\n'1 부터 1씩 증가하며 6회 반복\nIf domi.Offset(r) <> \"**\" And kalchi.Offset(r) <> \"**\" Then\n'**가 아니라면\nCells(c, 10) = domi.Offset(r) + kalchi.Offset(r) '\n도미 + 갈치 값을 입력\nCells(c, 12) = domi.Offset(r) - kalchi.Offset(r)\n'도미 - 갈치 값을 입력\nEnd If\nIf domi.Offset(r) <> \"**\" And doeji.Offset(r) <> \"**\" Then\n'**가 아니라면\nCells(c, 11) = domi.Offset(r) + doeji.Offset(r)\n'도미 + 돼지 값을 입력\nCells(c, 13) = domi.Offset(r) - doeji.Offset(r)\n'도미 - 돼지 값을 입력\nEnd If\nIf kalchi.Offset(r) <> \"**\" And kirin.Offset(r) <> \"**\" And _\ndoeji.Offset(r) <> \"**\" Then\n'**가 아니라면\nCells(c, 14) = (kalchi.Offset(r) * kirin.Offset(r)) - doeji.Offset(r)\n'갈치*기린-돼지 값을 입력\nCells(c, 15) = kalchi.Offset(r) - (kirin.Offset(r) * doeji.Offset(r))\n'갈치-기린*돼지 값을 입력\nEnd If\nr = r + 1\n'행을 1씩 더해감\nNext c\nColumns(\"A:I\").Delete\n'임시로 값을 불러온 영역을 삭제\nEnd Sub", "context": "1.  폴더내의 텍스트 파일을 가져와 위와 같이 계산 하여 넣는 것이 목표\n2.  아래 텍스트 파일에서 보듯 열의 위치가 고정되지 않고 불규칙함\n3.  ** 로 표시된 항목의 경우 값의 계산에서 제외\n4.  시트를 추가하며 값을 입력하고 시트이름은 파일 이름으로 함\n폴더내 텍스트 파일\n폴더내 텍스트 파일\n매크로 실행 전\n매크로 실행 후 생성된 시트\n매크로 실행 후 생성된 시트\nOption Explicit\nSub bring_All_Animals()\nDim strFilter As String\n'필터링될 파일 확장자 넣을 변수\nDim fileNames As Variant\n'모든 파일 넣을 배열 변수\nDim fileName As Variant\n'경로포함한 각 파일을 넣을 변수\nDim wkb As Workbook\n'workbook을 넣을 변수\nDim strFile As String\n'파일 이름과 확장자만 넣을 변수\nChDir\nThisWorkbook.Path\n'매크로 실행파일과 동일한 경로 기..."}
{"instruction": "Excel VBA code for: (1622) 반복적 패턴으로 숫자 이동하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub move_As_Patterned()\nDim colsCnt As Long\n'열 개수를 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim y As Long\n'행 늘려갈 변수\nDim rngLeft As Range\n'왼쪽 영역을 넣을 변수\nDim rngRight As Range\n'오른쪽 영역을 넣을 변수\nDim rowsCnt As Long\n'행 개수를 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim cnt As Long\n'셀의 카운터로 사용할 변수\ncolsCnt = [B2].\nCurrentRegion\n.Columns.Count\n'B2셀의 연결영역 열 개수를 변수에 넣음\nRows(2).\nSpecialCells(4)\n.EntireColumn.Delete\n'공백 열 삭제\nrowsCnt = Cells(Rows.Count, \"B\").End(3).\nRow\nFor i = 2 To rowsCnt\n'2행부터 마지막 행까지 1씩 늘려가며 반복\nIf y = colsCnt Then\n'만약 y 가 열 개수에 도달하면\ny = 0\n'y의 값을 재사용 하기 위하여 초기화\nEnd If\ny = y + 1\n'y의 값(행)을 1씩 늘려감\nIf y > 1 Then\n'y가 1보다 크면\nCells(i, 1).Resize(, y - 1).\nInsert\nshift:=xlToRight\nEnd If\n'y 개수만큼 오른쪽으로 행을 밀기\nNext i\nSet rngLeft = Range(\"A2\", Cells(2, colsCnt).End(xlDown))\n'왼쪽 영역을 변수에 넣음\nSet rngRight = Cells(2, Columns.Count).End(1)(1, 2).Resize(rowsCnt - 1, colsCnt)\n'오른쪽 영역을 변수에 넣음\nFor Each rngC In rngLeft\n'왼쪽 영역 각 셀을 순환\ncnt = cnt + 1\n'셀 위치로 사용할 카운터 1씩 늘려감\nIf\nIsEmpty\n(rngC) Then\n'만일 빈셀이면\nrngC = rngRight.Cells(cnt)\n'오른쪽 영역의 값을 채워 넣음\nrngRight.Cells(cnt).Clear\n'오늘쪽 영역의 값을 삭제\nEnd If\nNext rngC\nFor i = Cells(2, Columns.Count).End(1).Column + 1 To 1 Step -colsCnt\n'전체 열개수 + 1 에서 colsCnt 만큼씩 빼나감\nCells(1, i).EntireColumn.Insert\n'공백열을 삽입\nCells(1, i).EntireColumn.Clear\n'공백열의 외곽선 테두리를 삭제\nNext i\n[B2].CurrentRegion.\nBorders\n.\nLineStyle\n= 1\n'B2의 현재영역 외곽선 넣기\nEnd Sub", "context": "매크로 실행 전\n매크로 실행 후 결과\n참고로 아래코드는\n빈 열을 모두 삭제하고, 행을 오른쪽으로 1행씩 늘려가며 밀치고, 오른쪽 색칠한 영역을 왼쪽 색칠한 영역으로 옮긴 뒤, 다시 빈 열을 넣어 주는 방식을 택함.\nOption Explicit\nSub move_As_Patterned()\nDim colsCnt As Long\n'열 개수를 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim y As Long\n'행 늘려갈 변수\nDim rngLeft As Range\n'왼쪽 영역을 넣을 변수\nDim rngRight As Range\n'오른쪽 영역을 넣을 변수\nDim rowsCnt As Long\n'행 개수를 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim cnt As Long\n'셀의 카운터로 사용할 변수\ncolsCnt = [B2].\nCurrentRegion\n.Columns.Count\n'B2셀의 연결영역 열 개수를 변수에 넣음\nRows(2).\nSpecialCel..."}
{"instruction": "Excel VBA code for: (1623) 메일머지 예제 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub mail_Merge_Sample_1()\nDim rngAll As Range\n'전체 이름 영역을 넣을 변수\nDim rngC As Range\n'각 셀을 넣을 변수\nDim blnTF As Boolean\nWith Sheets(\"\n데이터\n\")\n'데이터 시트에서\nSet rngAll = .Range(\"\nB2\n\", .Cells(Rows.Count, \"\nB\n\").End(3))\n'B2 셀부터 B열 마지막 셀까지 변수에\nSet rngAll = rngAll.SpecialCells(xlCellTypeVisible)\nEnd With\n'필터링된 뒤 화면에 보이는 데이터만 변수에\nFor Each rngC In rngAll\n'B열 전체거래처의 각 거래처를 순환\nRange(\"\nC14\n\") = rngC\n'거래처를 (순환하며) C14셀에 입력\nActiveSheet.PrintPreview\n'인쇄 미리보기\n'Activesheet.Printout\n'실제인쇄(위 PrintPreview 삭제 후 주석제거)\nNext rngC\n​\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "아무리 최대한 쉽게 만들어도 초보님들이 자신의 데이터에 응용해서 메일머지(동일한 양식에 특정 내용만 바꾸어 전체 데이터 인쇄하는 기능)를 하기는 힘드나 보다. 나름 자세히 설명한다고 하여도 동일한 기능을 요청하시는 분들이 있다.\n인쇄할 데이터가 들어 있는 \"데이터\" 시트 (아래로 데이터 더 있음)\n- 자신이 인쇄하고자 하는 내용만 화면에 표시되도록 필터링을 적용한 상태.\n인쇄할 양식\n(화살표로 표시한 바와 같이, 각 셀의 값에 수식이 입력되어 있어 C12셀 값(거래처)이 변경되면 각 셀의 값도 자동으로 변경됨.  매크로 실행 시 C12 셀의 값 변경 => 인쇄 => C12 셀의 값 변경 => 인쇄 .... 작업을 반복하게 됨.)\n=INDEX(데이터!A:L, MATCH($C$14, 데이터!B:B, 0),\n7\n)\n7은 \"\n데이터\n\" 시트의 왼쪽으로 부터 7번째\n열\n(column) 의미. 자신의 데이터 위치에 따라 위 값을 수정. 그리고 아래 노란색으로 표시한 것만 자신의 데이터와 일치시..."}
{"instruction": "Excel VBA code for: (1624) 문자 + 숫자로 입력된 데이터 정렬하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_Text_As_Ascending_1()\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim colNo As Integer\n'열 번호를 넣을 변수\nDim rngC As Range\n'데이터영역의 각 셀(C)ell을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim strEach As String\n'각(Each) 문자를 넣을 변수\nDim strNo As String\n'합쳐진 숫자(number)를 넣을 변수\nDim strTxt As String\n'합쳐진(U)nion 문자를 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith\nSelection\n'선택영역에서\n'-------------------------------------------------\n' 영역선택 오류 시 사용자에게 이를 알리는 코드\n'-------------------------------------------------\nIf .\nAreas.Count\n> 1 Or .Columns.Count > 1 Then\n'복수영역 또는 1열 이상 선택 시\nMsgBox \"1개의 area만, 1개의 열만 선택가능\", 64, \"영역설정 에러\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nIf .\nCells.Count\n= 1 Then\n'1셀만 선택 시\nMsgBox \"1셀 이상 선택\", 64, \"영역설정 에러\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\ncolsCnt = .EntireRow.SpecialCells(2).\nColumns.Count\n'전체 열개수 추출하여 변수에\ncolNo = .Column\n'열번호 추출\n.Offset(, 1).Resize(, 2).EntireColumn.\nInsert\n'오른쪽에 2열 삽입\n'------------------------------------------------------\n'\n셀내의 각\n문자가 숫자인지 문자인지 확인 후 합치는 코드\n'------------------------------------------------------\nFor Each rngC In Selection\n'선택영역의 각셀(rngC)을 순환\nFor i = 1 To Len(rngC)\n'1부터 전체 문자 길이까지 1씩 증가\nstrEach = Mid(rngC, i, 1)\n'각 분자를 변수에 넣음\nIf strEach\nLike \"[0-9]\"\nOr strEach = \".\" Then\n'만약 각 문자가 숫자 또는 점(.)이라면\nstrNo = strNo & strEach\n'각 숫자를 합쳐감\nElse\nstrTxt = strTxt & strEach\n'각 문자를 합쳐감\nEnd If\nNext i\nrngC.Next = strTxt\n'합쳐진 문자를 오른쪽 열에 넣음\nrngC.Offset(, 2) = strNo\n'합쳐진 숫자를 2열 오른쪽에 넣음\nstrNo = \"\"\n'재사용 하기 위하여 초기화\nstrTxt = \"\"\n'재사용 하기 위하여 초기화​\nNext\n'--------------------------------------------------------------------\n' 선택영역을 전체열로 확장 후 오름차순 정렬하고 임시열 삭제하는 코드\n'--------------------------------------------------------------------\nWith .EntireRow\n'선택영역을 전체열로 확장\n.\nSort\nkey1:=.Columns(colNo + 1).Cells(1), key2:=.Columns(colNo + 2).Cells(1), order1:=1​\n'선택영역의 오른쪽열 기준 오름차순 정렬\nCells(1, colNo + 1).Resize(, 2).EntireColumn.Delete\n'임시로 사용한 정렬기준 데이터 삭제\n.Cells(colNo).Select\n'첫 번째셀 선택\nEnd With\nEnd With\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "문자 + 숫자가 입력된 영역의 데이터를 선택하고 매크로 실행하면 왼쪽 문자와 오른쪽 숫자에 따라 오름차순 정렬해주는 기능. 아래 동영상에서 보듯\n한 개의 열만을 선택하고 매크로를 실행\n하여야 한다.\n매크로 실행 전                                                 일반적인 오름차순 정렬을 실행한 결과\n아래의 매크로 코드를 실행하여 오름차순 정렬한 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1624) 문자 + 숫자로 입력된 데이터 정렬하기 2 (엑셀 VBA 매크로)\n재생\n1,798\n재생 (space/k)\n재생\n00:33\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:33\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1..."}
{"instruction": "Excel VBA code for: (1626) 문자 + 숫자로 입력된 데이터 정렬하기 3 (엑셀 VBA 매크로)", "input": "", "output": "Sub sort_Text_As_Ascending_2()\nDim colsCnt As Integer\n'전체 열 개수 넣을 변수\nDim colNo As Integer\n'열 번호를 넣을 변수\nDim rngC As Range\n'데이터영역의 각 셀(C)ell을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim strEach As String\n'각(Each) 문자를 넣을 변수\nDim strNo As String\n'합쳐진 숫자(number)를 넣을 변수\nDim strTxt As String\n'합쳐진(U)nion 문자를 넣을 변수\nDim lngNo As Long\n'합쳐진 문자를 숫자로 바꾸어 넣을 변수\nDim j As Long\n'합쳐진 문자 개수를 넣을 변수\nDim k As Long\n'반복구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 정지\nWith Selection\n'선택영역에서\n'-------------------------------------------------\n' 영역선택 오류 시 사용자에게 이를 알리는 코드\n'-------------------------------------------------\nIf .Areas.Count > 1 Or .Columns.Count > 1 Then\n'복수영역 또는 1열 이상 선택 시\nMsgBox \"1개의 area만, 1개의 열만 선택가능\", 64, \"영역설정 에러\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nIf .Cells.Count = 1 Then\n'1셀만 선택 시\nMsgBox \"1셀 이상 선택\", 64, \"영역설정 에러\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\ncolsCnt = .EntireRow.SpecialCells(2).Columns.Count\n'전체 열개수 추출하여 변수에\ncolNo = .Column\n'열번호 추출\n.Offset(, 1).Resize(, 2).EntireColumn.Insert\n'오른쪽에 2열 삽입\n'------------------------------------------------------\n'\n셀내의 각\n문자가 숫자인지 문자인지 확인 후 합치는 코드\n'------------------------------------------------------\nFor Each rngC In Selection\n'선택영역의 각셀(rngC)을 순환\nFor i = 1 To Len(rngC)\n'1부터 전체 문자 길이까지 1씩 증가\nstrEach = Mid(rngC, i, 1)\n'각 분자를 변수에 넣음\nIf strEach Like \"[0-9]\" Or strEach = \".\" Then\n'만약 각 문자가 숫자 또는 점(.)이라면\nstrNo = strNo & strEach\n'각 숫자를 합쳐감\nElse\nstrTxt = strTxt & strEach\n'각 문자를 합쳐감\nEnd If\nNext i\nj = Len(strTxt)\n'합쳐진 문자의 개수를 저장\nFor k = 1 To j\n'합쳐진 문자의 개수만큼 반복\nlngNo = lngNo + (Asc(UCase(Mid(strTxt, k, 1))) - 64) * (26 ^ (j - k))\nNext k\n'문자를 숫자로 바꾸어 변수에 넣음\nrngC.Next = lngNo\n'합쳐진 문자를 오른쪽 열에 넣음\nrngC.Offset(, 2) = strNo\n'합쳐진 숫자를 2열 오른쪽에 넣음\nstrNo = \"\"\n'재사용 하기 위하여 초기화\nstrTxt = \"\"\n'재사용 하기 위하여 초기화​\nlngNo = 0\n'재사용 하기 위하여 초기화​\nNext rngC\n'--------------------------------------------------------------------\n' 선택영역을 전체열로 확장 후 오름차순 정렬하고 임시열 삭제하는 코드\n'--------------------------------------------------------------------\nWith .EntireRow\n'선택영역을 전체열로 확장\n.Sort key1:=.Columns(colNo + 1).Cells(1), key2:=.Columns(colNo + 2).Cells(1), order1:=1​\n'선택영역의 오른쪽열 기준 오름차순 정렬\nCells(1, colNo + 1).Resize(, 2).EntireColumn.Delete\n'임시로 사용한 정렬기준 데이터 삭제\n.Cells(colNo).Select\n'첫 번째셀 선택\nEnd With\nEnd With\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "문자 + 숫자로 된 데이터가 있을 때, A1, A2, A3,...... A10, B1 ,B2, B3, .......Z1, Z2, Z3, ......Z10, AA1, AA2, AA3, .....AA10, AB1.... 과 같은 순서로 정렬 시키는 기능.\n(이 코드는 \"\n숫눈\n\" 아이디를 가지신님이 기존 코드를 수정해서 보내주셨습니다. 아래 코드 중 주황색으로 표시한 것이 \"숫눈\"님의 아이디어로 알파벳을 숫자로 변환해준 뒤 정렬을 시행하는 방식으로 간단하지만 원하는 목적을 충분히 달성하며, 이런 코드를 필요로 하는 분에게는 유용할 것 같습니다.)\n매크로 실행 전 데이터가 입력된 모습                         일반적인 정렬을 시행한 결과\n아래의 매크로 코드를 실행하여 오름차순 정렬한 결과\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1626) 문자 + 숫자로 입력된 데이터 정렬하기 3 (엑셀 VBA 매크로)\n재생\n1,853\n재생..."}
{"instruction": "Excel VBA code for: (1627) 목표값 숫자 랜덤 생성 (엑셀 VBA 매크로)", "input": "", "output": "Sub random_Sum()\nDim rngC As Range\n'K열 각 셀을 넣을 변수\nDim cnt As Long\n'카운터로 사용할 변수\nDim rngEach As Range\n'각 행의 각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nColumns(\"A:J\").ClearContents\n'A:J 열까지의 (기존) 데이터 삭제\nFor Each rngC In Range(\"K2\", Cells(Rows.Count, \"K\").End(3))\n'K열 각 셀을 순환\nIf rngC < 25 Or rngC > 85 Then\n'25보다 크고 85보다 작을 경우\nMsgBox \"데이터 범위를 벗어납니다. 25와 85 사이의 숫자만 입력\", 64, \"숫자확인\"\nExit Sub\n'메시지 출력 후 매크로 종료\nEnd If\nWith\nWorksheetFunction\n'엑셀 시트 함수에서\nDo\n'다음을 실행\nFor Each rngEach In Cells(rngC.Row, 1).Resize(, 10)\n'각 행의 각 셀을 순환\nrngEach = .\nRandBetween\n(1, 10)\n'셀에 1과 10사이의 숫자를 입력\nNext rngEach\nIf .\nSum\n(rngC.Offset(, -10).Resize(, 10)) = rngC Then\n'행의 합계가 K열의 값과 일치 시\ncnt = 0\n'카운터 재사용 위하여 초기화\nExit Do\n'Do 구문 종료\nElse\n'행의 합계가 K열의 값과 일치하지 않으면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nEnd If\nIf cnt > 100000 Then\n'카운터가 100,000 보다 크면\nMsgBox \"데이터에 문제가 있음.\", 64, \"데이터 확인\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nLoop\n'무한 반복\nEnd With\ncnt = 0\n'카운터 재사용 위하여 초기화\nNext rngC\nEnd Sub", "context": "A:J 열에 1 ~ 10까지의 숫자를 중복 허용하며 무작위로 넣어 행의 합계가 K열이 되도록 하는 기능.\n(이런 코드는 Do ... Loop 구문을 사용하므로 잘못 작성하면 무한 루프에 걸릴 확률이 있어 루프 방지 카운터를 넣어 두었다. 즉, 10만회를 시행하여 값을 찾지 못하면 매크로를 종료한다.)\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub random_Sum()\nDim rngC As Range\n'K열 각 셀을 넣을 변수\nDim cnt As Long\n'카운터로 사용할 변수\nDim rngEach As Range\n'각 행의 각 셀을 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nColumns(\"A:J\").ClearContents\n'A:J 열까지의 (기존) 데이터 삭제\nFor Each rngC In Range(\"K2\", Cells(Rows.Count, \"K\").End(3))\n'K열 각 셀을 순환\nIf..."}
{"instruction": "Excel VBA code for: (1628) 위아래 같은 값 셀병합 매크로 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub merge_Columns_Duped()\nDim x As Long\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nWith\nSelection\n'선택 영역에서\nIf .Cells.Count = 1 Then\n'1셀만 선택한 경우\nMsgBox \"1셀 이상 선택하고 재실행\", 64, \"영역선택 오류\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nFor x = 1 To .Columns.Count\n'1부터 선택영역 열 개수만큼 반복\nDo\n'다음을 실행\nr = r + 1\n'행을 1씩 증가\nIf .Cells(r, x) = .Cells(r + 1, x) Then\n'각 셀이 바로 아래 셀과 같으면\ni = i + 1\n'중복개수를 하나씩 늘려감\nElse\n'각 셀이 바로 아래 셀과 다르면\nIf i > 0 Then\n'중복이 있을 경우\nApplication.\nDisplayAlerts\n= False\n'화면 경고 중지\n.Cells(r - i, x).Resize(i + 1, 1).\nMerge\n'중복영역 셀병합\nApplication.DisplayAlerts = True\n'화면 경고 복원\nEnd If\ni = 0\n'재사용 위하여 초기화\nEnd If\nLoop Until r = .Rows.Count\n'선택영역 마지막 행까지 무한반복\nr = 0\n'재사용 위하여 초기화\nNext x\nEnd With\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "이미 이런 코드는 올린지 알았더니 찾아도 없다. 유사한 코드를 많이 올려서 그런 것 같다. 1개의 열에만 적용되는 코드는 올렸었다. 이제는 내코드를 내가 찾지 못할 때가 많다. 그러니, 이 블로그 방문한 사람들은 이 많은 코드 중에 자신이 필요한 코드를 어떻게 찾을지 염려된다. ^^\n매크로 실행전\n영역을 선택\n한 모습                                 매크로 실행 후 결과\nOption Explicit\nSub merge_Columns_Duped()\nDim x As Long\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim i As Long\n'동일 이름 중복개수 구할 변수\nWith\nSelection\n'선택 영역에서\nIf .Cells.Count = 1 Then\n'1셀만 선택한 경우\nMsgBox \"1셀 이상 선택하고 재실행\", 64, \"영역선택 오류\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nFor x = 1 To .Columns.Coun..."}
{"instruction": "Excel VBA code for: (1630) 식대 사인(signature) 붙여넣기 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_Signature()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngSign As Range\n'검색에 일치한 이름의 셀 넣을 변수\nSheets(\"출력용\").\nPictures.Delete\n'출력용 시트의 모든 사진(사인) 삭제\nFor Each rngC In Columns(\"C:F\").SpecialCells(2)\n'C:F열의 문자가 입력된 각 셀을 순환\nIf rngC = \"○\" Then\n'셀의 값이 o 인 경우\nSet rngSign = Sheets(\"사인\").Columns(\"A\").\nFind\n(Cells(rngC.Row, 2), , , xlWhole)\n'사인 시트에서 검색에 일치하는 이름 찾음\nIf\nNot\nrngSign\nIs Nothing\nThen\n'검색에 일치하는 이름이 있을 경우\nrngSign.Next.Copy Sheets(\"출력용\").Range(rngC.Address)\nEnd If\n'이름 일치한 셀의 오른쪽 셀을 출력용 시트에 복사\nEnd If\nNext rngC\nMsgBox \"매크로가 종료되었습니다.\"\n'매크로 종료 메시지창 출력\nSet rngSign = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "\"확인용\"시트에 \"O\" 표시된 경우, 일치하는 이름을 \"사인\"시트에서 찾아, \"출력용\"시트에 사인을 붙여넣는 기능.\n매크로 실행 전 \"확인용\" 시트\n매크로 실행 전 \"출력용\" 시트\n매크로 실행 전 성명과 사인이 입력된 \"사인\" 시트\n매크로 실행 후 \"출력용\"시트의 결과\nOption Explicit\nSub copy_Signature()\nDim rngC As Range\n'각 셀을 넣을 변수\nDim rngSign As Range\n'검색에 일치한 이름의 셀 넣을 변수\nSheets(\"출력용\").\nPictures.Delete\n'출력용 시트의 모든 사진(사인) 삭제\nFor Each rngC In Columns(\"C:F\").SpecialCells(2)\n'C:F열의 문자가 입력된 각 셀을 순환\nIf rngC = \"○\" Then\n'셀의 값이 o 인 경우\nSet rngSign = Sheets(\"사인\").Columns(\"A\").\nFind\n(Cells(rngC.Row, 2), , , xlWhole)\n'사인..."}
{"instruction": "Excel VBA code for: (1631) 일련번호에 따라 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub check_Reservation_Number()\nDim rngC As Range\n'각 셀을 넣을 변수\nRange(\"I3\").CurrentRegion.Offset(2, 1).ClearContents\n'기존 데이터삭제\nColumns(\"J:K\").\nInterior.Color\n=\nxlNone\n'J:K 열에서 적용된 색깔 삭제\nFor Each rngC In Range(\"E4\", Cells(Rows.Count, \"E\").End(3))\n'E열의 각 셀을 순환\nSelect Case rngC.Next\n'F열의 값이\nCase\nEmpty\n'비어 있을 경우\nWith Cells(rngC + 2, 10).Resize(, 2)\n'J:K 열에\n.Value\n= rngC.Offset(, -2).Resize(, 2).Value\n'C:E 열의 값을 복사\n.Interior.Color = rngC.Interior.Color\n'색을 E열의 색으로 채움\nEnd With\nCase Else\n'비어 있지 않을 경우\nWith Cells(rngC + 2, 10).Resize(rngC.Next - rngC + 1, 2)\n'J:K 열에\n.Value = rngC.Offset(, -2).Resize(, 2).Value\n'C:E 열의 값을 복사\n.Interior.Color = rngC.Interior.Color\n'색을 E열의 색으로 채움\nEnd With\nEnd Select\nNext rngC\nEnd Sub", "context": "1. E:F 열에 있는 일련번호에 따라 J:K 열에 복사하는 기능\n2. E열의 색에 따라 J:K 열에도 동일한 색을 복사\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub check_Reservation_Number()\nDim rngC As Range\n'각 셀을 넣을 변수\nRange(\"I3\").CurrentRegion.Offset(2, 1).ClearContents\n'기존 데이터삭제\nColumns(\"J:K\").\nInterior.Color\n=\nxlNone\n'J:K 열에서 적용된 색깔 삭제\nFor Each rngC In Range(\"E4\", Cells(Rows.Count, \"E\").End(3))\n'E열의 각 셀을 순환\nSelect Case rngC.Next\n'F열의 값이\nCase\nEmpty\n'비어 있을 경우\nWith Cells(rngC + 2, 10).Resize(, 2)\n'J:K 열에\n.Value\n= rngC.Offset(, -2).Resize(, 2).Valu..."}
{"instruction": "Excel VBA code for: (1632) 폴더속 모든파일내 특정시트의 데이터 통합하기 2 (엑셀 VBA 매크로)", "input": "", "output": "Sub combine_All_Sheets_In_Folder_9()\nDim strSht As String\n'시트 이름을 넣을 변수\nDim rngData As Range\n'데이터 영역을 넣을 영역변수\nDim strPath As String\n'폴더의 경로를 넣을 변수\nDim fileName As String\n'각 파일 이름을 넣을 변수\nDim rngT As Range\n'복사될 위치 넣을 변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nActiveSheet.UsedRange.Offset(1).ClearContents\n'기존 데이터 삭제\n'---------------------------------------------------------------------\n' 본인 시트명과 데이터 영역으로 수정사용. 시트명 틀리면 엑셀 에러창 뜸\n'---------------------------------------------------------------------\nstrSht = \"\nSheet1\n\"\n'데이터가 저장된 시트의 이름\nSet rngData = Range(\"\nA2:J2\n\")\n'데이터가 입력된 영역\nSet rngT = Range(\"\nA2:J2\n\")\n'데이터가 첫 복사될 위치를 변수에 넣음\n'----------------------------------------------------\n' 폴더 선택하는 창 출력 후 폴더 경로 추출하는 코드\n'----------------------------------------------------\nWith Application.\nFileDialog\n(msoFileDialogFolderPicker)\n'폴더선택 창에서\n.Show\n'폴더 선택창 띄우기\nIf .SelectedItems.Count = 0 Then\n'취소 선택 시\nExit Sub\n'매크로 중단\nElse\n'폴더를 선택한 경우\nstrPath = .SelectedItems(1) & \"\\\"\n'폴더 경로를 변수에 넣음\nEnd If\nEnd With\n'-----------------------------------\n' 폴더내 파일 유무를 확인하는 코드\n'-----------------------------------\nfileName =\nDir\n(strPath & \"*.xls*\")\n'(폴더내)각 엑셀파일 이름을 변수에 넣음\nIf fileName = \"\" Then\n'폴더에 파일이 없으면\nMsgBox \"폴더에 파일이 없습니다.\"\n'메시지 출력\nExit Sub\n'매크로 중단\nEnd If\nDo While\nfileName <> \"\"\n'이름이 없지 않다면, 즉, 파일이 존재하면\n'----------------------------------------------------------------\n' 배열수식을 이용하여 데이터 가져오고 수식을 값으로 변환하는 코드\n'----------------------------------------------------------------\nWith rngT\n'데이터가 복사될 기준 위치\n.\nFormulaArray\n= \"='\" & strPath & \"[\" & fileName & \"]\" _\n& strSht & \"'!\" & rngData.\nAddress\n(1, 1, 1)\n'데이터 영역을 배열로 가져옴\n.\nValue\n= .\nValue\n'셀의 수식을 값으로 바꿈\nEnd With\nSet\nrngT = rngT.Offset(1)\n'데이터 복사위치 1행 내림\nfileName = Dir\n'다음 파일을 파일이름에 넣음\nLoop\n'무한 반복\nSet rngData = Nothing\n'개체변수(들) 초기화(메모리 비우기)\n﻿    Set rngT = Nothing\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\n﻿\nEnd Sub", "context": "아래 코드의 경우 내 컴퓨터로 1초에 대략 100개 정도의 데이터를 가져온다. 파일을 열지 않고 데이터를 가져오는 코드들 중 가장 빠른 방법중의 하나가 아닌가 생각된다. 이제 여러번 해보아서 데이터의 위치가 변경되어도 손쉽게 코드의 수정이 가능히다.\n매크로 실행 전 제목행만 있으며 시트는 비어 있는 상태\n폴더내에 저장된 엑셀파일들. 이번 예제에서는 폴더내에 10개의 .xls 파일과 10개의 .xlsx 파일이 있음\n폴더내에 저장된 첫 번째 파일.  Sheet1 시트의 A2:J12 셀에 데이터가 입력되어 있음. 다른 모든 파일도 동일한 시트의 동일한 위치에 데이터가 들어 있음\n매크로 실행 후 데이터를 가져온 결과\nOption Explicit\nSub combine_All_Sheets_In_Folder_9()\nDim strSht As String\n'시트 이름을 넣을 변수\nDim rngData As Range\n'데이터 영역을 넣을 영역변수\nDim strPath As String\n'폴더의 경로..."}
{"instruction": "Excel VBA code for: (1633) 데이터 이동하며 재배치하기 5 (엑셀 VBA 매크로)", "input": "", "output": "Sub relocate_Data()\nDim r As Long\n'반복 구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트(일시) 중지\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nFor r = 2 To Cells(Rows.Count, 1).End(3).\nRow\n'2부터 1씩 늘려가며 A열 마지막 행까지 반복\n.Cells((r - 2) * 3 + 1, 1).Resize(, 2) = _\nCells(r, 1).Resize(, 2).Value\n'모델명과 컬러를 복사\n.Cells((r - 2) * 3 + 1, 3).Resize(3) = _\nWorksheetFunction.\nTranspose\n(Cells(1, 3).Resize(, 3))\n'xs, s, m 제목을 복사\n.Cells((r - 2) * 3 + 1, 4).Resize(3) = _\nWorksheetFunction.Transpose(Cells(r, 3).Resize(, 3))\nNext r\n'xs, s, m 값을 복사\n.Activate\n'활성화\nEnd With\nMsgBox \"매크로가 종료되었습니다.\"\n'종료 메시지창 출력\nEnd Sub", "context": "매크로 실행 전 (Sheet2는 비어 있는 상태)                   매크로 실행 후 Sheet2의 결과\nOption Explicit\nSub relocate_Data()\nDim r As Long\n'반복 구문에 사용할 변수\nApplication.ScreenUpdating = False\n'화면 업데이트(일시) 중지\nWith Sheets(2)\n'Sheet2 에서\n.UsedRange.ClearContents\n'기존 데이터 삭제\nFor r = 2 To Cells(Rows.Count, 1).End(3).\nRow\n'2부터 1씩 늘려가며 A열 마지막 행까지 반복\n.Cells((r - 2) * 3 + 1, 1).Resize(, 2) = _\nCells(r, 1).Resize(, 2).Value\n'모델명과 컬러를 복사\n.Cells((r - 2) * 3 + 1, 3).Resize(3) = _\nWorksheetFunction.\nTranspose\n(Cells(1, 3).Resize(, 3))\n'..."}
{"instruction": "Excel VBA code for: (1634) 지정된 위치에 백업파일 생성하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub save_And_BackUp_To_A_Different_Folder()\nDim wkb As Workbook\n'파일을 넣을 변수\nDim strName As String\n'파일이름 넣을 변수\nDim blnYN As Boolean\n'저장여부 넣을 변수\nDim strFolder As String\n'백업파일이 저장될 위치\nWith Application\n'애플리케이션 즉 엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nstrFolder = \"\nC:\\backup\\\n\"\n'백업파일이 저장될 위치\nIf\nTypeName\n(ActiveWorkbook) = \"Nothing\" Then Exit Sub\n'(개인용 매크로 통합파일에 매크로 저장되어) 열린파일 없으면 종료\nSet wkb = ActiveWorkbook\n'화면에 활성화된 파일을 변수에 넣음\nstrName =\nMid$\n(wkb.FullName, InStrRev(wkb.FullName, \"\\\") + 1)\n'확장자 포함한 파일이름 추출\nstrName = Split(strName, \".\")(0)\n'확장자 제거한 파일 이름만 추출\nIf wkb.Path = \"\" Then\n'아직 저장되지 않은 파일이면\n.Dialogs(\nxlDialogSaveAs\n).Show\n'다른이름으로 저장하는 파일창 출력\nCall\nbackUp_File(strFolder, strName)\n'백업파일 생성하는 하위 프로시저 호출\nElse\n'이미 저장된 파일이면\nCall backUp_File(strFolder, strName)\n'백업파일 생성하는 하위 프로시저 호출\nEnd If\nEnd With\nSet wkb = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub\n\nSub backUp_File(strF As String, strN As String)\nDim strPath As String\n'파일이름 포함하는 파일경로 넣을 변수\nDim msg As String\n'메시지창 결과 넣을 변수\nstrPath =\nDir$\n(strF & strN & \".bak\")\n'파일이름 포함하는 전체경로를 변수에 넣음\nIf strPath <> \"\" Then\n'동일한 이름의 백업파일이 이미 존재하면\nmsg = MsgBox(\"기존파일에 백업파일을 덮어쓸까요?\", vbYesNo, \"덮어쓰기 확인\")\n'파일 덮어쓸지 묻는 창 출력\nIf msg = vbNo Then\n'아니오(N) 선택 시\nExit Sub\n'매크로 종료\nElse\n'예(Y)선택 시\nKill\nstrF & strN & \".bak\"\n'기존 백업파일 삭제\nEnd If\nEnd If\nWith ActiveWorkbook\n'현재 활성화된 파일에서\nIf .Saved Then\n'이미 저장되었으면\n.\nSaveCopyAs\nstrN & \".bak\"\n'백업파일을 저장\nName\nstrN & \".bak\" As strF & strN & \".bak\"\n'백업파일 이동\nElse\n'수정되어 저장되지 않았다면\n.Save\n'화면에 활성화된 파일 저장\n.SaveCopyAs strN & \".bak\"\n'백업파일을 저장\nName strN & \".bak\" As strF & strN & \".bak\"\n'백업파일 이동\nEnd If\nEnd With\nMsgBox \"정상적으로 파일 저장되고 백업 저장됨\"\n'저장완료 메시지 출력\nEnd Sub", "context": "아래의 코드는 현재 화면에 활성화된 파일을 저장과 함께 지정한 위치에 백업파일을 생성해주는 기능으로, 아래의 코드를 개인용 매크로 통합문서(\nhttp://blog.naver.com/rosa0189/60148331554\n) 또는 빠른도구 모음에 추가하여 실행시키는 것이 좋다.\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1634) 지정된 위치에 백업파일 생성하기 (엑셀 VBA 매크로)\n재생\n2,068\n재생 (space/k)\n재생\n00:27\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:27\n실시간\n설정\n전체 화면 (f)\n해상도\n270p\n자막\n사용 안함\n재생 속도\n1.0x (기본)\n인기 구간 표시\n해상도\n270p\n자막\n설정\n사용 안함\n자막 설정\n글자 크기\n배경색\n재생 속도\n0.5x\n1.0x (기본)\n1.5x\n2.0x\n죄송합니다. 문제가 발생했습니다. 다시 시도해 주세요.\n도움말\n음소거 상태입니다.\n도움말\n라..."}
{"instruction": "Excel VBA code for: (1636) Old 와 New 두 시트의 유일한 데이터, 중복데이터 및 중복 없는 통합데이터 추출 8 (엑셀 VBA 매크로)", "input": "", "output": "Sub find_Duplicated_Data_7()\nDim s As Long\n'시트(s)heet 개수 늘려갈 변수\nDim colsCnt As Long\n'전체 열 개수 넣기 위한 변수\nDim varCol As Variant\n'중복삭제 열 개수 array 넣을 배열변수\nDim v As Long\n'중복삭제 array 반복할 변수\nDim varO As Variant\n'Old 시트내 A열 넣을 배열변수\nDim varOld As Variant\n'Old 시트 전체자료 넣기위한 배열변수\nDim varN As Variant\n'New 시트내 A열 넣을 변수\nDim varNew As Variant\n'New 시트 전체자료 넣기 위한 배열변수\nDim rowsCnt As Long\n'두 배열중 작은 배열의 행개수 넣을 변수\nDim varBoth As Variant\n'양쪽(B)oth에 중복된 자료 넣을 배열\nDim i As Long\n'Old 배열내 행을 늘려나갈 변수\nDim j As Long\n'New 배열내 행을 늘려갈 변수\nDim lngComp As Long\n'두 시트의 A열 비교한 값을 넣을 변수\nDim x As Long\n'열 개수 늘려갈 변수\nDim cnt As Long\n'카운터로 사용할 변수\nDim r As Long\n'배열 크기 늘려갈 변수\nWith WorksheetFunction\n'엑셀함수\nIf .\nCountA\n(Columns(\"A\")) < 2 Or _\n.CountA(Sheets(2).Columns(\"A\")) < 2 Then\n'Old/New 시트의 데이터가 2행 미만인 경우\nMsgBox \"작업할 데이터가 부족합니다.\", 64, \"데이터 입력 오류\"\nExit Sub\n'메시지 출력 후 매크로 종료\nEnd If\nEnd With\nWith Application\n'엑셀에서\n.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\n.Calculation = xlCalculationManual\n'셀계산 수동으로 전환\nEnd With\nFor s = 3 To 6\n'3 ~ 6번 시트에서 반복\nSheets(s).UsedRange.ClearContents\n'기존 데이터 삭제\nNext s\nFor s = 1 To 2\n'1 ~ 2번 시트에서 반복\nWith Sheets(s)\n'각 시트에서\n.UsedRange.Interior.ColorIndex =\nxlNone\n'사용영역의 모든 색채우기 제거\n.UsedRange.\nSort\n.[A1], 1\n'A열 기준 오름차순 정렬\nEnd With\nNext s\n'------------------------------------------------\n'열 개수 추출하고 Old / New 시트의 중복을 제거\n'------------------------------------------------\ncolsCnt = Sheets(1).UsedRange.Columns.Count\n'전체 열 개수를 변수에 넣음\nReDim\nvarCol(0 To colsCnt - 1)\n'배열크기 재지정\nFor v = 0 To colsCnt - 1\n'전체 열 개수만큼 반복\nvarCol(v) = v + 1\n'배열에 열 개수를 넣음\nNext v\nFor s = 1 To 2\n'Old와 New 시트의 중복 제거\nSheets(s).UsedRange.\nRemoveDuplicates\n_\nColumns:=(varCol), Header:=xlNo\n'전체열 모두 일치 시 중복제거\nNext s\n'------------------------------------------------------\n'각 배열에 제목 제외한 Old / New 시트의 데이터를 넣음\n'------------------------------------------------------\nvarO = Range(\"A1\", Cells(Rows.Count, \"A\").End(3))\n'Old시트 A열 전체 데이터를 배열에 넣음\nvarOld = Sheets(1).UsedRange\n'Old시트 사용영역을 배열에 넣음\nWith Sheets(2)\n'2번 시트(New 시트)에서\nvarN = Range(.Range(\"A1\"), _\n.Cells(Rows.Count, \"A\").End(3))\n'New시트 A열 전체 데이터를 배열에 넣음\nvarNew = .UsedRange\n'New시트 사용영역을 배열에 넣음\nEnd With\n'-------------------------------------\n'varBoth 배열의 크기를 결정하는 코드\n'-------------------------------------\nIf\nUBound\n(varOld, 1) > UBound(varNew, 1) Then\n'Old 행이 더 크면\nrowsCnt = UBound(varNew, 1)\n'Old행을 rowsCnt에 넣고\nElse\n'New 행이 더 크거나 같으면\nrowsCnt = UBound(varOld, 1)\n'New 행을 rowsCnt에 넣음\nEnd If\nReDim varBoth(1 To rowsCnt, 1 To colsCnt)\n'배열크기 재지정\ni = 1\n'Old시트 A열 1행부터 시작\nj = 1\n'New시트 A열 1행부터 시작\nDo\n'다음을 실행\nlngComp =\nStrComp\n(varO(i, 1), varN(j, 1))\n'Old시트 A열과 New 시트 B열의 값을 비교\nSelect Case lngComp\n'lngComp의 값이\nCase -1\n'A열이 더 큰 경우\ni = i + 1\n'B열이 행 1씩 늘려감\nCase 0\n'A열과 B열이 같은 경우\nFor x = 2 To colsCnt\n'2 ~ 마지막 열까지 반복\nIf varOld(i, x) = varNew(j, x) Then\n'값이 같다면\ncnt = cnt + 1\n'카운터를 1씩 늘려감\nElse: cnt = 0\n'카운터 값을 초기화\nExit For\n'값이 다르면 for 구문 종료\nEnd If\nNext x\n'----------------------------------------------------------\n' 중복 데이터를 varBoth에 넣고 varOld / varNew에서는 삭제\n'----------------------------------------------------------\nIf cnt = colsCnt - 1 Then\n'2 ~ 마지막 열까지 같다면\ncnt = 0\n'재사용 위하여 초기화\nCells(i, 1).Resize(, colsCnt).Interior.\nColorIndex = 36\n'Old 시트의 중복 데이터에 노란 색채우기\nSheets(2).Cells(j, 1).Resize(, colsCnt).Interior.ColorIndex = 36\n'New 시트의 중복 데이터에 노란 색채우기\nr = r + 1\n'배열 개수 1씩 늘려감\nFor x = 1 To colsCnt\n'전체 열 개수만큼 반복\nvarBoth(r, x) = varOld(i, x)\n'중복데이터를 varBoth에 넣음\nvarOld(i, x) =\nEmpty\n'varOld 내의 중복데이터 삭제\nvarNew(j, x) = Empty\n'varNew 내의 중복데이터 삭제\nNext x\nEnd If\ni = i + 1\n'A열 행 1씩 늘려감\nj = j + 1\n'B열 행 1씩 늘려감\n​\nCase 1\n'A열이 더 작은 경우\nj = j + 1\n'B열의 행 1씩 늘려감\nEnd Select\nLoop Until i > UBound(varO, 1) Or j > UBound(varN, 1)\n'마지막행 도달때까지 무한 반복\n'----------------------------------------------------------\n' OldOnly, Both, NewOnly 시트에 배열내 값을 뿌려주는 코드\n'----------------------------------------------------------\nSheets(3).Cells(1, 1).Resize(UBound(varOld, 1), _\ncolsCnt) = varOld\n'varOld 배열값을 OldOnly에 뿌림\nIf r > 0 Then\n'배열이 비어 있지 않으면\nSheets(4).Cells(1, 1).Resize(UBound(varBoth, 1), _\ncolsCnt) = varBoth\n'varBoth 배열값을 Both에 뿌림\nEnd If\nSheets(5).Cells(1, 1).Resize(UBound(varNew, 1), _\ncolsCnt) = varNew\n'varNew 배열값을 NewOnly에 뿌림\n'-------------------------------------------------------------\n' varOld, varBoth, varNew 배열에 추출한 데이터를 All 시트에 통합\n'-------------------------------------------------------------\nSheets(6).Cells(1, 1).Resize(UBound(varOld, 1), _\ncolsCnt) = varOld\n'varOld 배열값을 All 시트에 뿌림\nWith Sheets(6).Cells(Rows.Count, \"A\")\nIf r > 0 Then\n'배열이 비어 있지 않으면\n.End(3)(2).Resize(UBound(varBoth, 1), _\ncolsCnt) = varBoth\n'varBoth 배열값을 All 시트에 뿌림\nEnd If\n.End(3)(2).Resize(UBound(varNew, 1), colsCnt) = varNew\nEnd With\n'varNew 배열값을 All 시트에 뿌림\n'--------------------------------------------\n' 각 시트를 오름차순 정렬하고, 서식을 설정\n'--------------------------------------------\nFor s = 3 To 6\n'3 ~ 6번 시트에서 반복\nWith Sheets(s)\n'각 시트에서\nIf s = 4 Then\n's가 4이면\nIf r > 0 Then\n'배열이 비어 있지 않으면\n.Range(\"A1\", .Cells(Rows.Count, colsCnt).End(3)).Sort .[A1], 1\nEnd If\n'이름순으로 오름차순 정렬\nElse\n.Range(\"A1\", .Cells(Rows.Count, colsCnt).End(3)).Sort .[A1], 1\nEnd If\n'이름순으로 오름차순 정렬\n.Columns(\"E\").\nNumberFormat\n= \"yyyy-mm-dd\"\n'E열의 서식을 날짜로 설정\n.Columns.AutoFit\n'열너비 자동 맞춤\nEnd With\nNext s\nWith Application\n'엑셀에서\n.Calculation = xlCalculationAutomatic\n'셀계산 자동으로 복원\n.ScreenUpdating = True\n'화면업데이트 복원\nEnd With\nMsgBox \"데이터 작업이 완료되었습니다.\"\n'완료 메시지 출력\nEnd Sub", "context": "매크로 사용이 익숙치 않으면 첨부된 코드를 다운받고 자신의 데이터를\n제목행 없이\nOld 시트와 New 시트에 복사하여 넣고 매크로 버튼만 클릭하면 된다. 코드는 꽤 길지만, 두 데이터를 빠르게 비교한 뒤 중복데이터를 표시하고, 각 데이터를 추출하기 위해 많은 공을 들였다. 데이터 구조와 컴퓨터 속도에 따라 차이가 나지만,\nOld 시트와 New 시트에 각각 50,000 행, 6열의 데이터를 넣고 돌렸을 때 내 컴퓨터로 대략\n3초\n정도가 소요\n된다. 1열의 경우 1~2초면 된다.\n매크로 실행 시 ​Old 시트와 New 시트 양쪽에 중복된 데이터는 삭제되지 않지만,\nOld 시트 또는 New 시트에 중복된 데이터가 두 개 이상 있으면 한 개만 남겨두고 나머지는 삭제\n되므로 주의. 매크로 실행 시 Old/New 시트의 A열​은 오름차순으로 정렬됨\n​\n​\n매크로 실행 후,\nOld시트에만 있는 유일한 데이터를 OldOnly 시트에 추출\nOld와 New 시트에 중복된 데이터를 Both 시트에 추출..."}
{"instruction": "Excel VBA code for: (1637) 메일머지 예제 4 (엑셀 VBA 매크로)", "input": "", "output": "Sub mail_Merge_Sample_3()\nDim minNo As Long\n'시작행을 넣을 변수\nDim maxNo As Long\n'종료행을 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nminNo = check_Number()\n'시작행을 변수에 넣음\nmaxNo = check_Number()\n'종료행을 변수에 넣음\nIf maxNo >= minNo Then\n'최댓값이 최솟값보다 크거나 같으면\nFor i = minNo To maxNo\n'최솟값에서 최댓값까지 반복\nRange(\"A8\") = i\n'A8셀에 값을 넣음\nActiveSheet.\nPrintPreview\n'인쇄 미리보기\n'Activesheet.\nPrintout\n'실제인쇄(위 PrintPreview 삭제 후 주석제거)\nNext i\nElse\nMsgBox \"값 입력 오류\", 64, \"입력오류\"\n'입력오류 메시지창 출력\nExit Sub\n'매크로 종료\nEnd If\nEnd Sub\n\nFunction check_Number() As Long\nDim input_Value As String\n'입력값을 넣을 변수\nDim msg As String\n'메시지 넣을 문자 변수\nConst\nintMin As Long = 2\n'시작행을 넣을 변수\nDim intMax As Long\n'종료행을 넣을 변수\nWith Sheets(\"Sheet2\")\n'Sheet2 에서\nintMax = .Cells(Rows.Count, \"A\").End(3).\nRow\n'종료행을 변수에\nEnd With\nDo\n'다음을 실행\ninput_Value =\nInputBox\n(intMin & \" 과(와) \" & intMax & \" 사이의 숫자를 입력.\")\n'입력창 값을 변수에 넣음\nIf input_Value = \"\" Then\nEnd\n'입력값 없으면 매크로 중단\nIf\nIsNumeric\n(input_Value) Then\n'입력값이 숫자이면\nIf input_Value >= intMin And input_Value <= intMax Then\n'입력값이 2보다 크거나 같고, 마지막행보다 작거나 같으면 Do 구문 종료\ncheck_Number = input_Value\n'입력된 값을 함수에 되돌려줌\nExit Do\n'Do 구문 종료\nEnd If\nEnd If\nmsg = \"행번호 입력오류.\" & vbCr & vbCr\n'메시지창 내용 + 줄바꿈 2번\nmsg = msg & intMin & \" 과(와) \" & intMax & \" 사이의 숫자를 입력.\"\n'메시지창 내용\nMsgBox msg, 64, \"입력오류\"\n'입력오류 메시지창 출력\nLoop\n'무한 반복\nEnd Function", "context": "메일머지(동일한 양식에 특정 내용만 바꾸어 전체 데이터 인쇄하는 기능) 예제 3탄. 앞서 해보았던\n초 간단 메일머지 예제 1 :\nh\nttp://blog.naver.com/rosa0189/60210010293\n초 간단 메일머지 예제 2 :\nhttp://blog.naver.com/rosa0189/60210751647\n메일머지 예제 :\nhttp://blog.naver.com/rosa0189/60142117180\n는 필터링하여 화면에 보이는 데이터만 인쇄하였는데 아래 예제는 인쇄하려는 데이터 범위(시작행과 종료행)를 입력창에 숫자로 입력하도록 함.\nSheet2 에 입력된 데이터\n0초\n0초\n100%\n광고 후 계속됩니다.\n다음 동영상\nsubject\nauthor\n취소\n(1637) 메일머지 예제 4 (엑셀 VBA 매크로)\n재생\n5,522\n공유하기\n재생 (space/k)\n재생\n00:49\n0:00:00\n재생 (space/k)\n재생\n음소거 (m)\n음소거\n00:00\n/\n00:49\n실시간\n설정\n전체 화면 ..."}
{"instruction": "Excel VBA code for: (1638) 괄호안의 숫자 추출하기 1 (엑셀 VBA 매크로)", "input": "", "output": "Sub count_Strawberry_Banana_1()\nDim rngAll As Range\n'제목 제외한 B열 전체(All) 데이터 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim varTemp\n'문자 임시(Temp)orary로 넣을\n배열\n(var)iant변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nWith Columns(\"A:A\")\n'A열\n.Copy\n'복사\n.Insert Shift:=xlToRight\n'(임시 열을)오른쪽으로 밀며 붙여넣기\nEnd With\nApplication.CutCopyMode = False\n'클립보드 비우기\nSet rngAll = Range(\"B2\", Cells(Rows.Count, 2).End(3))\n'제목 제외한 B열 전체를 개체변수에 넣음\nWith rngAll\n'전체 데이터 영역에서\n.\nReplace\n\"딸기(\", \"\"\n'딸기( 를 삭제\n.Replace \",바나나(\", \"\"\n' ,바나나( 를 삭제\nEnd With\nFor Each rngC In rngAll\n'제목 제외한 A열 각 셀을 순환\nvarTemp =\nSplit\n(rngC, \"개)\")\n' 개) 로 분리하여 배열에 넣음\nrngC.Offset(, 1).Resize(, 2) = varTemp\n'배열의 값을 셀에 뿌림\nNext rngC\nWith rngAll.Offset(, 1).Resize(, 2)\n'C:D 열에서\n.\nValue\n= .\nValue\n'셀의 값을 값으로 변환\nEnd With\nColumns(\"B\").Delete\n'임시열 삭제\nSet rngAll = Nothing\n'개체변수 초기화(메모리 비우기)\nEnd Sub", "context": "매크로 실행 전                                                          매크로 실행 후 결과\nOption Explicit\nSub count_Strawberry_Banana_1()\nDim rngAll As Range\n'제목 제외한 B열 전체(All) 데이터 넣을 변수\nDim rngC As Range\n'각 셀(C)ell을 넣을 변수\nDim varTemp\n'문자 임시(Temp)orary로 넣을\n배열\n(var)iant변수\nApplication.ScreenUpdating = False\n'화면 업데이트 (일시) 중지\nWith Columns(\"A:A\")\n'A열\n.Copy\n'복사\n.Insert Shift:=xlToRight\n'(임시 열을)오른쪽으로 밀며 붙여넣기\nEnd With\nApplication.CutCopyMode = False\n'클립보드 비우기\nSet rngAll = Range(\"B2\", Cells(Rows.Count, 2).End(3))\n'제..."}
{"instruction": "Excel VBA code for: (1640) 색칠해진 영역만 복사하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub copy_Colored_Range()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim c As Long\n'열(c)olumn 늘려갈 변수\nDim x As Long\n'열(x 축)방향 복사될 위치 늘려갈 변수\nColumns(\"R:BJ\").\nStyle\n= \"Normal\"\n'R:BJ 열의 서식을 삭제\nx = 18\n'18열(R열) 부터 시작\nFor r = 2 To 10 Step 4\n'2행부터 4씩 늘려가며 10까지\nFor c = 3 To 17\n'3열부터 1씩 늘려가며 17열까지\nIf Cells(r, c).Interior.\nColorIndex\n<>\nxlNone\nThen\n'셀에 색이 채워져 있을 경우\nCells(r, c).Resize(3).Copy Cells(2, x)\n'셀을 3행씩 복사\nx = x + 1\n'열 위치 1씩 늘려감\nEnd If\nNext c\nNext r\nEnd Sub", "context": "C:R 열에 있는 노랑, 갈색, 녹색의 색칠해진 영역을 복사하는 기능\n세 가지 색의 열 개수는 가변적\n노란색은 C2셀부터 시작하며 3행이고 Q열을 넘지 않음. 갈색은 C6셀부터 시작하며 Q열을 넘지 않음. 녹색은 C10셀부터 시작하며 Q열을 넘지 않음.\n복사되는 위치는 R2 셀부터\n매크로 실행 전\n매크로 실행 후 결과\nOption Explicit\nSub copy_Colored_Range()\nDim r As Long\n'행(r)ow 늘려갈 변수\nDim c As Long\n'열(c)olumn 늘려갈 변수\nDim x As Long\n'열(x 축)방향 복사될 위치 늘려갈 변수\nColumns(\"R:BJ\").\nStyle\n= \"Normal\"\n'R:BJ 열의 서식을 삭제\nx = 18\n'18열(R열) 부터 시작\nFor r = 2 To 10 Step 4\n'2행부터 4씩 늘려가며 10까지\nFor c = 3 To 17\n'3열부터 1씩 늘려가며 17열까지\nIf Cells(r, c).Interior.\nColorI..."}
{"instruction": "Excel VBA code for: (1641) 현재 페이지만 인쇄하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub print_CurrentPage_Only\n(control As IRibbonControl)\nDim cntHor As Long\n'행(가로) 페이지 구분선 개수 넣을 변수\nDim cntVer As Long\n'열(세로) 페이지 구분선 개수 넣을 변수\nDim hPageB As\nHPageBreak\n'각 행 페이지구분선 넣을 변수\nDim r As Long\n'행 방향 늘려갈 변수\nDim vPageB As\nVPageBreak\n'각 행 페이지구분선 넣을 변수\nDim c As Long\n'열 방향 늘려갈 변수\nDim pageNo As Long\n'인쇄될 현재페이지 번호를 넣을 변수\nWith ActiveSheet\n'현재 시트에서\n.PageSetup.\nPrintArea\n= .UsedRange.Address\n'인쇄영역을 현재시트 전체 사용영역으로 설정\nIf .UsedRange.Address = \"$A$1\" And _\nWorksheetFunction.CountA(.UsedRange) = 0 Then\n'현재시트가 빈 시트라면\nMsgBox \"인쇄할 내용이 없습니다.\", 64, \"인쇄오류\"\n'메시지창 출력\nExit Sub\n'매크로 종료\nEnd If\ncntHor = .HPageBreaks.Count + 1\n'행 페이지 구분선 개수 + 1을 변수에\ncntVer = .VPageBreaks.Count + 1\n'열 페이지 구분선 개수 + 1을 변수에\nFor Each hPageB In .\nHPageBreaks\n'행 페이지 구분선을 순환\nIf hPageB.Location.Row < ActiveCell.Row Then\n'현재 활성화된 셀의 행보다 페이지 구분선의 행이 작을 경우\nr = r + 1\n'행 구분선 개수 늘려감\nEnd If\nNext hPageB\nFor Each vPageB In .VPageBreaks\n'열 페이지 구분선을 순환\nIf vPageB.\nLocation\n.Column < ActiveCell.Column Then\n'현재 활성화된 셀의 열보다 페이지 구분선의 열이 작을 경우\nc = c + 1\n'열 구분선 개수 늘려감\nEnd If\nNext vPageB\nIf .PageSetup.Order =\nxlDownThenOver\nThen\n'인쇄순서가 행우선일 경우\npageNo = cntHor * c + r + 1\n'행구분선 * 열구분선 + 행구분선 + 1을 변수에\nElse\n'인쇄순서가 열우선일 경우\npageNo = cntVer * r + c + 1\n'열구분선 * 행구분선 + 열구분선 + 1을 변수에\nEnd If\n.PrintOut pageNo, pageNo\n'현재 페이지를 인쇄\nEnd With\nEnd Sub", "context": "아래의 코드는 커서 즉 활성화된 셀(ActiveCell)이 속한 페이지(워드나 엑셀의 경우 현재페이지)만 인쇄하는 기능이다. 프린트 옵션에서 이기능을 사용하면 되므로 이런 코드는 별 유용성이 없는 것 같다. 하지만, 아래 코드를 이해하면 엑셀의 페이지 구분 방식을 충분히 할 수 있으므로 다른 코드를 작성하는데 도움이 될 것이라고 생각하여 올려본다.\n시트에 여러 페이지의 데이터가 입력된 모습(페이지 나누어 보기를 이용하여 본 것)으로 화살표의 경우 5 페이지가 된다. 단, 이는 아래와 같이 인쇄옵션에서 \"행우선(Down, then over)\"이 선택된 경우.\nOption Explicit\nSub print_CurrentPage_Only\n(control As IRibbonControl)\nDim cntHor As Long\n'행(가로) 페이지 구분선 개수 넣을 변수\nDim cntVer As Long\n'열(세로) 페이지 구분선 개수 넣을 변수\nDim hPageB As\nHPageBreak\n'각 ..."}
{"instruction": "Excel VBA code for: (1642) 색채우기 없는 열만 삭제하기 (엑셀 VBA 매크로)", "input": "", "output": "Sub delete_UnFilled_Columns()\nDim rngC As Range\n'선택영역 각 셀(C)ell 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngU As Range\n'영역을 합쳐(U)nion 넣을 변수\nWith Selection\n'선택 영역에서\nIf .Areas.Count > 1 Or .Rows.Count > 1 Or _\n.Count = Columns.Count Then\n'2개 이상 영역/행 선택 또는 전체행 선택 시\nMsgBox \"1행, 1개 영역만 선택(전체행 선택 불허)\", 64, \"영역선택 오류\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nFor i = 1 To .Count\n'1부터 (선택영역) 셀 개수까지 반복\nIf .Cells(i).Interior.ColorIndex =\nxlNone\nThen\n'색이 채워지지 않은 경우\nIf rngU\nIs Nothing\nThen\n'합쳐 넣을 영역이 비어 있을 경우\nSet rngU = .Cells(i)\n'빈셀을 rngU에 할당\nElse\n'합쳐 넣을 영역이 비어 있지 않을 경우\nSet rngU =\nUnion\n(rngU, .Cells(i))\n'기존 영역과 빈셀 영역을 합쳐감\nEnd If\nEnd If\nNext i\nIf Not rngU Is Nothing Then\n'공백셀이 하나라도 있으면\nrngU.EntireColumn.Delete\n'전체 공백열 삭제\nEnd If\nEnd With\nEnd Sub", "context": "1. 아래와 같이 1개의 행만을 선택하고 매크로 실행\n2. 1개의 행, 1개의 영역만 선택해야 함. 전체행을 선택하여도 안됨.\n매크로 실행 전 B2:P2 영역을 선택한 모습\n매크로 실행 후 결과\nOption Explicit\nSub delete_UnFilled_Columns()\nDim rngC As Range\n'선택영역 각 셀(C)ell 넣을 변수\nDim i As Long\n'반복구문에 사용할 변수\nDim rngU As Range\n'영역을 합쳐(U)nion 넣을 변수\nWith Selection\n'선택 영역에서\nIf .Areas.Count > 1 Or .Rows.Count > 1 Or _\n.Count = Columns.Count Then\n'2개 이상 영역/행 선택 또는 전체행 선택 시\nMsgBox \"1행, 1개 영역만 선택(전체행 선택 불허)\", 64, \"영역선택 오류\"\nExit Sub\n'메시지창 출력 후 매크로 종료\nEnd If\nFor i = 1 To .Count\n'1부터 (선택영역) ..."}
